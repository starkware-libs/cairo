/*!
 * This script generates a corpus of cairo code snippets for syntax highlighting tests.
 *
 * The corpus is generated from parser test data in the `cairo-lang-parser` crate.
 */

import assert from "assert/strict";
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { format } from "prettier";

const runners = {
  get_diagnostics: cairoCodeTestRunner,
  test_colored_parsed_code: cairoCodeAsFilePathTestRunner,
  test_full_parser_tree: cairoCodeAsFilePathTestRunner,
  test_partial_parser_tree: cairoCodeTestRunner,
  test_partial_parser_tree_with_trivia: cairoCodeTestRunner,
};

const cairoLangParserRoot = path.join(
  fileURLToPath(import.meta.url),
  "..",
  "..",
  "..",
  "crates",
  "cairo-lang-parser",
);

const parserTestDataRoot = path.join(cairoLangParserRoot, "src", "parser_test_data");
assert.ok((await fs.stat(parserTestDataRoot)).isDirectory());

const testedCode = new Set();

for await (const testFile of fs.glob(path.join(parserTestDataRoot, "**", "*"))) {
  if (!(await fs.stat(testFile)).isFile()) {
    continue;
  }

  if (path.extname(testFile) === ".cairo") {
    /// Skip cairo files as they will be read by `test_full_parser_tree` tests.
    continue;
  }

  for (const test of await parseTestFile(testFile)) {
    const runner = getRunner(test);
    const code = await runner(test);

    /// Do not test the same code snippet twice.
    if (testedCode.has(code)) {
      continue;
    }

    /// Skip comment-only snippets, as they are usually placeholders for WIP.
    if (/^\/+[^\n]*$/g.test(code)) {
      continue;
    }

    testedCode.add(code);
  }
}

const snippetsJson = JSON.stringify(Array.from(testedCode).sort(), null, 2);
const snippetsJs = `
// This file is generated by: npm run gen-cairo-snippets. DO NOT EDIT.
export default ${snippetsJson};
`;
const snippetsFormatted = await format(snippetsJs, { parser: "babel" });

const snippetsPath = path.join(
  fileURLToPath(import.meta.url),
  "..",
  "..",
  "test-support",
  "cairo-snippets.gen.mjs",
);
await fs.writeFile(snippetsPath, snippetsFormatted, "utf8");

/**
 * JavaScript reimplementation of `cairo_lang_test_utils::parse_test_file::parse_test_file`.
 *
 * @param {string} testFilePath
 * @returns {Promise<{ test_name: string, test_runner_name?: string, cairo_code?: string }[]>}
 */
export async function parseTestFile(testFilePath) {
  const testFileText = await fs.readFile(testFilePath, "utf8");
  const tests = [];

  const testTexts = testFileText.split(/\/\/! > =+\n/g);
  assert.ok(testTexts.length > 0, "no tests found in test file");
  for (const testText of testTexts) {
    const sections = Array.from(
      testText.matchAll(/\/\/! > (?<name>[^\n]+)\n(?<text>[^]*?(?=\/\/! >))/g),
    );
    assert.ok(sections.length > 0, "no sections found in test");

    const obj = {
      test_name: sections.shift().groups.name,
    };

    for (const m of sections) {
      obj[m.groups.name] = m.groups.text.trim();
    }

    tests.push(obj);
  }

  return tests;
}

/**
 * Finds a matching test runner for the given test, or fail the test if no runner is found.
 */
function getRunner({ test_runner_name }) {
  assert.ok(typeof test_runner_name === "string", "test is missing test_runner_name section");
  const name = /^(?<name>[a-zA-Z0-9_]+)/.exec(test_runner_name)?.groups?.name;
  assert.ok(name, `invalid test_runner_name: ${test_runner_name}`);

  if (name in runners) {
    return runners[name];
  } else {
    throw new Error(
      `Unknown test runner name: ${name}. ` +
        `Please add it to the '${nameOf(() => runners)}' array in ${fileURLToPath(import.meta.url)}.`,
    );
  }
}

/**
 * Extracts cairo code for highlighting test,
 * when test has a `cairo_code` section of the following form:
 *
 * ```
 * //! > cairo_code
 * some cairo code
 * ```
 */
async function cairoCodeTestRunner({ cairo_code }) {
  return cairo_code;
}

/**
 * Extracts cairo code for highlighting test,
 * when test has a `cairo_code` section of the following form:
 *
 * ```
 * //! > cairo_code
 * >>> file: src/parser_test_data/cairo_test_files/test1.cairo
 * ```
 */
async function cairoCodeAsFilePathTestRunner({ cairo_code }) {
  const relPath = /^>>> file: (?<path>.+)/.exec(cairo_code)?.groups?.path;
  assert.ok(relPath, "invalid cairo_code section");
  const fullPath = path.join(cairoLangParserRoot, relPath);
  return await fs.readFile(fullPath, "utf8");
}

/**
 * Stringifies function body.
 *
 * This helper is useful for getting the name of a variable in a way that survives refactorings.
 * Source: https://stackoverflow.com/a/66935761
 */
function nameOf(f) {
  return f.toString().replace(/[ |()=>]/g, "");
}
