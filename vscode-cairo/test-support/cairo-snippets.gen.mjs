// This file is generated by: npm run gen-cairo-snippets. DO NOT EDIT.
export default [
  "#[_]",
  "#[aaa]",
  "#[an_attr]",
  "#[attr1]",
  "#[attr]",
  "#[cairofmt::skip]",
  "#[derive(Copy, Drop)]",
  "#[extern]",
  "#[mod]",
  ";\n#[attr]\nfn foo(var1: int var2: felt252) -> int {\n    let bla = 7 + true + 'abc'; // comment\n    return bar(bla);\n}\n",
  "const X = 0x1234;",
  "const X: NonZero::<felt252> = 0x1234;",
  "const X: [felt252; 3] = [1, 2, 3];",
  "enum MyEnum {",
  "enum _ {}",
  "enum mod {}",
  "extern fn _() nopanic;",
  "extern fn mod() nopanic;",
  "extern type _;",
  "extern type mod;",
  "fn _() {}",
  "fn emit<S, +traits::Into<T: S, TEvent>, -traits::Into<S, S>>(ref self: T, event: S) {}",
  "fn f() -> u32 {",
  "fn f() {",
  "fn f(_: felt252) {}",
  "fn f(a:felt252 b:felt252) {",
  "fn f(mod: felt252) {}",
  "fn f(ref _: felt252) {}",
  "fn f(ref mod: felt252) {}",
  "fn f(x: felt252,) {",
  "fn foo (x:T) -> S\n{\n    let x = -5 + 3;\n    let y : T = x*2 + 3*5; // Comment.\n    let z = ;\n    let v = bool::True == false;\n    5 + Struct{a: 5, b: Struct2{_gg: ()}};\n    return df == 6;\n    x + y\n}\n\npub impl A of B {\n    fn foo() {\n        if bla.\n        // The module below should parse correctly, not inside this impl.\n    }\n}\n\npub mod my_mod{\n    fn bar (x:T0, s: S) -> X {\n        x.a *+-. s.s * foo(1,3)\n    }\n    struct A{\n        x: a, // Comment.\n        y: int\n    }\n\n}\n\nskipped tokens\n",
  "fn foo() -> Aaaaa  Bbb + Cc  {",
  "fn foo() -> Aaaaa  Bbb + Cc; let x = 0; }",
  "fn foo() implicits(_) {}",
  "fn foo() implicits(mod) {}",
  "fn foo() {",
  "fn foo() {}",
  "fn foo(a: Option::<felt252>) {}",
  "fn foo(a: Option<felt252>) {}",
  "fn foo(a: bool, b: bool, c: bool, d: bool) {",
  "fn foo(a: int, mut b: felt252, ref c{}, mut ref d: felt252) -> felt252 implicits(RangeCheck, Hash) nopanic {",
  "fn main() -> Option<felt252> {\n    fib(1, 1, 13)\n}\n\n/// Calculates fib...\nfn fib(a: felt252, b: felt252, n: felt252) -> Option<felt252> {\n    gas::withdraw_gas()?;\n    some_macro!();\n    match n {\n        0 => Option::Some(a),\n        _ => fib(b, a + b, n - 1),\n    }\n}\n\npub fn fib_tuple(a: felt252, b: felt252, n: felt252) -> (Option<felt252>, Option<felt252>) {\n    gas::withdraw_gas()?;\n    match n {\n        0 => (Option::Some(a), Option::Some(b)),\n        _ => fib_tuple(b, a + b, n - 1),\n    }\n}\n",
  "fn mod() {}",
  "fn test() {",
  "identifier",
  "identifier!(1,2",
  "identifier!(1,2)",
  "identifier(x)",
  "impl Abc of Def {",
  "impl MyImpl of MyTrait {",
  "impl MyImplAlias<T> = OtherImpl<Stuff, A<T>>;",
  "impl _ of MyTrait {}",
  "impl mod of MyTrait {}",
  "inline_macro!(1, 2);",
  "inline_macro![1, 2];",
  "inline_macro!{1, 2};",
  "inline_macro(1,2);",
  "inline_macro[1,2];",
  "inline_macro{1,2};",
  "macro!",
  "mod _;",
  "mod mod1 {",
  "mod mod;",
  "mod my_mod",
  "mod my_mod {",
  "mod my_mod }",
  "mod my_mod;",
  "mod submod;\nuse submod::something;\n\n// Func foo\n// Second line\n;\nfn foo(,var1: int,, mut ref var2: felt252,) -> int {\n    let bla3 = --7; // succeeds, ok\n    let bla4 = -!-!8; // succeeds, ok\n    let x = 1;\n    let y = match x {\n        0 => { 1 },\n        _ => 0,\n    };\n    let z = if 0 + x == y {\n        1\n    } else {\n        2\n    };\n    let block_combination = {5} + match x { E::V1(_) => 4, E::V2(_) => 2 }\n        - if cond { 32 } else { 1 };\n    let w = calc_with_error(x, y?, z)?;\n    let member_value = value.member?;\n    let method_return = value.method()?;\n    let x = true; // bla1\n                  // bla2\n    z = 5;\n    func1(x);\n    func2::<int>(x)\n    return x;\n\nfn bar<A, B>() -> felt252 { }\n\nextern type S<>;\nextern fn glee<A, b>(var1: int,) -> crate::S<int> nopanic;\n\nstruct A<A, B> {\n    pub member: bool,\n    #[annot(a)]\n    member2: (bool, felt252, ())\n}\n\npub(crate) enum E<A, B> {\n    V1: A,\n    V2: B,\n    VEmpty,\n}\n\nfn match_e_enum(e: E) -> felt252 {\n    match e {\n        E::V1(_) => 1,\n        E::V2(x) => 2,\n        E::VEmpty => 0,\n    }\n}\n\ntype Renamed = submod::inner::Other;\ntype Generic<T> = super::other::OtherGeneric::<T>;\n\ninline_item_macro!(x, y, z);\n\n#[attribute_without_item]\n",
  "mod x {",
  "pub // trailing.",
  "pub macro",
  "skipped   tokens",
  "skipped  \\\\ Comment",
  "skipped tokens",
  "struct A {",
  "struct A<_> {}",
  "struct A<mod> {}",
  "struct _ {}",
  "struct mod {}",
  "trait Abc {",
  "trait Foo<T> {",
  "trait Foo<T>;",
  "trait MyTrait {",
  "trait _ {}",
  "trait mod {}",
  "trait trt {",
  "use _::foo;",
  "use mod::foo;",
  "use std::format;\n\nfn foo(a: int) -> felt252 {\n    return a;\n}\n",
];
