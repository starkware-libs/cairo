// This file is generated by: npm run gen-cairo-snippets. DO NOT EDIT.
export default [
  "#[_]\nfn foo() {}",
  "#[aaa]\n#[bbb]\n2",
  "#[aaa]\n3",
  "#[aaa]\n[bbb]\n#[ccc]\nfn foo() {}",
  "#[an_attr]\ninline_macro!(1, 2);",
  "#[attr1]\n#[with_args(arg1, arg2)]\n#[attr2]\nfn foo(a: int) -> felt252 {\n    return a;\n}",
  "#[attr]\npub",
  "#[attr]\npub macro",
  "#[cairofmt::skip]\nfn foo() {\n    1 ! 2;\n    1 @ 2;\n}",
  "#[derive(Copy, Drop)]\nenum bool {\n    False: (),\n    True: (),\n}\n\n#[empty_attr()]\nmod empty {}\n\n#[derive(Copy, Drop, PartialEq, Serde)]\nstruct u256 {\n    low: u128,\n}\n\n#[post('/', data: '<todo_form>')]\nfn string_value() {}\n\n#[cfg(attr(value: C))]\nfn const_value() {}\n\n#[cfg_attr(test, assert_instr(instr: add_a.b))]\nfn custom_name() {}\n\n#[attr(foo::bar, qwe)]\nfn arbitrary_token_tree() {}",
  "#[extern]\n#[abc]\nfn missing_id<T> (ref: Ref::<T>) { }",
  "#[mod]\nfn foo() {}",
  "// TODO(Gil): handle multiline diagnostics.\n#[bbb]\nmacro",
  "/// TODO(Tomerstarkware): parse logical operators with lower precedence than `=`\nfn f() {\n    if let Some(x) = 2 && false {\n        3\n    }\n}",
  ";\n#[attr]\nfn foo(var1: int var2: felt252) -> int {\n    let bla = 7 + true + 'abc'; // comment\n    return bar(bla);\n}\n",
  "const X = 0x1234;",
  "const X: NonZero::<felt252> = 0x1234;",
  "const X: [felt252; 3] = [1, 2, 3];",
  "enum MyEnum {\n    A(felt252),\n}",
  "enum MyEnum {\n    A: felt252,\n    B: felt252,\n    MissingComma\n}",
  "enum _ {}",
  "enum mod {}",
  "extern fn _() nopanic;",
  "extern fn mod() nopanic;",
  "extern type _;",
  "extern type mod;",
  "fn _() {}",
  "fn emit<S, +traits::Into<T: S, TEvent>, -traits::Into<S, S>>(ref self: T, event: S) {}",
  "fn f() -> u32 {\n    -3 * 5\n}",
  "fn f() -> u32 {\n    -a * 5\n}",
  "fn f() {\n    if 0 == if x {1} else {2} {\n    }\n}",
  "fn f() {\n    if 1 == 2 {\n        3\n    } else if 4 == 5 {\n        6\n    } else if 7 == 8 {\n        9\n    } else {\n        10\n    }\n}",
  "fn f() {\n    if MyStruct{a: 0} == MyStruct{a: 1} {\n    }\n}",
  "fn f() {\n    if let = 5 {\n    }\n}",
  "fn f() {\n    if let Some(x) = 2 {\n        3\n    } else if 4 == 5 {\n        6\n    } else if let None(y) = 8 {\n        9\n    }\n}",
  "fn f() {\n    if let x {}\n}",
  "fn f() {\n    let [x, y, z] = [1, 2, 3];\n}",
  'fn f() {\n    let a = "";\n    let b = "abc";\n}',
  "fn f() {\n    let a = -0x123_u8 + -456_u256 + -'abc'_u16;\n}",
  "fn f() {\n    let a = 0x123 + 456 + 'abc';\n}",
  "fn f() {\n    let a = 0x123_u8 + 456_u256 + 'abc'_u16;\n}",
  "fn f() {\n    let array = [1, 2, 3];\n    for index at array {\n        1;\n    }\n}",
  "fn f() {\n    let array = [1, 2, 3];\n    for index in array {\n        1;\n    }\n}",
  "fn f() {\n    let ref abc::def = 5;\n    let A { x\n    let x = 5;\n}",
  "fn f() {\n    let x = 123\n    let y = 4   let z = 5\n    let y = 6 // comment\n    let w = 7 +\n}",
  "fn f() {\n    let x = 5;\n    match x {\n        0 = 1,\n        _ => 2,\n    };\n}",
  "fn f() {\n    let x = 5;\n    match x {\n        0 => 1,\n        _ => 2,\n    };\n}",
  "fn f() {\n    let x = 5;\n    match x {\n        0 | 1 | => 1,\n        _ => 2,\n    };\n}",
  "fn f() {\n    let x = calc()?;\n    let y = calc1(calc2()?)?;\n    let z = w?;\n    let block_eval = {\n        other_expr\n    }?;\n    let block_eval = 7 + {\n        other_expr\n    };\n    let multi = error_of_errors????;\n    let super_expr = (a? + b?)?;\n    let member_value = value.member?;\n    let method_return = value.method()?;\n}",
  "fn f() {\n    let x = loop {\n        break 5;\n    };\n}",
  "fn f() {\n    let x = true;\n    match x {\n        true => 1,\n        false => 2,\n    };\n}",
  "fn f() {\n    let x: [u32; 4] = [1, 2, 3, 4];\n}",
  "fn f() {\n    match MyStruct{a: 1} {\n    }\n    match x {\n      1 => {},\n      Struct{a, b: _, .., a: A::Variant(4)} => {},\n      x => {},\n      bool::False() => {}\n    }\n}",
  "fn f() {\n    while let Some(x) = 2 {\n        break 5;\n    }\n}",
  "fn f() {\n    while true {\n        1;\n    }\n}",
  "fn f() {\n    {\n        5\n    } + match x {\n        E::V1(_) => 4,\n        E::V2(_) => 2\n    } - if cond {\n        32\n    } else {\n        1\n    }\n}",
  "fn f() {\n    {4} - 1 + / 2 + {5}\n}",
  'fn f() {\n   let unterminated_str = "abc;\n}',
  "fn f() {\n   let unterminated_str = 'abc;\n}",
  "fn f(_: felt252) {}",
  "fn f(a:felt252 b:felt252) {\n    if let x == y {}\n}",
  "fn f(mod: felt252) {}",
  "fn f(ref _: felt252) {}",
  "fn f(ref mod: felt252) {}",
  "fn f(x: felt252,) {\n    let x = 5;\n    match x {\n        0 | 1 => 1,\n        _ => 2,\n    };\n}",
  "fn foo (x:T) -> S\n{\n    let x = -5 + 3;\n    let y : T = x*2 + 3*5; // Comment.\n    let z = ;\n    let v = bool::True == false;\n    5 + Struct{a: 5, b: Struct2{_gg: ()}};\n    return df == 6;\n    x + y\n}\n\npub impl A of B {\n    fn foo() {\n        if bla.\n        // The module below should parse correctly, not inside this impl.\n    }\n}\n\npub mod my_mod{\n    fn bar (x:T0, s: S) -> X {\n        x.a *+-. s.s * foo(1,3)\n    }\n    struct A{\n        x: a, // Comment.\n        y: int\n    }\n\n}\n\nskipped tokens\n",
  "fn foo() -> Aaaaa  Bbb + Cc  {\n}",
  "fn foo() -> Aaaaa  Bbb + Cc; let x = 0; }",
  "fn foo() implicits(_) {}",
  "fn foo() implicits(mod) {}",
  "fn foo() {\n    #[aaa]\n    #[bbb]\n}",
  "fn foo() {\n    #[aaa]\n    $\n    #[bbb]\n}",
  "fn foo() {\n    #[aaa]\n    $\n}",
  "fn foo() {\n    #[aaa]\n    let x = 1;\n    #[bbb]\n}",
  "fn foo() {\n    #[aaa]\n}",
  "fn foo() {\n    #[an_attribute]\n    let x = 1;\n}",
  "fn foo() {\n    #[bbb]\n    // A comment\n}",
  "fn foo() {\n    $\n    #[aaa]\n}",
  "fn foo() {\n    // A comment\n    #[bbb]\n}",
  "fn foo() {\n    A { _ }\n}",
  "fn foo() {\n    A { mod }\n}",
  "fn foo() {\n    bar::<S: >();\n}",
  "fn foo() {\n    bar::<S: usize>();\n}",
  "fn foo() {\n    let MyStruct { _ } = 3;\n}",
  "fn foo() {\n    let MyStruct { mod } = 3;\n}",
  'fn foo() {\n    let a = "\\u{1024}";\n}',
  "fn foo() {\n    let a = '\\p';\n}",
  "fn foo() {\n    let a = '\\u{1024}';\n}",
  "fn foo() {\n    let a = 'a'u16;\n}",
  "fn foo() {\n    let legal_bin = 0b1;\n    let illegal_bin = 0b2;\n    let illegal_bin = 0b12;\n    let legal_oct = 0o1;\n    let illegal_oct = 0o8;\n    let illegal_oct = 0o78;\n    let legal_hex = 0xf;\n    let illegal_hex = 0xg;\n    let illegal_hex = 0xfg;\n}",
  "fn foo() {\n    let mut x = 3;\n    x += 5;\n    x -= 5;\n    x *= 5;\n    x /= 5;\n    x %= 5;\n    x = 5;\n}",
  "fn foo() {\n    let ref _ = 3;\n}",
  "fn foo() {\n    let ref mod = 3;\n}",
  "fn foo() {\n    let x += 5;\n}",
  "fn foo() {}\nskipped tokens\nfn bar() {}",
  "fn foo(a: Option::<felt252>) {}",
  "fn foo(a: Option<felt252>) {}",
  "fn foo(a: bool, b: bool, c: bool, d: bool) {\n    a && b || c && d\n}",
  "fn foo(a: int, mut b: felt252, ref c{}, mut ref d: felt252) -> felt252 implicits(RangeCheck, Hash) nopanic {\n    return a;\n}\n\nfn bar() -> (felt252) {\n    (1,)\n}",
  "fn main() -> Option<felt252> {\n    fib(1, 1, 13)\n}\n\n/// Calculates fib...\nfn fib(a: felt252, b: felt252, n: felt252) -> Option<felt252> {\n    gas::withdraw_gas()?;\n    some_macro!();\n    match n {\n        0 => Option::Some(a),\n        _ => fib(b, a + b, n - 1),\n    }\n}\n\npub fn fib_tuple(a: felt252, b: felt252, n: felt252) -> (Option<felt252>, Option<felt252>) {\n    gas::withdraw_gas()?;\n    match n {\n        0 => (Option::Some(a), Option::Some(b)),\n        _ => fib_tuple(b, a + b, n - 1),\n    }\n}\n",
  "fn mod() {}",
  "fn test() {\n    a[1];\n}",
  "fn test() {\n    a[a[1]];\n}",
  "fn test() {\n    a[x + y];\n}",
  "fn test() {\n    a[{\n        x + y\n    }];\n}",
  "fn test() {\n    f(12, y: a + 3, :z);\n}",
  "fn test() {\n    f::<felt252, 7>(12, a + 3, ref b);\n}",
  "fn test() {\n    let expensive_closure =  || -> u32 3;\n}",
  "fn test() {\n    let expensive_closure =  || -> u32 {\n        let x = num + 5;\n        x\n    };\n}",
  "fn test() {\n    let expensive_closure =  || 3;\n}",
  "fn test() {\n    let expensive_closure =  || nopanic 3;\n}",
  "fn test() {\n    let expensive_closure =  || {\n        x\n    };\n}",
  "fn test() {\n    let expensive_closure = |num: u32, b, c: felt252| -> u32 {\n        let x = num + 5;\n        x\n    };\n}",
  "fn test() {\n    println!('foo');\n}",
  "identifier\nfn foo() {}",
  "identifier!(1,2\nfn foo() {}",
  "identifier!(1,2)\nfn foo() {}",
  "identifier(x)\nfn foo() {}",
  "impl Abc of Def {\n    #[aaa]\n    3\n}",
  "impl MyImpl of MyTrait {\n    const MyConst: u32 = 3;\n}",
  "impl MyImpl of MyTrait {\n    impl OtherImpl = AnotherImpl;\n}",
  "impl MyImpl of MyTrait {\n    type MyType = u32;\n}",
  "impl MyImpl of MyTrait {\n    type MyType<T> = Array<T>;\n}",
  "impl MyImplAlias<T> = OtherImpl<Stuff, A<T>>;",
  "impl _ of MyTrait {}",
  "impl mod of MyTrait {}",
  "inline_macro!(1, 2);",
  "inline_macro![1, 2];",
  "inline_macro!{1, 2};",
  "inline_macro(1,2);",
  "inline_macro[1,2];",
  "inline_macro{1,2};",
  "macro!\nfn foo() {}",
  "mod _;",
  "mod mod1 {\n    #[aaa]\n    $\n    #[bbb]\n}",
  "mod mod1 {\n    #[aaa]\n    $\n}",
  "mod mod1 {\n    #[aaa]\n    // A comment\n}",
  "mod mod1 {\n    #[aaa]\n    fn foo() {}\n    #[bbb]\n}",
  "mod mod1 {\n    $\n    #[aaa]\n}",
  "mod mod1 {\n    // A comment\n    #[aaa]\n    // A second comment\n}",
  "mod mod1 {\n    // A comment\n    #[aaa]\n}",
  "mod mod;",
  "mod my_mod\nfn foo() {}",
  "mod my_mod {\n    trait Foo<T>;\n    impl FooImpl<S> of Foo<S> {\n        fn foo(a: int) -> felt252 {\n            return a;\n        }\n    }\n\n    fn test() {}\n\n    struct MyStruct {}\n}",
  "mod my_mod {\nfn foo() {}",
  "mod my_mod }",
  "mod my_mod;",
  "mod submod;\nuse submod::something;\n\n// Func foo\n// Second line\n;\nfn foo(,var1: int,, mut ref var2: felt252,) -> int {\n    let bla3 = --7; // succeeds, ok\n    let bla4 = -!-!8; // succeeds, ok\n    let x = 1;\n    let y = match x {\n        0 => { 1 },\n        _ => 0,\n    };\n    let z = if 0 + x == y {\n        1\n    } else {\n        2\n    };\n    let block_combination = {5} + match x { E::V1(_) => 4, E::V2(_) => 2 }\n        - if cond { 32 } else { 1 };\n    let w = calc_with_error(x, y?, z)?;\n    let member_value = value.member?;\n    let method_return = value.method()?;\n    let x = true; // bla1\n                  // bla2\n    z = 5;\n    func1(x);\n    func2::<int>(x)\n    return x;\n\nfn bar<A, B>() -> felt252 { }\n\nextern type S<>;\nextern fn glee<A, b>(var1: int,) -> crate::S<int> nopanic;\n\nstruct A<A, B> {\n    pub member: bool,\n    #[annot(a)]\n    member2: (bool, felt252, ())\n}\n\npub(crate) enum E<A, B> {\n    V1: A,\n    V2: B,\n    VEmpty,\n}\n\nfn match_e_enum(e: E) -> felt252 {\n    match e {\n        E::V1(_) => 1,\n        E::V2(x) => 2,\n        E::VEmpty => 0,\n    }\n}\n\ntype Renamed = submod::inner::Other;\ntype Generic<T> = super::other::OtherGeneric::<T>;\n\ninline_item_macro!(x, y, z);\n\n#[attribute_without_item]\n",
  "mod x {\n    trait A {\n        fn foo() {}\n    }\n    struct Y {}\n}",
  "pub // trailing.",
  "pub macro",
  "skipped   tokens",
  "skipped  \\\\ Comment\n\n  tokens",
  "skipped  \\\\ Comment\n\n  tokens  fn foo() {}",
  "skipped tokens",
  "struct A {\n    _: felt252\n}",
  "struct A {\n    a: felt252,\n}\nfn f(x: (A, felt252)) {\n    let (A { a: mut a }, ref mut b) = x;\n}",
  "struct A {\n    mod: felt252\n}",
  "struct A<_> {}",
  "struct A<mod> {}",
  "struct _ {}",
  "struct mod {}",
  "trait Abc {\n    #[aaa]\n    3\n}",
  "trait Foo<T> {\n    fn foo<S>(x: T, y: S);\n}\n#[cairofmt::skip]\nimpl FooImpl<W> of Foo::<u8> {\n    fn foo<W>(x: u8, y: W) {\n    }\n}",
  "trait Foo<T>;\nimpl FooImpl<S> of Foo<S> {}",
  "trait MyTrait {\n    const MyConst: u32;\n}",
  "trait MyTrait {\n    impl MyImpl: OtherTrait;\n}",
  "trait MyTrait {\n    type MyType;\n}",
  "trait MyTrait {\n    type MyType<T>;\n}",
  "trait _ {}",
  "trait mod {}",
  "trait trt {\n    fn _();\n}",
  "trait trt {\n    fn mod();\n}",
  "use _::foo;",
  "use mod::foo;",
  "use std::format;\n\nfn foo(a: int) -> felt252 {\n    return a;\n}\n",
];
