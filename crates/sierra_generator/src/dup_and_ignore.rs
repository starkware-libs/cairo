#![allow(dead_code)]
#[cfg(test)]
#[path = "dup_and_ignore_test.rs"]
mod test;

use std::collections::{HashMap, HashSet};

use itertools::{chain, Itertools};
use sierra::ids::VarId;
use sierra::program::{GenBranchTarget, Param};
use utils::ordered_hash_set::OrderedHashSet;

use crate::pre_sierra::{LabelId, Statement};

/// Variables that needs to be dupped and dropped in a statement.
#[derive(Clone, Default)]
pub struct VarsDupsAndIgnores {
    pub dups: OrderedHashSet<VarId>,
    pub ignores: OrderedHashSet<VarId>,
}

/// Calculates the set of variables requiring duplication, and variables that can be dropped per
/// statement.
/// Variables that could have been dropped earlier are not considered.
pub fn calculate_statement_dups_and_ignores(
    next_statement_index_fetch: &NextStatementIndexFetch,
    params: &[Param],
    statements: &[Statement],
) -> Vec<VarsDupsAndIgnores> {
    let mut statement_required_vars = vec![RequiredVarsSets::default(); statements.len()];
    calculate_required_vars_per_statement(
        next_statement_index_fetch,
        &mut statement_required_vars,
        0,
        statements,
    );
    let mut statement_existing_vars = vec![OrderedHashSet::<VarId>::default(); statements.len()];
    statement_existing_vars[0] = params.iter().map(|p| p.id.clone()).collect();
    statements
        .iter()
        .enumerate()
        .map(|(i, statement)| {
            let RequiredVarsSets { curr_vars, future_vars } = &statement_required_vars[i];
            match statement {
                Statement::Sierra(sierra::program::GenStatement::Invocation(invocation)) => {
                    // Updating `statement_existing_vars` for the branchs - which are all the
                    // `next_required_vars` with the branches inserted results.
                    for branch in &invocation.branches {
                        let next_index = next_statement_index_fetch.get(i, &branch.target);
                        statement_existing_vars[next_index] =
                            chain!(future_vars.iter(), branch.results.iter()).cloned().collect();
                    }
                    VarsDupsAndIgnores {
                        dups: curr_vars
                            .iter()
                            .filter(|var| future_vars.contains(*var))
                            .cloned()
                            .collect(),
                        ignores: statement_existing_vars[i]
                            .iter()
                            .filter(|var| !curr_vars.contains(*var) && !future_vars.contains(*var))
                            .cloned()
                            .collect(),
                    }
                }
                Statement::Sierra(sierra::program::GenStatement::Return(_)) => VarsDupsAndIgnores {
                    dups: OrderedHashSet::<VarId>::default(),
                    ignores: statement_existing_vars[i]
                        .iter()
                        .filter(|var| !curr_vars.contains(*var) && !future_vars.contains(*var))
                        .cloned()
                        .collect(),
                },
                Statement::Label(_) => {
                    // Label is a no-op - so we do no changes to it.
                    statement_existing_vars[i + 1] = statement_existing_vars[i].clone();
                    VarsDupsAndIgnores {
                        dups: OrderedHashSet::<VarId>::default(),
                        ignores: OrderedHashSet::<VarId>::default(),
                    }
                }
            }
        })
        .collect()
}

/// The required vars for a statement.
#[derive(Clone, Default)]
pub struct RequiredVarsSets {
    /// Variables required by the current command.
    pub curr_vars: OrderedHashSet<VarId>,
    /// Variables required by following command.
    pub future_vars: OrderedHashSet<VarId>,
}

/// Calculates the set of required existing variables per pre-Sierra statement.
pub fn calculate_required_vars_per_statement(
    next_statement_index_fetch: &NextStatementIndexFetch,
    required_vars: &mut Vec<RequiredVarsSets>,
    index: usize,
    statements: &[Statement],
) {
    // TODO(orizi): Use option instead of empty.
    if !required_vars[index].future_vars.is_empty() {
        return;
    }
    required_vars[index] = match &statements[index] {
        // The required variables for an invocation, is all of its branches required vars, without
        // vars generated by the call, and its arguments.
        Statement::Sierra(sierra::program::GenStatement::Invocation(invocation)) => {
            RequiredVarsSets {
                curr_vars: invocation.args.iter().cloned().collect(),
                future_vars: invocation
                    .branches
                    .iter()
                    .flat_map(|branch| {
                        let next_index = next_statement_index_fetch.get(index, &branch.target);
                        calculate_required_vars_per_statement(
                            next_statement_index_fetch,
                            required_vars,
                            next_index,
                            statements,
                        );
                        let results: HashSet<VarId> = branch.results.iter().cloned().collect();
                        chain!(
                            required_vars[next_index]
                                .future_vars
                                .iter()
                                .filter(move |v| !results.contains(v)),
                            required_vars[next_index].curr_vars.iter()
                        )
                        .cloned()
                        .collect_vec()
                    })
                    .collect(),
            }
        }
        Statement::Sierra(sierra::program::GenStatement::Return(ret_vars)) => {
            // At return - the only required variables are the returned variables.
            RequiredVarsSets {
                curr_vars: ret_vars.iter().cloned().collect(),
                future_vars: OrderedHashSet::default(),
            }
        }
        Statement::Label(_) => {
            // Labels are no-ops - so we just use the same as next line.
            calculate_required_vars_per_statement(
                next_statement_index_fetch,
                required_vars,
                index + 1,
                statements,
            );
            required_vars[index + 1].clone()
        }
    }
}

/// Helper to fetch the next statement index from a branch target.
pub struct NextStatementIndexFetch {
    label_to_statement: HashMap<LabelId, usize>,
}
impl NextStatementIndexFetch {
    pub fn new(statements: &[Statement]) -> Self {
        Self {
            label_to_statement: statements
                .iter()
                .enumerate()
                .filter_map(|(i, s)| match s {
                    Statement::Sierra(_) => None,
                    Statement::Label(label) => Some((label.id, i)),
                })
                .collect(),
        }
    }
    pub fn get(&self, index: usize, target: &GenBranchTarget<LabelId>) -> usize {
        match target {
            sierra::program::GenBranchTarget::Fallthrough => index + 1,
            sierra::program::GenBranchTarget::Statement(label) => {
                *self.label_to_statement.get(label).unwrap()
            }
        }
    }
}
