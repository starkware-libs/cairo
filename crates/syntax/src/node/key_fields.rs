// Autogenerated file. To regenerate, please run `cargo run --bin generate_syntax`.
use super::ids::GreenId;
use super::kind::SyntaxKind;
pub fn get_key_fields(kind: SyntaxKind, children: Vec<GreenId>) -> Vec<GreenId> {
    match kind {
        SyntaxKind::Terminal => {
            vec![]
        }
        SyntaxKind::TriviumSkippedTerminal => {
            vec![]
        }
        SyntaxKind::Trivia => {
            vec![]
        }
        SyntaxKind::StructArgExpr => {
            vec![]
        }
        SyntaxKind::OptionStructArgExprEmpty => {
            vec![]
        }
        SyntaxKind::StructArgSingle => {
            vec![/* identifier */ children[0]]
        }
        SyntaxKind::StructArgTail => {
            vec![]
        }
        SyntaxKind::StructArgList => {
            vec![]
        }
        SyntaxKind::ArgListBraced => {
            vec![]
        }
        SyntaxKind::Identifier => {
            vec![/* terminal */ children[0]]
        }
        SyntaxKind::ExprList => {
            vec![]
        }
        SyntaxKind::ExprMissing => {
            vec![]
        }
        SyntaxKind::OptionGenericArgsEmpty => {
            vec![]
        }
        SyntaxKind::OptionGenericArgsSome => {
            vec![]
        }
        SyntaxKind::PathSegment => {
            vec![]
        }
        SyntaxKind::ExprPath => {
            vec![]
        }
        SyntaxKind::ExprLiteral => {
            vec![]
        }
        SyntaxKind::ExprParenthesized => {
            vec![]
        }
        SyntaxKind::ExprUnary => {
            vec![]
        }
        SyntaxKind::ExprBinary => {
            vec![]
        }
        SyntaxKind::ExprTuple => {
            vec![]
        }
        SyntaxKind::ExprListParenthesized => {
            vec![]
        }
        SyntaxKind::ExprFunctionCall => {
            vec![]
        }
        SyntaxKind::ExprStructCtorCall => {
            vec![]
        }
        SyntaxKind::ExprBlock => {
            vec![]
        }
        SyntaxKind::TypeClause => {
            vec![]
        }
        SyntaxKind::OptionTypeClauseEmpty => {
            vec![]
        }
        SyntaxKind::ReturnTypeClause => {
            vec![]
        }
        SyntaxKind::OptionReturnTypeClauseEmpty => {
            vec![]
        }
        SyntaxKind::StatementList => {
            vec![]
        }
        SyntaxKind::StatementMissing => {
            vec![]
        }
        SyntaxKind::StatementLet => {
            vec![/* lhs */ children[1]]
        }
        SyntaxKind::OptionSemicolonEmpty => {
            vec![]
        }
        SyntaxKind::StatementExpr => {
            vec![]
        }
        SyntaxKind::StatementReturn => {
            vec![]
        }
        SyntaxKind::Param => {
            vec![/* identifier */ children[0]]
        }
        SyntaxKind::ParamList => {
            vec![]
        }
        SyntaxKind::ParamListParenthesized => {
            vec![]
        }
        SyntaxKind::ParamListBraced => {
            vec![]
        }
        SyntaxKind::FunctionSignature => {
            vec![/* name */ children[1]]
        }
        SyntaxKind::ItemList => {
            vec![]
        }
        SyntaxKind::ItemModule => {
            vec![/* name */ children[1]]
        }
        SyntaxKind::ItemFunction => {
            vec![/* signature */ children[0]]
        }
        SyntaxKind::ItemFunctionSignature => {
            vec![/* signature */ children[0]]
        }
        SyntaxKind::ItemTrait => {
            vec![/* name */ children[1]]
        }
        SyntaxKind::ItemImpl => {
            vec![/* name */ children[1]]
        }
        SyntaxKind::ItemStruct => {
            vec![/* name */ children[1]]
        }
        SyntaxKind::ItemEnum => {
            vec![/* name */ children[1]]
        }
        SyntaxKind::ItemUse => {
            vec![/* path */ children[1]]
        }
        SyntaxKind::SyntaxFile => {
            vec![]
        }
    }
}
