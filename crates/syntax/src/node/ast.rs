// Autogenerated file. To regenerate, please run `cargo run --bin generate_syntax`.
#![allow(clippy::match_single_binding)]
#![allow(clippy::too_many_arguments)]
#![allow(dead_code)]
#![allow(unused_variables)]
use std::ops::Deref;

use super::element_list::ElementList;
use super::green::GreenNodeInternal;
use super::kind::SyntaxKind;
use super::{
    GreenId, GreenNode, SyntaxGroup, SyntaxNode, SyntaxStablePtrId, Token, TypedSyntaxNode,
};
use crate::token::TokenKind;
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Terminal {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: GreenId,
        token: GreenId,
        trailing_trivia: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![leading_trivia, token, trailing_trivia];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Terminal,
            children,
            width,
        }))
    }
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> Token {
        let child = self.children[1].clone();
        Token::from_syntax_node(db, child)
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct TerminalPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for Terminal {
    type StablePtr = TerminalPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Terminal,
            children: vec![Trivia::missing(db), Token::missing(db), Trivia::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Terminal {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Terminal,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Terminal,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TriviumSkippedTerminal {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TriviumSkippedTerminal {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: GreenId,
        token: GreenId,
        trailing_trivia: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![leading_trivia, token, trailing_trivia];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TriviumSkippedTerminal,
            children,
            width,
        }))
    }
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> Token {
        let child = self.children[1].clone();
        Token::from_syntax_node(db, child)
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct TriviumSkippedTerminalPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for TriviumSkippedTerminal {
    type StablePtr = TriviumSkippedTerminalPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TriviumSkippedTerminal,
            children: vec![Trivia::missing(db), Token::missing(db), Trivia::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::TriviumSkippedTerminal {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::TriviumSkippedTerminal,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::TriviumSkippedTerminal,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviumSkippedTerminalPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Trivia(ElementList<Trivium, 1>);
impl Deref for Trivia {
    type Target = ElementList<Trivium, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl Trivia {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Trivia,
            children,
            width,
        }))
    }
}
pub struct TriviaPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for Trivia {
    type StablePtr = TriviaPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Trivia,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviaPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Trivium {
    TriviumSingleLineComment(Token),
    TriviumWhitespace(Token),
    TriviumNewline(Token),
    SkippedTerminal(TriviumSkippedTerminal),
}
pub struct TriviumPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for Trivium {
    type StablePtr = TriviumPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::TriviumSkippedTerminal => {
                    Trivium::SkippedTerminal(TriviumSkippedTerminal::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Trivium"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                TokenKind::SingleLineComment => {
                    Trivium::TriviumSingleLineComment(Token::from_syntax_node(db, node))
                }
                TokenKind::Whitespace => {
                    Trivium::TriviumWhitespace(Token::from_syntax_node(db, node))
                }
                TokenKind::Newline => Trivium::TriviumNewline(Token::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "Trivium"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Trivium::TriviumSingleLineComment(x) => x.as_syntax_node(),
            Trivium::TriviumWhitespace(x) => x.as_syntax_node(),
            Trivium::TriviumNewline(x) => x.as_syntax_node(),
            Trivium::SkippedTerminal(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviumPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgExpr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgExpr {
    pub fn new_green(db: &dyn SyntaxGroup, colon: GreenId, expr: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![colon, expr];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgExpr,
            children,
            width,
        }))
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct StructArgExprPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for StructArgExpr {
    type StablePtr = StructArgExprPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgExpr,
            children: vec![Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StructArgExpr {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StructArgExpr,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StructArgExpr,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgExprPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionStructArgExpr {
    Empty(OptionStructArgExprEmpty),
    Some(StructArgExpr),
}
pub struct OptionStructArgExprPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionStructArgExpr {
    type StablePtr = OptionStructArgExprPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionStructArgExprEmpty => {
                    OptionStructArgExpr::Empty(OptionStructArgExprEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::StructArgExpr => {
                    OptionStructArgExpr::Some(StructArgExpr::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionStructArgExpr"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionStructArgExpr"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionStructArgExpr::Empty(x) => x.as_syntax_node(),
            OptionStructArgExpr::Some(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionStructArgExprPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionStructArgExprEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionStructArgExprEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionStructArgExprEmpty,
            children,
            width,
        }))
    }
}
pub struct OptionStructArgExprEmptyPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionStructArgExprEmpty {
    type StablePtr = OptionStructArgExprEmptyPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionStructArgExprEmpty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionStructArgExprEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionStructArgExprEmpty,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionStructArgExprEmpty,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionStructArgExprEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgSingle {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgSingle {
    pub fn new_green(db: &dyn SyntaxGroup, identifier: GreenId, arg_expr: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![identifier, arg_expr];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgSingle,
            children,
            width,
        }))
    }
    pub fn identifier(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arg_expr(&self, db: &dyn SyntaxGroup) -> OptionStructArgExpr {
        OptionStructArgExpr::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct StructArgSinglePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for StructArgSingle {
    type StablePtr = StructArgSinglePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgSingle,
            children: vec![Terminal::missing(db), OptionStructArgExpr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StructArgSingle {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StructArgSingle,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StructArgSingle,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgSinglePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgTail {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgTail {
    pub fn new_green(db: &dyn SyntaxGroup, dotdot: GreenId, expression: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![dotdot, expression];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgTail,
            children,
            width,
        }))
    }
    pub fn dotdot(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expression(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct StructArgTailPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for StructArgTail {
    type StablePtr = StructArgTailPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgTail,
            children: vec![Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StructArgTail {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StructArgTail,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StructArgTail,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgTailPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum StructArg {
    StructArgSingle(StructArgSingle),
    StructArgTail(StructArgTail),
}
pub struct StructArgPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for StructArg {
    type StablePtr = StructArgPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::StructArgSingle => {
                    StructArg::StructArgSingle(StructArgSingle::from_syntax_node(db, node))
                }
                SyntaxKind::StructArgTail => {
                    StructArg::StructArgTail(StructArgTail::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "StructArg"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "StructArg"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            StructArg::StructArgSingle(x) => x.as_syntax_node(),
            StructArg::StructArgTail(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgList(ElementList<StructArg, 2>);
impl Deref for StructArgList {
    type Target = ElementList<StructArg, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StructArgList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgList,
            children,
            width,
        }))
    }
}
pub struct StructArgListPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for StructArgList {
    type StablePtr = StructArgListPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgListBraced {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ArgListBraced {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: GreenId,
        arguments: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lbrace, arguments, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ArgListBraced,
            children,
            width,
        }))
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> StructArgList {
        StructArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ArgListBracedPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ArgListBraced {
    type StablePtr = ArgListBracedPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ArgListBraced,
            children: vec![
                Terminal::missing(db),
                StructArgList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ArgListBraced {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ArgListBraced,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ArgListBraced,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgListBracedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Expr {
    Path(ExprPath),
    Literal(ExprLiteral),
    Parenthesized(ExprParenthesized),
    Unary(ExprUnary),
    Binary(ExprBinary),
    Tuple(ExprTuple),
    FunctionCall(ExprFunctionCall),
    StructCtorCall(ExprStructCtorCall),
    Block(ExprBlock),
    Match(ExprMatch),
    ExprMissing(ExprMissing),
}
pub struct ExprPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for Expr {
    type StablePtr = ExprPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::ExprPath => Expr::Path(ExprPath::from_syntax_node(db, node)),
                SyntaxKind::ExprLiteral => Expr::Literal(ExprLiteral::from_syntax_node(db, node)),
                SyntaxKind::ExprParenthesized => {
                    Expr::Parenthesized(ExprParenthesized::from_syntax_node(db, node))
                }
                SyntaxKind::ExprUnary => Expr::Unary(ExprUnary::from_syntax_node(db, node)),
                SyntaxKind::ExprBinary => Expr::Binary(ExprBinary::from_syntax_node(db, node)),
                SyntaxKind::ExprTuple => Expr::Tuple(ExprTuple::from_syntax_node(db, node)),
                SyntaxKind::ExprFunctionCall => {
                    Expr::FunctionCall(ExprFunctionCall::from_syntax_node(db, node))
                }
                SyntaxKind::ExprStructCtorCall => {
                    Expr::StructCtorCall(ExprStructCtorCall::from_syntax_node(db, node))
                }
                SyntaxKind::ExprBlock => Expr::Block(ExprBlock::from_syntax_node(db, node)),
                SyntaxKind::ExprMatch => Expr::Match(ExprMatch::from_syntax_node(db, node)),
                SyntaxKind::ExprMissing => {
                    Expr::ExprMissing(ExprMissing::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Expr"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!("Unexpected token kind {:?} when constructing {}.", token.kind, "Expr"),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Expr::Path(x) => x.as_syntax_node(),
            Expr::Literal(x) => x.as_syntax_node(),
            Expr::Parenthesized(x) => x.as_syntax_node(),
            Expr::Unary(x) => x.as_syntax_node(),
            Expr::Binary(x) => x.as_syntax_node(),
            Expr::Tuple(x) => x.as_syntax_node(),
            Expr::FunctionCall(x) => x.as_syntax_node(),
            Expr::StructCtorCall(x) => x.as_syntax_node(),
            Expr::Block(x) => x.as_syntax_node(),
            Expr::Match(x) => x.as_syntax_node(),
            Expr::ExprMissing(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprList(ElementList<Expr, 2>);
impl Deref for ExprList {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprList,
            children,
            width,
        }))
    }
}
pub struct ExprListPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprList {
    type StablePtr = ExprListPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children,
            width,
        }))
    }
}
pub struct ExprMissingPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprMissing {
    type StablePtr = ExprMissingPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprMissing {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprMissing,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprMissing,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprMissingPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionGenericArgs {
    Empty(OptionGenericArgsEmpty),
    Some(OptionGenericArgsSome),
}
pub struct OptionGenericArgsPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionGenericArgs {
    type StablePtr = OptionGenericArgsPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionGenericArgsEmpty => {
                    OptionGenericArgs::Empty(OptionGenericArgsEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::OptionGenericArgsSome => {
                    OptionGenericArgs::Some(OptionGenericArgsSome::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionGenericArgs"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionGenericArgs"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionGenericArgs::Empty(x) => x.as_syntax_node(),
            OptionGenericArgs::Some(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionGenericArgsPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionGenericArgsEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionGenericArgsEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsEmpty,
            children,
            width,
        }))
    }
}
pub struct OptionGenericArgsEmptyPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionGenericArgsEmpty {
    type StablePtr = OptionGenericArgsEmptyPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsEmpty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionGenericArgsEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionGenericArgsEmpty,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionGenericArgsEmpty,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionGenericArgsEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionGenericArgsSome(ElementList<Expr, 2>);
impl Deref for OptionGenericArgsSome {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl OptionGenericArgsSome {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsSome,
            children,
            width,
        }))
    }
}
pub struct OptionGenericArgsSomePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionGenericArgsSome {
    type StablePtr = OptionGenericArgsSomePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsSome,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionGenericArgsSomePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PathSegment {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PathSegment {
    pub fn new_green(db: &dyn SyntaxGroup, ident: GreenId, generic_args: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![ident, generic_args];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::PathSegment,
            children,
            width,
        }))
    }
    pub fn ident(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> OptionGenericArgs {
        OptionGenericArgs::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct PathSegmentPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for PathSegment {
    type StablePtr = PathSegmentPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::PathSegment,
            children: vec![Terminal::missing(db), OptionGenericArgs::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::PathSegment {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::PathSegment,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::PathSegment,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PathSegmentPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprPath(ElementList<PathSegment, 2>);
impl Deref for ExprPath {
    type Target = ElementList<PathSegment, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprPath {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprPath,
            children,
            width,
        }))
    }
}
pub struct ExprPathPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprPath {
    type StablePtr = ExprPathPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprPath,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprPathPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprLiteral {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprLiteral {
    pub fn new_green(db: &dyn SyntaxGroup, terminal: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![terminal];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprLiteral,
            children,
            width,
        }))
    }
    pub fn terminal(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
}
pub struct ExprLiteralPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprLiteral {
    type StablePtr = ExprLiteralPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprLiteral,
            children: vec![Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprLiteral {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprLiteral,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprLiteral,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprLiteralPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprParenthesized {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: GreenId,
        expr: GreenId,
        rparen: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, expr, rparen];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprParenthesized,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ExprParenthesizedPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprParenthesized {
    type StablePtr = ExprParenthesizedPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprParenthesized,
            children: vec![Terminal::missing(db), Expr::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprParenthesized,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprParenthesized,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprParenthesizedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprUnary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprUnary {
    pub fn new_green(db: &dyn SyntaxGroup, op: GreenId, expr: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![op, expr];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprUnary,
            children,
            width,
        }))
    }
    pub fn op(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct ExprUnaryPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprUnary {
    type StablePtr = ExprUnaryPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprUnary,
            children: vec![Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprUnary {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprUnary,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprUnary,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprUnaryPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBinary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBinary {
    pub fn new_green(db: &dyn SyntaxGroup, lhs: GreenId, op: GreenId, rhs: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![lhs, op, rhs];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBinary,
            children,
            width,
        }))
    }
    pub fn lhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn op(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ExprBinaryPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprBinary {
    type StablePtr = ExprBinaryPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBinary,
            children: vec![Expr::missing(db), Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprBinary {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprBinary,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprBinary,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprBinaryPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprTuple {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprTuple {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: GreenId,
        expressions: GreenId,
        rparen: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, expressions, rparen];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprTuple,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expressions(&self, db: &dyn SyntaxGroup) -> ExprList {
        ExprList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ExprTuplePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprTuple {
    type StablePtr = ExprTuplePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprTuple,
            children: vec![Terminal::missing(db), ExprList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprTuple {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprTuple,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprTuple,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprTuplePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprListParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprListParenthesized {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: GreenId,
        expressions: GreenId,
        rparen: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, expressions, rparen];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprListParenthesized,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expressions(&self, db: &dyn SyntaxGroup) -> ExprList {
        ExprList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ExprListParenthesizedPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprListParenthesized {
    type StablePtr = ExprListParenthesizedPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprListParenthesized,
            children: vec![Terminal::missing(db), ExprList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprListParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprListParenthesized,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprListParenthesized,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprListParenthesizedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprFunctionCall {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprFunctionCall {
    pub fn new_green(db: &dyn SyntaxGroup, path: GreenId, arguments: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![path, arguments];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprFunctionCall,
            children,
            width,
        }))
    }
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> ExprListParenthesized {
        ExprListParenthesized::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct ExprFunctionCallPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprFunctionCall {
    type StablePtr = ExprFunctionCallPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprFunctionCall,
            children: vec![ExprPath::missing(db), ExprListParenthesized::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprFunctionCall {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprFunctionCall,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprFunctionCall,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprFunctionCallPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprStructCtorCall {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprStructCtorCall {
    pub fn new_green(db: &dyn SyntaxGroup, path: GreenId, arguments: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![path, arguments];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprStructCtorCall,
            children,
            width,
        }))
    }
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> ArgListBraced {
        ArgListBraced::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct ExprStructCtorCallPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprStructCtorCall {
    type StablePtr = ExprStructCtorCallPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprStructCtorCall,
            children: vec![ExprPath::missing(db), ArgListBraced::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprStructCtorCall {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprStructCtorCall,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprStructCtorCall,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprStructCtorCallPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBlock {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBlock {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: GreenId,
        statements: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lbrace, statements, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBlock,
            children,
            width,
        }))
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn statements(&self, db: &dyn SyntaxGroup) -> StatementList {
        StatementList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ExprBlockPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprBlock {
    type StablePtr = ExprBlockPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBlock,
            children: vec![
                Terminal::missing(db),
                StatementList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprBlock {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprBlock,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprBlock,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprBlockPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Pattern {
    Underscore(Terminal),
    Literal(ExprLiteral),
}
pub struct PatternPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for Pattern {
    type StablePtr = PatternPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::Terminal => Pattern::Underscore(Terminal::from_syntax_node(db, node)),
                SyntaxKind::ExprLiteral => {
                    Pattern::Literal(ExprLiteral::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Pattern"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "Pattern"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Pattern::Underscore(x) => x.as_syntax_node(),
            Pattern::Literal(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MatchArm {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl MatchArm {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        pattern: GreenId,
        arrow: GreenId,
        expression: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![pattern, arrow, expression];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::MatchArm,
            children,
            width,
        }))
    }
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arrow(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn expression(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct MatchArmPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for MatchArm {
    type StablePtr = MatchArmPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::MatchArm,
            children: vec![Pattern::missing(db), Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::MatchArm {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::MatchArm,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::MatchArm,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MatchArmPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MatchArms(ElementList<MatchArm, 2>);
impl Deref for MatchArms {
    type Target = ElementList<MatchArm, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl MatchArms {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::MatchArms,
            children,
            width,
        }))
    }
}
pub struct MatchArmsPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for MatchArms {
    type StablePtr = MatchArmsPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::MatchArms,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MatchArmsPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprMatch {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprMatch {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        matchkw: GreenId,
        expr: GreenId,
        lbrace: GreenId,
        arms: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![matchkw, expr, lbrace, arms, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMatch,
            children,
            width,
        }))
    }
    pub fn matchkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn arms(&self, db: &dyn SyntaxGroup) -> MatchArms {
        MatchArms::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
}
pub struct ExprMatchPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ExprMatch {
    type StablePtr = ExprMatchPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMatch,
            children: vec![
                Terminal::missing(db),
                Expr::missing(db),
                Terminal::missing(db),
                MatchArms::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprMatch {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprMatch,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprMatch,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprMatchPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TypeClause {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TypeClause {
    pub fn new_green(db: &dyn SyntaxGroup, colon: GreenId, ty: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![colon, ty];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TypeClause,
            children,
            width,
        }))
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ty(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct TypeClausePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for TypeClause {
    type StablePtr = TypeClausePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TypeClause,
            children: vec![Terminal::missing(db), ExprPath::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::TypeClause {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::TypeClause,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::TypeClause,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TypeClausePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTypeClause {
    Empty(OptionTypeClauseEmpty),
    TypeClause(TypeClause),
}
pub struct OptionTypeClausePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionTypeClause {
    type StablePtr = OptionTypeClausePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionTypeClauseEmpty => {
                    OptionTypeClause::Empty(OptionTypeClauseEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::TypeClause => {
                    OptionTypeClause::TypeClause(TypeClause::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionTypeClause"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionTypeClause"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTypeClause::Empty(x) => x.as_syntax_node(),
            OptionTypeClause::TypeClause(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTypeClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum NonOptionTypeClause {
    TypeClause(TypeClause),
    NonOptionTypeClauseMissing(NonOptionTypeClauseMissing),
}
pub struct NonOptionTypeClausePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for NonOptionTypeClause {
    type StablePtr = NonOptionTypeClausePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::NonOptionTypeClauseMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::TypeClause => {
                    NonOptionTypeClause::TypeClause(TypeClause::from_syntax_node(db, node))
                }
                SyntaxKind::NonOptionTypeClauseMissing => {
                    NonOptionTypeClause::NonOptionTypeClauseMissing(
                        NonOptionTypeClauseMissing::from_syntax_node(db, node),
                    )
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "NonOptionTypeClause"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "NonOptionTypeClause"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            NonOptionTypeClause::TypeClause(x) => x.as_syntax_node(),
            NonOptionTypeClause::NonOptionTypeClauseMissing(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        NonOptionTypeClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct NonOptionTypeClauseMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl NonOptionTypeClauseMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::NonOptionTypeClauseMissing,
            children,
            width,
        }))
    }
}
pub struct NonOptionTypeClauseMissingPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for NonOptionTypeClauseMissing {
    type StablePtr = NonOptionTypeClauseMissingPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::NonOptionTypeClauseMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::NonOptionTypeClauseMissing {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::NonOptionTypeClauseMissing,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::NonOptionTypeClauseMissing,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        NonOptionTypeClauseMissingPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTypeClauseEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionTypeClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionTypeClauseEmpty,
            children,
            width,
        }))
    }
}
pub struct OptionTypeClauseEmptyPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionTypeClauseEmpty {
    type StablePtr = OptionTypeClauseEmptyPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionTypeClauseEmpty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionTypeClauseEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionTypeClauseEmpty,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionTypeClauseEmpty,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTypeClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ReturnTypeClause {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ReturnTypeClause {
    pub fn new_green(db: &dyn SyntaxGroup, arrow: GreenId, ty: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![arrow, ty];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ReturnTypeClause,
            children,
            width,
        }))
    }
    pub fn arrow(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ty(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct ReturnTypeClausePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ReturnTypeClause {
    type StablePtr = ReturnTypeClausePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ReturnTypeClause,
            children: vec![Terminal::missing(db), ExprPath::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ReturnTypeClause {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ReturnTypeClause,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ReturnTypeClause,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ReturnTypeClausePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionReturnTypeClause {
    Empty(OptionReturnTypeClauseEmpty),
    ReturnTypeClause(ReturnTypeClause),
}
pub struct OptionReturnTypeClausePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionReturnTypeClause {
    type StablePtr = OptionReturnTypeClausePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionReturnTypeClauseEmpty => OptionReturnTypeClause::Empty(
                    OptionReturnTypeClauseEmpty::from_syntax_node(db, node),
                ),
                SyntaxKind::ReturnTypeClause => OptionReturnTypeClause::ReturnTypeClause(
                    ReturnTypeClause::from_syntax_node(db, node),
                ),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionReturnTypeClause"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionReturnTypeClause"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionReturnTypeClause::Empty(x) => x.as_syntax_node(),
            OptionReturnTypeClause::ReturnTypeClause(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionReturnTypeClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionReturnTypeClauseEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionReturnTypeClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionReturnTypeClauseEmpty,
            children,
            width,
        }))
    }
}
pub struct OptionReturnTypeClauseEmptyPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionReturnTypeClauseEmpty {
    type StablePtr = OptionReturnTypeClauseEmptyPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionReturnTypeClauseEmpty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionReturnTypeClauseEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionReturnTypeClauseEmpty,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionReturnTypeClauseEmpty,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionReturnTypeClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Statement {
    Let(StatementLet),
    Expr(StatementExpr),
    Return(StatementReturn),
    StatementMissing(StatementMissing),
}
pub struct StatementPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for Statement {
    type StablePtr = StatementPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::StatementLet => {
                    Statement::Let(StatementLet::from_syntax_node(db, node))
                }
                SyntaxKind::StatementExpr => {
                    Statement::Expr(StatementExpr::from_syntax_node(db, node))
                }
                SyntaxKind::StatementReturn => {
                    Statement::Return(StatementReturn::from_syntax_node(db, node))
                }
                SyntaxKind::StatementMissing => {
                    Statement::StatementMissing(StatementMissing::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Statement"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "Statement"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Statement::Let(x) => x.as_syntax_node(),
            Statement::Expr(x) => x.as_syntax_node(),
            Statement::Return(x) => x.as_syntax_node(),
            Statement::StatementMissing(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementList(ElementList<Statement, 1>);
impl Deref for StatementList {
    type Target = ElementList<Statement, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StatementList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementList,
            children,
            width,
        }))
    }
}
pub struct StatementListPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for StatementList {
    type StablePtr = StatementListPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children,
            width,
        }))
    }
}
pub struct StatementMissingPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for StatementMissing {
    type StablePtr = StatementMissingPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementMissing {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementMissing,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::StatementMissing,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementMissingPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementLet {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementLet {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        letkw: GreenId,
        lhs: GreenId,
        type_clause: GreenId,
        eq: GreenId,
        rhs: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![letkw, lhs, type_clause, eq, rhs, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementLet,
            children,
            width,
        }))
    }
    pub fn letkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lhs(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> OptionTypeClause {
        OptionTypeClause::from_syntax_node(db, self.children[2].clone())
    }
    pub fn eq(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[4].clone())
    }
    pub fn semi(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[5].clone())
    }
}
pub struct StatementLetPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for StatementLet {
    type StablePtr = StatementLetPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementLet,
            children: vec![
                Terminal::missing(db),
                Terminal::missing(db),
                OptionTypeClause::missing(db),
                Terminal::missing(db),
                Expr::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementLet {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementLet,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementLet,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementLetPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionSemicolon {
    Empty(OptionSemicolonEmpty),
    Some(Terminal),
}
pub struct OptionSemicolonPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionSemicolon {
    type StablePtr = OptionSemicolonPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionSemicolonEmpty => {
                    OptionSemicolon::Empty(OptionSemicolonEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::Terminal => OptionSemicolon::Some(Terminal::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionSemicolon"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionSemicolon"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionSemicolon::Empty(x) => x.as_syntax_node(),
            OptionSemicolon::Some(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionSemicolonPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionSemicolonEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionSemicolonEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionSemicolonEmpty,
            children,
            width,
        }))
    }
}
pub struct OptionSemicolonEmptyPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for OptionSemicolonEmpty {
    type StablePtr = OptionSemicolonEmptyPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionSemicolonEmpty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionSemicolonEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionSemicolonEmpty,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionSemicolonEmpty,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionSemicolonEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementExpr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementExpr {
    pub fn new_green(db: &dyn SyntaxGroup, expr: GreenId, semi: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![expr, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementExpr,
            children,
            width,
        }))
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn semi(&self, db: &dyn SyntaxGroup) -> OptionSemicolon {
        OptionSemicolon::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct StatementExprPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for StatementExpr {
    type StablePtr = StatementExprPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementExpr,
            children: vec![Expr::missing(db), OptionSemicolon::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementExpr {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementExpr,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementExpr,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementExprPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementReturn {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementReturn {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        returnkw: GreenId,
        expr: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![returnkw, expr, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementReturn,
            children,
            width,
        }))
    }
    pub fn returnkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semi(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct StatementReturnPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for StatementReturn {
    type StablePtr = StatementReturnPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementReturn,
            children: vec![Terminal::missing(db), Expr::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementReturn {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementReturn,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementReturn,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementReturnPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Param {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Param {
    pub fn new_green(db: &dyn SyntaxGroup, identifier: GreenId, type_clause: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![identifier, type_clause];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Param,
            children,
            width,
        }))
    }
    pub fn identifier(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> NonOptionTypeClause {
        NonOptionTypeClause::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct ParamPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for Param {
    type StablePtr = ParamPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Param,
            children: vec![Terminal::missing(db), NonOptionTypeClause::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Param {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Param,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Param,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamList(ElementList<Param, 2>);
impl Deref for ParamList {
    type Target = ElementList<Param, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ParamList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamList,
            children,
            width,
        }))
    }
}
pub struct ParamListPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ParamList {
    type StablePtr = ParamListPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamListParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ParamListParenthesized {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: GreenId,
        parameters: GreenId,
        rparen: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, parameters, rparen];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListParenthesized,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn parameters(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ParamListParenthesizedPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ParamListParenthesized {
    type StablePtr = ParamListParenthesizedPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListParenthesized,
            children: vec![Terminal::missing(db), ParamList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ParamListParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ParamListParenthesized,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ParamListParenthesized,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamListParenthesizedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamListBraced {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ParamListBraced {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: GreenId,
        parameters: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lbrace, parameters, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListBraced,
            children,
            width,
        }))
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn parameters(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ParamListBracedPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ParamListBraced {
    type StablePtr = ParamListBracedPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListBraced,
            children: vec![Terminal::missing(db), ParamList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ParamListBraced {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ParamListBraced,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ParamListBraced,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamListBracedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct FunctionSignature {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl FunctionSignature {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: GreenId,
        parameters: GreenId,
        rparen: GreenId,
        ret_ty: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, parameters, rparen, ret_ty];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::FunctionSignature,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn parameters(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn ret_ty(&self, db: &dyn SyntaxGroup) -> OptionReturnTypeClause {
        OptionReturnTypeClause::from_syntax_node(db, self.children[3].clone())
    }
}
pub struct FunctionSignaturePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for FunctionSignature {
    type StablePtr = FunctionSignaturePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::FunctionSignature,
            children: vec![
                Terminal::missing(db),
                ParamList::missing(db),
                Terminal::missing(db),
                OptionReturnTypeClause::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::FunctionSignature {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::FunctionSignature,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::FunctionSignature,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        FunctionSignaturePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Item {
    Module(ItemModule),
    Function(ItemFunction),
    ExternFunction(ItemExternFunction),
    ExternType(ItemExternType),
    Trait(ItemTrait),
    Impl(ItemImpl),
    Struct(ItemStruct),
    Enum(ItemEnum),
    Use(ItemUse),
}
pub struct ItemPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for Item {
    type StablePtr = ItemPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::ItemModule => Item::Module(ItemModule::from_syntax_node(db, node)),
                SyntaxKind::ItemFunction => {
                    Item::Function(ItemFunction::from_syntax_node(db, node))
                }
                SyntaxKind::ItemExternFunction => {
                    Item::ExternFunction(ItemExternFunction::from_syntax_node(db, node))
                }
                SyntaxKind::ItemExternType => {
                    Item::ExternType(ItemExternType::from_syntax_node(db, node))
                }
                SyntaxKind::ItemTrait => Item::Trait(ItemTrait::from_syntax_node(db, node)),
                SyntaxKind::ItemImpl => Item::Impl(ItemImpl::from_syntax_node(db, node)),
                SyntaxKind::ItemStruct => Item::Struct(ItemStruct::from_syntax_node(db, node)),
                SyntaxKind::ItemEnum => Item::Enum(ItemEnum::from_syntax_node(db, node)),
                SyntaxKind::ItemUse => Item::Use(ItemUse::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Item"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!("Unexpected token kind {:?} when constructing {}.", token.kind, "Item"),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Item::Module(x) => x.as_syntax_node(),
            Item::Function(x) => x.as_syntax_node(),
            Item::ExternFunction(x) => x.as_syntax_node(),
            Item::ExternType(x) => x.as_syntax_node(),
            Item::Trait(x) => x.as_syntax_node(),
            Item::Impl(x) => x.as_syntax_node(),
            Item::Struct(x) => x.as_syntax_node(),
            Item::Enum(x) => x.as_syntax_node(),
            Item::Use(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemList(ElementList<Item, 1>);
impl Deref for ItemList {
    type Target = ElementList<Item, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ItemList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemList,
            children,
            width,
        }))
    }
}
pub struct ItemListPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ItemList {
    type StablePtr = ItemListPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemModule {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemModule {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        modkw: GreenId,
        name: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![modkw, name, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemModule,
            children,
            width,
        }))
    }
    pub fn modkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semi(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ItemModulePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ItemModule {
    type StablePtr = ItemModulePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemModule,
            children: vec![Terminal::missing(db), Terminal::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemModule {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemModule,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemModule,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemModulePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemFunction {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemFunction {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        funckw: GreenId,
        name: GreenId,
        signature: GreenId,
        body: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![funckw, name, signature, body];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFunction,
            children,
            width,
        }))
    }
    pub fn funckw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn signature(&self, db: &dyn SyntaxGroup) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[2].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[3].clone())
    }
}
pub struct ItemFunctionPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ItemFunction {
    type StablePtr = ItemFunctionPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFunction,
            children: vec![
                Terminal::missing(db),
                Terminal::missing(db),
                FunctionSignature::missing(db),
                ExprBlock::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemFunction {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemFunction,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemFunction,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemFunctionPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemExternFunction {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemExternFunction {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        externkw: GreenId,
        funckw: GreenId,
        name: GreenId,
        signature: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![externkw, funckw, name, signature, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemExternFunction,
            children,
            width,
        }))
    }
    pub fn externkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn funckw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn signature(&self, db: &dyn SyntaxGroup) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[3].clone())
    }
    pub fn semi(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
}
pub struct ItemExternFunctionPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ItemExternFunction {
    type StablePtr = ItemExternFunctionPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemExternFunction,
            children: vec![
                Terminal::missing(db),
                Terminal::missing(db),
                Terminal::missing(db),
                FunctionSignature::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemExternFunction {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemExternFunction,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ItemExternFunction,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemExternFunctionPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemExternType {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemExternType {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        externkw: GreenId,
        typekw: GreenId,
        name: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![externkw, typekw, name, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemExternType,
            children,
            width,
        }))
    }
    pub fn externkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn typekw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn semi(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[3].clone())
    }
}
pub struct ItemExternTypePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ItemExternType {
    type StablePtr = ItemExternTypePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemExternType,
            children: vec![
                Terminal::missing(db),
                Terminal::missing(db),
                Terminal::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemExternType {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemExternType,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemExternType,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemExternTypePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemTrait {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemTrait {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        traitkw: GreenId,
        name: GreenId,
        lbrace: GreenId,
        items: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![traitkw, name, lbrace, items, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemTrait,
            children,
            width,
        }))
    }
    pub fn traitkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> ItemList {
        ItemList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
}
pub struct ItemTraitPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ItemTrait {
    type StablePtr = ItemTraitPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemTrait,
            children: vec![
                Terminal::missing(db),
                Terminal::missing(db),
                Terminal::missing(db),
                ItemList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemTrait {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemTrait,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemTrait,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemTraitPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemImpl {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemImpl {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        implkw: GreenId,
        name: GreenId,
        forkw: GreenId,
        trait_name: GreenId,
        lbrace: GreenId,
        items: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![implkw, name, forkw, trait_name, lbrace, items, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemImpl,
            children,
            width,
        }))
    }
    pub fn implkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn forkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn trait_name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[3].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> ItemList {
        ItemList::from_syntax_node(db, self.children[5].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[6].clone())
    }
}
pub struct ItemImplPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ItemImpl {
    type StablePtr = ItemImplPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemImpl,
            children: vec![
                Terminal::missing(db),
                Terminal::missing(db),
                Terminal::missing(db),
                Terminal::missing(db),
                Terminal::missing(db),
                ItemList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemImpl {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemImpl,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemImpl,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemImplPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemStruct {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemStruct {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        structkw: GreenId,
        name: GreenId,
        lbrace: GreenId,
        members: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![structkw, name, lbrace, members, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemStruct,
            children,
            width,
        }))
    }
    pub fn structkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn members(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
}
pub struct ItemStructPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ItemStruct {
    type StablePtr = ItemStructPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemStruct,
            children: vec![
                Terminal::missing(db),
                Terminal::missing(db),
                Terminal::missing(db),
                ParamList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemStruct {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemStruct,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemStruct,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemStructPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemEnum {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemEnum {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        enumkw: GreenId,
        name: GreenId,
        body: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![enumkw, name, body];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemEnum,
            children,
            width,
        }))
    }
    pub fn enumkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> ParamListBraced {
        ParamListBraced::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ItemEnumPtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ItemEnum {
    type StablePtr = ItemEnumPtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemEnum,
            children: vec![
                Terminal::missing(db),
                Terminal::missing(db),
                ParamListBraced::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemEnum {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemEnum,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemEnum,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemEnumPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemUse {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemUse {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        usekw: GreenId,
        path: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![usekw, path, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemUse,
            children,
            width,
        }))
    }
    pub fn usekw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semi(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
pub struct ItemUsePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for ItemUse {
    type StablePtr = ItemUsePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemUse,
            children: vec![Terminal::missing(db), ExprPath::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemUse {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemUse,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemUse,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemUsePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct SyntaxFile {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl SyntaxFile {
    pub fn new_green(db: &dyn SyntaxGroup, items: GreenId, eof: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![items, eof];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::SyntaxFile,
            children,
            width,
        }))
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> ItemList {
        ItemList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn eof(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
}
pub struct SyntaxFilePtr(SyntaxStablePtrId);
impl TypedSyntaxNode for SyntaxFile {
    type StablePtr = SyntaxFilePtr;
    fn missing(db: &dyn SyntaxGroup) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::SyntaxFile,
            children: vec![ItemList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::SyntaxFile {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::SyntaxFile,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::SyntaxFile,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        SyntaxFilePtr(self.node.0.stable_ptr)
    }
}
