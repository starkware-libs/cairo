// Autogenerated file. To regenerate, please run `cargo run --bin generate_syntax`.
#![allow(clippy::match_single_binding)]
#![allow(clippy::too_many_arguments)]
#![allow(dead_code)]
#![allow(unused_variables)]
use std::ops::Deref;

use super::element_list::ElementList;
use super::green::GreenNodeInternal;
use super::kind::SyntaxKind;
use super::{GreenId, GreenInterner, GreenNode, SyntaxNode, Token, TypedSyntaxNode};
use crate::token::TokenKind;
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Terminal {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal {
    pub fn new_green(
        db: &dyn GreenInterner,
        leading_trivia: GreenId,
        token: GreenId,
        trailing_trivia: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![leading_trivia, token, trailing_trivia];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Terminal,
            children,
            width,
        }))
    }
    pub fn leading_trivia(&self, db: &dyn GreenInterner) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn GreenInterner) -> Token {
        let child = self.children[1].clone();
        Token::from_syntax_node(db, child)
    }
    pub fn trailing_trivia(&self, db: &dyn GreenInterner) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for Terminal {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Terminal,
            children: vec![Trivia::missing(db), Token::missing(db), Trivia::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Terminal {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Terminal
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Terminal);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Trivia(ElementList<Trivium, 1>);
impl Deref for Trivia {
    type Target = ElementList<Trivium, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl Trivia {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Trivia,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for Trivia {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Trivia,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Trivium {
    TriviumSingleLineComment(Token),
    TriviumWhitespace(Token),
    TriviumNewline(Token),
}
impl TypedSyntaxNode for Trivium {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Trivium"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                TokenKind::SingleLineComment => {
                    Trivium::TriviumSingleLineComment(Token::from_syntax_node(db, node))
                }
                TokenKind::Whitespace => {
                    Trivium::TriviumWhitespace(Token::from_syntax_node(db, node))
                }
                TokenKind::Newline => Trivium::TriviumNewline(Token::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "Trivium"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Trivium::TriviumSingleLineComment(x) => x.as_syntax_node(),
            Trivium::TriviumWhitespace(x) => x.as_syntax_node(),
            Trivium::TriviumNewline(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Identifier {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Identifier {
    pub fn new_green(db: &dyn GreenInterner, terminal: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![terminal];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Identifier,
            children,
            width,
        }))
    }
    pub fn terminal(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
}
impl TypedSyntaxNode for Identifier {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Identifier,
            children: vec![Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Identifier {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Identifier
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Identifier);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Expr {
    ExprPath(ExprPath),
    ExprLiteral(ExprLiteral),
    ExprParenthesized(ExprParenthesized),
    ExprUnary(ExprUnary),
    ExprBinary(ExprBinary),
    ExprMissing(ExprMissing),
}
impl TypedSyntaxNode for Expr {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::ExprPath => Expr::ExprPath(ExprPath::from_syntax_node(db, node)),
                SyntaxKind::ExprLiteral => {
                    Expr::ExprLiteral(ExprLiteral::from_syntax_node(db, node))
                }
                SyntaxKind::ExprParenthesized => {
                    Expr::ExprParenthesized(ExprParenthesized::from_syntax_node(db, node))
                }
                SyntaxKind::ExprUnary => Expr::ExprUnary(ExprUnary::from_syntax_node(db, node)),
                SyntaxKind::ExprBinary => Expr::ExprBinary(ExprBinary::from_syntax_node(db, node)),
                SyntaxKind::ExprMissing => {
                    Expr::ExprMissing(ExprMissing::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Expr"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!("Unexpected token kind {:?} when constructing {}.", token.kind, "Expr"),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Expr::ExprPath(x) => x.as_syntax_node(),
            Expr::ExprLiteral(x) => x.as_syntax_node(),
            Expr::ExprParenthesized(x) => x.as_syntax_node(),
            Expr::ExprUnary(x) => x.as_syntax_node(),
            Expr::ExprBinary(x) => x.as_syntax_node(),
            Expr::ExprMissing(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprMissing {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ExprMissing {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprMissing {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprMissing
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprMissing);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprPath(ElementList<PathSegment, 2>);
impl Deref for ExprPath {
    type Target = ElementList<PathSegment, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprPath {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprPath,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ExprPath {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprPath,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PathSegment {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PathSegment {
    pub fn new_green(db: &dyn GreenInterner, ident: GreenId, args: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![ident, args];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::PathSegment,
            children,
            width,
        }))
    }
    pub fn ident(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn args(&self, db: &dyn GreenInterner) -> OptionGenericArgs {
        OptionGenericArgs::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for PathSegment {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::PathSegment,
            children: vec![Identifier::missing(db), OptionGenericArgs::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::PathSegment {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::PathSegment
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::PathSegment);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionGenericArgs {
    OptionGenericArgsNone(OptionGenericArgsNone),
    OptionGenericArgsSome(OptionGenericArgsSome),
}
impl TypedSyntaxNode for OptionGenericArgs {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionGenericArgsNone => OptionGenericArgs::OptionGenericArgsNone(
                    OptionGenericArgsNone::from_syntax_node(db, node),
                ),
                SyntaxKind::OptionGenericArgsSome => OptionGenericArgs::OptionGenericArgsSome(
                    OptionGenericArgsSome::from_syntax_node(db, node),
                ),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionGenericArgs"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionGenericArgs"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionGenericArgs::OptionGenericArgsNone(x) => x.as_syntax_node(),
            OptionGenericArgs::OptionGenericArgsSome(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionGenericArgsNone {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionGenericArgsNone {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsNone,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for OptionGenericArgsNone {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsNone,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionGenericArgsNone {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionGenericArgsNone
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionGenericArgsNone
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionGenericArgsSome(ElementList<Expr, 2>);
impl Deref for OptionGenericArgsSome {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl OptionGenericArgsSome {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsSome,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for OptionGenericArgsSome {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsSome,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprLiteral {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprLiteral {
    pub fn new_green(db: &dyn GreenInterner, terminal: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![terminal];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprLiteral,
            children,
            width,
        }))
    }
    pub fn terminal(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
}
impl TypedSyntaxNode for ExprLiteral {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprLiteral,
            children: vec![Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprLiteral {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprLiteral
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprLiteral);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprParenthesized {
    pub fn new_green(
        db: &dyn GreenInterner,
        lparen: GreenId,
        expr: GreenId,
        rparen: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, expr, rparen];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprParenthesized,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ExprParenthesized {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprParenthesized,
            children: vec![Terminal::missing(db), Expr::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprParenthesized
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprParenthesized
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprUnary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprUnary {
    pub fn new_green(db: &dyn GreenInterner, op: GreenId, expr: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![op, expr];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprUnary,
            children,
            width,
        }))
    }
    pub fn op(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for ExprUnary {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprUnary,
            children: vec![Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprUnary {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprUnary
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprUnary);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBinary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBinary {
    pub fn new_green(db: &dyn GreenInterner, lhs: GreenId, op: GreenId, rhs: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![lhs, op, rhs];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBinary,
            children,
            width,
        }))
    }
    pub fn lhs(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn op(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rhs(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ExprBinary {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBinary,
            children: vec![Expr::missing(db), Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprBinary {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprBinary
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprBinary);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBlock {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBlock {
    pub fn new_green(
        db: &dyn GreenInterner,
        lbrace: GreenId,
        statements: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lbrace, statements, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBlock,
            children,
            width,
        }))
    }
    pub fn lbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn statements(&self, db: &dyn GreenInterner) -> StatementList {
        StatementList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ExprBlock {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBlock,
            children: vec![
                Terminal::missing(db),
                StatementList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprBlock {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprBlock
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprBlock);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementList(ElementList<Statement, 2>);
impl Deref for StatementList {
    type Target = ElementList<Statement, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StatementList {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementList,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for StatementList {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Statement {
    StatementLet(StatementLet),
    StatementExpr(StatementExpr),
    StatementReturn(StatementReturn),
    StatementMissing(StatementMissing),
}
impl TypedSyntaxNode for Statement {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::StatementLet => {
                    Statement::StatementLet(StatementLet::from_syntax_node(db, node))
                }
                SyntaxKind::StatementExpr => {
                    Statement::StatementExpr(StatementExpr::from_syntax_node(db, node))
                }
                SyntaxKind::StatementReturn => {
                    Statement::StatementReturn(StatementReturn::from_syntax_node(db, node))
                }
                SyntaxKind::StatementMissing => {
                    Statement::StatementMissing(StatementMissing::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Statement"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "Statement"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Statement::StatementLet(x) => x.as_syntax_node(),
            Statement::StatementExpr(x) => x.as_syntax_node(),
            Statement::StatementReturn(x) => x.as_syntax_node(),
            Statement::StatementMissing(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementMissing {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for StatementMissing {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementMissing {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementMissing
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::StatementMissing
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementLet {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementLet {
    pub fn new_green(
        db: &dyn GreenInterner,
        letkw: GreenId,
        lhs: GreenId,
        eq: GreenId,
        rhs: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![letkw, lhs, eq, rhs];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementLet,
            children,
            width,
        }))
    }
    pub fn letkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lhs(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn eq(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn rhs(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[3].clone())
    }
}
impl TypedSyntaxNode for StatementLet {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementLet,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                Terminal::missing(db),
                Expr::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementLet {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementLet
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementLet);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementExpr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementExpr {
    pub fn new_green(db: &dyn GreenInterner, expr: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![expr];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementExpr,
            children,
            width,
        }))
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
}
impl TypedSyntaxNode for StatementExpr {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementExpr,
            children: vec![Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementExpr {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementExpr
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementExpr);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementReturn {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementReturn {
    pub fn new_green(db: &dyn GreenInterner, returnkw: GreenId, expr: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![returnkw, expr];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementReturn,
            children,
            width,
        }))
    }
    pub fn returnkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for StatementReturn {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementReturn,
            children: vec![Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementReturn {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementReturn
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementReturn);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemList(ElementList<Item, 2>);
impl Deref for ItemList {
    type Target = ElementList<Item, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ItemList {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemList,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ItemList {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Item {
    ItemModule(ItemModule),
    ItemFunction(ItemFunction),
    ItemTrait(ItemTrait),
    ItemImpl(ItemImpl),
    ItemStruct(ItemStruct),
    ItemEnum(ItemEnum),
    ItemUse(ItemUse),
}
impl TypedSyntaxNode for Item {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::ItemModule => Item::ItemModule(ItemModule::from_syntax_node(db, node)),
                SyntaxKind::ItemFunction => {
                    Item::ItemFunction(ItemFunction::from_syntax_node(db, node))
                }
                SyntaxKind::ItemTrait => Item::ItemTrait(ItemTrait::from_syntax_node(db, node)),
                SyntaxKind::ItemImpl => Item::ItemImpl(ItemImpl::from_syntax_node(db, node)),
                SyntaxKind::ItemStruct => Item::ItemStruct(ItemStruct::from_syntax_node(db, node)),
                SyntaxKind::ItemEnum => Item::ItemEnum(ItemEnum::from_syntax_node(db, node)),
                SyntaxKind::ItemUse => Item::ItemUse(ItemUse::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Item"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!("Unexpected token kind {:?} when constructing {}.", token.kind, "Item"),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Item::ItemModule(x) => x.as_syntax_node(),
            Item::ItemFunction(x) => x.as_syntax_node(),
            Item::ItemTrait(x) => x.as_syntax_node(),
            Item::ItemImpl(x) => x.as_syntax_node(),
            Item::ItemStruct(x) => x.as_syntax_node(),
            Item::ItemEnum(x) => x.as_syntax_node(),
            Item::ItemUse(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemModule {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemModule {
    pub fn new_green(
        db: &dyn GreenInterner,
        modkw: GreenId,
        name: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![modkw, name, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemModule,
            children,
            width,
        }))
    }
    pub fn modkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semi(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ItemModule {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemModule,
            children: vec![Terminal::missing(db), Identifier::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemModule {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemModule
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemModule);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemFunction {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemFunction {
    pub fn new_green(db: &dyn GreenInterner, signature: GreenId, body: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![signature, body];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFunction,
            children,
            width,
        }))
    }
    pub fn signature(&self, db: &dyn GreenInterner) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[0].clone())
    }
    pub fn body(&self, db: &dyn GreenInterner) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for ItemFunction {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFunction,
            children: vec![FunctionSignature::missing(db), ExprBlock::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemFunction {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemFunction
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemFunction);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemFunctionSignature {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemFunctionSignature {
    pub fn new_green(db: &dyn GreenInterner, signature: GreenId, semi: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![signature, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFunctionSignature,
            children,
            width,
        }))
    }
    pub fn signature(&self, db: &dyn GreenInterner) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[0].clone())
    }
    pub fn semi(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for ItemFunctionSignature {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFunctionSignature,
            children: vec![FunctionSignature::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemFunctionSignature {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemFunctionSignature
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ItemFunctionSignature
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct FunctionSignature {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl FunctionSignature {
    pub fn new_green(
        db: &dyn GreenInterner,
        funckw: GreenId,
        name: GreenId,
        lparen: GreenId,
        parameters: GreenId,
        rparen: GreenId,
        arrow: GreenId,
        ret_ty: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![funckw, name, lparen, parameters, rparen, arrow, ret_ty];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::FunctionSignature,
            children,
            width,
        }))
    }
    pub fn funckw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn parameters(&self, db: &dyn GreenInterner) -> ParameterList {
        ParameterList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
    pub fn arrow(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[5].clone())
    }
    pub fn ret_ty(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[6].clone())
    }
}
impl TypedSyntaxNode for FunctionSignature {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::FunctionSignature,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                Terminal::missing(db),
                ParameterList::missing(db),
                Terminal::missing(db),
                Terminal::missing(db),
                Expr::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::FunctionSignature {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::FunctionSignature
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::FunctionSignature
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParameterList(ElementList<Parameter, 2>);
impl Deref for ParameterList {
    type Target = ElementList<Parameter, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ParameterList {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParameterList,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ParameterList {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParameterList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Parameter {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Parameter {
    pub fn new_green(
        db: &dyn GreenInterner,
        name: GreenId,
        colon: GreenId,
        ty: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![name, colon, ty];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Parameter,
            children,
            width,
        }))
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn colon(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn ty(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for Parameter {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Parameter,
            children: vec![Identifier::missing(db), Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Parameter {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Parameter
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Parameter);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemTrait {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemTrait {
    pub fn new_green(
        db: &dyn GreenInterner,
        traitkw: GreenId,
        name: GreenId,
        lbrace: GreenId,
        items: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![traitkw, name, lbrace, items, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemTrait,
            children,
            width,
        }))
    }
    pub fn traitkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn items(&self, db: &dyn GreenInterner) -> ItemList {
        ItemList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
}
impl TypedSyntaxNode for ItemTrait {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemTrait,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                Terminal::missing(db),
                ItemList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemTrait {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemTrait
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemTrait);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemImpl {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemImpl {
    pub fn new_green(
        db: &dyn GreenInterner,
        implkw: GreenId,
        name: GreenId,
        forkw: GreenId,
        trait_name: GreenId,
        lbrace: GreenId,
        items: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![implkw, name, forkw, trait_name, lbrace, items, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemImpl,
            children,
            width,
        }))
    }
    pub fn implkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn forkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn trait_name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn lbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
    pub fn items(&self, db: &dyn GreenInterner) -> ItemList {
        ItemList::from_syntax_node(db, self.children[5].clone())
    }
    pub fn rbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[6].clone())
    }
}
impl TypedSyntaxNode for ItemImpl {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemImpl,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                Terminal::missing(db),
                Identifier::missing(db),
                Terminal::missing(db),
                ItemList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemImpl {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemImpl
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemImpl);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemStruct {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemStruct {
    pub fn new_green(
        db: &dyn GreenInterner,
        structkw: GreenId,
        name: GreenId,
        lbrace: GreenId,
        members: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![structkw, name, lbrace, members, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemStruct,
            children,
            width,
        }))
    }
    pub fn structkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn members(&self, db: &dyn GreenInterner) -> MemberList {
        MemberList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
}
impl TypedSyntaxNode for ItemStruct {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemStruct,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                Terminal::missing(db),
                MemberList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemStruct {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemStruct
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemStruct);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemEnum {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemEnum {
    pub fn new_green(
        db: &dyn GreenInterner,
        enumkw: GreenId,
        name: GreenId,
        lbrace: GreenId,
        members: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![enumkw, name, lbrace, members, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemEnum,
            children,
            width,
        }))
    }
    pub fn enumkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn members(&self, db: &dyn GreenInterner) -> MemberList {
        MemberList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
}
impl TypedSyntaxNode for ItemEnum {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemEnum,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                Terminal::missing(db),
                MemberList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemEnum {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemEnum
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemEnum);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MemberList(ElementList<Member, 2>);
impl Deref for MemberList {
    type Target = ElementList<Member, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl MemberList {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::MemberList,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for MemberList {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::MemberList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Member {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Member {
    pub fn new_green(
        db: &dyn GreenInterner,
        name: GreenId,
        colon: GreenId,
        ty: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![name, colon, ty];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Member,
            children,
            width,
        }))
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn colon(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn ty(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for Member {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Member,
            children: vec![Identifier::missing(db), Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Member {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Member
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Member);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemUse {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemUse {
    pub fn new_green(
        db: &dyn GreenInterner,
        usekw: GreenId,
        path: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![usekw, path, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemUse,
            children,
            width,
        }))
    }
    pub fn usekw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn path(&self, db: &dyn GreenInterner) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semi(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ItemUse {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemUse,
            children: vec![Terminal::missing(db), ExprPath::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemUse {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemUse
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemUse);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct SyntaxFile {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl SyntaxFile {
    pub fn new_green(db: &dyn GreenInterner, items: GreenId, eof: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![items, eof];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::SyntaxFile,
            children,
            width,
        }))
    }
    pub fn items(&self, db: &dyn GreenInterner) -> ItemList {
        ItemList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn eof(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for SyntaxFile {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::SyntaxFile,
            children: vec![ItemList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::SyntaxFile {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::SyntaxFile
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::SyntaxFile);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
