// Autogenerated file. To regenerate, please run `cargo run --bin generate_syntax`.
#![allow(clippy::match_single_binding)]
#![allow(clippy::too_many_arguments)]
#![allow(dead_code)]
#![allow(unused_variables)]
use std::ops::Deref;

use super::element_list::ElementList;
use super::green::GreenNodeInternal;
use super::kind::SyntaxKind;
use super::{GreenId, GreenInterner, GreenNode, SyntaxNode, Token, TypedSyntaxNode};
use crate::token::TokenKind;
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Terminal {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal {
    pub fn new_green(
        db: &dyn GreenInterner,
        leading_trivia: GreenId,
        token: GreenId,
        trailing_trivia: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![leading_trivia, token, trailing_trivia];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Terminal,
            children,
            width,
        }))
    }
    pub fn leading_trivia(&self, db: &dyn GreenInterner) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn GreenInterner) -> Token {
        let child = self.children[1].clone();
        Token::from_syntax_node(db, child)
    }
    pub fn trailing_trivia(&self, db: &dyn GreenInterner) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for Terminal {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Terminal,
            children: vec![Trivia::missing(db), Token::missing(db), Trivia::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Terminal {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Terminal
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Terminal);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TriviumSkippedTerminal {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TriviumSkippedTerminal {
    pub fn new_green(
        db: &dyn GreenInterner,
        leading_trivia: GreenId,
        token: GreenId,
        trailing_trivia: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![leading_trivia, token, trailing_trivia];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TriviumSkippedTerminal,
            children,
            width,
        }))
    }
    pub fn leading_trivia(&self, db: &dyn GreenInterner) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn GreenInterner) -> Token {
        let child = self.children[1].clone();
        Token::from_syntax_node(db, child)
    }
    pub fn trailing_trivia(&self, db: &dyn GreenInterner) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for TriviumSkippedTerminal {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TriviumSkippedTerminal,
            children: vec![Trivia::missing(db), Token::missing(db), Trivia::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::TriviumSkippedTerminal {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::TriviumSkippedTerminal
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::TriviumSkippedTerminal
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Trivia(ElementList<Trivium, 1>);
impl Deref for Trivia {
    type Target = ElementList<Trivium, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl Trivia {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Trivia,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for Trivia {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Trivia,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Trivium {
    TriviumSingleLineComment(Token),
    TriviumWhitespace(Token),
    TriviumNewline(Token),
    SkippedTerminal(TriviumSkippedTerminal),
}
impl TypedSyntaxNode for Trivium {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::TriviumSkippedTerminal => {
                    Trivium::SkippedTerminal(TriviumSkippedTerminal::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Trivium"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                TokenKind::SingleLineComment => {
                    Trivium::TriviumSingleLineComment(Token::from_syntax_node(db, node))
                }
                TokenKind::Whitespace => {
                    Trivium::TriviumWhitespace(Token::from_syntax_node(db, node))
                }
                TokenKind::Newline => Trivium::TriviumNewline(Token::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "Trivium"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Trivium::TriviumSingleLineComment(x) => x.as_syntax_node(),
            Trivium::TriviumWhitespace(x) => x.as_syntax_node(),
            Trivium::TriviumNewline(x) => x.as_syntax_node(),
            Trivium::SkippedTerminal(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgExpr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgExpr {
    pub fn new_green(db: &dyn GreenInterner, colon: GreenId, expr: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![colon, expr];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgExpr,
            children,
            width,
        }))
    }
    pub fn colon(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for StructArgExpr {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgExpr,
            children: vec![Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StructArgExpr {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StructArgExpr
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StructArgExpr);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionStructArgExpr {
    Empty(OptionStructArgExprEmpty),
    Some(StructArgExpr),
}
impl TypedSyntaxNode for OptionStructArgExpr {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionStructArgExprEmpty => {
                    OptionStructArgExpr::Empty(OptionStructArgExprEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::StructArgExpr => {
                    OptionStructArgExpr::Some(StructArgExpr::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionStructArgExpr"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionStructArgExpr"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionStructArgExpr::Empty(x) => x.as_syntax_node(),
            OptionStructArgExpr::Some(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionStructArgExprEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionStructArgExprEmpty {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionStructArgExprEmpty,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for OptionStructArgExprEmpty {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionStructArgExprEmpty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionStructArgExprEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionStructArgExprEmpty
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionStructArgExprEmpty
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgSingle {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgSingle {
    pub fn new_green(db: &dyn GreenInterner, identifier: GreenId, arg_expr: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![identifier, arg_expr];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgSingle,
            children,
            width,
        }))
    }
    pub fn identifier(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arg_expr(&self, db: &dyn GreenInterner) -> OptionStructArgExpr {
        OptionStructArgExpr::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for StructArgSingle {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgSingle,
            children: vec![Identifier::missing(db), OptionStructArgExpr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StructArgSingle {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StructArgSingle
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StructArgSingle);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgTail {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgTail {
    pub fn new_green(db: &dyn GreenInterner, dotdot: GreenId, expression: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![dotdot, expression];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgTail,
            children,
            width,
        }))
    }
    pub fn dotdot(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expression(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for StructArgTail {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgTail,
            children: vec![Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StructArgTail {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StructArgTail
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StructArgTail);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum StructArg {
    StructArgSingle(StructArgSingle),
    StructArgTail(StructArgTail),
}
impl TypedSyntaxNode for StructArg {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::StructArgSingle => {
                    StructArg::StructArgSingle(StructArgSingle::from_syntax_node(db, node))
                }
                SyntaxKind::StructArgTail => {
                    StructArg::StructArgTail(StructArgTail::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "StructArg"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "StructArg"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            StructArg::StructArgSingle(x) => x.as_syntax_node(),
            StructArg::StructArgTail(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgList(ElementList<StructArg, 2>);
impl Deref for StructArgList {
    type Target = ElementList<StructArg, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StructArgList {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgList,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for StructArgList {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgListBraced {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ArgListBraced {
    pub fn new_green(
        db: &dyn GreenInterner,
        lbrace: GreenId,
        arguments: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lbrace, arguments, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ArgListBraced,
            children,
            width,
        }))
    }
    pub fn lbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn GreenInterner) -> StructArgList {
        StructArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ArgListBraced {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ArgListBraced,
            children: vec![
                Terminal::missing(db),
                StructArgList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ArgListBraced {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ArgListBraced
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ArgListBraced);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Identifier {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Identifier {
    pub fn new_green(db: &dyn GreenInterner, terminal: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![terminal];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Identifier,
            children,
            width,
        }))
    }
    pub fn terminal(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
}
impl TypedSyntaxNode for Identifier {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Identifier,
            children: vec![Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Identifier {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Identifier
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Identifier);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Expr {
    Path(ExprPath),
    Literal(ExprLiteral),
    Parenthesized(ExprParenthesized),
    Unary(ExprUnary),
    Binary(ExprBinary),
    Tuple(ExprTuple),
    FunctionCall(ExprFunctionCall),
    StructCtorCall(ExprStructCtorCall),
    Block(ExprBlock),
    ExprMissing(ExprMissing),
}
impl TypedSyntaxNode for Expr {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::ExprPath => Expr::Path(ExprPath::from_syntax_node(db, node)),
                SyntaxKind::ExprLiteral => Expr::Literal(ExprLiteral::from_syntax_node(db, node)),
                SyntaxKind::ExprParenthesized => {
                    Expr::Parenthesized(ExprParenthesized::from_syntax_node(db, node))
                }
                SyntaxKind::ExprUnary => Expr::Unary(ExprUnary::from_syntax_node(db, node)),
                SyntaxKind::ExprBinary => Expr::Binary(ExprBinary::from_syntax_node(db, node)),
                SyntaxKind::ExprTuple => Expr::Tuple(ExprTuple::from_syntax_node(db, node)),
                SyntaxKind::ExprFunctionCall => {
                    Expr::FunctionCall(ExprFunctionCall::from_syntax_node(db, node))
                }
                SyntaxKind::ExprStructCtorCall => {
                    Expr::StructCtorCall(ExprStructCtorCall::from_syntax_node(db, node))
                }
                SyntaxKind::ExprBlock => Expr::Block(ExprBlock::from_syntax_node(db, node)),
                SyntaxKind::ExprMissing => {
                    Expr::ExprMissing(ExprMissing::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Expr"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!("Unexpected token kind {:?} when constructing {}.", token.kind, "Expr"),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Expr::Path(x) => x.as_syntax_node(),
            Expr::Literal(x) => x.as_syntax_node(),
            Expr::Parenthesized(x) => x.as_syntax_node(),
            Expr::Unary(x) => x.as_syntax_node(),
            Expr::Binary(x) => x.as_syntax_node(),
            Expr::Tuple(x) => x.as_syntax_node(),
            Expr::FunctionCall(x) => x.as_syntax_node(),
            Expr::StructCtorCall(x) => x.as_syntax_node(),
            Expr::Block(x) => x.as_syntax_node(),
            Expr::ExprMissing(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprList(ElementList<Expr, 2>);
impl Deref for ExprList {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprList {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprList,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ExprList {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprMissing {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ExprMissing {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprMissing {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprMissing
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprMissing);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionGenericArgs {
    None(OptionGenericArgsNone),
    Some(OptionGenericArgsSome),
}
impl TypedSyntaxNode for OptionGenericArgs {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionGenericArgsNone => {
                    OptionGenericArgs::None(OptionGenericArgsNone::from_syntax_node(db, node))
                }
                SyntaxKind::OptionGenericArgsSome => {
                    OptionGenericArgs::Some(OptionGenericArgsSome::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionGenericArgs"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionGenericArgs"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionGenericArgs::None(x) => x.as_syntax_node(),
            OptionGenericArgs::Some(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionGenericArgsNone {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionGenericArgsNone {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsNone,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for OptionGenericArgsNone {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsNone,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionGenericArgsNone {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionGenericArgsNone
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionGenericArgsNone
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionGenericArgsSome(ElementList<Expr, 2>);
impl Deref for OptionGenericArgsSome {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl OptionGenericArgsSome {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsSome,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for OptionGenericArgsSome {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsSome,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PathSegment {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PathSegment {
    pub fn new_green(db: &dyn GreenInterner, ident: GreenId, generic_args: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![ident, generic_args];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::PathSegment,
            children,
            width,
        }))
    }
    pub fn ident(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn generic_args(&self, db: &dyn GreenInterner) -> OptionGenericArgs {
        OptionGenericArgs::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for PathSegment {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::PathSegment,
            children: vec![Identifier::missing(db), OptionGenericArgs::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::PathSegment {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::PathSegment
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::PathSegment);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprPath(ElementList<PathSegment, 2>);
impl Deref for ExprPath {
    type Target = ElementList<PathSegment, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprPath {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprPath,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ExprPath {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprPath,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprLiteral {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprLiteral {
    pub fn new_green(db: &dyn GreenInterner, terminal: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![terminal];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprLiteral,
            children,
            width,
        }))
    }
    pub fn terminal(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
}
impl TypedSyntaxNode for ExprLiteral {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprLiteral,
            children: vec![Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprLiteral {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprLiteral
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprLiteral);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprParenthesized {
    pub fn new_green(
        db: &dyn GreenInterner,
        lparen: GreenId,
        expr: GreenId,
        rparen: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, expr, rparen];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprParenthesized,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ExprParenthesized {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprParenthesized,
            children: vec![Terminal::missing(db), Expr::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprParenthesized
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprParenthesized
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprUnary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprUnary {
    pub fn new_green(db: &dyn GreenInterner, op: GreenId, expr: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![op, expr];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprUnary,
            children,
            width,
        }))
    }
    pub fn op(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for ExprUnary {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprUnary,
            children: vec![Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprUnary {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprUnary
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprUnary);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBinary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBinary {
    pub fn new_green(db: &dyn GreenInterner, lhs: GreenId, op: GreenId, rhs: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![lhs, op, rhs];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBinary,
            children,
            width,
        }))
    }
    pub fn lhs(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn op(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rhs(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ExprBinary {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBinary,
            children: vec![Expr::missing(db), Terminal::missing(db), Expr::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprBinary {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprBinary
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprBinary);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprTuple {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprTuple {
    pub fn new_green(
        db: &dyn GreenInterner,
        lparen: GreenId,
        expressions: GreenId,
        rparen: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, expressions, rparen];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprTuple,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expressions(&self, db: &dyn GreenInterner) -> ExprList {
        ExprList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ExprTuple {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprTuple,
            children: vec![Terminal::missing(db), ExprList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprTuple {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprTuple
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprTuple);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprListParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprListParenthesized {
    pub fn new_green(
        db: &dyn GreenInterner,
        lparen: GreenId,
        expressions: GreenId,
        rparen: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, expressions, rparen];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprListParenthesized,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expressions(&self, db: &dyn GreenInterner) -> ExprList {
        ExprList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ExprListParenthesized {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprListParenthesized,
            children: vec![Terminal::missing(db), ExprList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprListParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprListParenthesized
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprListParenthesized
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprFunctionCall {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprFunctionCall {
    pub fn new_green(db: &dyn GreenInterner, path: GreenId, arguments: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![path, arguments];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprFunctionCall,
            children,
            width,
        }))
    }
    pub fn path(&self, db: &dyn GreenInterner) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn GreenInterner) -> ExprListParenthesized {
        ExprListParenthesized::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for ExprFunctionCall {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprFunctionCall,
            children: vec![ExprPath::missing(db), ExprListParenthesized::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprFunctionCall {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprFunctionCall
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprFunctionCall
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprStructCtorCall {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprStructCtorCall {
    pub fn new_green(db: &dyn GreenInterner, path: GreenId, arguments: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![path, arguments];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprStructCtorCall,
            children,
            width,
        }))
    }
    pub fn path(&self, db: &dyn GreenInterner) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn GreenInterner) -> ArgListBraced {
        ArgListBraced::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for ExprStructCtorCall {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprStructCtorCall,
            children: vec![ExprPath::missing(db), ArgListBraced::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprStructCtorCall {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprStructCtorCall
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprStructCtorCall
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBlock {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBlock {
    pub fn new_green(
        db: &dyn GreenInterner,
        lbrace: GreenId,
        statements: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lbrace, statements, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBlock,
            children,
            width,
        }))
    }
    pub fn lbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn statements(&self, db: &dyn GreenInterner) -> StatementList {
        StatementList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ExprBlock {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBlock,
            children: vec![
                Terminal::missing(db),
                StatementList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprBlock {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprBlock
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprBlock);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TypeClause {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TypeClause {
    pub fn new_green(db: &dyn GreenInterner, colon: GreenId, ty: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![colon, ty];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TypeClause,
            children,
            width,
        }))
    }
    pub fn colon(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ty(&self, db: &dyn GreenInterner) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for TypeClause {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TypeClause,
            children: vec![Terminal::missing(db), ExprPath::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::TypeClause {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::TypeClause
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::TypeClause);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTypeClause {
    Empty(OptionTypeClauseEmpty),
    TypeClause(TypeClause),
}
impl TypedSyntaxNode for OptionTypeClause {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionTypeClauseEmpty => {
                    OptionTypeClause::Empty(OptionTypeClauseEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::TypeClause => {
                    OptionTypeClause::TypeClause(TypeClause::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionTypeClause"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionTypeClause"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTypeClause::Empty(x) => x.as_syntax_node(),
            OptionTypeClause::TypeClause(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTypeClauseEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionTypeClauseEmpty {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionTypeClauseEmpty,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for OptionTypeClauseEmpty {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionTypeClauseEmpty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionTypeClauseEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionTypeClauseEmpty
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionTypeClauseEmpty
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ReturnTypeClause {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ReturnTypeClause {
    pub fn new_green(db: &dyn GreenInterner, arrow: GreenId, ty: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![arrow, ty];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ReturnTypeClause,
            children,
            width,
        }))
    }
    pub fn arrow(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ty(&self, db: &dyn GreenInterner) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for ReturnTypeClause {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ReturnTypeClause,
            children: vec![Terminal::missing(db), ExprPath::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ReturnTypeClause {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ReturnTypeClause
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ReturnTypeClause
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionReturnTypeClause {
    Empty(OptionReturnTypeClauseEmpty),
    ReturnTypeClause(ReturnTypeClause),
}
impl TypedSyntaxNode for OptionReturnTypeClause {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionReturnTypeClauseEmpty => OptionReturnTypeClause::Empty(
                    OptionReturnTypeClauseEmpty::from_syntax_node(db, node),
                ),
                SyntaxKind::ReturnTypeClause => OptionReturnTypeClause::ReturnTypeClause(
                    ReturnTypeClause::from_syntax_node(db, node),
                ),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionReturnTypeClause"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionReturnTypeClause"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionReturnTypeClause::Empty(x) => x.as_syntax_node(),
            OptionReturnTypeClause::ReturnTypeClause(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionReturnTypeClauseEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionReturnTypeClauseEmpty {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionReturnTypeClauseEmpty,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for OptionReturnTypeClauseEmpty {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionReturnTypeClauseEmpty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionReturnTypeClauseEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionReturnTypeClauseEmpty
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionReturnTypeClauseEmpty
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Statement {
    Let(StatementLet),
    Expr(StatementExpr),
    Return(StatementReturn),
    StatementMissing(StatementMissing),
}
impl TypedSyntaxNode for Statement {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::StatementLet => {
                    Statement::Let(StatementLet::from_syntax_node(db, node))
                }
                SyntaxKind::StatementExpr => {
                    Statement::Expr(StatementExpr::from_syntax_node(db, node))
                }
                SyntaxKind::StatementReturn => {
                    Statement::Return(StatementReturn::from_syntax_node(db, node))
                }
                SyntaxKind::StatementMissing => {
                    Statement::StatementMissing(StatementMissing::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Statement"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "Statement"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Statement::Let(x) => x.as_syntax_node(),
            Statement::Expr(x) => x.as_syntax_node(),
            Statement::Return(x) => x.as_syntax_node(),
            Statement::StatementMissing(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementList(ElementList<Statement, 1>);
impl Deref for StatementList {
    type Target = ElementList<Statement, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StatementList {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementList,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for StatementList {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementMissing {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for StatementMissing {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementMissing {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementMissing
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::StatementMissing
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementLet {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementLet {
    pub fn new_green(
        db: &dyn GreenInterner,
        letkw: GreenId,
        lhs: GreenId,
        type_clause: GreenId,
        eq: GreenId,
        rhs: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![letkw, lhs, type_clause, eq, rhs, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementLet,
            children,
            width,
        }))
    }
    pub fn letkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lhs(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn type_clause(&self, db: &dyn GreenInterner) -> OptionTypeClause {
        OptionTypeClause::from_syntax_node(db, self.children[2].clone())
    }
    pub fn eq(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rhs(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[4].clone())
    }
    pub fn semi(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[5].clone())
    }
}
impl TypedSyntaxNode for StatementLet {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementLet,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                OptionTypeClause::missing(db),
                Terminal::missing(db),
                Expr::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementLet {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementLet
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementLet);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionSemicolon {
    Empty(OptionSemicolonEmpty),
    Some(Terminal),
}
impl TypedSyntaxNode for OptionSemicolon {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionSemicolonEmpty => {
                    OptionSemicolon::Empty(OptionSemicolonEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::Terminal => OptionSemicolon::Some(Terminal::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionSemicolon"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionSemicolon"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionSemicolon::Empty(x) => x.as_syntax_node(),
            OptionSemicolon::Some(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionSemicolonEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionSemicolonEmpty {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionSemicolonEmpty,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for OptionSemicolonEmpty {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionSemicolonEmpty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionSemicolonEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionSemicolonEmpty
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionSemicolonEmpty
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementExpr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementExpr {
    pub fn new_green(db: &dyn GreenInterner, expr: GreenId, semi: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![expr, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementExpr,
            children,
            width,
        }))
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn semi(&self, db: &dyn GreenInterner) -> OptionSemicolon {
        OptionSemicolon::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for StatementExpr {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementExpr,
            children: vec![Expr::missing(db), OptionSemicolon::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementExpr {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementExpr
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementExpr);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementReturn {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementReturn {
    pub fn new_green(
        db: &dyn GreenInterner,
        returnkw: GreenId,
        expr: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![returnkw, expr, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementReturn,
            children,
            width,
        }))
    }
    pub fn returnkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semi(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for StatementReturn {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementReturn,
            children: vec![Terminal::missing(db), Expr::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementReturn {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementReturn
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementReturn);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Param {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Param {
    pub fn new_green(db: &dyn GreenInterner, identifier: GreenId, type_clause: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![identifier, type_clause];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Param,
            children,
            width,
        }))
    }
    pub fn identifier(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn type_clause(&self, db: &dyn GreenInterner) -> TypeClause {
        TypeClause::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for Param {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Param,
            children: vec![Terminal::missing(db), TypeClause::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Param {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Param
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Param);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamList(ElementList<Param, 2>);
impl Deref for ParamList {
    type Target = ElementList<Param, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ParamList {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamList,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ParamList {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamListParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ParamListParenthesized {
    pub fn new_green(
        db: &dyn GreenInterner,
        lparen: GreenId,
        parameters: GreenId,
        rparen: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, parameters, rparen];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListParenthesized,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn parameters(&self, db: &dyn GreenInterner) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ParamListParenthesized {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListParenthesized,
            children: vec![Terminal::missing(db), ParamList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ParamListParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ParamListParenthesized
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ParamListParenthesized
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamListBraced {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ParamListBraced {
    pub fn new_green(
        db: &dyn GreenInterner,
        lbrace: GreenId,
        parameters: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lbrace, parameters, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListBraced,
            children,
            width,
        }))
    }
    pub fn lbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn parameters(&self, db: &dyn GreenInterner) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ParamListBraced {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListBraced,
            children: vec![Terminal::missing(db), ParamList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ParamListBraced {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ParamListBraced
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ParamListBraced);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct FunctionSignature {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl FunctionSignature {
    pub fn new_green(
        db: &dyn GreenInterner,
        funckw: GreenId,
        name: GreenId,
        parameters: GreenId,
        ret_ty: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![funckw, name, parameters, ret_ty];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::FunctionSignature,
            children,
            width,
        }))
    }
    pub fn funckw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn parameters(&self, db: &dyn GreenInterner) -> ParamListParenthesized {
        ParamListParenthesized::from_syntax_node(db, self.children[2].clone())
    }
    pub fn ret_ty(&self, db: &dyn GreenInterner) -> ReturnTypeClause {
        ReturnTypeClause::from_syntax_node(db, self.children[3].clone())
    }
}
impl TypedSyntaxNode for FunctionSignature {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::FunctionSignature,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                ParamListParenthesized::missing(db),
                ReturnTypeClause::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::FunctionSignature {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::FunctionSignature
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::FunctionSignature
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Item {
    Module(ItemModule),
    Function(ItemFunction),
    FunctionSignature(ItemFunctionSignature),
    Trait(ItemTrait),
    Impl(ItemImpl),
    Struct(ItemStruct),
    Enum(ItemEnum),
    Use(ItemUse),
}
impl TypedSyntaxNode for Item {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::ItemModule => Item::Module(ItemModule::from_syntax_node(db, node)),
                SyntaxKind::ItemFunction => {
                    Item::Function(ItemFunction::from_syntax_node(db, node))
                }
                SyntaxKind::ItemFunctionSignature => {
                    Item::FunctionSignature(ItemFunctionSignature::from_syntax_node(db, node))
                }
                SyntaxKind::ItemTrait => Item::Trait(ItemTrait::from_syntax_node(db, node)),
                SyntaxKind::ItemImpl => Item::Impl(ItemImpl::from_syntax_node(db, node)),
                SyntaxKind::ItemStruct => Item::Struct(ItemStruct::from_syntax_node(db, node)),
                SyntaxKind::ItemEnum => Item::Enum(ItemEnum::from_syntax_node(db, node)),
                SyntaxKind::ItemUse => Item::Use(ItemUse::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Item"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!("Unexpected token kind {:?} when constructing {}.", token.kind, "Item"),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Item::Module(x) => x.as_syntax_node(),
            Item::Function(x) => x.as_syntax_node(),
            Item::FunctionSignature(x) => x.as_syntax_node(),
            Item::Trait(x) => x.as_syntax_node(),
            Item::Impl(x) => x.as_syntax_node(),
            Item::Struct(x) => x.as_syntax_node(),
            Item::Enum(x) => x.as_syntax_node(),
            Item::Use(x) => x.as_syntax_node(),
        }
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemList(ElementList<Item, 1>);
impl Deref for ItemList {
    type Target = ElementList<Item, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ItemList {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemList,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ItemList {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemList,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemModule {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemModule {
    pub fn new_green(
        db: &dyn GreenInterner,
        modkw: GreenId,
        name: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![modkw, name, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemModule,
            children,
            width,
        }))
    }
    pub fn modkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semi(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ItemModule {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemModule,
            children: vec![Terminal::missing(db), Identifier::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemModule {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemModule
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemModule);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemFunction {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemFunction {
    pub fn new_green(db: &dyn GreenInterner, signature: GreenId, body: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![signature, body];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFunction,
            children,
            width,
        }))
    }
    pub fn signature(&self, db: &dyn GreenInterner) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[0].clone())
    }
    pub fn body(&self, db: &dyn GreenInterner) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for ItemFunction {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFunction,
            children: vec![FunctionSignature::missing(db), ExprBlock::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemFunction {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemFunction
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemFunction);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemFunctionSignature {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemFunctionSignature {
    pub fn new_green(db: &dyn GreenInterner, signature: GreenId, semi: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![signature, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFunctionSignature,
            children,
            width,
        }))
    }
    pub fn signature(&self, db: &dyn GreenInterner) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[0].clone())
    }
    pub fn semi(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for ItemFunctionSignature {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFunctionSignature,
            children: vec![FunctionSignature::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemFunctionSignature {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemFunctionSignature
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ItemFunctionSignature
                );
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemTrait {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemTrait {
    pub fn new_green(
        db: &dyn GreenInterner,
        traitkw: GreenId,
        name: GreenId,
        lbrace: GreenId,
        items: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![traitkw, name, lbrace, items, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemTrait,
            children,
            width,
        }))
    }
    pub fn traitkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn items(&self, db: &dyn GreenInterner) -> ItemList {
        ItemList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
}
impl TypedSyntaxNode for ItemTrait {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemTrait,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                Terminal::missing(db),
                ItemList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemTrait {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemTrait
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemTrait);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemImpl {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemImpl {
    pub fn new_green(
        db: &dyn GreenInterner,
        implkw: GreenId,
        name: GreenId,
        forkw: GreenId,
        trait_name: GreenId,
        lbrace: GreenId,
        items: GreenId,
        rbrace: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![implkw, name, forkw, trait_name, lbrace, items, rbrace];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemImpl,
            children,
            width,
        }))
    }
    pub fn implkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn forkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn trait_name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn lbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
    pub fn items(&self, db: &dyn GreenInterner) -> ItemList {
        ItemList::from_syntax_node(db, self.children[5].clone())
    }
    pub fn rbrace(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[6].clone())
    }
}
impl TypedSyntaxNode for ItemImpl {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemImpl,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                Terminal::missing(db),
                Identifier::missing(db),
                Terminal::missing(db),
                ItemList::missing(db),
                Terminal::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemImpl {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemImpl
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemImpl);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemStruct {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemStruct {
    pub fn new_green(
        db: &dyn GreenInterner,
        structkw: GreenId,
        name: GreenId,
        body: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![structkw, name, body];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemStruct,
            children,
            width,
        }))
    }
    pub fn structkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn body(&self, db: &dyn GreenInterner) -> ParamListBraced {
        ParamListBraced::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ItemStruct {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemStruct,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                ParamListBraced::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemStruct {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemStruct
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemStruct);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemEnum {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemEnum {
    pub fn new_green(
        db: &dyn GreenInterner,
        enumkw: GreenId,
        name: GreenId,
        body: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![enumkw, name, body];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemEnum,
            children,
            width,
        }))
    }
    pub fn enumkw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn GreenInterner) -> Identifier {
        Identifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn body(&self, db: &dyn GreenInterner) -> ParamListBraced {
        ParamListBraced::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ItemEnum {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemEnum,
            children: vec![
                Terminal::missing(db),
                Identifier::missing(db),
                ParamListBraced::missing(db),
            ],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemEnum {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemEnum
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemEnum);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemUse {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemUse {
    pub fn new_green(
        db: &dyn GreenInterner,
        usekw: GreenId,
        path: GreenId,
        semi: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![usekw, path, semi];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemUse,
            children,
            width,
        }))
    }
    pub fn usekw(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn path(&self, db: &dyn GreenInterner) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semi(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
impl TypedSyntaxNode for ItemUse {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemUse,
            children: vec![Terminal::missing(db), ExprPath::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemUse {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemUse
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemUse);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct SyntaxFile {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl SyntaxFile {
    pub fn new_green(db: &dyn GreenInterner, items: GreenId, eof: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![items, eof];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::SyntaxFile,
            children,
            width,
        }))
    }
    pub fn items(&self, db: &dyn GreenInterner) -> ItemList {
        ItemList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn eof(&self, db: &dyn GreenInterner) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
}
impl TypedSyntaxNode for SyntaxFile {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::SyntaxFile,
            children: vec![ItemList::missing(db), Terminal::missing(db)],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::SyntaxFile {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::SyntaxFile
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::SyntaxFile);
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
}
