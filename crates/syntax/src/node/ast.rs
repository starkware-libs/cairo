// Autogenerated file. To regenerate, please run `cargo run --bin generate_syntax`.
#![allow(clippy::match_single_binding)]
#![allow(clippy::too_many_arguments)]
#![allow(dead_code)]
#![allow(unused_variables)]
use std::ops::Deref;

use super::element_list::ElementList;
use super::green::GreenNodeInternal;
use super::kind::SyntaxKind;
use super::{
    GreenId, GreenNode, SyntaxGroup, SyntaxNode, SyntaxStablePtr, SyntaxStablePtrId, Token,
    TokenGreen, TypedSyntaxNode,
};
use crate::token::TokenKind;
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Terminal {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: TokenGreen,
        trailing_trivia: TriviaGreen,
    ) -> TerminalGreen {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Terminal,
            children,
            width,
        })))
    }
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> Token {
        let child = self.children[1].clone();
        Token::from_syntax_node(db, child)
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalPtr(SyntaxStablePtrId);
impl TerminalPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalGreen(pub GreenId);
impl TypedSyntaxNode for Terminal {
    type StablePtr = TerminalPtr;
    type Green = TerminalGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Terminal,
            children: vec![Trivia::missing(db).0, Token::missing(db).0, Trivia::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Terminal {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Terminal,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Terminal,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TriviumSkippedToken {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TriviumSkippedToken {
    pub fn new_green(db: &dyn SyntaxGroup, token: TokenGreen) -> TriviumSkippedTokenGreen {
        let children: Vec<GreenId> = vec![token.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TriviumSkippedTokenGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TriviumSkippedToken,
            children,
            width,
        })))
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> Token {
        let child = self.children[0].clone();
        Token::from_syntax_node(db, child)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviumSkippedTokenPtr(SyntaxStablePtrId);
impl TriviumSkippedTokenPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviumSkippedTokenGreen(pub GreenId);
impl TypedSyntaxNode for TriviumSkippedToken {
    type StablePtr = TriviumSkippedTokenPtr;
    type Green = TriviumSkippedTokenGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TriviumSkippedTokenGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TriviumSkippedToken,
            children: vec![Token::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::TriviumSkippedToken {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::TriviumSkippedToken,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::TriviumSkippedToken,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviumSkippedTokenPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Trivia(ElementList<Trivium, 1>);
impl Deref for Trivia {
    type Target = ElementList<Trivium, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl Trivia {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<TriviumGreen>) -> TriviaGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.0).width()).sum();
        TriviaGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Trivia,
            children: children.iter().map(|x| x.0).collect(),
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviaPtr(SyntaxStablePtrId);
impl TriviaPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviaGreen(pub GreenId);
impl TypedSyntaxNode for Trivia {
    type StablePtr = TriviaPtr;
    type Green = TriviaGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TriviaGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Trivia,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviaPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Trivium {
    TriviumSingleLineComment(Token),
    TriviumWhitespace(Token),
    TriviumNewline(Token),
    SkippedToken(TriviumSkippedToken),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviumPtr(SyntaxStablePtrId);
impl TriviumPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TriviumSkippedTokenGreen> for TriviumGreen {
    fn from(value: TriviumSkippedTokenGreen) -> Self {
        Self(value.0)
    }
}
impl From<TokenGreen> for TriviumGreen {
    fn from(value: TokenGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviumGreen(pub GreenId);
impl TypedSyntaxNode for Trivium {
    type StablePtr = TriviumPtr;
    type Green = TriviumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::TriviumSkippedToken => {
                    Trivium::SkippedToken(TriviumSkippedToken::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Trivium"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                TokenKind::SingleLineComment => {
                    Trivium::TriviumSingleLineComment(Token::from_syntax_node(db, node))
                }
                TokenKind::Whitespace => {
                    Trivium::TriviumWhitespace(Token::from_syntax_node(db, node))
                }
                TokenKind::Newline => Trivium::TriviumNewline(Token::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "Trivium"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Trivium::TriviumSingleLineComment(x) => x.as_syntax_node(),
            Trivium::TriviumWhitespace(x) => x.as_syntax_node(),
            Trivium::TriviumNewline(x) => x.as_syntax_node(),
            Trivium::SkippedToken(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviumPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgExpr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgExpr {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        colon: TerminalGreen,
        expr: ExprGreen,
    ) -> StructArgExprGreen {
        let children: Vec<GreenId> = vec![colon.0, expr.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StructArgExprGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgExpr,
            children,
            width,
        })))
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgExprPtr(SyntaxStablePtrId);
impl StructArgExprPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgExprGreen(pub GreenId);
impl TypedSyntaxNode for StructArgExpr {
    type StablePtr = StructArgExprPtr;
    type Green = StructArgExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgExprGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgExpr,
            children: vec![Terminal::missing(db).0, Expr::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StructArgExpr {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StructArgExpr,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StructArgExpr,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgExprPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionStructArgExpr {
    Empty(OptionStructArgExprEmpty),
    Some(StructArgExpr),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprPtr(SyntaxStablePtrId);
impl OptionStructArgExprPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionStructArgExprEmptyGreen> for OptionStructArgExprGreen {
    fn from(value: OptionStructArgExprEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<StructArgExprGreen> for OptionStructArgExprGreen {
    fn from(value: StructArgExprGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprGreen(pub GreenId);
impl TypedSyntaxNode for OptionStructArgExpr {
    type StablePtr = OptionStructArgExprPtr;
    type Green = OptionStructArgExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionStructArgExprEmpty => {
                    OptionStructArgExpr::Empty(OptionStructArgExprEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::StructArgExpr => {
                    OptionStructArgExpr::Some(StructArgExpr::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionStructArgExpr"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionStructArgExpr"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionStructArgExpr::Empty(x) => x.as_syntax_node(),
            OptionStructArgExpr::Some(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionStructArgExprPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionStructArgExprEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionStructArgExprEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionStructArgExprEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionStructArgExprEmptyGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionStructArgExprEmpty,
            children,
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprEmptyPtr(SyntaxStablePtrId);
impl OptionStructArgExprEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionStructArgExprEmpty {
    type StablePtr = OptionStructArgExprEmptyPtr;
    type Green = OptionStructArgExprEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionStructArgExprEmptyGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionStructArgExprEmpty,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionStructArgExprEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionStructArgExprEmpty,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionStructArgExprEmpty,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionStructArgExprEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgSingle {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgSingle {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        identifier: TerminalGreen,
        arg_expr: OptionStructArgExprGreen,
    ) -> StructArgSingleGreen {
        let children: Vec<GreenId> = vec![identifier.0, arg_expr.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StructArgSingleGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgSingle,
            children,
            width,
        })))
    }
    pub fn identifier(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arg_expr(&self, db: &dyn SyntaxGroup) -> OptionStructArgExpr {
        OptionStructArgExpr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgSinglePtr(SyntaxStablePtrId);
impl StructArgSinglePtr {
    pub fn identifier_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgSingleGreen(pub GreenId);
impl TypedSyntaxNode for StructArgSingle {
    type StablePtr = StructArgSinglePtr;
    type Green = StructArgSingleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgSingleGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgSingle,
            children: vec![Terminal::missing(db).0, OptionStructArgExpr::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StructArgSingle {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StructArgSingle,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StructArgSingle,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgSinglePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgTail {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgTail {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        dotdot: TerminalGreen,
        expression: ExprGreen,
    ) -> StructArgTailGreen {
        let children: Vec<GreenId> = vec![dotdot.0, expression.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StructArgTailGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgTail,
            children,
            width,
        })))
    }
    pub fn dotdot(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expression(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgTailPtr(SyntaxStablePtrId);
impl StructArgTailPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgTailGreen(pub GreenId);
impl TypedSyntaxNode for StructArgTail {
    type StablePtr = StructArgTailPtr;
    type Green = StructArgTailGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgTailGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgTail,
            children: vec![Terminal::missing(db).0, Expr::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StructArgTail {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StructArgTail,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StructArgTail,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgTailPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum StructArg {
    StructArgSingle(StructArgSingle),
    StructArgTail(StructArgTail),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgPtr(SyntaxStablePtrId);
impl StructArgPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<StructArgSingleGreen> for StructArgGreen {
    fn from(value: StructArgSingleGreen) -> Self {
        Self(value.0)
    }
}
impl From<StructArgTailGreen> for StructArgGreen {
    fn from(value: StructArgTailGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgGreen(pub GreenId);
impl TypedSyntaxNode for StructArg {
    type StablePtr = StructArgPtr;
    type Green = StructArgGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::StructArgSingle => {
                    StructArg::StructArgSingle(StructArgSingle::from_syntax_node(db, node))
                }
                SyntaxKind::StructArgTail => {
                    StructArg::StructArgTail(StructArgTail::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "StructArg"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "StructArg"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            StructArg::StructArgSingle(x) => x.as_syntax_node(),
            StructArg::StructArgTail(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgList(ElementList<StructArg, 2>);
impl Deref for StructArgList {
    type Target = ElementList<StructArg, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StructArgList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<StructArgListElementOrSeparatorGreen>,
    ) -> StructArgListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        StructArgListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgList,
            children: children.iter().map(|x| x.id()).collect(),
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgListPtr(SyntaxStablePtrId);
impl StructArgListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum StructArgListElementOrSeparatorGreen {
    Separator(TerminalGreen),
    Element(StructArgGreen),
}
impl From<TerminalGreen> for StructArgListElementOrSeparatorGreen {
    fn from(value: TerminalGreen) -> Self {
        StructArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<StructArgGreen> for StructArgListElementOrSeparatorGreen {
    fn from(value: StructArgGreen) -> Self {
        StructArgListElementOrSeparatorGreen::Element(value)
    }
}
impl StructArgListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            StructArgListElementOrSeparatorGreen::Separator(green) => green.0,
            StructArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgListGreen(pub GreenId);
impl TypedSyntaxNode for StructArgList {
    type StablePtr = StructArgListPtr;
    type Green = StructArgListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StructArgList,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgListBraced {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ArgListBraced {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalGreen,
        arguments: StructArgListGreen,
        rbrace: TerminalGreen,
    ) -> ArgListBracedGreen {
        let children: Vec<GreenId> = vec![lbrace.0, arguments.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ArgListBracedGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ArgListBraced,
            children,
            width,
        })))
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> StructArgList {
        StructArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListBracedPtr(SyntaxStablePtrId);
impl ArgListBracedPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListBracedGreen(pub GreenId);
impl TypedSyntaxNode for ArgListBraced {
    type StablePtr = ArgListBracedPtr;
    type Green = ArgListBracedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ArgListBracedGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ArgListBraced,
            children: vec![
                Terminal::missing(db).0,
                StructArgList::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ArgListBraced {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ArgListBraced,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ArgListBraced,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgListBracedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Expr {
    Path(ExprPath),
    Literal(ExprLiteral),
    Parenthesized(ExprParenthesized),
    Unary(ExprUnary),
    Binary(ExprBinary),
    Tuple(ExprTuple),
    FunctionCall(ExprFunctionCall),
    StructCtorCall(ExprStructCtorCall),
    Block(ExprBlock),
    Match(ExprMatch),
    Missing(ExprMissing),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprPtr(SyntaxStablePtrId);
impl ExprPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<ExprPathGreen> for ExprGreen {
    fn from(value: ExprPathGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprLiteralGreen> for ExprGreen {
    fn from(value: ExprLiteralGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprParenthesizedGreen> for ExprGreen {
    fn from(value: ExprParenthesizedGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprUnaryGreen> for ExprGreen {
    fn from(value: ExprUnaryGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprBinaryGreen> for ExprGreen {
    fn from(value: ExprBinaryGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprTupleGreen> for ExprGreen {
    fn from(value: ExprTupleGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprFunctionCallGreen> for ExprGreen {
    fn from(value: ExprFunctionCallGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprStructCtorCallGreen> for ExprGreen {
    fn from(value: ExprStructCtorCallGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprBlockGreen> for ExprGreen {
    fn from(value: ExprBlockGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprMatchGreen> for ExprGreen {
    fn from(value: ExprMatchGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprMissingGreen> for ExprGreen {
    fn from(value: ExprMissingGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprGreen(pub GreenId);
impl TypedSyntaxNode for Expr {
    type StablePtr = ExprPtr;
    type Green = ExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprGreen(ExprMissing::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::ExprPath => Expr::Path(ExprPath::from_syntax_node(db, node)),
                SyntaxKind::ExprLiteral => Expr::Literal(ExprLiteral::from_syntax_node(db, node)),
                SyntaxKind::ExprParenthesized => {
                    Expr::Parenthesized(ExprParenthesized::from_syntax_node(db, node))
                }
                SyntaxKind::ExprUnary => Expr::Unary(ExprUnary::from_syntax_node(db, node)),
                SyntaxKind::ExprBinary => Expr::Binary(ExprBinary::from_syntax_node(db, node)),
                SyntaxKind::ExprTuple => Expr::Tuple(ExprTuple::from_syntax_node(db, node)),
                SyntaxKind::ExprFunctionCall => {
                    Expr::FunctionCall(ExprFunctionCall::from_syntax_node(db, node))
                }
                SyntaxKind::ExprStructCtorCall => {
                    Expr::StructCtorCall(ExprStructCtorCall::from_syntax_node(db, node))
                }
                SyntaxKind::ExprBlock => Expr::Block(ExprBlock::from_syntax_node(db, node)),
                SyntaxKind::ExprMatch => Expr::Match(ExprMatch::from_syntax_node(db, node)),
                SyntaxKind::ExprMissing => Expr::Missing(ExprMissing::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Expr"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!("Unexpected token kind {:?} when constructing {}.", token.kind, "Expr"),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Expr::Path(x) => x.as_syntax_node(),
            Expr::Literal(x) => x.as_syntax_node(),
            Expr::Parenthesized(x) => x.as_syntax_node(),
            Expr::Unary(x) => x.as_syntax_node(),
            Expr::Binary(x) => x.as_syntax_node(),
            Expr::Tuple(x) => x.as_syntax_node(),
            Expr::FunctionCall(x) => x.as_syntax_node(),
            Expr::StructCtorCall(x) => x.as_syntax_node(),
            Expr::Block(x) => x.as_syntax_node(),
            Expr::Match(x) => x.as_syntax_node(),
            Expr::Missing(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprList(ElementList<Expr, 2>);
impl Deref for ExprList {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ExprListElementOrSeparatorGreen>,
    ) -> ExprListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        ExprListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprList,
            children: children.iter().map(|x| x.id()).collect(),
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListPtr(SyntaxStablePtrId);
impl ExprListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ExprListElementOrSeparatorGreen {
    Separator(TerminalGreen),
    Element(ExprGreen),
}
impl From<TerminalGreen> for ExprListElementOrSeparatorGreen {
    fn from(value: TerminalGreen) -> Self {
        ExprListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ExprGreen> for ExprListElementOrSeparatorGreen {
    fn from(value: ExprGreen) -> Self {
        ExprListElementOrSeparatorGreen::Element(value)
    }
}
impl ExprListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ExprListElementOrSeparatorGreen::Separator(green) => green.0,
            ExprListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListGreen(pub GreenId);
impl TypedSyntaxNode for ExprList {
    type StablePtr = ExprListPtr;
    type Green = ExprListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprList,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> ExprMissingGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprMissingGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children,
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMissingPtr(SyntaxStablePtrId);
impl ExprMissingPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMissingGreen(pub GreenId);
impl TypedSyntaxNode for ExprMissing {
    type StablePtr = ExprMissingPtr;
    type Green = ExprMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprMissingGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMissing,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprMissing {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprMissing,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprMissing,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprMissingPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionGenericArgs {
    Empty(OptionGenericArgsEmpty),
    Some(OptionGenericArgsSome),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionGenericArgsPtr(SyntaxStablePtrId);
impl OptionGenericArgsPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionGenericArgsEmptyGreen> for OptionGenericArgsGreen {
    fn from(value: OptionGenericArgsEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<OptionGenericArgsSomeGreen> for OptionGenericArgsGreen {
    fn from(value: OptionGenericArgsSomeGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionGenericArgsGreen(pub GreenId);
impl TypedSyntaxNode for OptionGenericArgs {
    type StablePtr = OptionGenericArgsPtr;
    type Green = OptionGenericArgsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionGenericArgsEmpty => {
                    OptionGenericArgs::Empty(OptionGenericArgsEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::OptionGenericArgsSome => {
                    OptionGenericArgs::Some(OptionGenericArgsSome::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionGenericArgs"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionGenericArgs"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionGenericArgs::Empty(x) => x.as_syntax_node(),
            OptionGenericArgs::Some(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionGenericArgsPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionGenericArgsEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionGenericArgsEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionGenericArgsEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionGenericArgsEmptyGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsEmpty,
            children,
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionGenericArgsEmptyPtr(SyntaxStablePtrId);
impl OptionGenericArgsEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionGenericArgsEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionGenericArgsEmpty {
    type StablePtr = OptionGenericArgsEmptyPtr;
    type Green = OptionGenericArgsEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionGenericArgsEmptyGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsEmpty,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionGenericArgsEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionGenericArgsEmpty,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionGenericArgsEmpty,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionGenericArgsEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionGenericArgsSome {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionGenericArgsSome {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        langle: TerminalGreen,
        generic_args: GenericArgListGreen,
        rangle: TerminalGreen,
    ) -> OptionGenericArgsSomeGreen {
        let children: Vec<GreenId> = vec![langle.0, generic_args.0, rangle.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionGenericArgsSomeGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsSome,
            children,
            width,
        })))
    }
    pub fn langle(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> GenericArgList {
        GenericArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rangle(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionGenericArgsSomePtr(SyntaxStablePtrId);
impl OptionGenericArgsSomePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionGenericArgsSomeGreen(pub GreenId);
impl TypedSyntaxNode for OptionGenericArgsSome {
    type StablePtr = OptionGenericArgsSomePtr;
    type Green = OptionGenericArgsSomeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionGenericArgsSomeGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionGenericArgsSome,
            children: vec![
                Terminal::missing(db).0,
                GenericArgList::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionGenericArgsSome {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionGenericArgsSome,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionGenericArgsSome,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionGenericArgsSomePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericArgList(ElementList<Expr, 2>);
impl Deref for GenericArgList {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl GenericArgList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<GenericArgListElementOrSeparatorGreen>,
    ) -> GenericArgListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        GenericArgListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::GenericArgList,
            children: children.iter().map(|x| x.id()).collect(),
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgListPtr(SyntaxStablePtrId);
impl GenericArgListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum GenericArgListElementOrSeparatorGreen {
    Separator(TerminalGreen),
    Element(ExprGreen),
}
impl From<TerminalGreen> for GenericArgListElementOrSeparatorGreen {
    fn from(value: TerminalGreen) -> Self {
        GenericArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ExprGreen> for GenericArgListElementOrSeparatorGreen {
    fn from(value: ExprGreen) -> Self {
        GenericArgListElementOrSeparatorGreen::Element(value)
    }
}
impl GenericArgListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            GenericArgListElementOrSeparatorGreen::Separator(green) => green.0,
            GenericArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgListGreen(pub GreenId);
impl TypedSyntaxNode for GenericArgList {
    type StablePtr = GenericArgListPtr;
    type Green = GenericArgListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericArgListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::GenericArgList,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericArgListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum PathSegment {
    GenericArgs(PathSegmentGenericArgs),
    Ident(PathSegmentIdent),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentPtr(SyntaxStablePtrId);
impl PathSegmentPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<PathSegmentGenericArgsGreen> for PathSegmentGreen {
    fn from(value: PathSegmentGenericArgsGreen) -> Self {
        Self(value.0)
    }
}
impl From<PathSegmentIdentGreen> for PathSegmentGreen {
    fn from(value: PathSegmentIdentGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentGreen(pub GreenId);
impl TypedSyntaxNode for PathSegment {
    type StablePtr = PathSegmentPtr;
    type Green = PathSegmentGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PathSegmentGreen(PathSegmentIdent::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::PathSegmentGenericArgs => {
                    PathSegment::GenericArgs(PathSegmentGenericArgs::from_syntax_node(db, node))
                }
                SyntaxKind::PathSegmentIdent => {
                    PathSegment::Ident(PathSegmentIdent::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "PathSegment"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "PathSegment"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            PathSegment::GenericArgs(x) => x.as_syntax_node(),
            PathSegment::Ident(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PathSegmentPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PathSegmentIdent {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PathSegmentIdent {
    pub fn new_green(db: &dyn SyntaxGroup, ident: TerminalGreen) -> PathSegmentIdentGreen {
        let children: Vec<GreenId> = vec![ident.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        PathSegmentIdentGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::PathSegmentIdent,
            children,
            width,
        })))
    }
    pub fn ident(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentIdentPtr(SyntaxStablePtrId);
impl PathSegmentIdentPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentIdentGreen(pub GreenId);
impl TypedSyntaxNode for PathSegmentIdent {
    type StablePtr = PathSegmentIdentPtr;
    type Green = PathSegmentIdentGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PathSegmentIdentGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::PathSegmentIdent,
            children: vec![Terminal::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::PathSegmentIdent {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::PathSegmentIdent,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::PathSegmentIdent,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PathSegmentIdentPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PathSegmentGenericArgs {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PathSegmentGenericArgs {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        generic_args: OptionGenericArgsSomeGreen,
    ) -> PathSegmentGenericArgsGreen {
        let children: Vec<GreenId> = vec![generic_args.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        PathSegmentGenericArgsGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::PathSegmentGenericArgs,
            children,
            width,
        })))
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> OptionGenericArgsSome {
        OptionGenericArgsSome::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentGenericArgsPtr(SyntaxStablePtrId);
impl PathSegmentGenericArgsPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentGenericArgsGreen(pub GreenId);
impl TypedSyntaxNode for PathSegmentGenericArgs {
    type StablePtr = PathSegmentGenericArgsPtr;
    type Green = PathSegmentGenericArgsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PathSegmentGenericArgsGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::PathSegmentGenericArgs,
            children: vec![OptionGenericArgsSome::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::PathSegmentGenericArgs {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::PathSegmentGenericArgs,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::PathSegmentGenericArgs,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PathSegmentGenericArgsPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprPath(ElementList<PathSegment, 2>);
impl Deref for ExprPath {
    type Target = ElementList<PathSegment, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprPath {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ExprPathElementOrSeparatorGreen>,
    ) -> ExprPathGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        ExprPathGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprPath,
            children: children.iter().map(|x| x.id()).collect(),
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprPathPtr(SyntaxStablePtrId);
impl ExprPathPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ExprPathElementOrSeparatorGreen {
    Separator(TerminalGreen),
    Element(PathSegmentGreen),
}
impl From<TerminalGreen> for ExprPathElementOrSeparatorGreen {
    fn from(value: TerminalGreen) -> Self {
        ExprPathElementOrSeparatorGreen::Separator(value)
    }
}
impl From<PathSegmentGreen> for ExprPathElementOrSeparatorGreen {
    fn from(value: PathSegmentGreen) -> Self {
        ExprPathElementOrSeparatorGreen::Element(value)
    }
}
impl ExprPathElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ExprPathElementOrSeparatorGreen::Separator(green) => green.0,
            ExprPathElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprPathGreen(pub GreenId);
impl TypedSyntaxNode for ExprPath {
    type StablePtr = ExprPathPtr;
    type Green = ExprPathGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprPathGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprPath,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprPathPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprLiteral {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprLiteral {
    pub fn new_green(db: &dyn SyntaxGroup, terminal: TerminalGreen) -> ExprLiteralGreen {
        let children: Vec<GreenId> = vec![terminal.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprLiteralGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprLiteral,
            children,
            width,
        })))
    }
    pub fn terminal(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprLiteralPtr(SyntaxStablePtrId);
impl ExprLiteralPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprLiteralGreen(pub GreenId);
impl TypedSyntaxNode for ExprLiteral {
    type StablePtr = ExprLiteralPtr;
    type Green = ExprLiteralGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprLiteralGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprLiteral,
            children: vec![Terminal::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprLiteral {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprLiteral,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprLiteral,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprLiteralPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprParenthesized {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalGreen,
        expr: ExprGreen,
        rparen: TerminalGreen,
    ) -> ExprParenthesizedGreen {
        let children: Vec<GreenId> = vec![lparen.0, expr.0, rparen.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprParenthesizedGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprParenthesized,
            children,
            width,
        })))
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprParenthesizedPtr(SyntaxStablePtrId);
impl ExprParenthesizedPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprParenthesizedGreen(pub GreenId);
impl TypedSyntaxNode for ExprParenthesized {
    type StablePtr = ExprParenthesizedPtr;
    type Green = ExprParenthesizedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprParenthesizedGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprParenthesized,
            children: vec![Terminal::missing(db).0, Expr::missing(db).0, Terminal::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprParenthesized,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprParenthesized,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprParenthesizedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprUnary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprUnary {
    pub fn new_green(db: &dyn SyntaxGroup, op: TerminalGreen, expr: ExprGreen) -> ExprUnaryGreen {
        let children: Vec<GreenId> = vec![op.0, expr.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprUnaryGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprUnary,
            children,
            width,
        })))
    }
    pub fn op(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprUnaryPtr(SyntaxStablePtrId);
impl ExprUnaryPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprUnaryGreen(pub GreenId);
impl TypedSyntaxNode for ExprUnary {
    type StablePtr = ExprUnaryPtr;
    type Green = ExprUnaryGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprUnaryGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprUnary,
            children: vec![Terminal::missing(db).0, Expr::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprUnary {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprUnary,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprUnary,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprUnaryPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBinary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBinary {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lhs: ExprGreen,
        op: TerminalGreen,
        rhs: ExprGreen,
    ) -> ExprBinaryGreen {
        let children: Vec<GreenId> = vec![lhs.0, op.0, rhs.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprBinaryGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBinary,
            children,
            width,
        })))
    }
    pub fn lhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn op(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBinaryPtr(SyntaxStablePtrId);
impl ExprBinaryPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBinaryGreen(pub GreenId);
impl TypedSyntaxNode for ExprBinary {
    type StablePtr = ExprBinaryPtr;
    type Green = ExprBinaryGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprBinaryGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBinary,
            children: vec![Expr::missing(db).0, Terminal::missing(db).0, Expr::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprBinary {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprBinary,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprBinary,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprBinaryPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprTuple {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprTuple {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalGreen,
        expressions: ExprListGreen,
        rparen: TerminalGreen,
    ) -> ExprTupleGreen {
        let children: Vec<GreenId> = vec![lparen.0, expressions.0, rparen.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprTupleGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprTuple,
            children,
            width,
        })))
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expressions(&self, db: &dyn SyntaxGroup) -> ExprList {
        ExprList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprTuplePtr(SyntaxStablePtrId);
impl ExprTuplePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprTupleGreen(pub GreenId);
impl TypedSyntaxNode for ExprTuple {
    type StablePtr = ExprTuplePtr;
    type Green = ExprTupleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprTupleGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprTuple,
            children: vec![
                Terminal::missing(db).0,
                ExprList::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprTuple {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprTuple,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprTuple,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprTuplePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprListParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprListParenthesized {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalGreen,
        expressions: ExprListGreen,
        rparen: TerminalGreen,
    ) -> ExprListParenthesizedGreen {
        let children: Vec<GreenId> = vec![lparen.0, expressions.0, rparen.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprListParenthesizedGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprListParenthesized,
            children,
            width,
        })))
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expressions(&self, db: &dyn SyntaxGroup) -> ExprList {
        ExprList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListParenthesizedPtr(SyntaxStablePtrId);
impl ExprListParenthesizedPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListParenthesizedGreen(pub GreenId);
impl TypedSyntaxNode for ExprListParenthesized {
    type StablePtr = ExprListParenthesizedPtr;
    type Green = ExprListParenthesizedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprListParenthesizedGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprListParenthesized,
            children: vec![
                Terminal::missing(db).0,
                ExprList::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprListParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprListParenthesized,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprListParenthesized,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprListParenthesizedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprFunctionCall {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprFunctionCall {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        arguments: ExprListParenthesizedGreen,
    ) -> ExprFunctionCallGreen {
        let children: Vec<GreenId> = vec![path.0, arguments.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprFunctionCallGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprFunctionCall,
            children,
            width,
        })))
    }
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> ExprListParenthesized {
        ExprListParenthesized::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprFunctionCallPtr(SyntaxStablePtrId);
impl ExprFunctionCallPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprFunctionCallGreen(pub GreenId);
impl TypedSyntaxNode for ExprFunctionCall {
    type StablePtr = ExprFunctionCallPtr;
    type Green = ExprFunctionCallGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprFunctionCallGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprFunctionCall,
            children: vec![ExprPath::missing(db).0, ExprListParenthesized::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprFunctionCall {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprFunctionCall,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprFunctionCall,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprFunctionCallPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprStructCtorCall {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprStructCtorCall {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        arguments: ArgListBracedGreen,
    ) -> ExprStructCtorCallGreen {
        let children: Vec<GreenId> = vec![path.0, arguments.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprStructCtorCallGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprStructCtorCall,
            children,
            width,
        })))
    }
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> ArgListBraced {
        ArgListBraced::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprStructCtorCallPtr(SyntaxStablePtrId);
impl ExprStructCtorCallPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprStructCtorCallGreen(pub GreenId);
impl TypedSyntaxNode for ExprStructCtorCall {
    type StablePtr = ExprStructCtorCallPtr;
    type Green = ExprStructCtorCallGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprStructCtorCallGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprStructCtorCall,
            children: vec![ExprPath::missing(db).0, ArgListBraced::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprStructCtorCall {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprStructCtorCall,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprStructCtorCall,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprStructCtorCallPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBlock {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBlock {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalGreen,
        statements: StatementListGreen,
        rbrace: TerminalGreen,
    ) -> ExprBlockGreen {
        let children: Vec<GreenId> = vec![lbrace.0, statements.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprBlockGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBlock,
            children,
            width,
        })))
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn statements(&self, db: &dyn SyntaxGroup) -> StatementList {
        StatementList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBlockPtr(SyntaxStablePtrId);
impl ExprBlockPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBlockGreen(pub GreenId);
impl TypedSyntaxNode for ExprBlock {
    type StablePtr = ExprBlockPtr;
    type Green = ExprBlockGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprBlockGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprBlock,
            children: vec![
                Terminal::missing(db).0,
                StatementList::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprBlock {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprBlock,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprBlock,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprBlockPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Pattern {
    Underscore(Terminal),
    Literal(ExprLiteral),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternPtr(SyntaxStablePtrId);
impl PatternPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TerminalGreen> for PatternGreen {
    fn from(value: TerminalGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprLiteralGreen> for PatternGreen {
    fn from(value: ExprLiteralGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternGreen(pub GreenId);
impl TypedSyntaxNode for Pattern {
    type StablePtr = PatternPtr;
    type Green = PatternGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::Terminal => Pattern::Underscore(Terminal::from_syntax_node(db, node)),
                SyntaxKind::ExprLiteral => {
                    Pattern::Literal(ExprLiteral::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Pattern"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "Pattern"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Pattern::Underscore(x) => x.as_syntax_node(),
            Pattern::Literal(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MatchArm {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl MatchArm {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        pattern: PatternGreen,
        arrow: TerminalGreen,
        expression: ExprGreen,
    ) -> MatchArmGreen {
        let children: Vec<GreenId> = vec![pattern.0, arrow.0, expression.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        MatchArmGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::MatchArm,
            children,
            width,
        })))
    }
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arrow(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn expression(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmPtr(SyntaxStablePtrId);
impl MatchArmPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmGreen(pub GreenId);
impl TypedSyntaxNode for MatchArm {
    type StablePtr = MatchArmPtr;
    type Green = MatchArmGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        MatchArmGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::MatchArm,
            children: vec![Pattern::missing(db).0, Terminal::missing(db).0, Expr::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::MatchArm {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::MatchArm,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::MatchArm,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MatchArmPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MatchArms(ElementList<MatchArm, 2>);
impl Deref for MatchArms {
    type Target = ElementList<MatchArm, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl MatchArms {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<MatchArmsElementOrSeparatorGreen>,
    ) -> MatchArmsGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        MatchArmsGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::MatchArms,
            children: children.iter().map(|x| x.id()).collect(),
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmsPtr(SyntaxStablePtrId);
impl MatchArmsPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum MatchArmsElementOrSeparatorGreen {
    Separator(TerminalGreen),
    Element(MatchArmGreen),
}
impl From<TerminalGreen> for MatchArmsElementOrSeparatorGreen {
    fn from(value: TerminalGreen) -> Self {
        MatchArmsElementOrSeparatorGreen::Separator(value)
    }
}
impl From<MatchArmGreen> for MatchArmsElementOrSeparatorGreen {
    fn from(value: MatchArmGreen) -> Self {
        MatchArmsElementOrSeparatorGreen::Element(value)
    }
}
impl MatchArmsElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            MatchArmsElementOrSeparatorGreen::Separator(green) => green.0,
            MatchArmsElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmsGreen(pub GreenId);
impl TypedSyntaxNode for MatchArms {
    type StablePtr = MatchArmsPtr;
    type Green = MatchArmsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        MatchArmsGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::MatchArms,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MatchArmsPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprMatch {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprMatch {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        matchkw: TerminalGreen,
        expr: ExprGreen,
        lbrace: TerminalGreen,
        arms: MatchArmsGreen,
        rbrace: TerminalGreen,
    ) -> ExprMatchGreen {
        let children: Vec<GreenId> = vec![matchkw.0, expr.0, lbrace.0, arms.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprMatchGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMatch,
            children,
            width,
        })))
    }
    pub fn matchkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn arms(&self, db: &dyn SyntaxGroup) -> MatchArms {
        MatchArms::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMatchPtr(SyntaxStablePtrId);
impl ExprMatchPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMatchGreen(pub GreenId);
impl TypedSyntaxNode for ExprMatch {
    type StablePtr = ExprMatchPtr;
    type Green = ExprMatchGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprMatchGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ExprMatch,
            children: vec![
                Terminal::missing(db).0,
                Expr::missing(db).0,
                Terminal::missing(db).0,
                MatchArms::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprMatch {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprMatch,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprMatch,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprMatchPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TypeClause {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TypeClause {
    pub fn new_green(db: &dyn SyntaxGroup, colon: TerminalGreen, ty: ExprGreen) -> TypeClauseGreen {
        let children: Vec<GreenId> = vec![colon.0, ty.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TypeClauseGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TypeClause,
            children,
            width,
        })))
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ty(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TypeClausePtr(SyntaxStablePtrId);
impl TypeClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for TypeClause {
    type StablePtr = TypeClausePtr;
    type Green = TypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TypeClauseGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::TypeClause,
            children: vec![Terminal::missing(db).0, Expr::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::TypeClause {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::TypeClause,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::TypeClause,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TypeClausePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTypeClause {
    Empty(OptionTypeClauseEmpty),
    TypeClause(TypeClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClausePtr(SyntaxStablePtrId);
impl OptionTypeClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionTypeClauseEmptyGreen> for OptionTypeClauseGreen {
    fn from(value: OptionTypeClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TypeClauseGreen> for OptionTypeClauseGreen {
    fn from(value: TypeClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionTypeClause {
    type StablePtr = OptionTypeClausePtr;
    type Green = OptionTypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionTypeClauseEmpty => {
                    OptionTypeClause::Empty(OptionTypeClauseEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::TypeClause => {
                    OptionTypeClause::TypeClause(TypeClause::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionTypeClause"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionTypeClause"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTypeClause::Empty(x) => x.as_syntax_node(),
            OptionTypeClause::TypeClause(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTypeClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTypeClauseEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionTypeClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionTypeClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionTypeClauseEmptyGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionTypeClauseEmpty,
            children,
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClauseEmptyPtr(SyntaxStablePtrId);
impl OptionTypeClauseEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionTypeClauseEmpty {
    type StablePtr = OptionTypeClauseEmptyPtr;
    type Green = OptionTypeClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionTypeClauseEmptyGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionTypeClauseEmpty,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionTypeClauseEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionTypeClauseEmpty,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionTypeClauseEmpty,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTypeClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ReturnTypeClause {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ReturnTypeClause {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        arrow: TerminalGreen,
        ty: ExprGreen,
    ) -> ReturnTypeClauseGreen {
        let children: Vec<GreenId> = vec![arrow.0, ty.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ReturnTypeClauseGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ReturnTypeClause,
            children,
            width,
        })))
    }
    pub fn arrow(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ty(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ReturnTypeClausePtr(SyntaxStablePtrId);
impl ReturnTypeClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ReturnTypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for ReturnTypeClause {
    type StablePtr = ReturnTypeClausePtr;
    type Green = ReturnTypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ReturnTypeClauseGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ReturnTypeClause,
            children: vec![Terminal::missing(db).0, Expr::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ReturnTypeClause {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ReturnTypeClause,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ReturnTypeClause,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ReturnTypeClausePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionReturnTypeClause {
    Empty(OptionReturnTypeClauseEmpty),
    ReturnTypeClause(ReturnTypeClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClausePtr(SyntaxStablePtrId);
impl OptionReturnTypeClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionReturnTypeClauseEmptyGreen> for OptionReturnTypeClauseGreen {
    fn from(value: OptionReturnTypeClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ReturnTypeClauseGreen> for OptionReturnTypeClauseGreen {
    fn from(value: ReturnTypeClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionReturnTypeClause {
    type StablePtr = OptionReturnTypeClausePtr;
    type Green = OptionReturnTypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionReturnTypeClauseEmpty => OptionReturnTypeClause::Empty(
                    OptionReturnTypeClauseEmpty::from_syntax_node(db, node),
                ),
                SyntaxKind::ReturnTypeClause => OptionReturnTypeClause::ReturnTypeClause(
                    ReturnTypeClause::from_syntax_node(db, node),
                ),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionReturnTypeClause"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionReturnTypeClause"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionReturnTypeClause::Empty(x) => x.as_syntax_node(),
            OptionReturnTypeClause::ReturnTypeClause(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionReturnTypeClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionReturnTypeClauseEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionReturnTypeClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionReturnTypeClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionReturnTypeClauseEmptyGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionReturnTypeClauseEmpty,
            children,
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClauseEmptyPtr(SyntaxStablePtrId);
impl OptionReturnTypeClauseEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionReturnTypeClauseEmpty {
    type StablePtr = OptionReturnTypeClauseEmptyPtr;
    type Green = OptionReturnTypeClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionReturnTypeClauseEmptyGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionReturnTypeClauseEmpty,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionReturnTypeClauseEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionReturnTypeClauseEmpty,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionReturnTypeClauseEmpty,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionReturnTypeClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Statement {
    Let(StatementLet),
    Expr(StatementExpr),
    Return(StatementReturn),
    Missing(StatementMissing),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementPtr(SyntaxStablePtrId);
impl StatementPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<StatementLetGreen> for StatementGreen {
    fn from(value: StatementLetGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementExprGreen> for StatementGreen {
    fn from(value: StatementExprGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementReturnGreen> for StatementGreen {
    fn from(value: StatementReturnGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementMissingGreen> for StatementGreen {
    fn from(value: StatementMissingGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementGreen(pub GreenId);
impl TypedSyntaxNode for Statement {
    type StablePtr = StatementPtr;
    type Green = StatementGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementGreen(StatementMissing::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::StatementLet => {
                    Statement::Let(StatementLet::from_syntax_node(db, node))
                }
                SyntaxKind::StatementExpr => {
                    Statement::Expr(StatementExpr::from_syntax_node(db, node))
                }
                SyntaxKind::StatementReturn => {
                    Statement::Return(StatementReturn::from_syntax_node(db, node))
                }
                SyntaxKind::StatementMissing => {
                    Statement::Missing(StatementMissing::from_syntax_node(db, node))
                }
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Statement"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "Statement"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Statement::Let(x) => x.as_syntax_node(),
            Statement::Expr(x) => x.as_syntax_node(),
            Statement::Return(x) => x.as_syntax_node(),
            Statement::Missing(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementList(ElementList<Statement, 1>);
impl Deref for StatementList {
    type Target = ElementList<Statement, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StatementList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<StatementGreen>) -> StatementListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.0).width()).sum();
        StatementListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementList,
            children: children.iter().map(|x| x.0).collect(),
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementListPtr(SyntaxStablePtrId);
impl StatementListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementListGreen(pub GreenId);
impl TypedSyntaxNode for StatementList {
    type StablePtr = StatementListPtr;
    type Green = StatementListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementList,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> StatementMissingGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StatementMissingGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children,
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementMissingPtr(SyntaxStablePtrId);
impl StatementMissingPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementMissingGreen(pub GreenId);
impl TypedSyntaxNode for StatementMissing {
    type StablePtr = StatementMissingPtr;
    type Green = StatementMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementMissingGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementMissing,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementMissing {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementMissing,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::StatementMissing,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementMissingPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementLet {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementLet {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        letkw: TerminalGreen,
        name: TerminalGreen,
        type_clause: OptionTypeClauseGreen,
        eq: TerminalGreen,
        rhs: ExprGreen,
        semicolon: TerminalGreen,
    ) -> StatementLetGreen {
        let children: Vec<GreenId> = vec![letkw.0, name.0, type_clause.0, eq.0, rhs.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StatementLetGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementLet,
            children,
            width,
        })))
    }
    pub fn letkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> OptionTypeClause {
        OptionTypeClause::from_syntax_node(db, self.children[2].clone())
    }
    pub fn eq(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[4].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementLetPtr(SyntaxStablePtrId);
impl StatementLetPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementLetGreen(pub GreenId);
impl TypedSyntaxNode for StatementLet {
    type StablePtr = StatementLetPtr;
    type Green = StatementLetGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementLetGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementLet,
            children: vec![
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                OptionTypeClause::missing(db).0,
                Terminal::missing(db).0,
                Expr::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementLet {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementLet,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementLet,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementLetPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionSemicolon {
    Empty(OptionSemicolonEmpty),
    Some(Terminal),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionSemicolonPtr(SyntaxStablePtrId);
impl OptionSemicolonPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionSemicolonEmptyGreen> for OptionSemicolonGreen {
    fn from(value: OptionSemicolonEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGreen> for OptionSemicolonGreen {
    fn from(value: TerminalGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionSemicolonGreen(pub GreenId);
impl TypedSyntaxNode for OptionSemicolon {
    type StablePtr = OptionSemicolonPtr;
    type Green = OptionSemicolonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::OptionSemicolonEmpty => {
                    OptionSemicolon::Empty(OptionSemicolonEmpty::from_syntax_node(db, node))
                }
                SyntaxKind::Terminal => OptionSemicolon::Some(Terminal::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "OptionSemicolon"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!(
                    "Unexpected token kind {:?} when constructing {}.",
                    token.kind, "OptionSemicolon"
                ),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionSemicolon::Empty(x) => x.as_syntax_node(),
            OptionSemicolon::Some(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionSemicolonPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionSemicolonEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionSemicolonEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionSemicolonEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionSemicolonEmptyGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionSemicolonEmpty,
            children,
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionSemicolonEmptyPtr(SyntaxStablePtrId);
impl OptionSemicolonEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionSemicolonEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionSemicolonEmpty {
    type StablePtr = OptionSemicolonEmptyPtr;
    type Green = OptionSemicolonEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionSemicolonEmptyGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::OptionSemicolonEmpty,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::OptionSemicolonEmpty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::OptionSemicolonEmpty,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::OptionSemicolonEmpty,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionSemicolonEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementExpr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementExpr {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        expr: ExprGreen,
        semicolon: OptionSemicolonGreen,
    ) -> StatementExprGreen {
        let children: Vec<GreenId> = vec![expr.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StatementExprGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementExpr,
            children,
            width,
        })))
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> OptionSemicolon {
        OptionSemicolon::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementExprPtr(SyntaxStablePtrId);
impl StatementExprPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementExprGreen(pub GreenId);
impl TypedSyntaxNode for StatementExpr {
    type StablePtr = StatementExprPtr;
    type Green = StatementExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementExprGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementExpr,
            children: vec![Expr::missing(db).0, OptionSemicolon::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementExpr {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementExpr,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementExpr,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementExprPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementReturn {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementReturn {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        returnkw: TerminalGreen,
        expr: ExprGreen,
        semicolon: TerminalGreen,
    ) -> StatementReturnGreen {
        let children: Vec<GreenId> = vec![returnkw.0, expr.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StatementReturnGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementReturn,
            children,
            width,
        })))
    }
    pub fn returnkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementReturnPtr(SyntaxStablePtrId);
impl StatementReturnPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementReturnGreen(pub GreenId);
impl TypedSyntaxNode for StatementReturn {
    type StablePtr = StatementReturnPtr;
    type Green = StatementReturnGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementReturnGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::StatementReturn,
            children: vec![Terminal::missing(db).0, Expr::missing(db).0, Terminal::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::StatementReturn {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::StatementReturn,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::StatementReturn,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementReturnPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Param {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Param {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        name: TerminalGreen,
        type_clause: TypeClauseGreen,
    ) -> ParamGreen {
        let children: Vec<GreenId> = vec![name.0, type_clause.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ParamGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Param,
            children,
            width,
        })))
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> TypeClause {
        TypeClause::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamPtr(SyntaxStablePtrId);
impl ParamPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamGreen(pub GreenId);
impl TypedSyntaxNode for Param {
    type StablePtr = ParamPtr;
    type Green = ParamGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ParamGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::Param,
            children: vec![Terminal::missing(db).0, TypeClause::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Param {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Param,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Param,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamList(ElementList<Param, 2>);
impl Deref for ParamList {
    type Target = ElementList<Param, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ParamList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ParamListElementOrSeparatorGreen>,
    ) -> ParamListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        ParamListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamList,
            children: children.iter().map(|x| x.id()).collect(),
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamListPtr(SyntaxStablePtrId);
impl ParamListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ParamListElementOrSeparatorGreen {
    Separator(TerminalGreen),
    Element(ParamGreen),
}
impl From<TerminalGreen> for ParamListElementOrSeparatorGreen {
    fn from(value: TerminalGreen) -> Self {
        ParamListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ParamGreen> for ParamListElementOrSeparatorGreen {
    fn from(value: ParamGreen) -> Self {
        ParamListElementOrSeparatorGreen::Element(value)
    }
}
impl ParamListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ParamListElementOrSeparatorGreen::Separator(green) => green.0,
            ParamListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamListGreen(pub GreenId);
impl TypedSyntaxNode for ParamList {
    type StablePtr = ParamListPtr;
    type Green = ParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ParamListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamList,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamListParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ParamListParenthesized {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalGreen,
        parameters: ParamListGreen,
        rparen: TerminalGreen,
    ) -> ParamListParenthesizedGreen {
        let children: Vec<GreenId> = vec![lparen.0, parameters.0, rparen.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ParamListParenthesizedGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListParenthesized,
            children,
            width,
        })))
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn parameters(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamListParenthesizedPtr(SyntaxStablePtrId);
impl ParamListParenthesizedPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamListParenthesizedGreen(pub GreenId);
impl TypedSyntaxNode for ParamListParenthesized {
    type StablePtr = ParamListParenthesizedPtr;
    type Green = ParamListParenthesizedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ParamListParenthesizedGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListParenthesized,
            children: vec![
                Terminal::missing(db).0,
                ParamList::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ParamListParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ParamListParenthesized,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ParamListParenthesized,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamListParenthesizedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamListBraced {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ParamListBraced {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalGreen,
        parameters: ParamListGreen,
        rbrace: TerminalGreen,
    ) -> ParamListBracedGreen {
        let children: Vec<GreenId> = vec![lbrace.0, parameters.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ParamListBracedGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListBraced,
            children,
            width,
        })))
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn parameters(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamListBracedPtr(SyntaxStablePtrId);
impl ParamListBracedPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamListBracedGreen(pub GreenId);
impl TypedSyntaxNode for ParamListBraced {
    type StablePtr = ParamListBracedPtr;
    type Green = ParamListBracedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ParamListBracedGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ParamListBraced,
            children: vec![
                Terminal::missing(db).0,
                ParamList::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ParamListBraced {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ParamListBraced,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ParamListBraced,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamListBracedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct FunctionSignature {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl FunctionSignature {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalGreen,
        parameters: ParamListGreen,
        rparen: TerminalGreen,
        ret_ty: OptionReturnTypeClauseGreen,
    ) -> FunctionSignatureGreen {
        let children: Vec<GreenId> = vec![lparen.0, parameters.0, rparen.0, ret_ty.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        FunctionSignatureGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::FunctionSignature,
            children,
            width,
        })))
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn parameters(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn ret_ty(&self, db: &dyn SyntaxGroup) -> OptionReturnTypeClause {
        OptionReturnTypeClause::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FunctionSignaturePtr(SyntaxStablePtrId);
impl FunctionSignaturePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FunctionSignatureGreen(pub GreenId);
impl TypedSyntaxNode for FunctionSignature {
    type StablePtr = FunctionSignaturePtr;
    type Green = FunctionSignatureGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        FunctionSignatureGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::FunctionSignature,
            children: vec![
                Terminal::missing(db).0,
                ParamList::missing(db).0,
                Terminal::missing(db).0,
                OptionReturnTypeClause::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::FunctionSignature {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::FunctionSignature,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::FunctionSignature,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        FunctionSignaturePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Item {
    Module(ItemModule),
    Use(ItemUse),
    FreeFunction(ItemFreeFunction),
    ExternFunction(ItemExternFunction),
    ExternType(ItemExternType),
    Trait(ItemTrait),
    Impl(ItemImpl),
    Struct(ItemStruct),
    Enum(ItemEnum),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemPtr(SyntaxStablePtrId);
impl ItemPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<ItemModuleGreen> for ItemGreen {
    fn from(value: ItemModuleGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemUseGreen> for ItemGreen {
    fn from(value: ItemUseGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemFreeFunctionGreen> for ItemGreen {
    fn from(value: ItemFreeFunctionGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternFunctionGreen> for ItemGreen {
    fn from(value: ItemExternFunctionGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternTypeGreen> for ItemGreen {
    fn from(value: ItemExternTypeGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemTraitGreen> for ItemGreen {
    fn from(value: ItemTraitGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemImplGreen> for ItemGreen {
    fn from(value: ItemImplGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemStructGreen> for ItemGreen {
    fn from(value: ItemStructGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemEnumGreen> for ItemGreen {
    fn from(value: ItemEnumGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemGreen(pub GreenId);
impl TypedSyntaxNode for Item {
    type StablePtr = ItemPtr;
    type Green = ItemGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => match internal.kind {
                SyntaxKind::ItemModule => Item::Module(ItemModule::from_syntax_node(db, node)),
                SyntaxKind::ItemUse => Item::Use(ItemUse::from_syntax_node(db, node)),
                SyntaxKind::ItemFreeFunction => {
                    Item::FreeFunction(ItemFreeFunction::from_syntax_node(db, node))
                }
                SyntaxKind::ItemExternFunction => {
                    Item::ExternFunction(ItemExternFunction::from_syntax_node(db, node))
                }
                SyntaxKind::ItemExternType => {
                    Item::ExternType(ItemExternType::from_syntax_node(db, node))
                }
                SyntaxKind::ItemTrait => Item::Trait(ItemTrait::from_syntax_node(db, node)),
                SyntaxKind::ItemImpl => Item::Impl(ItemImpl::from_syntax_node(db, node)),
                SyntaxKind::ItemStruct => Item::Struct(ItemStruct::from_syntax_node(db, node)),
                SyntaxKind::ItemEnum => Item::Enum(ItemEnum::from_syntax_node(db, node)),
                _ => panic!(
                    "Unexpected syntax kind {:?} when constructing {}.",
                    internal.kind, "Item"
                ),
            },
            GreenNode::Token(token) => match token.kind {
                _ => panic!("Unexpected token kind {:?} when constructing {}.", token.kind, "Item"),
            },
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Item::Module(x) => x.as_syntax_node(),
            Item::Use(x) => x.as_syntax_node(),
            Item::FreeFunction(x) => x.as_syntax_node(),
            Item::ExternFunction(x) => x.as_syntax_node(),
            Item::ExternType(x) => x.as_syntax_node(),
            Item::Trait(x) => x.as_syntax_node(),
            Item::Impl(x) => x.as_syntax_node(),
            Item::Struct(x) => x.as_syntax_node(),
            Item::Enum(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemList(ElementList<Item, 1>);
impl Deref for ItemList {
    type Target = ElementList<Item, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ItemList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<ItemGreen>) -> ItemListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.0).width()).sum();
        ItemListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemList,
            children: children.iter().map(|x| x.0).collect(),
            width,
        })))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemListPtr(SyntaxStablePtrId);
impl ItemListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemListGreen(pub GreenId);
impl TypedSyntaxNode for ItemList {
    type StablePtr = ItemListPtr;
    type Green = ItemListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemListGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemList,
            children: vec![],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemModule {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemModule {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        modkw: TerminalGreen,
        name: TerminalGreen,
        semicolon: TerminalGreen,
    ) -> ItemModuleGreen {
        let children: Vec<GreenId> = vec![modkw.0, name.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemModuleGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemModule,
            children,
            width,
        })))
    }
    pub fn modkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemModulePtr(SyntaxStablePtrId);
impl ItemModulePtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemModuleGreen(pub GreenId);
impl TypedSyntaxNode for ItemModule {
    type StablePtr = ItemModulePtr;
    type Green = ItemModuleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemModuleGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemModule,
            children: vec![
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemModule {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemModule,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemModule,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemModulePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemFreeFunction {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemFreeFunction {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        funckw: TerminalGreen,
        name: TerminalGreen,
        generic_args: OptionGenericArgsGreen,
        signature: FunctionSignatureGreen,
        body: ExprBlockGreen,
    ) -> ItemFreeFunctionGreen {
        let children: Vec<GreenId> = vec![funckw.0, name.0, generic_args.0, signature.0, body.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemFreeFunctionGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFreeFunction,
            children,
            width,
        })))
    }
    pub fn funckw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> OptionGenericArgs {
        OptionGenericArgs::from_syntax_node(db, self.children[2].clone())
    }
    pub fn signature(&self, db: &dyn SyntaxGroup) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[3].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemFreeFunctionPtr(SyntaxStablePtrId);
impl ItemFreeFunctionPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemFreeFunctionGreen(pub GreenId);
impl TypedSyntaxNode for ItemFreeFunction {
    type StablePtr = ItemFreeFunctionPtr;
    type Green = ItemFreeFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemFreeFunctionGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemFreeFunction,
            children: vec![
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                OptionGenericArgs::missing(db).0,
                FunctionSignature::missing(db).0,
                ExprBlock::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemFreeFunction {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemFreeFunction,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ItemFreeFunction,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemFreeFunctionPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemExternFunction {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemExternFunction {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        externkw: TerminalGreen,
        funckw: TerminalGreen,
        name: TerminalGreen,
        generic_args: OptionGenericArgsGreen,
        signature: FunctionSignatureGreen,
        semicolon: TerminalGreen,
    ) -> ItemExternFunctionGreen {
        let children: Vec<GreenId> =
            vec![externkw.0, funckw.0, name.0, generic_args.0, signature.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemExternFunctionGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemExternFunction,
            children,
            width,
        })))
    }
    pub fn externkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn funckw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> OptionGenericArgs {
        OptionGenericArgs::from_syntax_node(db, self.children[3].clone())
    }
    pub fn signature(&self, db: &dyn SyntaxGroup) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[4].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternFunctionPtr(SyntaxStablePtrId);
impl ItemExternFunctionPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternFunctionGreen(pub GreenId);
impl TypedSyntaxNode for ItemExternFunction {
    type StablePtr = ItemExternFunctionPtr;
    type Green = ItemExternFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemExternFunctionGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemExternFunction,
            children: vec![
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                OptionGenericArgs::missing(db).0,
                FunctionSignature::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemExternFunction {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemExternFunction,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ItemExternFunction,
                );
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemExternFunctionPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemExternType {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemExternType {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        externkw: TerminalGreen,
        typekw: TerminalGreen,
        name: TerminalGreen,
        generic_args: OptionGenericArgsGreen,
        semicolon: TerminalGreen,
    ) -> ItemExternTypeGreen {
        let children: Vec<GreenId> =
            vec![externkw.0, typekw.0, name.0, generic_args.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemExternTypeGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemExternType,
            children,
            width,
        })))
    }
    pub fn externkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn typekw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> OptionGenericArgs {
        OptionGenericArgs::from_syntax_node(db, self.children[3].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternTypePtr(SyntaxStablePtrId);
impl ItemExternTypePtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternTypeGreen(pub GreenId);
impl TypedSyntaxNode for ItemExternType {
    type StablePtr = ItemExternTypePtr;
    type Green = ItemExternTypeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemExternTypeGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemExternType,
            children: vec![
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                OptionGenericArgs::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemExternType {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemExternType,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemExternType,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemExternTypePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemTrait {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemTrait {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        traitkw: TerminalGreen,
        name: TerminalGreen,
        generic_args: OptionGenericArgsGreen,
        lbrace: TerminalGreen,
        items: ItemListGreen,
        rbrace: TerminalGreen,
    ) -> ItemTraitGreen {
        let children: Vec<GreenId> =
            vec![traitkw.0, name.0, generic_args.0, lbrace.0, items.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemTraitGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemTrait,
            children,
            width,
        })))
    }
    pub fn traitkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> OptionGenericArgs {
        OptionGenericArgs::from_syntax_node(db, self.children[2].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[3].clone())
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> ItemList {
        ItemList::from_syntax_node(db, self.children[4].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemTraitPtr(SyntaxStablePtrId);
impl ItemTraitPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemTraitGreen(pub GreenId);
impl TypedSyntaxNode for ItemTrait {
    type StablePtr = ItemTraitPtr;
    type Green = ItemTraitGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemTraitGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemTrait,
            children: vec![
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                OptionGenericArgs::missing(db).0,
                Terminal::missing(db).0,
                ItemList::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemTrait {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemTrait,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemTrait,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemTraitPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemImpl {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemImpl {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        implkw: TerminalGreen,
        name: TerminalGreen,
        generic_args: OptionGenericArgsGreen,
        forkw: TerminalGreen,
        trait_name: TerminalGreen,
        lbrace: TerminalGreen,
        items: ItemListGreen,
        rbrace: TerminalGreen,
    ) -> ItemImplGreen {
        let children: Vec<GreenId> = vec![
            implkw.0,
            name.0,
            generic_args.0,
            forkw.0,
            trait_name.0,
            lbrace.0,
            items.0,
            rbrace.0,
        ];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemImplGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemImpl,
            children,
            width,
        })))
    }
    pub fn implkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> OptionGenericArgs {
        OptionGenericArgs::from_syntax_node(db, self.children[2].clone())
    }
    pub fn forkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[3].clone())
    }
    pub fn trait_name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[4].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[5].clone())
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> ItemList {
        ItemList::from_syntax_node(db, self.children[6].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[7].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemImplPtr(SyntaxStablePtrId);
impl ItemImplPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemImplGreen(pub GreenId);
impl TypedSyntaxNode for ItemImpl {
    type StablePtr = ItemImplPtr;
    type Green = ItemImplGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemImplGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemImpl,
            children: vec![
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                OptionGenericArgs::missing(db).0,
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                ItemList::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemImpl {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemImpl,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemImpl,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemImplPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemStruct {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemStruct {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        structkw: TerminalGreen,
        name: TerminalGreen,
        generic_args: OptionGenericArgsGreen,
        lbrace: TerminalGreen,
        members: ParamListGreen,
        rbrace: TerminalGreen,
    ) -> ItemStructGreen {
        let children: Vec<GreenId> =
            vec![structkw.0, name.0, generic_args.0, lbrace.0, members.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemStructGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemStruct,
            children,
            width,
        })))
    }
    pub fn structkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> OptionGenericArgs {
        OptionGenericArgs::from_syntax_node(db, self.children[2].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[3].clone())
    }
    pub fn members(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[4].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemStructPtr(SyntaxStablePtrId);
impl ItemStructPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemStructGreen(pub GreenId);
impl TypedSyntaxNode for ItemStruct {
    type StablePtr = ItemStructPtr;
    type Green = ItemStructGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemStructGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemStruct,
            children: vec![
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                OptionGenericArgs::missing(db).0,
                Terminal::missing(db).0,
                ParamList::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemStruct {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemStruct,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemStruct,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemStructPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemEnum {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemEnum {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        enumkw: TerminalGreen,
        name: TerminalGreen,
        body: ParamListBracedGreen,
    ) -> ItemEnumGreen {
        let children: Vec<GreenId> = vec![enumkw.0, name.0, body.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemEnumGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemEnum,
            children,
            width,
        })))
    }
    pub fn enumkw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> ParamListBraced {
        ParamListBraced::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemEnumPtr(SyntaxStablePtrId);
impl ItemEnumPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemEnumGreen(pub GreenId);
impl TypedSyntaxNode for ItemEnum {
    type StablePtr = ItemEnumPtr;
    type Green = ItemEnumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemEnumGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemEnum,
            children: vec![
                Terminal::missing(db).0,
                Terminal::missing(db).0,
                ParamListBraced::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemEnum {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemEnum,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemEnum,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemEnumPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemUse {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemUse {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        usekw: TerminalGreen,
        name: ExprPathGreen,
        semicolon: TerminalGreen,
    ) -> ItemUseGreen {
        let children: Vec<GreenId> = vec![usekw.0, name.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemUseGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemUse,
            children,
            width,
        })))
    }
    pub fn usekw(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemUsePtr(SyntaxStablePtrId);
impl ItemUsePtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> ExprPathGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            ExprPathGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemUseGreen(pub GreenId);
impl TypedSyntaxNode for ItemUse {
    type StablePtr = ItemUsePtr;
    type Green = ItemUseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemUseGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::ItemUse,
            children: vec![
                Terminal::missing(db).0,
                ExprPath::missing(db).0,
                Terminal::missing(db).0,
            ],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ItemUse {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ItemUse,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ItemUse,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemUsePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct SyntaxFile {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl SyntaxFile {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        items: ItemListGreen,
        eof: TerminalGreen,
    ) -> SyntaxFileGreen {
        let children: Vec<GreenId> = vec![items.0, eof.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        SyntaxFileGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::SyntaxFile,
            children,
            width,
        })))
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> ItemList {
        ItemList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn eof(&self, db: &dyn SyntaxGroup) -> Terminal {
        Terminal::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct SyntaxFilePtr(SyntaxStablePtrId);
impl SyntaxFilePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct SyntaxFileGreen(pub GreenId);
impl TypedSyntaxNode for SyntaxFile {
    type StablePtr = SyntaxFilePtr;
    type Green = SyntaxFileGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        SyntaxFileGreen(db.intern_green(GreenNode::Internal(GreenNodeInternal {
            kind: SyntaxKind::SyntaxFile,
            children: vec![ItemList::missing(db).0, Terminal::missing(db).0],
            width: 0,
        })))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green) {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::SyntaxFile {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::SyntaxFile,
                    );
                }
                let children = node.children(db).collect();
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::SyntaxFile,);
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        SyntaxFilePtr(self.node.0.stable_ptr)
    }
}
