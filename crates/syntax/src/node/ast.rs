// Autogenerated file. To regenerate, please run `cargo run --bin generate_syntax`.
#![allow(clippy::match_single_binding)]
#![allow(clippy::too_many_arguments)]
#![allow(dead_code)]
#![allow(unused_variables)]
use std::ops::Deref;

use smol_str::SmolStr;
use utils::extract_matches;

use super::element_list::ElementList;
use super::green::GreenNodeDetails;
use super::kind::SyntaxKind;
use super::{
    GreenId, GreenNode, SyntaxGroup, SyntaxNode, SyntaxStablePtr, SyntaxStablePtrId, Terminal,
    Token, TypedSyntaxNode,
};
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Trivia(ElementList<Trivium, 1>);
impl Deref for Trivia {
    type Target = ElementList<Trivium, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl Trivia {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<TriviumGreen>) -> TriviaGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.0).width()).sum();
        TriviaGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::Trivia,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.0).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviaPtr(pub SyntaxStablePtrId);
impl TriviaPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviaGreen(pub GreenId);
impl TypedSyntaxNode for Trivia {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Trivia);
    type StablePtr = TriviaPtr;
    type Green = TriviaGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TriviaGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::Trivia,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviaPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Trivium {
    SingleLineComment(TokenSingleLineComment),
    Whitespace(TokenWhitespace),
    Newline(TokenNewline),
    Skipped(TokenSkipped),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviumPtr(pub SyntaxStablePtrId);
impl TriviumPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TokenSingleLineCommentPtr> for TriviumPtr {
    fn from(value: TokenSingleLineCommentPtr) -> Self {
        Self(value.0)
    }
}
impl From<TokenWhitespacePtr> for TriviumPtr {
    fn from(value: TokenWhitespacePtr) -> Self {
        Self(value.0)
    }
}
impl From<TokenNewlinePtr> for TriviumPtr {
    fn from(value: TokenNewlinePtr) -> Self {
        Self(value.0)
    }
}
impl From<TokenSkippedPtr> for TriviumPtr {
    fn from(value: TokenSkippedPtr) -> Self {
        Self(value.0)
    }
}
impl From<TokenSingleLineCommentGreen> for TriviumGreen {
    fn from(value: TokenSingleLineCommentGreen) -> Self {
        Self(value.0)
    }
}
impl From<TokenWhitespaceGreen> for TriviumGreen {
    fn from(value: TokenWhitespaceGreen) -> Self {
        Self(value.0)
    }
}
impl From<TokenNewlineGreen> for TriviumGreen {
    fn from(value: TokenNewlineGreen) -> Self {
        Self(value.0)
    }
}
impl From<TokenSkippedGreen> for TriviumGreen {
    fn from(value: TokenSkippedGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviumGreen(pub GreenId);
impl TypedSyntaxNode for Trivium {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = TriviumPtr;
    type Green = TriviumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TokenSingleLineComment => {
                Trivium::SingleLineComment(TokenSingleLineComment::from_syntax_node(db, node))
            }
            SyntaxKind::TokenWhitespace => {
                Trivium::Whitespace(TokenWhitespace::from_syntax_node(db, node))
            }
            SyntaxKind::TokenNewline => Trivium::Newline(TokenNewline::from_syntax_node(db, node)),
            SyntaxKind::TokenSkipped => Trivium::Skipped(TokenSkipped::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Trivium"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Trivium::SingleLineComment(x) => x.as_syntax_node(),
            Trivium::Whitespace(x) => x.as_syntax_node(),
            Trivium::Newline(x) => x.as_syntax_node(),
            Trivium::Skipped(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviumPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Expr {
    Path(ExprPath),
    Literal(TerminalLiteralNumber),
    ShortString(TerminalShortString),
    False(TerminalFalse),
    True(TerminalTrue),
    Parenthesized(ExprParenthesized),
    Unary(ExprUnary),
    Binary(ExprBinary),
    Tuple(ExprTuple),
    FunctionCall(ExprFunctionCall),
    StructCtorCall(ExprStructCtorCall),
    Block(ExprBlock),
    Match(ExprMatch),
    If(ExprIf),
    ErrorPropagate(ExprErrorPropagate),
    Missing(ExprMissing),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprPtr(pub SyntaxStablePtrId);
impl ExprPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<ExprPathPtr> for ExprPtr {
    fn from(value: ExprPathPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLiteralNumberPtr> for ExprPtr {
    fn from(value: TerminalLiteralNumberPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalShortStringPtr> for ExprPtr {
    fn from(value: TerminalShortStringPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalFalsePtr> for ExprPtr {
    fn from(value: TerminalFalsePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTruePtr> for ExprPtr {
    fn from(value: TerminalTruePtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprParenthesizedPtr> for ExprPtr {
    fn from(value: ExprParenthesizedPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprUnaryPtr> for ExprPtr {
    fn from(value: ExprUnaryPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprBinaryPtr> for ExprPtr {
    fn from(value: ExprBinaryPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprTuplePtr> for ExprPtr {
    fn from(value: ExprTuplePtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprFunctionCallPtr> for ExprPtr {
    fn from(value: ExprFunctionCallPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprStructCtorCallPtr> for ExprPtr {
    fn from(value: ExprStructCtorCallPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprBlockPtr> for ExprPtr {
    fn from(value: ExprBlockPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprMatchPtr> for ExprPtr {
    fn from(value: ExprMatchPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprIfPtr> for ExprPtr {
    fn from(value: ExprIfPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprErrorPropagatePtr> for ExprPtr {
    fn from(value: ExprErrorPropagatePtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprMissingPtr> for ExprPtr {
    fn from(value: ExprMissingPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprPathGreen> for ExprGreen {
    fn from(value: ExprPathGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLiteralNumberGreen> for ExprGreen {
    fn from(value: TerminalLiteralNumberGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalShortStringGreen> for ExprGreen {
    fn from(value: TerminalShortStringGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalFalseGreen> for ExprGreen {
    fn from(value: TerminalFalseGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTrueGreen> for ExprGreen {
    fn from(value: TerminalTrueGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprParenthesizedGreen> for ExprGreen {
    fn from(value: ExprParenthesizedGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprUnaryGreen> for ExprGreen {
    fn from(value: ExprUnaryGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprBinaryGreen> for ExprGreen {
    fn from(value: ExprBinaryGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprTupleGreen> for ExprGreen {
    fn from(value: ExprTupleGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprFunctionCallGreen> for ExprGreen {
    fn from(value: ExprFunctionCallGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprStructCtorCallGreen> for ExprGreen {
    fn from(value: ExprStructCtorCallGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprBlockGreen> for ExprGreen {
    fn from(value: ExprBlockGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprMatchGreen> for ExprGreen {
    fn from(value: ExprMatchGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprIfGreen> for ExprGreen {
    fn from(value: ExprIfGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprErrorPropagateGreen> for ExprGreen {
    fn from(value: ExprErrorPropagateGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprMissingGreen> for ExprGreen {
    fn from(value: ExprMissingGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprGreen(pub GreenId);
impl TypedSyntaxNode for Expr {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ExprPtr;
    type Green = ExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprGreen(ExprMissing::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprPath => Expr::Path(ExprPath::from_syntax_node(db, node)),
            SyntaxKind::TerminalLiteralNumber => {
                Expr::Literal(TerminalLiteralNumber::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalShortString => {
                Expr::ShortString(TerminalShortString::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalFalse => Expr::False(TerminalFalse::from_syntax_node(db, node)),
            SyntaxKind::TerminalTrue => Expr::True(TerminalTrue::from_syntax_node(db, node)),
            SyntaxKind::ExprParenthesized => {
                Expr::Parenthesized(ExprParenthesized::from_syntax_node(db, node))
            }
            SyntaxKind::ExprUnary => Expr::Unary(ExprUnary::from_syntax_node(db, node)),
            SyntaxKind::ExprBinary => Expr::Binary(ExprBinary::from_syntax_node(db, node)),
            SyntaxKind::ExprTuple => Expr::Tuple(ExprTuple::from_syntax_node(db, node)),
            SyntaxKind::ExprFunctionCall => {
                Expr::FunctionCall(ExprFunctionCall::from_syntax_node(db, node))
            }
            SyntaxKind::ExprStructCtorCall => {
                Expr::StructCtorCall(ExprStructCtorCall::from_syntax_node(db, node))
            }
            SyntaxKind::ExprBlock => Expr::Block(ExprBlock::from_syntax_node(db, node)),
            SyntaxKind::ExprMatch => Expr::Match(ExprMatch::from_syntax_node(db, node)),
            SyntaxKind::ExprIf => Expr::If(ExprIf::from_syntax_node(db, node)),
            SyntaxKind::ExprErrorPropagate => {
                Expr::ErrorPropagate(ExprErrorPropagate::from_syntax_node(db, node))
            }
            SyntaxKind::ExprMissing => Expr::Missing(ExprMissing::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Expr"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Expr::Path(x) => x.as_syntax_node(),
            Expr::Literal(x) => x.as_syntax_node(),
            Expr::ShortString(x) => x.as_syntax_node(),
            Expr::False(x) => x.as_syntax_node(),
            Expr::True(x) => x.as_syntax_node(),
            Expr::Parenthesized(x) => x.as_syntax_node(),
            Expr::Unary(x) => x.as_syntax_node(),
            Expr::Binary(x) => x.as_syntax_node(),
            Expr::Tuple(x) => x.as_syntax_node(),
            Expr::FunctionCall(x) => x.as_syntax_node(),
            Expr::StructCtorCall(x) => x.as_syntax_node(),
            Expr::Block(x) => x.as_syntax_node(),
            Expr::Match(x) => x.as_syntax_node(),
            Expr::If(x) => x.as_syntax_node(),
            Expr::ErrorPropagate(x) => x.as_syntax_node(),
            Expr::Missing(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprList(ElementList<Expr, 2>);
impl Deref for ExprList {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ExprListElementOrSeparatorGreen>,
    ) -> ExprListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        ExprListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListPtr(pub SyntaxStablePtrId);
impl ExprListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ExprListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(ExprGreen),
}
impl From<TerminalCommaGreen> for ExprListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        ExprListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ExprGreen> for ExprListElementOrSeparatorGreen {
    fn from(value: ExprGreen) -> Self {
        ExprListElementOrSeparatorGreen::Element(value)
    }
}
impl ExprListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ExprListElementOrSeparatorGreen::Separator(green) => green.0,
            ExprListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListGreen(pub GreenId);
impl TypedSyntaxNode for ExprList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprList);
    type StablePtr = ExprListPtr;
    type Green = ExprListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> ExprMissingGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprMissingGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprMissing,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprMissing {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMissingPtr(pub SyntaxStablePtrId);
impl ExprMissingPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMissingGreen(pub GreenId);
impl TypedSyntaxNode for ExprMissing {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprMissing);
    type StablePtr = ExprMissingPtr;
    type Green = ExprMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprMissingGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprMissing,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprMissing
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprMissingPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum PathSegment {
    WithGenericArgs(PathSegmentWithGenericArgs),
    Simple(PathSegmentSimple),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentPtr(pub SyntaxStablePtrId);
impl PathSegmentPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<PathSegmentWithGenericArgsPtr> for PathSegmentPtr {
    fn from(value: PathSegmentWithGenericArgsPtr) -> Self {
        Self(value.0)
    }
}
impl From<PathSegmentSimplePtr> for PathSegmentPtr {
    fn from(value: PathSegmentSimplePtr) -> Self {
        Self(value.0)
    }
}
impl From<PathSegmentWithGenericArgsGreen> for PathSegmentGreen {
    fn from(value: PathSegmentWithGenericArgsGreen) -> Self {
        Self(value.0)
    }
}
impl From<PathSegmentSimpleGreen> for PathSegmentGreen {
    fn from(value: PathSegmentSimpleGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentGreen(pub GreenId);
impl TypedSyntaxNode for PathSegment {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = PathSegmentPtr;
    type Green = PathSegmentGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PathSegmentGreen(PathSegmentSimple::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::PathSegmentWithGenericArgs => {
                PathSegment::WithGenericArgs(PathSegmentWithGenericArgs::from_syntax_node(db, node))
            }
            SyntaxKind::PathSegmentSimple => {
                PathSegment::Simple(PathSegmentSimple::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "PathSegment"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            PathSegment::WithGenericArgs(x) => x.as_syntax_node(),
            PathSegment::Simple(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PathSegmentPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PathSegmentSimple {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PathSegmentSimple {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        ident: TerminalIdentifierGreen,
    ) -> PathSegmentSimpleGreen {
        let children: Vec<GreenId> = vec![ident.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        PathSegmentSimpleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PathSegmentSimple,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl PathSegmentSimple {
    pub fn ident(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentSimplePtr(pub SyntaxStablePtrId);
impl PathSegmentSimplePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentSimpleGreen(pub GreenId);
impl TypedSyntaxNode for PathSegmentSimple {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PathSegmentSimple);
    type StablePtr = PathSegmentSimplePtr;
    type Green = PathSegmentSimpleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PathSegmentSimpleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PathSegmentSimple,
            details: GreenNodeDetails::Node {
                children: vec![TerminalIdentifier::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PathSegmentSimple,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PathSegmentSimple
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PathSegmentSimplePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PathSegmentWithGenericArgs {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PathSegmentWithGenericArgs {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        ident: TerminalIdentifierGreen,
        separator: TerminalColonColonGreen,
        generic_args: GenericArgsGreen,
    ) -> PathSegmentWithGenericArgsGreen {
        let children: Vec<GreenId> = vec![ident.0, separator.0, generic_args.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        PathSegmentWithGenericArgsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PathSegmentWithGenericArgs,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl PathSegmentWithGenericArgs {
    pub fn ident(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn separator(&self, db: &dyn SyntaxGroup) -> TerminalColonColon {
        TerminalColonColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> GenericArgs {
        GenericArgs::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentWithGenericArgsPtr(pub SyntaxStablePtrId);
impl PathSegmentWithGenericArgsPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentWithGenericArgsGreen(pub GreenId);
impl TypedSyntaxNode for PathSegmentWithGenericArgs {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PathSegmentWithGenericArgs);
    type StablePtr = PathSegmentWithGenericArgsPtr;
    type Green = PathSegmentWithGenericArgsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PathSegmentWithGenericArgsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PathSegmentWithGenericArgs,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalIdentifier::missing(db).0,
                    TerminalColonColon::missing(db).0,
                    GenericArgs::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PathSegmentWithGenericArgs,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PathSegmentWithGenericArgs
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PathSegmentWithGenericArgsPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprPath(ElementList<PathSegment, 2>);
impl Deref for ExprPath {
    type Target = ElementList<PathSegment, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprPath {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ExprPathElementOrSeparatorGreen>,
    ) -> ExprPathGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        ExprPathGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprPath,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprPathPtr(pub SyntaxStablePtrId);
impl ExprPathPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ExprPathElementOrSeparatorGreen {
    Separator(TerminalColonColonGreen),
    Element(PathSegmentGreen),
}
impl From<TerminalColonColonGreen> for ExprPathElementOrSeparatorGreen {
    fn from(value: TerminalColonColonGreen) -> Self {
        ExprPathElementOrSeparatorGreen::Separator(value)
    }
}
impl From<PathSegmentGreen> for ExprPathElementOrSeparatorGreen {
    fn from(value: PathSegmentGreen) -> Self {
        ExprPathElementOrSeparatorGreen::Element(value)
    }
}
impl ExprPathElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ExprPathElementOrSeparatorGreen::Separator(green) => green.0,
            ExprPathElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprPathGreen(pub GreenId);
impl TypedSyntaxNode for ExprPath {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprPath);
    type StablePtr = ExprPathPtr;
    type Green = ExprPathGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprPathGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprPath,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprPathPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprParenthesized {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        expr: ExprGreen,
        rparen: TerminalRParenGreen,
    ) -> ExprParenthesizedGreen {
        let children: Vec<GreenId> = vec![lparen.0, expr.0, rparen.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprParenthesizedGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprParenthesized,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprParenthesized {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprParenthesizedPtr(pub SyntaxStablePtrId);
impl ExprParenthesizedPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprParenthesizedGreen(pub GreenId);
impl TypedSyntaxNode for ExprParenthesized {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprParenthesized);
    type StablePtr = ExprParenthesizedPtr;
    type Green = ExprParenthesizedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprParenthesizedGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprParenthesized,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLParen::missing(db).0,
                    Expr::missing(db).0,
                    TerminalRParen::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprParenthesized,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprParenthesized
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprParenthesizedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprUnary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprUnary {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        op: UnaryOperatorGreen,
        expr: ExprGreen,
    ) -> ExprUnaryGreen {
        let children: Vec<GreenId> = vec![op.0, expr.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprUnaryGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprUnary,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprUnary {
    pub fn op(&self, db: &dyn SyntaxGroup) -> UnaryOperator {
        UnaryOperator::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprUnaryPtr(pub SyntaxStablePtrId);
impl ExprUnaryPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprUnaryGreen(pub GreenId);
impl TypedSyntaxNode for ExprUnary {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprUnary);
    type StablePtr = ExprUnaryPtr;
    type Green = ExprUnaryGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprUnaryGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprUnary,
            details: GreenNodeDetails::Node {
                children: vec![UnaryOperator::missing(db).0, Expr::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprUnary,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprUnary
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprUnaryPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum UnaryOperator {
    Not(TerminalNot),
    Minus(TerminalMinus),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UnaryOperatorPtr(pub SyntaxStablePtrId);
impl UnaryOperatorPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TerminalNotPtr> for UnaryOperatorPtr {
    fn from(value: TerminalNotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusPtr> for UnaryOperatorPtr {
    fn from(value: TerminalMinusPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNotGreen> for UnaryOperatorGreen {
    fn from(value: TerminalNotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusGreen> for UnaryOperatorGreen {
    fn from(value: TerminalMinusGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UnaryOperatorGreen(pub GreenId);
impl TypedSyntaxNode for UnaryOperator {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = UnaryOperatorPtr;
    type Green = UnaryOperatorGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalNot => UnaryOperator::Not(TerminalNot::from_syntax_node(db, node)),
            SyntaxKind::TerminalMinus => {
                UnaryOperator::Minus(TerminalMinus::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "UnaryOperator"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            UnaryOperator::Not(x) => x.as_syntax_node(),
            UnaryOperator::Minus(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        UnaryOperatorPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBinary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBinary {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lhs: ExprGreen,
        op: BinaryOperatorGreen,
        rhs: ExprGreen,
    ) -> ExprBinaryGreen {
        let children: Vec<GreenId> = vec![lhs.0, op.0, rhs.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprBinaryGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprBinary,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprBinary {
    pub fn lhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn op(&self, db: &dyn SyntaxGroup) -> BinaryOperator {
        BinaryOperator::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBinaryPtr(pub SyntaxStablePtrId);
impl ExprBinaryPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBinaryGreen(pub GreenId);
impl TypedSyntaxNode for ExprBinary {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprBinary);
    type StablePtr = ExprBinaryPtr;
    type Green = ExprBinaryGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprBinaryGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprBinary,
            details: GreenNodeDetails::Node {
                children: vec![
                    Expr::missing(db).0,
                    BinaryOperator::missing(db).0,
                    Expr::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprBinary,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprBinary
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprBinaryPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum BinaryOperator {
    Dot(TerminalDot),
    Not(TerminalNot),
    Mul(TerminalMul),
    Div(TerminalDiv),
    Mod(TerminalMod),
    Plus(TerminalPlus),
    Minus(TerminalMinus),
    EqEq(TerminalEqEq),
    Neq(TerminalNeq),
    Eq(TerminalEq),
    And(TerminalAnd),
    Or(TerminalOr),
    LE(TerminalLE),
    GE(TerminalGE),
    LT(TerminalLT),
    GT(TerminalGT),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct BinaryOperatorPtr(pub SyntaxStablePtrId);
impl BinaryOperatorPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TerminalDotPtr> for BinaryOperatorPtr {
    fn from(value: TerminalDotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNotPtr> for BinaryOperatorPtr {
    fn from(value: TerminalNotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulPtr> for BinaryOperatorPtr {
    fn from(value: TerminalMulPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDivPtr> for BinaryOperatorPtr {
    fn from(value: TerminalDivPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModPtr> for BinaryOperatorPtr {
    fn from(value: TerminalModPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPlusPtr> for BinaryOperatorPtr {
    fn from(value: TerminalPlusPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusPtr> for BinaryOperatorPtr {
    fn from(value: TerminalMinusPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqEqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalEqEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNeqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalNeqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAndPtr> for BinaryOperatorPtr {
    fn from(value: TerminalAndPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrPtr> for BinaryOperatorPtr {
    fn from(value: TerminalOrPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLEPtr> for BinaryOperatorPtr {
    fn from(value: TerminalLEPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGEPtr> for BinaryOperatorPtr {
    fn from(value: TerminalGEPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLTPtr> for BinaryOperatorPtr {
    fn from(value: TerminalLTPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGTPtr> for BinaryOperatorPtr {
    fn from(value: TerminalGTPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotGreen> for BinaryOperatorGreen {
    fn from(value: TerminalDotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNotGreen> for BinaryOperatorGreen {
    fn from(value: TerminalNotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulGreen> for BinaryOperatorGreen {
    fn from(value: TerminalMulGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDivGreen> for BinaryOperatorGreen {
    fn from(value: TerminalDivGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModGreen> for BinaryOperatorGreen {
    fn from(value: TerminalModGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPlusGreen> for BinaryOperatorGreen {
    fn from(value: TerminalPlusGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusGreen> for BinaryOperatorGreen {
    fn from(value: TerminalMinusGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqEqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalEqEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNeqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalNeqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAndGreen> for BinaryOperatorGreen {
    fn from(value: TerminalAndGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrGreen> for BinaryOperatorGreen {
    fn from(value: TerminalOrGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLEGreen> for BinaryOperatorGreen {
    fn from(value: TerminalLEGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGEGreen> for BinaryOperatorGreen {
    fn from(value: TerminalGEGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLTGreen> for BinaryOperatorGreen {
    fn from(value: TerminalLTGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGTGreen> for BinaryOperatorGreen {
    fn from(value: TerminalGTGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct BinaryOperatorGreen(pub GreenId);
impl TypedSyntaxNode for BinaryOperator {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = BinaryOperatorPtr;
    type Green = BinaryOperatorGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalDot => BinaryOperator::Dot(TerminalDot::from_syntax_node(db, node)),
            SyntaxKind::TerminalNot => BinaryOperator::Not(TerminalNot::from_syntax_node(db, node)),
            SyntaxKind::TerminalMul => BinaryOperator::Mul(TerminalMul::from_syntax_node(db, node)),
            SyntaxKind::TerminalDiv => BinaryOperator::Div(TerminalDiv::from_syntax_node(db, node)),
            SyntaxKind::TerminalMod => BinaryOperator::Mod(TerminalMod::from_syntax_node(db, node)),
            SyntaxKind::TerminalPlus => {
                BinaryOperator::Plus(TerminalPlus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinus => {
                BinaryOperator::Minus(TerminalMinus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEqEq => {
                BinaryOperator::EqEq(TerminalEqEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNeq => BinaryOperator::Neq(TerminalNeq::from_syntax_node(db, node)),
            SyntaxKind::TerminalEq => BinaryOperator::Eq(TerminalEq::from_syntax_node(db, node)),
            SyntaxKind::TerminalAnd => BinaryOperator::And(TerminalAnd::from_syntax_node(db, node)),
            SyntaxKind::TerminalOr => BinaryOperator::Or(TerminalOr::from_syntax_node(db, node)),
            SyntaxKind::TerminalLE => BinaryOperator::LE(TerminalLE::from_syntax_node(db, node)),
            SyntaxKind::TerminalGE => BinaryOperator::GE(TerminalGE::from_syntax_node(db, node)),
            SyntaxKind::TerminalLT => BinaryOperator::LT(TerminalLT::from_syntax_node(db, node)),
            SyntaxKind::TerminalGT => BinaryOperator::GT(TerminalGT::from_syntax_node(db, node)),
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "BinaryOperator")
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            BinaryOperator::Dot(x) => x.as_syntax_node(),
            BinaryOperator::Not(x) => x.as_syntax_node(),
            BinaryOperator::Mul(x) => x.as_syntax_node(),
            BinaryOperator::Div(x) => x.as_syntax_node(),
            BinaryOperator::Mod(x) => x.as_syntax_node(),
            BinaryOperator::Plus(x) => x.as_syntax_node(),
            BinaryOperator::Minus(x) => x.as_syntax_node(),
            BinaryOperator::EqEq(x) => x.as_syntax_node(),
            BinaryOperator::Neq(x) => x.as_syntax_node(),
            BinaryOperator::Eq(x) => x.as_syntax_node(),
            BinaryOperator::And(x) => x.as_syntax_node(),
            BinaryOperator::Or(x) => x.as_syntax_node(),
            BinaryOperator::LE(x) => x.as_syntax_node(),
            BinaryOperator::GE(x) => x.as_syntax_node(),
            BinaryOperator::LT(x) => x.as_syntax_node(),
            BinaryOperator::GT(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        BinaryOperatorPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprTuple {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprTuple {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        expressions: ExprListGreen,
        rparen: TerminalRParenGreen,
    ) -> ExprTupleGreen {
        let children: Vec<GreenId> = vec![lparen.0, expressions.0, rparen.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprTupleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprTuple,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprTuple {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expressions(&self, db: &dyn SyntaxGroup) -> ExprList {
        ExprList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprTuplePtr(pub SyntaxStablePtrId);
impl ExprTuplePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprTupleGreen(pub GreenId);
impl TypedSyntaxNode for ExprTuple {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprTuple);
    type StablePtr = ExprTuplePtr;
    type Green = ExprTupleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprTupleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprTuple,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLParen::missing(db).0,
                    ExprList::missing(db).0,
                    TerminalRParen::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprTuple,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprTuple
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprTuplePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprFunctionCall {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprFunctionCall {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        arguments: ExprListParenthesizedGreen,
    ) -> ExprFunctionCallGreen {
        let children: Vec<GreenId> = vec![path.0, arguments.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprFunctionCallGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprFunctionCall,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprFunctionCall {
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> ExprListParenthesized {
        ExprListParenthesized::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprFunctionCallPtr(pub SyntaxStablePtrId);
impl ExprFunctionCallPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprFunctionCallGreen(pub GreenId);
impl TypedSyntaxNode for ExprFunctionCall {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprFunctionCall);
    type StablePtr = ExprFunctionCallPtr;
    type Green = ExprFunctionCallGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprFunctionCallGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprFunctionCall,
            details: GreenNodeDetails::Node {
                children: vec![ExprPath::missing(db).0, ExprListParenthesized::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprFunctionCall,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprFunctionCall
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprFunctionCallPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprListParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprListParenthesized {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        expressions: ExprListGreen,
        rparen: TerminalRParenGreen,
    ) -> ExprListParenthesizedGreen {
        let children: Vec<GreenId> = vec![lparen.0, expressions.0, rparen.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprListParenthesizedGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprListParenthesized,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprListParenthesized {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expressions(&self, db: &dyn SyntaxGroup) -> ExprList {
        ExprList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListParenthesizedPtr(pub SyntaxStablePtrId);
impl ExprListParenthesizedPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListParenthesizedGreen(pub GreenId);
impl TypedSyntaxNode for ExprListParenthesized {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprListParenthesized);
    type StablePtr = ExprListParenthesizedPtr;
    type Green = ExprListParenthesizedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprListParenthesizedGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprListParenthesized,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLParen::missing(db).0,
                    ExprList::missing(db).0,
                    TerminalRParen::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprListParenthesized,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprListParenthesized
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprListParenthesizedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprStructCtorCall {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprStructCtorCall {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        arguments: ArgListBracedGreen,
    ) -> ExprStructCtorCallGreen {
        let children: Vec<GreenId> = vec![path.0, arguments.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprStructCtorCallGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprStructCtorCall,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprStructCtorCall {
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> ArgListBraced {
        ArgListBraced::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprStructCtorCallPtr(pub SyntaxStablePtrId);
impl ExprStructCtorCallPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprStructCtorCallGreen(pub GreenId);
impl TypedSyntaxNode for ExprStructCtorCall {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprStructCtorCall);
    type StablePtr = ExprStructCtorCallPtr;
    type Green = ExprStructCtorCallGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprStructCtorCallGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprStructCtorCall,
            details: GreenNodeDetails::Node {
                children: vec![ExprPath::missing(db).0, ArgListBraced::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprStructCtorCall,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprStructCtorCall
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprStructCtorCallPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBlock {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBlock {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        statements: StatementListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ExprBlockGreen {
        let children: Vec<GreenId> = vec![lbrace.0, statements.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprBlockGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprBlock,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprBlock {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn statements(&self, db: &dyn SyntaxGroup) -> StatementList {
        StatementList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBlockPtr(pub SyntaxStablePtrId);
impl ExprBlockPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBlockGreen(pub GreenId);
impl TypedSyntaxNode for ExprBlock {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprBlock);
    type StablePtr = ExprBlockPtr;
    type Green = ExprBlockGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprBlockGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprBlock,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLBrace::missing(db).0,
                    StatementList::missing(db).0,
                    TerminalRBrace::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprBlock,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprBlock
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprBlockPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprMatch {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprMatch {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        match_kw: TerminalMatchGreen,
        expr: ExprGreen,
        lbrace: TerminalLBraceGreen,
        arms: MatchArmsGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ExprMatchGreen {
        let children: Vec<GreenId> = vec![match_kw.0, expr.0, lbrace.0, arms.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprMatchGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprMatch,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprMatch {
    pub fn match_kw(&self, db: &dyn SyntaxGroup) -> TerminalMatch {
        TerminalMatch::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[2].clone())
    }
    pub fn arms(&self, db: &dyn SyntaxGroup) -> MatchArms {
        MatchArms::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMatchPtr(pub SyntaxStablePtrId);
impl ExprMatchPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMatchGreen(pub GreenId);
impl TypedSyntaxNode for ExprMatch {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprMatch);
    type StablePtr = ExprMatchPtr;
    type Green = ExprMatchGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprMatchGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprMatch,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalMatch::missing(db).0,
                    Expr::missing(db).0,
                    TerminalLBrace::missing(db).0,
                    MatchArms::missing(db).0,
                    TerminalRBrace::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprMatch,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprMatch
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprMatchPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MatchArms(ElementList<MatchArm, 2>);
impl Deref for MatchArms {
    type Target = ElementList<MatchArm, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl MatchArms {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<MatchArmsElementOrSeparatorGreen>,
    ) -> MatchArmsGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        MatchArmsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::MatchArms,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmsPtr(pub SyntaxStablePtrId);
impl MatchArmsPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum MatchArmsElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(MatchArmGreen),
}
impl From<TerminalCommaGreen> for MatchArmsElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        MatchArmsElementOrSeparatorGreen::Separator(value)
    }
}
impl From<MatchArmGreen> for MatchArmsElementOrSeparatorGreen {
    fn from(value: MatchArmGreen) -> Self {
        MatchArmsElementOrSeparatorGreen::Element(value)
    }
}
impl MatchArmsElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            MatchArmsElementOrSeparatorGreen::Separator(green) => green.0,
            MatchArmsElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmsGreen(pub GreenId);
impl TypedSyntaxNode for MatchArms {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MatchArms);
    type StablePtr = MatchArmsPtr;
    type Green = MatchArmsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        MatchArmsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::MatchArms,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MatchArmsPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MatchArm {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl MatchArm {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        pattern: PatternGreen,
        arrow: TerminalMatchArrowGreen,
        expression: ExprGreen,
    ) -> MatchArmGreen {
        let children: Vec<GreenId> = vec![pattern.0, arrow.0, expression.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        MatchArmGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::MatchArm,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl MatchArm {
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arrow(&self, db: &dyn SyntaxGroup) -> TerminalMatchArrow {
        TerminalMatchArrow::from_syntax_node(db, self.children[1].clone())
    }
    pub fn expression(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmPtr(pub SyntaxStablePtrId);
impl MatchArmPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmGreen(pub GreenId);
impl TypedSyntaxNode for MatchArm {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MatchArm);
    type StablePtr = MatchArmPtr;
    type Green = MatchArmGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        MatchArmGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::MatchArm,
            details: GreenNodeDetails::Node {
                children: vec![
                    Pattern::missing(db).0,
                    TerminalMatchArrow::missing(db).0,
                    Expr::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::MatchArm,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::MatchArm
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MatchArmPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprIf {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprIf {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        if_kw: TerminalIfGreen,
        condition: ExprGreen,
        if_block: ExprBlockGreen,
        else_clause: OptionElseClauseGreen,
    ) -> ExprIfGreen {
        let children: Vec<GreenId> = vec![if_kw.0, condition.0, if_block.0, else_clause.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprIfGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprIf,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprIf {
    pub fn if_kw(&self, db: &dyn SyntaxGroup) -> TerminalIf {
        TerminalIf::from_syntax_node(db, self.children[0].clone())
    }
    pub fn condition(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn if_block(&self, db: &dyn SyntaxGroup) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[2].clone())
    }
    pub fn else_clause(&self, db: &dyn SyntaxGroup) -> OptionElseClause {
        OptionElseClause::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprIfPtr(pub SyntaxStablePtrId);
impl ExprIfPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprIfGreen(pub GreenId);
impl TypedSyntaxNode for ExprIf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprIf);
    type StablePtr = ExprIfPtr;
    type Green = ExprIfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprIfGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprIf,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalIf::missing(db).0,
                    Expr::missing(db).0,
                    ExprBlock::missing(db).0,
                    OptionElseClause::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprIf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprIf
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprIfPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum BlockOrIf {
    Block(ExprBlock),
    If(ExprIf),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct BlockOrIfPtr(pub SyntaxStablePtrId);
impl BlockOrIfPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<ExprBlockPtr> for BlockOrIfPtr {
    fn from(value: ExprBlockPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprIfPtr> for BlockOrIfPtr {
    fn from(value: ExprIfPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprBlockGreen> for BlockOrIfGreen {
    fn from(value: ExprBlockGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprIfGreen> for BlockOrIfGreen {
    fn from(value: ExprIfGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct BlockOrIfGreen(pub GreenId);
impl TypedSyntaxNode for BlockOrIf {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = BlockOrIfPtr;
    type Green = BlockOrIfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprBlock => BlockOrIf::Block(ExprBlock::from_syntax_node(db, node)),
            SyntaxKind::ExprIf => BlockOrIf::If(ExprIf::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "BlockOrIf"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            BlockOrIf::Block(x) => x.as_syntax_node(),
            BlockOrIf::If(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        BlockOrIfPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ElseClause {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ElseClause {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        else_kw: TerminalElseGreen,
        else_block_or_if: BlockOrIfGreen,
    ) -> ElseClauseGreen {
        let children: Vec<GreenId> = vec![else_kw.0, else_block_or_if.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ElseClauseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ElseClause,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ElseClause {
    pub fn else_kw(&self, db: &dyn SyntaxGroup) -> TerminalElse {
        TerminalElse::from_syntax_node(db, self.children[0].clone())
    }
    pub fn else_block_or_if(&self, db: &dyn SyntaxGroup) -> BlockOrIf {
        BlockOrIf::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ElseClausePtr(pub SyntaxStablePtrId);
impl ElseClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ElseClauseGreen(pub GreenId);
impl TypedSyntaxNode for ElseClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ElseClause);
    type StablePtr = ElseClausePtr;
    type Green = ElseClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ElseClauseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ElseClause,
            details: GreenNodeDetails::Node {
                children: vec![TerminalElse::missing(db).0, BlockOrIf::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ElseClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ElseClause
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ElseClausePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionElseClause {
    Empty(OptionElseClauseEmpty),
    ElseClause(ElseClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionElseClausePtr(pub SyntaxStablePtrId);
impl OptionElseClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionElseClauseEmptyPtr> for OptionElseClausePtr {
    fn from(value: OptionElseClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<ElseClausePtr> for OptionElseClausePtr {
    fn from(value: ElseClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionElseClauseEmptyGreen> for OptionElseClauseGreen {
    fn from(value: OptionElseClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ElseClauseGreen> for OptionElseClauseGreen {
    fn from(value: ElseClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionElseClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionElseClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionElseClausePtr;
    type Green = OptionElseClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionElseClauseEmpty => {
                OptionElseClause::Empty(OptionElseClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::ElseClause => {
                OptionElseClause::ElseClause(ElseClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionElseClause"
            ),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionElseClause::Empty(x) => x.as_syntax_node(),
            OptionElseClause::ElseClause(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionElseClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionElseClauseEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionElseClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionElseClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionElseClauseEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionElseClauseEmpty,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl OptionElseClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionElseClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionElseClauseEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionElseClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionElseClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionElseClauseEmpty);
    type StablePtr = OptionElseClauseEmptyPtr;
    type Green = OptionElseClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionElseClauseEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionElseClauseEmpty,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionElseClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionElseClauseEmpty
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionElseClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprErrorPropagate {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprErrorPropagate {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        expr: ExprGreen,
        op: TerminalQuestionMarkGreen,
    ) -> ExprErrorPropagateGreen {
        let children: Vec<GreenId> = vec![expr.0, op.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ExprErrorPropagateGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprErrorPropagate,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ExprErrorPropagate {
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn op(&self, db: &dyn SyntaxGroup) -> TerminalQuestionMark {
        TerminalQuestionMark::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprErrorPropagatePtr(pub SyntaxStablePtrId);
impl ExprErrorPropagatePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprErrorPropagateGreen(pub GreenId);
impl TypedSyntaxNode for ExprErrorPropagate {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprErrorPropagate);
    type StablePtr = ExprErrorPropagatePtr;
    type Green = ExprErrorPropagateGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprErrorPropagateGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ExprErrorPropagate,
            details: GreenNodeDetails::Node {
                children: vec![Expr::missing(db).0, TerminalQuestionMark::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprErrorPropagate,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprErrorPropagate
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprErrorPropagatePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgExpr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgExpr {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        colon: TerminalColonGreen,
        expr: ExprGreen,
    ) -> StructArgExprGreen {
        let children: Vec<GreenId> = vec![colon.0, expr.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StructArgExprGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StructArgExpr,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl StructArgExpr {
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgExprPtr(pub SyntaxStablePtrId);
impl StructArgExprPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgExprGreen(pub GreenId);
impl TypedSyntaxNode for StructArgExpr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgExpr);
    type StablePtr = StructArgExprPtr;
    type Green = StructArgExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgExprGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StructArgExpr,
            details: GreenNodeDetails::Node {
                children: vec![TerminalColon::missing(db).0, Expr::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgExpr
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgExprPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionStructArgExpr {
    Empty(OptionStructArgExprEmpty),
    StructArgExpr(StructArgExpr),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprPtr(pub SyntaxStablePtrId);
impl OptionStructArgExprPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionStructArgExprEmptyPtr> for OptionStructArgExprPtr {
    fn from(value: OptionStructArgExprEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<StructArgExprPtr> for OptionStructArgExprPtr {
    fn from(value: StructArgExprPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionStructArgExprEmptyGreen> for OptionStructArgExprGreen {
    fn from(value: OptionStructArgExprEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<StructArgExprGreen> for OptionStructArgExprGreen {
    fn from(value: StructArgExprGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprGreen(pub GreenId);
impl TypedSyntaxNode for OptionStructArgExpr {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionStructArgExprPtr;
    type Green = OptionStructArgExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionStructArgExprEmpty => {
                OptionStructArgExpr::Empty(OptionStructArgExprEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::StructArgExpr => {
                OptionStructArgExpr::StructArgExpr(StructArgExpr::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionStructArgExpr"
            ),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionStructArgExpr::Empty(x) => x.as_syntax_node(),
            OptionStructArgExpr::StructArgExpr(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionStructArgExprPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionStructArgExprEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionStructArgExprEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionStructArgExprEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionStructArgExprEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionStructArgExprEmpty,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl OptionStructArgExprEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprEmptyPtr(pub SyntaxStablePtrId);
impl OptionStructArgExprEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionStructArgExprEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionStructArgExprEmpty);
    type StablePtr = OptionStructArgExprEmptyPtr;
    type Green = OptionStructArgExprEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionStructArgExprEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionStructArgExprEmpty,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionStructArgExprEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionStructArgExprEmpty
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionStructArgExprEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgSingle {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgSingle {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        identifier: TerminalIdentifierGreen,
        arg_expr: OptionStructArgExprGreen,
    ) -> StructArgSingleGreen {
        let children: Vec<GreenId> = vec![identifier.0, arg_expr.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StructArgSingleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StructArgSingle,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl StructArgSingle {
    pub fn identifier(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arg_expr(&self, db: &dyn SyntaxGroup) -> OptionStructArgExpr {
        OptionStructArgExpr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgSinglePtr(pub SyntaxStablePtrId);
impl StructArgSinglePtr {
    pub fn identifier_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgSingleGreen(pub GreenId);
impl TypedSyntaxNode for StructArgSingle {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgSingle);
    type StablePtr = StructArgSinglePtr;
    type Green = StructArgSingleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgSingleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StructArgSingle,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalIdentifier::missing(db).0,
                    OptionStructArgExpr::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgSingle,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgSingle
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgSinglePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgTail {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StructArgTail {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        dotdot: TerminalDotDotGreen,
        expression: ExprGreen,
    ) -> StructArgTailGreen {
        let children: Vec<GreenId> = vec![dotdot.0, expression.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StructArgTailGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StructArgTail,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl StructArgTail {
    pub fn dotdot(&self, db: &dyn SyntaxGroup) -> TerminalDotDot {
        TerminalDotDot::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expression(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgTailPtr(pub SyntaxStablePtrId);
impl StructArgTailPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgTailGreen(pub GreenId);
impl TypedSyntaxNode for StructArgTail {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgTail);
    type StablePtr = StructArgTailPtr;
    type Green = StructArgTailGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgTailGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StructArgTail,
            details: GreenNodeDetails::Node {
                children: vec![TerminalDotDot::missing(db).0, Expr::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgTail,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgTail
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgTailPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum StructArg {
    StructArgSingle(StructArgSingle),
    StructArgTail(StructArgTail),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgPtr(pub SyntaxStablePtrId);
impl StructArgPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<StructArgSinglePtr> for StructArgPtr {
    fn from(value: StructArgSinglePtr) -> Self {
        Self(value.0)
    }
}
impl From<StructArgTailPtr> for StructArgPtr {
    fn from(value: StructArgTailPtr) -> Self {
        Self(value.0)
    }
}
impl From<StructArgSingleGreen> for StructArgGreen {
    fn from(value: StructArgSingleGreen) -> Self {
        Self(value.0)
    }
}
impl From<StructArgTailGreen> for StructArgGreen {
    fn from(value: StructArgTailGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgGreen(pub GreenId);
impl TypedSyntaxNode for StructArg {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = StructArgPtr;
    type Green = StructArgGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::StructArgSingle => {
                StructArg::StructArgSingle(StructArgSingle::from_syntax_node(db, node))
            }
            SyntaxKind::StructArgTail => {
                StructArg::StructArgTail(StructArgTail::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "StructArg"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            StructArg::StructArgSingle(x) => x.as_syntax_node(),
            StructArg::StructArgTail(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgList(ElementList<StructArg, 2>);
impl Deref for StructArgList {
    type Target = ElementList<StructArg, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StructArgList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<StructArgListElementOrSeparatorGreen>,
    ) -> StructArgListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        StructArgListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StructArgList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgListPtr(pub SyntaxStablePtrId);
impl StructArgListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum StructArgListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(StructArgGreen),
}
impl From<TerminalCommaGreen> for StructArgListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        StructArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<StructArgGreen> for StructArgListElementOrSeparatorGreen {
    fn from(value: StructArgGreen) -> Self {
        StructArgListElementOrSeparatorGreen::Element(value)
    }
}
impl StructArgListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            StructArgListElementOrSeparatorGreen::Separator(green) => green.0,
            StructArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgListGreen(pub GreenId);
impl TypedSyntaxNode for StructArgList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgList);
    type StablePtr = StructArgListPtr;
    type Green = StructArgListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StructArgList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgListBraced {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ArgListBraced {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        arguments: StructArgListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ArgListBracedGreen {
        let children: Vec<GreenId> = vec![lbrace.0, arguments.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ArgListBracedGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ArgListBraced,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ArgListBraced {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> StructArgList {
        StructArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListBracedPtr(pub SyntaxStablePtrId);
impl ArgListBracedPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListBracedGreen(pub GreenId);
impl TypedSyntaxNode for ArgListBraced {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgListBraced);
    type StablePtr = ArgListBracedPtr;
    type Green = ArgListBracedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ArgListBracedGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ArgListBraced,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLBrace::missing(db).0,
                    StructArgList::missing(db).0,
                    TerminalRBrace::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgListBraced,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgListBraced
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgListBracedPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Pattern {
    Underscore(TerminalUnderscore),
    Literal(TerminalLiteralNumber),
    ShortString(TerminalShortString),
    Identifier(PatternIdentifier),
    Struct(PatternStruct),
    Tuple(PatternTuple),
    Enum(PatternEnum),
    Path(ExprPath),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternPtr(pub SyntaxStablePtrId);
impl PatternPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TerminalUnderscorePtr> for PatternPtr {
    fn from(value: TerminalUnderscorePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLiteralNumberPtr> for PatternPtr {
    fn from(value: TerminalLiteralNumberPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalShortStringPtr> for PatternPtr {
    fn from(value: TerminalShortStringPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternIdentifierPtr> for PatternPtr {
    fn from(value: PatternIdentifierPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternStructPtr> for PatternPtr {
    fn from(value: PatternStructPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternTuplePtr> for PatternPtr {
    fn from(value: PatternTuplePtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternEnumPtr> for PatternPtr {
    fn from(value: PatternEnumPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprPathPtr> for PatternPtr {
    fn from(value: ExprPathPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalUnderscoreGreen> for PatternGreen {
    fn from(value: TerminalUnderscoreGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLiteralNumberGreen> for PatternGreen {
    fn from(value: TerminalLiteralNumberGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalShortStringGreen> for PatternGreen {
    fn from(value: TerminalShortStringGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternIdentifierGreen> for PatternGreen {
    fn from(value: PatternIdentifierGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternStructGreen> for PatternGreen {
    fn from(value: PatternStructGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternTupleGreen> for PatternGreen {
    fn from(value: PatternTupleGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternEnumGreen> for PatternGreen {
    fn from(value: PatternEnumGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprPathGreen> for PatternGreen {
    fn from(value: ExprPathGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternGreen(pub GreenId);
impl TypedSyntaxNode for Pattern {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = PatternPtr;
    type Green = PatternGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalUnderscore => {
                Pattern::Underscore(TerminalUnderscore::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLiteralNumber => {
                Pattern::Literal(TerminalLiteralNumber::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalShortString => {
                Pattern::ShortString(TerminalShortString::from_syntax_node(db, node))
            }
            SyntaxKind::PatternIdentifier => {
                Pattern::Identifier(PatternIdentifier::from_syntax_node(db, node))
            }
            SyntaxKind::PatternStruct => Pattern::Struct(PatternStruct::from_syntax_node(db, node)),
            SyntaxKind::PatternTuple => Pattern::Tuple(PatternTuple::from_syntax_node(db, node)),
            SyntaxKind::PatternEnum => Pattern::Enum(PatternEnum::from_syntax_node(db, node)),
            SyntaxKind::ExprPath => Pattern::Path(ExprPath::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Pattern"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Pattern::Underscore(x) => x.as_syntax_node(),
            Pattern::Literal(x) => x.as_syntax_node(),
            Pattern::ShortString(x) => x.as_syntax_node(),
            Pattern::Identifier(x) => x.as_syntax_node(),
            Pattern::Struct(x) => x.as_syntax_node(),
            Pattern::Tuple(x) => x.as_syntax_node(),
            Pattern::Enum(x) => x.as_syntax_node(),
            Pattern::Path(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternIdentifier {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PatternIdentifier {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        modifiers: ModifierListGreen,
        name: TerminalIdentifierGreen,
    ) -> PatternIdentifierGreen {
        let children: Vec<GreenId> = vec![modifiers.0, name.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        PatternIdentifierGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternIdentifier,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl PatternIdentifier {
    pub fn modifiers(&self, db: &dyn SyntaxGroup) -> ModifierList {
        ModifierList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternIdentifierPtr(pub SyntaxStablePtrId);
impl PatternIdentifierPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternIdentifierGreen(pub GreenId);
impl TypedSyntaxNode for PatternIdentifier {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternIdentifier);
    type StablePtr = PatternIdentifierPtr;
    type Green = PatternIdentifierGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternIdentifierGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternIdentifier,
            details: GreenNodeDetails::Node {
                children: vec![ModifierList::missing(db).0, TerminalIdentifier::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternIdentifier,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternIdentifier
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternIdentifierPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternStruct {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PatternStruct {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        lbrace: TerminalLBraceGreen,
        params: PatternStructParamListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> PatternStructGreen {
        let children: Vec<GreenId> = vec![path.0, lbrace.0, params.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        PatternStructGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternStruct,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl PatternStruct {
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[1].clone())
    }
    pub fn params(&self, db: &dyn SyntaxGroup) -> PatternStructParamList {
        PatternStructParamList::from_syntax_node(db, self.children[2].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructPtr(pub SyntaxStablePtrId);
impl PatternStructPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructGreen(pub GreenId);
impl TypedSyntaxNode for PatternStruct {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternStruct);
    type StablePtr = PatternStructPtr;
    type Green = PatternStructGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternStructGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternStruct,
            details: GreenNodeDetails::Node {
                children: vec![
                    ExprPath::missing(db).0,
                    TerminalLBrace::missing(db).0,
                    PatternStructParamList::missing(db).0,
                    TerminalRBrace::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternStruct,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternStruct
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternStructPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternStructParamList(ElementList<PatternStructParam, 2>);
impl Deref for PatternStructParamList {
    type Target = ElementList<PatternStructParam, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl PatternStructParamList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<PatternStructParamListElementOrSeparatorGreen>,
    ) -> PatternStructParamListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        PatternStructParamListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternStructParamList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamListPtr(pub SyntaxStablePtrId);
impl PatternStructParamListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum PatternStructParamListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(PatternStructParamGreen),
}
impl From<TerminalCommaGreen> for PatternStructParamListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        PatternStructParamListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<PatternStructParamGreen> for PatternStructParamListElementOrSeparatorGreen {
    fn from(value: PatternStructParamGreen) -> Self {
        PatternStructParamListElementOrSeparatorGreen::Element(value)
    }
}
impl PatternStructParamListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            PatternStructParamListElementOrSeparatorGreen::Separator(green) => green.0,
            PatternStructParamListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamListGreen(pub GreenId);
impl TypedSyntaxNode for PatternStructParamList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternStructParamList);
    type StablePtr = PatternStructParamListPtr;
    type Green = PatternStructParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternStructParamListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternStructParamList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternStructParamListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternTuple {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PatternTuple {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        patterns: PatternListGreen,
        rparen: TerminalRParenGreen,
    ) -> PatternTupleGreen {
        let children: Vec<GreenId> = vec![lparen.0, patterns.0, rparen.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        PatternTupleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternTuple,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl PatternTuple {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn patterns(&self, db: &dyn SyntaxGroup) -> PatternList {
        PatternList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternTuplePtr(pub SyntaxStablePtrId);
impl PatternTuplePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternTupleGreen(pub GreenId);
impl TypedSyntaxNode for PatternTuple {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternTuple);
    type StablePtr = PatternTuplePtr;
    type Green = PatternTupleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternTupleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternTuple,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLParen::missing(db).0,
                    PatternList::missing(db).0,
                    TerminalRParen::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternTuple,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternTuple
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternTuplePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternList(ElementList<Pattern, 2>);
impl Deref for PatternList {
    type Target = ElementList<Pattern, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl PatternList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<PatternListElementOrSeparatorGreen>,
    ) -> PatternListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        PatternListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternListPtr(pub SyntaxStablePtrId);
impl PatternListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum PatternListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(PatternGreen),
}
impl From<TerminalCommaGreen> for PatternListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        PatternListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<PatternGreen> for PatternListElementOrSeparatorGreen {
    fn from(value: PatternGreen) -> Self {
        PatternListElementOrSeparatorGreen::Element(value)
    }
}
impl PatternListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            PatternListElementOrSeparatorGreen::Separator(green) => green.0,
            PatternListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternListGreen(pub GreenId);
impl TypedSyntaxNode for PatternList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternList);
    type StablePtr = PatternListPtr;
    type Green = PatternListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum PatternStructParam {
    Single(TerminalIdentifier),
    WithExpr(PatternStructParamWithExpr),
    Tail(TerminalDotDot),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamPtr(pub SyntaxStablePtrId);
impl PatternStructParamPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TerminalIdentifierPtr> for PatternStructParamPtr {
    fn from(value: TerminalIdentifierPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternStructParamWithExprPtr> for PatternStructParamPtr {
    fn from(value: PatternStructParamWithExprPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotPtr> for PatternStructParamPtr {
    fn from(value: TerminalDotDotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalIdentifierGreen> for PatternStructParamGreen {
    fn from(value: TerminalIdentifierGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternStructParamWithExprGreen> for PatternStructParamGreen {
    fn from(value: PatternStructParamWithExprGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotGreen> for PatternStructParamGreen {
    fn from(value: TerminalDotDotGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamGreen(pub GreenId);
impl TypedSyntaxNode for PatternStructParam {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = PatternStructParamPtr;
    type Green = PatternStructParamGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalIdentifier => {
                PatternStructParam::Single(TerminalIdentifier::from_syntax_node(db, node))
            }
            SyntaxKind::PatternStructParamWithExpr => {
                PatternStructParam::WithExpr(PatternStructParamWithExpr::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDotDot => {
                PatternStructParam::Tail(TerminalDotDot::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "PatternStructParam"
            ),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            PatternStructParam::Single(x) => x.as_syntax_node(),
            PatternStructParam::WithExpr(x) => x.as_syntax_node(),
            PatternStructParam::Tail(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternStructParamPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternStructParamWithExpr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PatternStructParamWithExpr {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        name: TerminalIdentifierGreen,
        colon: TerminalColonGreen,
        pattern: PatternGreen,
    ) -> PatternStructParamWithExprGreen {
        let children: Vec<GreenId> = vec![name.0, colon.0, pattern.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        PatternStructParamWithExprGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternStructParamWithExpr,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl PatternStructParamWithExpr {
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamWithExprPtr(pub SyntaxStablePtrId);
impl PatternStructParamWithExprPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamWithExprGreen(pub GreenId);
impl TypedSyntaxNode for PatternStructParamWithExpr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternStructParamWithExpr);
    type StablePtr = PatternStructParamWithExprPtr;
    type Green = PatternStructParamWithExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternStructParamWithExprGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternStructParamWithExpr,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalIdentifier::missing(db).0,
                    TerminalColon::missing(db).0,
                    Pattern::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternStructParamWithExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternStructParamWithExpr
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternStructParamWithExprPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternEnum {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PatternEnum {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        lparen: TerminalLParenGreen,
        pattern: PatternGreen,
        rparen: TerminalRParenGreen,
    ) -> PatternEnumGreen {
        let children: Vec<GreenId> = vec![path.0, lparen.0, pattern.0, rparen.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        PatternEnumGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternEnum,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl PatternEnum {
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[1].clone())
    }
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.children[2].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternEnumPtr(pub SyntaxStablePtrId);
impl PatternEnumPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternEnumGreen(pub GreenId);
impl TypedSyntaxNode for PatternEnum {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternEnum);
    type StablePtr = PatternEnumPtr;
    type Green = PatternEnumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternEnumGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::PatternEnum,
            details: GreenNodeDetails::Node {
                children: vec![
                    ExprPath::missing(db).0,
                    TerminalLParen::missing(db).0,
                    Pattern::missing(db).0,
                    TerminalRParen::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternEnum,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternEnum
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternEnumPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TypeClause {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TypeClause {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        colon: TerminalColonGreen,
        ty: ExprGreen,
    ) -> TypeClauseGreen {
        let children: Vec<GreenId> = vec![colon.0, ty.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TypeClauseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TypeClause,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl TypeClause {
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ty(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TypeClausePtr(pub SyntaxStablePtrId);
impl TypeClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for TypeClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TypeClause);
    type StablePtr = TypeClausePtr;
    type Green = TypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TypeClauseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TypeClause,
            details: GreenNodeDetails::Node {
                children: vec![TerminalColon::missing(db).0, Expr::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TypeClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TypeClause
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TypeClausePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTypeClause {
    Empty(OptionTypeClauseEmpty),
    TypeClause(TypeClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClausePtr(pub SyntaxStablePtrId);
impl OptionTypeClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionTypeClauseEmptyPtr> for OptionTypeClausePtr {
    fn from(value: OptionTypeClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TypeClausePtr> for OptionTypeClausePtr {
    fn from(value: TypeClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionTypeClauseEmptyGreen> for OptionTypeClauseGreen {
    fn from(value: OptionTypeClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TypeClauseGreen> for OptionTypeClauseGreen {
    fn from(value: TypeClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionTypeClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTypeClausePtr;
    type Green = OptionTypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTypeClauseEmpty => {
                OptionTypeClause::Empty(OptionTypeClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::TypeClause => {
                OptionTypeClause::TypeClause(TypeClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTypeClause"
            ),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTypeClause::Empty(x) => x.as_syntax_node(),
            OptionTypeClause::TypeClause(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTypeClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTypeClauseEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionTypeClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionTypeClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionTypeClauseEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionTypeClauseEmpty,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl OptionTypeClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionTypeClauseEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionTypeClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTypeClauseEmpty);
    type StablePtr = OptionTypeClauseEmptyPtr;
    type Green = OptionTypeClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionTypeClauseEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionTypeClauseEmpty,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTypeClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTypeClauseEmpty
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTypeClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ReturnTypeClause {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ReturnTypeClause {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        arrow: TerminalArrowGreen,
        ty: ExprGreen,
    ) -> ReturnTypeClauseGreen {
        let children: Vec<GreenId> = vec![arrow.0, ty.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ReturnTypeClauseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ReturnTypeClause,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ReturnTypeClause {
    pub fn arrow(&self, db: &dyn SyntaxGroup) -> TerminalArrow {
        TerminalArrow::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ty(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ReturnTypeClausePtr(pub SyntaxStablePtrId);
impl ReturnTypeClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ReturnTypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for ReturnTypeClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ReturnTypeClause);
    type StablePtr = ReturnTypeClausePtr;
    type Green = ReturnTypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ReturnTypeClauseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ReturnTypeClause,
            details: GreenNodeDetails::Node {
                children: vec![TerminalArrow::missing(db).0, Expr::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ReturnTypeClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ReturnTypeClause
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ReturnTypeClausePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionReturnTypeClause {
    Empty(OptionReturnTypeClauseEmpty),
    ReturnTypeClause(ReturnTypeClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClausePtr(pub SyntaxStablePtrId);
impl OptionReturnTypeClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionReturnTypeClauseEmptyPtr> for OptionReturnTypeClausePtr {
    fn from(value: OptionReturnTypeClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<ReturnTypeClausePtr> for OptionReturnTypeClausePtr {
    fn from(value: ReturnTypeClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionReturnTypeClauseEmptyGreen> for OptionReturnTypeClauseGreen {
    fn from(value: OptionReturnTypeClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ReturnTypeClauseGreen> for OptionReturnTypeClauseGreen {
    fn from(value: ReturnTypeClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionReturnTypeClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionReturnTypeClausePtr;
    type Green = OptionReturnTypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionReturnTypeClauseEmpty => OptionReturnTypeClause::Empty(
                OptionReturnTypeClauseEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::ReturnTypeClause => OptionReturnTypeClause::ReturnTypeClause(
                ReturnTypeClause::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionReturnTypeClause"
            ),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionReturnTypeClause::Empty(x) => x.as_syntax_node(),
            OptionReturnTypeClause::ReturnTypeClause(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionReturnTypeClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionReturnTypeClauseEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionReturnTypeClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionReturnTypeClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionReturnTypeClauseEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionReturnTypeClauseEmpty,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl OptionReturnTypeClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionReturnTypeClauseEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionReturnTypeClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionReturnTypeClauseEmpty);
    type StablePtr = OptionReturnTypeClauseEmptyPtr;
    type Green = OptionReturnTypeClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionReturnTypeClauseEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionReturnTypeClauseEmpty,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionReturnTypeClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionReturnTypeClauseEmpty
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionReturnTypeClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Statement {
    Let(StatementLet),
    Expr(StatementExpr),
    Return(StatementReturn),
    Missing(StatementMissing),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementPtr(pub SyntaxStablePtrId);
impl StatementPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<StatementLetPtr> for StatementPtr {
    fn from(value: StatementLetPtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementExprPtr> for StatementPtr {
    fn from(value: StatementExprPtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementReturnPtr> for StatementPtr {
    fn from(value: StatementReturnPtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementMissingPtr> for StatementPtr {
    fn from(value: StatementMissingPtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementLetGreen> for StatementGreen {
    fn from(value: StatementLetGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementExprGreen> for StatementGreen {
    fn from(value: StatementExprGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementReturnGreen> for StatementGreen {
    fn from(value: StatementReturnGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementMissingGreen> for StatementGreen {
    fn from(value: StatementMissingGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementGreen(pub GreenId);
impl TypedSyntaxNode for Statement {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = StatementPtr;
    type Green = StatementGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementGreen(StatementMissing::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::StatementLet => Statement::Let(StatementLet::from_syntax_node(db, node)),
            SyntaxKind::StatementExpr => Statement::Expr(StatementExpr::from_syntax_node(db, node)),
            SyntaxKind::StatementReturn => {
                Statement::Return(StatementReturn::from_syntax_node(db, node))
            }
            SyntaxKind::StatementMissing => {
                Statement::Missing(StatementMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Statement"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Statement::Let(x) => x.as_syntax_node(),
            Statement::Expr(x) => x.as_syntax_node(),
            Statement::Return(x) => x.as_syntax_node(),
            Statement::Missing(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementList(ElementList<Statement, 1>);
impl Deref for StatementList {
    type Target = ElementList<Statement, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StatementList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<StatementGreen>) -> StatementListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.0).width()).sum();
        StatementListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StatementList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.0).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementListPtr(pub SyntaxStablePtrId);
impl StatementListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementListGreen(pub GreenId);
impl TypedSyntaxNode for StatementList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementList);
    type StablePtr = StatementListPtr;
    type Green = StatementListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StatementList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> StatementMissingGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StatementMissingGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StatementMissing,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl StatementMissing {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementMissingPtr(pub SyntaxStablePtrId);
impl StatementMissingPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementMissingGreen(pub GreenId);
impl TypedSyntaxNode for StatementMissing {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementMissing);
    type StablePtr = StatementMissingPtr;
    type Green = StatementMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementMissingGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StatementMissing,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementMissing
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementMissingPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementLet {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementLet {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        let_kw: TerminalLetGreen,
        pattern: PatternGreen,
        type_clause: OptionTypeClauseGreen,
        eq: TerminalEqGreen,
        rhs: ExprGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> StatementLetGreen {
        let children: Vec<GreenId> =
            vec![let_kw.0, pattern.0, type_clause.0, eq.0, rhs.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StatementLetGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StatementLet,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl StatementLet {
    pub fn let_kw(&self, db: &dyn SyntaxGroup) -> TerminalLet {
        TerminalLet::from_syntax_node(db, self.children[0].clone())
    }
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.children[1].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> OptionTypeClause {
        OptionTypeClause::from_syntax_node(db, self.children[2].clone())
    }
    pub fn eq(&self, db: &dyn SyntaxGroup) -> TerminalEq {
        TerminalEq::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[4].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementLetPtr(pub SyntaxStablePtrId);
impl StatementLetPtr {
    pub fn pattern_green(self, db: &dyn SyntaxGroup) -> PatternGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            PatternGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementLetGreen(pub GreenId);
impl TypedSyntaxNode for StatementLet {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementLet);
    type StablePtr = StatementLetPtr;
    type Green = StatementLetGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementLetGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StatementLet,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLet::missing(db).0,
                    Pattern::missing(db).0,
                    OptionTypeClause::missing(db).0,
                    TerminalEq::missing(db).0,
                    Expr::missing(db).0,
                    TerminalSemicolon::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementLet,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementLet
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementLetPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTerminalSemicolon {
    Empty(OptionTerminalSemicolonEmpty),
    TerminalSemicolon(TerminalSemicolon),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalSemicolonPtr(pub SyntaxStablePtrId);
impl OptionTerminalSemicolonPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionTerminalSemicolonEmptyPtr> for OptionTerminalSemicolonPtr {
    fn from(value: OptionTerminalSemicolonEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonPtr> for OptionTerminalSemicolonPtr {
    fn from(value: TerminalSemicolonPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionTerminalSemicolonEmptyGreen> for OptionTerminalSemicolonGreen {
    fn from(value: OptionTerminalSemicolonEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonGreen> for OptionTerminalSemicolonGreen {
    fn from(value: TerminalSemicolonGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalSemicolonGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalSemicolon {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalSemicolonPtr;
    type Green = OptionTerminalSemicolonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalSemicolonEmpty => OptionTerminalSemicolon::Empty(
                OptionTerminalSemicolonEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::TerminalSemicolon => OptionTerminalSemicolon::TerminalSemicolon(
                TerminalSemicolon::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalSemicolon"
            ),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTerminalSemicolon::Empty(x) => x.as_syntax_node(),
            OptionTerminalSemicolon::TerminalSemicolon(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalSemicolonPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTerminalSemicolonEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionTerminalSemicolonEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionTerminalSemicolonEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionTerminalSemicolonEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionTerminalSemicolonEmpty,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl OptionTerminalSemicolonEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalSemicolonEmptyPtr(pub SyntaxStablePtrId);
impl OptionTerminalSemicolonEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalSemicolonEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalSemicolonEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalSemicolonEmpty);
    type StablePtr = OptionTerminalSemicolonEmptyPtr;
    type Green = OptionTerminalSemicolonEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionTerminalSemicolonEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionTerminalSemicolonEmpty,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalSemicolonEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalSemicolonEmpty
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalSemicolonEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementExpr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementExpr {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        expr: ExprGreen,
        semicolon: OptionTerminalSemicolonGreen,
    ) -> StatementExprGreen {
        let children: Vec<GreenId> = vec![expr.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StatementExprGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StatementExpr,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl StatementExpr {
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> OptionTerminalSemicolon {
        OptionTerminalSemicolon::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementExprPtr(pub SyntaxStablePtrId);
impl StatementExprPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementExprGreen(pub GreenId);
impl TypedSyntaxNode for StatementExpr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementExpr);
    type StablePtr = StatementExprPtr;
    type Green = StatementExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementExprGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StatementExpr,
            details: GreenNodeDetails::Node {
                children: vec![Expr::missing(db).0, OptionTerminalSemicolon::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementExpr
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementExprPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementReturn {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl StatementReturn {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        return_kw: TerminalReturnGreen,
        expr: ExprGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> StatementReturnGreen {
        let children: Vec<GreenId> = vec![return_kw.0, expr.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        StatementReturnGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StatementReturn,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl StatementReturn {
    pub fn return_kw(&self, db: &dyn SyntaxGroup) -> TerminalReturn {
        TerminalReturn::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementReturnPtr(pub SyntaxStablePtrId);
impl StatementReturnPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementReturnGreen(pub GreenId);
impl TypedSyntaxNode for StatementReturn {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementReturn);
    type StablePtr = StatementReturnPtr;
    type Green = StatementReturnGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementReturnGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::StatementReturn,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalReturn::missing(db).0,
                    Expr::missing(db).0,
                    TerminalSemicolon::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementReturn,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementReturn
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementReturnPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum ParamName {
    Underscore(TerminalUnderscore),
    Name(TerminalIdentifier),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamNamePtr(pub SyntaxStablePtrId);
impl ParamNamePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TerminalUnderscorePtr> for ParamNamePtr {
    fn from(value: TerminalUnderscorePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalIdentifierPtr> for ParamNamePtr {
    fn from(value: TerminalIdentifierPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalUnderscoreGreen> for ParamNameGreen {
    fn from(value: TerminalUnderscoreGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalIdentifierGreen> for ParamNameGreen {
    fn from(value: TerminalIdentifierGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamNameGreen(pub GreenId);
impl TypedSyntaxNode for ParamName {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ParamNamePtr;
    type Green = ParamNameGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalUnderscore => {
                ParamName::Underscore(TerminalUnderscore::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalIdentifier => {
                ParamName::Name(TerminalIdentifier::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "ParamName"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            ParamName::Underscore(x) => x.as_syntax_node(),
            ParamName::Name(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamNamePtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Param {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Param {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        modifiers: ModifierListGreen,
        name: ParamNameGreen,
        type_clause: TypeClauseGreen,
    ) -> ParamGreen {
        let children: Vec<GreenId> = vec![modifiers.0, name.0, type_clause.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ParamGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::Param,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl Param {
    pub fn modifiers(&self, db: &dyn SyntaxGroup) -> ModifierList {
        ModifierList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> ParamName {
        ParamName::from_syntax_node(db, self.children[1].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> TypeClause {
        TypeClause::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamPtr(pub SyntaxStablePtrId);
impl ParamPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> ParamNameGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            ParamNameGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamGreen(pub GreenId);
impl TypedSyntaxNode for Param {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Param);
    type StablePtr = ParamPtr;
    type Green = ParamGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ParamGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::Param,
            details: GreenNodeDetails::Node {
                children: vec![
                    ModifierList::missing(db).0,
                    ParamName::missing(db).0,
                    TypeClause::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Param,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Param
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ModifierList(ElementList<Modifier, 1>);
impl Deref for ModifierList {
    type Target = ElementList<Modifier, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ModifierList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<ModifierGreen>) -> ModifierListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.0).width()).sum();
        ModifierListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ModifierList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.0).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModifierListPtr(pub SyntaxStablePtrId);
impl ModifierListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModifierListGreen(pub GreenId);
impl TypedSyntaxNode for ModifierList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ModifierList);
    type StablePtr = ModifierListPtr;
    type Green = ModifierListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ModifierListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ModifierList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ModifierListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Modifier {
    Ref(TerminalRef),
    Mut(TerminalMut),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModifierPtr(pub SyntaxStablePtrId);
impl ModifierPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TerminalRefPtr> for ModifierPtr {
    fn from(value: TerminalRefPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMutPtr> for ModifierPtr {
    fn from(value: TerminalMutPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalRefGreen> for ModifierGreen {
    fn from(value: TerminalRefGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMutGreen> for ModifierGreen {
    fn from(value: TerminalMutGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModifierGreen(pub GreenId);
impl TypedSyntaxNode for Modifier {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ModifierPtr;
    type Green = ModifierGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalRef => Modifier::Ref(TerminalRef::from_syntax_node(db, node)),
            SyntaxKind::TerminalMut => Modifier::Mut(TerminalMut::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Modifier"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Modifier::Ref(x) => x.as_syntax_node(),
            Modifier::Mut(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ModifierPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamList(ElementList<Param, 2>);
impl Deref for ParamList {
    type Target = ElementList<Param, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ParamList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ParamListElementOrSeparatorGreen>,
    ) -> ParamListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        ParamListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ParamList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamListPtr(pub SyntaxStablePtrId);
impl ParamListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ParamListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(ParamGreen),
}
impl From<TerminalCommaGreen> for ParamListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        ParamListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ParamGreen> for ParamListElementOrSeparatorGreen {
    fn from(value: ParamGreen) -> Self {
        ParamListElementOrSeparatorGreen::Element(value)
    }
}
impl ParamListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ParamListElementOrSeparatorGreen::Separator(green) => green.0,
            ParamListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamListGreen(pub GreenId);
impl TypedSyntaxNode for ParamList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ParamList);
    type StablePtr = ParamListPtr;
    type Green = ParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ParamListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ParamList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ImplicitsClause {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ImplicitsClause {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        implicits_kw: TerminalImplicitsGreen,
        lparen: TerminalLParenGreen,
        implicits: ImplicitsListGreen,
        rparen: TerminalRParenGreen,
    ) -> ImplicitsClauseGreen {
        let children: Vec<GreenId> = vec![implicits_kw.0, lparen.0, implicits.0, rparen.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ImplicitsClauseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ImplicitsClause,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ImplicitsClause {
    pub fn implicits_kw(&self, db: &dyn SyntaxGroup) -> TerminalImplicits {
        TerminalImplicits::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[1].clone())
    }
    pub fn implicits(&self, db: &dyn SyntaxGroup) -> ImplicitsList {
        ImplicitsList::from_syntax_node(db, self.children[2].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplicitsClausePtr(pub SyntaxStablePtrId);
impl ImplicitsClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplicitsClauseGreen(pub GreenId);
impl TypedSyntaxNode for ImplicitsClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplicitsClause);
    type StablePtr = ImplicitsClausePtr;
    type Green = ImplicitsClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ImplicitsClauseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ImplicitsClause,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalImplicits::missing(db).0,
                    TerminalLParen::missing(db).0,
                    ImplicitsList::missing(db).0,
                    TerminalRParen::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ImplicitsClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ImplicitsClause
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ImplicitsClausePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ImplicitsList(ElementList<ExprPath, 2>);
impl Deref for ImplicitsList {
    type Target = ElementList<ExprPath, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ImplicitsList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ImplicitsListElementOrSeparatorGreen>,
    ) -> ImplicitsListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        ImplicitsListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ImplicitsList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplicitsListPtr(pub SyntaxStablePtrId);
impl ImplicitsListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ImplicitsListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(ExprPathGreen),
}
impl From<TerminalCommaGreen> for ImplicitsListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        ImplicitsListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ExprPathGreen> for ImplicitsListElementOrSeparatorGreen {
    fn from(value: ExprPathGreen) -> Self {
        ImplicitsListElementOrSeparatorGreen::Element(value)
    }
}
impl ImplicitsListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ImplicitsListElementOrSeparatorGreen::Separator(green) => green.0,
            ImplicitsListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplicitsListGreen(pub GreenId);
impl TypedSyntaxNode for ImplicitsList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplicitsList);
    type StablePtr = ImplicitsListPtr;
    type Green = ImplicitsListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ImplicitsListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ImplicitsList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ImplicitsListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionImplicitsClause {
    Empty(OptionImplicitsClauseEmpty),
    ImplicitsClause(ImplicitsClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionImplicitsClausePtr(pub SyntaxStablePtrId);
impl OptionImplicitsClausePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionImplicitsClauseEmptyPtr> for OptionImplicitsClausePtr {
    fn from(value: OptionImplicitsClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<ImplicitsClausePtr> for OptionImplicitsClausePtr {
    fn from(value: ImplicitsClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionImplicitsClauseEmptyGreen> for OptionImplicitsClauseGreen {
    fn from(value: OptionImplicitsClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ImplicitsClauseGreen> for OptionImplicitsClauseGreen {
    fn from(value: ImplicitsClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionImplicitsClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionImplicitsClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionImplicitsClausePtr;
    type Green = OptionImplicitsClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionImplicitsClauseEmpty => {
                OptionImplicitsClause::Empty(OptionImplicitsClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::ImplicitsClause => {
                OptionImplicitsClause::ImplicitsClause(ImplicitsClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionImplicitsClause"
            ),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionImplicitsClause::Empty(x) => x.as_syntax_node(),
            OptionImplicitsClause::ImplicitsClause(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionImplicitsClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionImplicitsClauseEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionImplicitsClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionImplicitsClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionImplicitsClauseEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionImplicitsClauseEmpty,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl OptionImplicitsClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionImplicitsClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionImplicitsClauseEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionImplicitsClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionImplicitsClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionImplicitsClauseEmpty);
    type StablePtr = OptionImplicitsClauseEmptyPtr;
    type Green = OptionImplicitsClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionImplicitsClauseEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionImplicitsClauseEmpty,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionImplicitsClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionImplicitsClauseEmpty
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionImplicitsClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTerminalNoPanic {
    Empty(OptionTerminalNoPanicEmpty),
    TerminalNoPanic(TerminalNoPanic),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalNoPanicPtr(pub SyntaxStablePtrId);
impl OptionTerminalNoPanicPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionTerminalNoPanicEmptyPtr> for OptionTerminalNoPanicPtr {
    fn from(value: OptionTerminalNoPanicEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNoPanicPtr> for OptionTerminalNoPanicPtr {
    fn from(value: TerminalNoPanicPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionTerminalNoPanicEmptyGreen> for OptionTerminalNoPanicGreen {
    fn from(value: OptionTerminalNoPanicEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNoPanicGreen> for OptionTerminalNoPanicGreen {
    fn from(value: TerminalNoPanicGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalNoPanicGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalNoPanic {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalNoPanicPtr;
    type Green = OptionTerminalNoPanicGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalNoPanicEmpty => {
                OptionTerminalNoPanic::Empty(OptionTerminalNoPanicEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNoPanic => {
                OptionTerminalNoPanic::TerminalNoPanic(TerminalNoPanic::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalNoPanic"
            ),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTerminalNoPanic::Empty(x) => x.as_syntax_node(),
            OptionTerminalNoPanic::TerminalNoPanic(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalNoPanicPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTerminalNoPanicEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionTerminalNoPanicEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionTerminalNoPanicEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionTerminalNoPanicEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionTerminalNoPanicEmpty,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl OptionTerminalNoPanicEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalNoPanicEmptyPtr(pub SyntaxStablePtrId);
impl OptionTerminalNoPanicEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalNoPanicEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalNoPanicEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalNoPanicEmpty);
    type StablePtr = OptionTerminalNoPanicEmptyPtr;
    type Green = OptionTerminalNoPanicEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionTerminalNoPanicEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionTerminalNoPanicEmpty,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalNoPanicEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalNoPanicEmpty
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalNoPanicEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct FunctionSignature {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl FunctionSignature {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        parameters: ParamListGreen,
        rparen: TerminalRParenGreen,
        ret_ty: OptionReturnTypeClauseGreen,
        implicits_clause: OptionImplicitsClauseGreen,
        optional_no_panic: OptionTerminalNoPanicGreen,
    ) -> FunctionSignatureGreen {
        let children: Vec<GreenId> = vec![
            lparen.0,
            parameters.0,
            rparen.0,
            ret_ty.0,
            implicits_clause.0,
            optional_no_panic.0,
        ];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        FunctionSignatureGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::FunctionSignature,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl FunctionSignature {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn parameters(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
    pub fn ret_ty(&self, db: &dyn SyntaxGroup) -> OptionReturnTypeClause {
        OptionReturnTypeClause::from_syntax_node(db, self.children[3].clone())
    }
    pub fn implicits_clause(&self, db: &dyn SyntaxGroup) -> OptionImplicitsClause {
        OptionImplicitsClause::from_syntax_node(db, self.children[4].clone())
    }
    pub fn optional_no_panic(&self, db: &dyn SyntaxGroup) -> OptionTerminalNoPanic {
        OptionTerminalNoPanic::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FunctionSignaturePtr(pub SyntaxStablePtrId);
impl FunctionSignaturePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FunctionSignatureGreen(pub GreenId);
impl TypedSyntaxNode for FunctionSignature {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::FunctionSignature);
    type StablePtr = FunctionSignaturePtr;
    type Green = FunctionSignatureGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        FunctionSignatureGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::FunctionSignature,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLParen::missing(db).0,
                    ParamList::missing(db).0,
                    TerminalRParen::missing(db).0,
                    OptionReturnTypeClause::missing(db).0,
                    OptionImplicitsClause::missing(db).0,
                    OptionTerminalNoPanic::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::FunctionSignature,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::FunctionSignature
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        FunctionSignaturePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Member {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Member {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        name: TerminalIdentifierGreen,
        type_clause: TypeClauseGreen,
    ) -> MemberGreen {
        let children: Vec<GreenId> = vec![name.0, type_clause.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        MemberGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::Member,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl Member {
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> TypeClause {
        TypeClause::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MemberPtr(pub SyntaxStablePtrId);
impl MemberPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MemberGreen(pub GreenId);
impl TypedSyntaxNode for Member {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Member);
    type StablePtr = MemberPtr;
    type Green = MemberGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        MemberGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::Member,
            details: GreenNodeDetails::Node {
                children: vec![TerminalIdentifier::missing(db).0, TypeClause::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Member,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Member
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MemberPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MemberList(ElementList<Member, 2>);
impl Deref for MemberList {
    type Target = ElementList<Member, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl MemberList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<MemberListElementOrSeparatorGreen>,
    ) -> MemberListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        MemberListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::MemberList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MemberListPtr(pub SyntaxStablePtrId);
impl MemberListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum MemberListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(MemberGreen),
}
impl From<TerminalCommaGreen> for MemberListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        MemberListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<MemberGreen> for MemberListElementOrSeparatorGreen {
    fn from(value: MemberGreen) -> Self {
        MemberListElementOrSeparatorGreen::Element(value)
    }
}
impl MemberListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            MemberListElementOrSeparatorGreen::Separator(green) => green.0,
            MemberListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MemberListGreen(pub GreenId);
impl TypedSyntaxNode for MemberList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MemberList);
    type StablePtr = MemberListPtr;
    type Green = MemberListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        MemberListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::MemberList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MemberListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Item {
    Module(ItemModule),
    Use(ItemUse),
    FreeFunction(ItemFreeFunction),
    ExternFunction(ItemExternFunction),
    ExternType(ItemExternType),
    Trait(ItemTrait),
    Impl(ItemImpl),
    Struct(ItemStruct),
    Enum(ItemEnum),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemPtr(pub SyntaxStablePtrId);
impl ItemPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<ItemModulePtr> for ItemPtr {
    fn from(value: ItemModulePtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemUsePtr> for ItemPtr {
    fn from(value: ItemUsePtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemFreeFunctionPtr> for ItemPtr {
    fn from(value: ItemFreeFunctionPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternFunctionPtr> for ItemPtr {
    fn from(value: ItemExternFunctionPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternTypePtr> for ItemPtr {
    fn from(value: ItemExternTypePtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemTraitPtr> for ItemPtr {
    fn from(value: ItemTraitPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemImplPtr> for ItemPtr {
    fn from(value: ItemImplPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemStructPtr> for ItemPtr {
    fn from(value: ItemStructPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemEnumPtr> for ItemPtr {
    fn from(value: ItemEnumPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemModuleGreen> for ItemGreen {
    fn from(value: ItemModuleGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemUseGreen> for ItemGreen {
    fn from(value: ItemUseGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemFreeFunctionGreen> for ItemGreen {
    fn from(value: ItemFreeFunctionGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternFunctionGreen> for ItemGreen {
    fn from(value: ItemExternFunctionGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternTypeGreen> for ItemGreen {
    fn from(value: ItemExternTypeGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemTraitGreen> for ItemGreen {
    fn from(value: ItemTraitGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemImplGreen> for ItemGreen {
    fn from(value: ItemImplGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemStructGreen> for ItemGreen {
    fn from(value: ItemStructGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemEnumGreen> for ItemGreen {
    fn from(value: ItemEnumGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemGreen(pub GreenId);
impl TypedSyntaxNode for Item {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ItemPtr;
    type Green = ItemGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ItemModule => Item::Module(ItemModule::from_syntax_node(db, node)),
            SyntaxKind::ItemUse => Item::Use(ItemUse::from_syntax_node(db, node)),
            SyntaxKind::ItemFreeFunction => {
                Item::FreeFunction(ItemFreeFunction::from_syntax_node(db, node))
            }
            SyntaxKind::ItemExternFunction => {
                Item::ExternFunction(ItemExternFunction::from_syntax_node(db, node))
            }
            SyntaxKind::ItemExternType => {
                Item::ExternType(ItemExternType::from_syntax_node(db, node))
            }
            SyntaxKind::ItemTrait => Item::Trait(ItemTrait::from_syntax_node(db, node)),
            SyntaxKind::ItemImpl => Item::Impl(ItemImpl::from_syntax_node(db, node)),
            SyntaxKind::ItemStruct => Item::Struct(ItemStruct::from_syntax_node(db, node)),
            SyntaxKind::ItemEnum => Item::Enum(ItemEnum::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Item"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Item::Module(x) => x.as_syntax_node(),
            Item::Use(x) => x.as_syntax_node(),
            Item::FreeFunction(x) => x.as_syntax_node(),
            Item::ExternFunction(x) => x.as_syntax_node(),
            Item::ExternType(x) => x.as_syntax_node(),
            Item::Trait(x) => x.as_syntax_node(),
            Item::Impl(x) => x.as_syntax_node(),
            Item::Struct(x) => x.as_syntax_node(),
            Item::Enum(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemList(ElementList<Item, 1>);
impl Deref for ItemList {
    type Target = ElementList<Item, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ItemList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<ItemGreen>) -> ItemListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.0).width()).sum();
        ItemListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.0).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemListPtr(pub SyntaxStablePtrId);
impl ItemListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemListGreen(pub GreenId);
impl TypedSyntaxNode for ItemList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemList);
    type StablePtr = ItemListPtr;
    type Green = ItemListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Attribute {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Attribute {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        hash: TerminalHashGreen,
        lbrack: TerminalLBrackGreen,
        attr: TerminalIdentifierGreen,
        args: OptionAttributeArgsGreen,
        rbrack: TerminalRBrackGreen,
    ) -> AttributeGreen {
        let children: Vec<GreenId> = vec![hash.0, lbrack.0, attr.0, args.0, rbrack.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        AttributeGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::Attribute,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl Attribute {
    pub fn hash(&self, db: &dyn SyntaxGroup) -> TerminalHash {
        TerminalHash::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lbrack(&self, db: &dyn SyntaxGroup) -> TerminalLBrack {
        TerminalLBrack::from_syntax_node(db, self.children[1].clone())
    }
    pub fn attr(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn args(&self, db: &dyn SyntaxGroup) -> OptionAttributeArgs {
        OptionAttributeArgs::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrack(&self, db: &dyn SyntaxGroup) -> TerminalRBrack {
        TerminalRBrack::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributePtr(pub SyntaxStablePtrId);
impl AttributePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributeGreen(pub GreenId);
impl TypedSyntaxNode for Attribute {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Attribute);
    type StablePtr = AttributePtr;
    type Green = AttributeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        AttributeGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::Attribute,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalHash::missing(db).0,
                    TerminalLBrack::missing(db).0,
                    TerminalIdentifier::missing(db).0,
                    OptionAttributeArgs::missing(db).0,
                    TerminalRBrack::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Attribute,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Attribute
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        AttributePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct AttributeList(ElementList<Attribute, 1>);
impl Deref for AttributeList {
    type Target = ElementList<Attribute, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl AttributeList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<AttributeGreen>) -> AttributeListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.0).width()).sum();
        AttributeListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::AttributeList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.0).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributeListPtr(pub SyntaxStablePtrId);
impl AttributeListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributeListGreen(pub GreenId);
impl TypedSyntaxNode for AttributeList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AttributeList);
    type StablePtr = AttributeListPtr;
    type Green = AttributeListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        AttributeListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::AttributeList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        AttributeListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemModule {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemModule {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        module_kw: TerminalModuleGreen,
        name: TerminalIdentifierGreen,
        body: MaybeModuleBodyGreen,
    ) -> ItemModuleGreen {
        let children: Vec<GreenId> = vec![attributes.0, module_kw.0, name.0, body.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemModuleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemModule,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ItemModule {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn module_kw(&self, db: &dyn SyntaxGroup) -> TerminalModule {
        TerminalModule::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> MaybeModuleBody {
        MaybeModuleBody::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemModulePtr(pub SyntaxStablePtrId);
impl ItemModulePtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemModuleGreen(pub GreenId);
impl TypedSyntaxNode for ItemModule {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemModule);
    type StablePtr = ItemModulePtr;
    type Green = ItemModuleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemModuleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemModule,
            details: GreenNodeDetails::Node {
                children: vec![
                    AttributeList::missing(db).0,
                    TerminalModule::missing(db).0,
                    TerminalIdentifier::missing(db).0,
                    MaybeModuleBody::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemModule,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemModule
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemModulePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum MaybeModuleBody {
    Some(ModuleBody),
    None(TerminalSemicolon),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeModuleBodyPtr(pub SyntaxStablePtrId);
impl MaybeModuleBodyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<ModuleBodyPtr> for MaybeModuleBodyPtr {
    fn from(value: ModuleBodyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonPtr> for MaybeModuleBodyPtr {
    fn from(value: TerminalSemicolonPtr) -> Self {
        Self(value.0)
    }
}
impl From<ModuleBodyGreen> for MaybeModuleBodyGreen {
    fn from(value: ModuleBodyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonGreen> for MaybeModuleBodyGreen {
    fn from(value: TerminalSemicolonGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeModuleBodyGreen(pub GreenId);
impl TypedSyntaxNode for MaybeModuleBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeModuleBodyPtr;
    type Green = MaybeModuleBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ModuleBody => MaybeModuleBody::Some(ModuleBody::from_syntax_node(db, node)),
            SyntaxKind::TerminalSemicolon => {
                MaybeModuleBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MaybeModuleBody")
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            MaybeModuleBody::Some(x) => x.as_syntax_node(),
            MaybeModuleBody::None(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MaybeModuleBodyPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ModuleBody {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ModuleBody {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        items: ItemListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ModuleBodyGreen {
        let children: Vec<GreenId> = vec![lbrace.0, items.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ModuleBodyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ModuleBody,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ModuleBody {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> ItemList {
        ItemList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModuleBodyPtr(pub SyntaxStablePtrId);
impl ModuleBodyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModuleBodyGreen(pub GreenId);
impl TypedSyntaxNode for ModuleBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ModuleBody);
    type StablePtr = ModuleBodyPtr;
    type Green = ModuleBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ModuleBodyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ModuleBody,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLBrace::missing(db).0,
                    ItemList::missing(db).0,
                    TerminalRBrace::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ModuleBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ModuleBody
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ModuleBodyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionAttributeArgs {
    Empty(OptionAttributeArgsEmpty),
    AttributeArgs(AttributeArgs),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAttributeArgsPtr(pub SyntaxStablePtrId);
impl OptionAttributeArgsPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionAttributeArgsEmptyPtr> for OptionAttributeArgsPtr {
    fn from(value: OptionAttributeArgsEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<AttributeArgsPtr> for OptionAttributeArgsPtr {
    fn from(value: AttributeArgsPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionAttributeArgsEmptyGreen> for OptionAttributeArgsGreen {
    fn from(value: OptionAttributeArgsEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<AttributeArgsGreen> for OptionAttributeArgsGreen {
    fn from(value: AttributeArgsGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAttributeArgsGreen(pub GreenId);
impl TypedSyntaxNode for OptionAttributeArgs {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionAttributeArgsPtr;
    type Green = OptionAttributeArgsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionAttributeArgsEmpty => {
                OptionAttributeArgs::Empty(OptionAttributeArgsEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::AttributeArgs => {
                OptionAttributeArgs::AttributeArgs(AttributeArgs::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionAttributeArgs"
            ),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionAttributeArgs::Empty(x) => x.as_syntax_node(),
            OptionAttributeArgs::AttributeArgs(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionAttributeArgsPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionAttributeArgsEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionAttributeArgsEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionAttributeArgsEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionAttributeArgsEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionAttributeArgsEmpty,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl OptionAttributeArgsEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAttributeArgsEmptyPtr(pub SyntaxStablePtrId);
impl OptionAttributeArgsEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAttributeArgsEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionAttributeArgsEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionAttributeArgsEmpty);
    type StablePtr = OptionAttributeArgsEmptyPtr;
    type Green = OptionAttributeArgsEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionAttributeArgsEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionAttributeArgsEmpty,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionAttributeArgsEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionAttributeArgsEmpty
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionAttributeArgsEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct AttributeArgs {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl AttributeArgs {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        arg_list: AttributeArgListGreen,
        rangle: TerminalRParenGreen,
    ) -> AttributeArgsGreen {
        let children: Vec<GreenId> = vec![lparen.0, arg_list.0, rangle.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        AttributeArgsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::AttributeArgs,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl AttributeArgs {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arg_list(&self, db: &dyn SyntaxGroup) -> AttributeArgList {
        AttributeArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rangle(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributeArgsPtr(pub SyntaxStablePtrId);
impl AttributeArgsPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributeArgsGreen(pub GreenId);
impl TypedSyntaxNode for AttributeArgs {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AttributeArgs);
    type StablePtr = AttributeArgsPtr;
    type Green = AttributeArgsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        AttributeArgsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::AttributeArgs,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLParen::missing(db).0,
                    AttributeArgList::missing(db).0,
                    TerminalRParen::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::AttributeArgs,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::AttributeArgs
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        AttributeArgsPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct AttributeArgList(ElementList<Expr, 2>);
impl Deref for AttributeArgList {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl AttributeArgList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<AttributeArgListElementOrSeparatorGreen>,
    ) -> AttributeArgListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        AttributeArgListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::AttributeArgList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributeArgListPtr(pub SyntaxStablePtrId);
impl AttributeArgListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum AttributeArgListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(ExprGreen),
}
impl From<TerminalCommaGreen> for AttributeArgListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        AttributeArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ExprGreen> for AttributeArgListElementOrSeparatorGreen {
    fn from(value: ExprGreen) -> Self {
        AttributeArgListElementOrSeparatorGreen::Element(value)
    }
}
impl AttributeArgListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            AttributeArgListElementOrSeparatorGreen::Separator(green) => green.0,
            AttributeArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributeArgListGreen(pub GreenId);
impl TypedSyntaxNode for AttributeArgList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AttributeArgList);
    type StablePtr = AttributeArgListPtr;
    type Green = AttributeArgListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        AttributeArgListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::AttributeArgList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        AttributeArgListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemFreeFunction {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemFreeFunction {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        function_kw: TerminalFunctionGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        signature: FunctionSignatureGreen,
        body: ExprBlockGreen,
    ) -> ItemFreeFunctionGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, function_kw.0, name.0, generic_params.0, signature.0, body.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemFreeFunctionGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemFreeFunction,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ItemFreeFunction {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn function_kw(&self, db: &dyn SyntaxGroup) -> TerminalFunction {
        TerminalFunction::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn signature(&self, db: &dyn SyntaxGroup) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[4].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemFreeFunctionPtr(pub SyntaxStablePtrId);
impl ItemFreeFunctionPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemFreeFunctionGreen(pub GreenId);
impl TypedSyntaxNode for ItemFreeFunction {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemFreeFunction);
    type StablePtr = ItemFreeFunctionPtr;
    type Green = ItemFreeFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemFreeFunctionGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemFreeFunction,
            details: GreenNodeDetails::Node {
                children: vec![
                    AttributeList::missing(db).0,
                    TerminalFunction::missing(db).0,
                    TerminalIdentifier::missing(db).0,
                    OptionWrappedGenericParamList::missing(db).0,
                    FunctionSignature::missing(db).0,
                    ExprBlock::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemFreeFunction,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemFreeFunction
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemFreeFunctionPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemExternFunction {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemExternFunction {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        extern_kw: TerminalExternGreen,
        function_kw: TerminalFunctionGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        signature: FunctionSignatureGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> ItemExternFunctionGreen {
        let children: Vec<GreenId> = vec![
            attributes.0,
            extern_kw.0,
            function_kw.0,
            name.0,
            generic_params.0,
            signature.0,
            semicolon.0,
        ];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemExternFunctionGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemExternFunction,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ItemExternFunction {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn extern_kw(&self, db: &dyn SyntaxGroup) -> TerminalExtern {
        TerminalExtern::from_syntax_node(db, self.children[1].clone())
    }
    pub fn function_kw(&self, db: &dyn SyntaxGroup) -> TerminalFunction {
        TerminalFunction::from_syntax_node(db, self.children[2].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4].clone())
    }
    pub fn signature(&self, db: &dyn SyntaxGroup) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[5].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[6].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternFunctionPtr(pub SyntaxStablePtrId);
impl ItemExternFunctionPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternFunctionGreen(pub GreenId);
impl TypedSyntaxNode for ItemExternFunction {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemExternFunction);
    type StablePtr = ItemExternFunctionPtr;
    type Green = ItemExternFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemExternFunctionGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemExternFunction,
            details: GreenNodeDetails::Node {
                children: vec![
                    AttributeList::missing(db).0,
                    TerminalExtern::missing(db).0,
                    TerminalFunction::missing(db).0,
                    TerminalIdentifier::missing(db).0,
                    OptionWrappedGenericParamList::missing(db).0,
                    FunctionSignature::missing(db).0,
                    TerminalSemicolon::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemExternFunction,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemExternFunction
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemExternFunctionPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemExternType {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemExternType {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        extern_kw: TerminalExternGreen,
        type_kw: TerminalTypeGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> ItemExternTypeGreen {
        let children: Vec<GreenId> =
            vec![extern_kw.0, type_kw.0, name.0, generic_params.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemExternTypeGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemExternType,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ItemExternType {
    pub fn extern_kw(&self, db: &dyn SyntaxGroup) -> TerminalExtern {
        TerminalExtern::from_syntax_node(db, self.children[0].clone())
    }
    pub fn type_kw(&self, db: &dyn SyntaxGroup) -> TerminalType {
        TerminalType::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternTypePtr(pub SyntaxStablePtrId);
impl ItemExternTypePtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternTypeGreen(pub GreenId);
impl TypedSyntaxNode for ItemExternType {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemExternType);
    type StablePtr = ItemExternTypePtr;
    type Green = ItemExternTypeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemExternTypeGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemExternType,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalExtern::missing(db).0,
                    TerminalType::missing(db).0,
                    TerminalIdentifier::missing(db).0,
                    OptionWrappedGenericParamList::missing(db).0,
                    TerminalSemicolon::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemExternType,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemExternType
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemExternTypePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemTrait {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemTrait {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        trait_kw: TerminalTraitGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        body: MaybeTraitBodyGreen,
    ) -> ItemTraitGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, trait_kw.0, name.0, generic_params.0, body.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemTraitGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemTrait,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ItemTrait {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn trait_kw(&self, db: &dyn SyntaxGroup) -> TerminalTrait {
        TerminalTrait::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> MaybeTraitBody {
        MaybeTraitBody::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemTraitPtr(pub SyntaxStablePtrId);
impl ItemTraitPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemTraitGreen(pub GreenId);
impl TypedSyntaxNode for ItemTrait {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemTrait);
    type StablePtr = ItemTraitPtr;
    type Green = ItemTraitGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemTraitGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemTrait,
            details: GreenNodeDetails::Node {
                children: vec![
                    AttributeList::missing(db).0,
                    TerminalTrait::missing(db).0,
                    TerminalIdentifier::missing(db).0,
                    OptionWrappedGenericParamList::missing(db).0,
                    MaybeTraitBody::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemTrait,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemTrait
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemTraitPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum MaybeTraitBody {
    Some(TraitBody),
    None(TerminalSemicolon),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeTraitBodyPtr(pub SyntaxStablePtrId);
impl MaybeTraitBodyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TraitBodyPtr> for MaybeTraitBodyPtr {
    fn from(value: TraitBodyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonPtr> for MaybeTraitBodyPtr {
    fn from(value: TerminalSemicolonPtr) -> Self {
        Self(value.0)
    }
}
impl From<TraitBodyGreen> for MaybeTraitBodyGreen {
    fn from(value: TraitBodyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonGreen> for MaybeTraitBodyGreen {
    fn from(value: TerminalSemicolonGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeTraitBodyGreen(pub GreenId);
impl TypedSyntaxNode for MaybeTraitBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeTraitBodyPtr;
    type Green = MaybeTraitBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TraitBody => MaybeTraitBody::Some(TraitBody::from_syntax_node(db, node)),
            SyntaxKind::TerminalSemicolon => {
                MaybeTraitBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MaybeTraitBody")
            }
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            MaybeTraitBody::Some(x) => x.as_syntax_node(),
            MaybeTraitBody::None(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MaybeTraitBodyPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TraitBody {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TraitBody {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        items: TraitItemListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> TraitBodyGreen {
        let children: Vec<GreenId> = vec![lbrace.0, items.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TraitBodyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TraitBody,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl TraitBody {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> TraitItemList {
        TraitItemList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitBodyPtr(pub SyntaxStablePtrId);
impl TraitBodyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitBodyGreen(pub GreenId);
impl TypedSyntaxNode for TraitBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitBody);
    type StablePtr = TraitBodyPtr;
    type Green = TraitBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitBodyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TraitBody,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLBrace::missing(db).0,
                    TraitItemList::missing(db).0,
                    TerminalRBrace::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitBody
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitBodyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TraitItemList(ElementList<TraitItem, 1>);
impl Deref for TraitItemList {
    type Target = ElementList<TraitItem, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl TraitItemList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<TraitItemGreen>) -> TraitItemListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.0).width()).sum();
        TraitItemListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TraitItemList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.0).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemListPtr(pub SyntaxStablePtrId);
impl TraitItemListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemListGreen(pub GreenId);
impl TypedSyntaxNode for TraitItemList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemList);
    type StablePtr = TraitItemListPtr;
    type Green = TraitItemListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitItemListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TraitItemList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitItemListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum TraitItem {
    Function(TraitItemFunction),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemPtr(pub SyntaxStablePtrId);
impl TraitItemPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<TraitItemFunctionPtr> for TraitItemPtr {
    fn from(value: TraitItemFunctionPtr) -> Self {
        Self(value.0)
    }
}
impl From<TraitItemFunctionGreen> for TraitItemGreen {
    fn from(value: TraitItemFunctionGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemGreen(pub GreenId);
impl TypedSyntaxNode for TraitItem {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = TraitItemPtr;
    type Green = TraitItemGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TraitItemFunction => {
                TraitItem::Function(TraitItemFunction::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "TraitItem"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            TraitItem::Function(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitItemPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TraitItemFunction {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TraitItemFunction {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        function_kw: TerminalFunctionGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        signature: FunctionSignatureGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> TraitItemFunctionGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, function_kw.0, name.0, generic_params.0, signature.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TraitItemFunctionGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TraitItemFunction,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl TraitItemFunction {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn function_kw(&self, db: &dyn SyntaxGroup) -> TerminalFunction {
        TerminalFunction::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn signature(&self, db: &dyn SyntaxGroup) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[4].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemFunctionPtr(pub SyntaxStablePtrId);
impl TraitItemFunctionPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemFunctionGreen(pub GreenId);
impl TypedSyntaxNode for TraitItemFunction {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemFunction);
    type StablePtr = TraitItemFunctionPtr;
    type Green = TraitItemFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitItemFunctionGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TraitItemFunction,
            details: GreenNodeDetails::Node {
                children: vec![
                    AttributeList::missing(db).0,
                    TerminalFunction::missing(db).0,
                    TerminalIdentifier::missing(db).0,
                    OptionWrappedGenericParamList::missing(db).0,
                    FunctionSignature::missing(db).0,
                    TerminalSemicolon::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemFunction,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemFunction
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitItemFunctionPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemImpl {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemImpl {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        impl_kw: TerminalImplGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        of_kw: TerminalOfGreen,
        trait_path: ExprPathGreen,
        body: MaybeImplBodyGreen,
    ) -> ItemImplGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, impl_kw.0, name.0, generic_params.0, of_kw.0, trait_path.0, body.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemImplGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemImpl,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ItemImpl {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn impl_kw(&self, db: &dyn SyntaxGroup) -> TerminalImpl {
        TerminalImpl::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn of_kw(&self, db: &dyn SyntaxGroup) -> TerminalOf {
        TerminalOf::from_syntax_node(db, self.children[4].clone())
    }
    pub fn trait_path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[5].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> MaybeImplBody {
        MaybeImplBody::from_syntax_node(db, self.children[6].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemImplPtr(pub SyntaxStablePtrId);
impl ItemImplPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemImplGreen(pub GreenId);
impl TypedSyntaxNode for ItemImpl {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemImpl);
    type StablePtr = ItemImplPtr;
    type Green = ItemImplGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemImplGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemImpl,
            details: GreenNodeDetails::Node {
                children: vec![
                    AttributeList::missing(db).0,
                    TerminalImpl::missing(db).0,
                    TerminalIdentifier::missing(db).0,
                    OptionWrappedGenericParamList::missing(db).0,
                    TerminalOf::missing(db).0,
                    ExprPath::missing(db).0,
                    MaybeImplBody::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemImpl,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemImpl
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemImplPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum MaybeImplBody {
    Some(ImplBody),
    None(TerminalSemicolon),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeImplBodyPtr(pub SyntaxStablePtrId);
impl MaybeImplBodyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<ImplBodyPtr> for MaybeImplBodyPtr {
    fn from(value: ImplBodyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonPtr> for MaybeImplBodyPtr {
    fn from(value: TerminalSemicolonPtr) -> Self {
        Self(value.0)
    }
}
impl From<ImplBodyGreen> for MaybeImplBodyGreen {
    fn from(value: ImplBodyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonGreen> for MaybeImplBodyGreen {
    fn from(value: TerminalSemicolonGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeImplBodyGreen(pub GreenId);
impl TypedSyntaxNode for MaybeImplBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeImplBodyPtr;
    type Green = MaybeImplBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ImplBody => MaybeImplBody::Some(ImplBody::from_syntax_node(db, node)),
            SyntaxKind::TerminalSemicolon => {
                MaybeImplBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MaybeImplBody"),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            MaybeImplBody::Some(x) => x.as_syntax_node(),
            MaybeImplBody::None(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MaybeImplBodyPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ImplBody {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ImplBody {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        items: ItemListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ImplBodyGreen {
        let children: Vec<GreenId> = vec![lbrace.0, items.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ImplBodyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ImplBody,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ImplBody {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> ItemList {
        ItemList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplBodyPtr(pub SyntaxStablePtrId);
impl ImplBodyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplBodyGreen(pub GreenId);
impl TypedSyntaxNode for ImplBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplBody);
    type StablePtr = ImplBodyPtr;
    type Green = ImplBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ImplBodyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ImplBody,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLBrace::missing(db).0,
                    ItemList::missing(db).0,
                    TerminalRBrace::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ImplBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ImplBody
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ImplBodyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemStruct {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemStruct {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        struct_kw: TerminalStructGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        lbrace: TerminalLBraceGreen,
        members: MemberListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ItemStructGreen {
        let children: Vec<GreenId> = vec![
            attributes.0,
            struct_kw.0,
            name.0,
            generic_params.0,
            lbrace.0,
            members.0,
            rbrace.0,
        ];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemStructGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemStruct,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ItemStruct {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn struct_kw(&self, db: &dyn SyntaxGroup) -> TerminalStruct {
        TerminalStruct::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[4].clone())
    }
    pub fn members(&self, db: &dyn SyntaxGroup) -> MemberList {
        MemberList::from_syntax_node(db, self.children[5].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[6].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemStructPtr(pub SyntaxStablePtrId);
impl ItemStructPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemStructGreen(pub GreenId);
impl TypedSyntaxNode for ItemStruct {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemStruct);
    type StablePtr = ItemStructPtr;
    type Green = ItemStructGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemStructGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemStruct,
            details: GreenNodeDetails::Node {
                children: vec![
                    AttributeList::missing(db).0,
                    TerminalStruct::missing(db).0,
                    TerminalIdentifier::missing(db).0,
                    OptionWrappedGenericParamList::missing(db).0,
                    TerminalLBrace::missing(db).0,
                    MemberList::missing(db).0,
                    TerminalRBrace::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemStruct,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemStruct
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemStructPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemEnum {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemEnum {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        enum_kw: TerminalEnumGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        lbrace: TerminalLBraceGreen,
        variants: MemberListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ItemEnumGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, enum_kw.0, name.0, generic_params.0, lbrace.0, variants.0, rbrace.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemEnumGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemEnum,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ItemEnum {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn enum_kw(&self, db: &dyn SyntaxGroup) -> TerminalEnum {
        TerminalEnum::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[4].clone())
    }
    pub fn variants(&self, db: &dyn SyntaxGroup) -> MemberList {
        MemberList::from_syntax_node(db, self.children[5].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[6].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemEnumPtr(pub SyntaxStablePtrId);
impl ItemEnumPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemEnumGreen(pub GreenId);
impl TypedSyntaxNode for ItemEnum {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemEnum);
    type StablePtr = ItemEnumPtr;
    type Green = ItemEnumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemEnumGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemEnum,
            details: GreenNodeDetails::Node {
                children: vec![
                    AttributeList::missing(db).0,
                    TerminalEnum::missing(db).0,
                    TerminalIdentifier::missing(db).0,
                    OptionWrappedGenericParamList::missing(db).0,
                    TerminalLBrace::missing(db).0,
                    MemberList::missing(db).0,
                    TerminalRBrace::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemEnum,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemEnum
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemEnumPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemUse {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ItemUse {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        use_kw: TerminalUseGreen,
        name: ExprPathGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> ItemUseGreen {
        let children: Vec<GreenId> = vec![attributes.0, use_kw.0, name.0, semicolon.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        ItemUseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemUse,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl ItemUse {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn use_kw(&self, db: &dyn SyntaxGroup) -> TerminalUse {
        TerminalUse::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[2].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemUsePtr(pub SyntaxStablePtrId);
impl ItemUsePtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> ExprPathGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            ExprPathGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemUseGreen(pub GreenId);
impl TypedSyntaxNode for ItemUse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemUse);
    type StablePtr = ItemUsePtr;
    type Green = ItemUseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemUseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::ItemUse,
            details: GreenNodeDetails::Node {
                children: vec![
                    AttributeList::missing(db).0,
                    TerminalUse::missing(db).0,
                    ExprPath::missing(db).0,
                    TerminalSemicolon::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemUse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemUse
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemUsePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericArgs {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl GenericArgs {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        langle: TerminalLTGreen,
        generic_args: GenericArgListGreen,
        rangle: TerminalGTGreen,
    ) -> GenericArgsGreen {
        let children: Vec<GreenId> = vec![langle.0, generic_args.0, rangle.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        GenericArgsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::GenericArgs,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl GenericArgs {
    pub fn langle(&self, db: &dyn SyntaxGroup) -> TerminalLT {
        TerminalLT::from_syntax_node(db, self.children[0].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> GenericArgList {
        GenericArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rangle(&self, db: &dyn SyntaxGroup) -> TerminalGT {
        TerminalGT::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgsPtr(pub SyntaxStablePtrId);
impl GenericArgsPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgsGreen(pub GreenId);
impl TypedSyntaxNode for GenericArgs {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgs);
    type StablePtr = GenericArgsPtr;
    type Green = GenericArgsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericArgsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::GenericArgs,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLT::missing(db).0,
                    GenericArgList::missing(db).0,
                    TerminalGT::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericArgs,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericArgs
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericArgsPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericArgList(ElementList<Expr, 2>);
impl Deref for GenericArgList {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl GenericArgList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<GenericArgListElementOrSeparatorGreen>,
    ) -> GenericArgListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        GenericArgListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::GenericArgList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgListPtr(pub SyntaxStablePtrId);
impl GenericArgListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum GenericArgListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(ExprGreen),
}
impl From<TerminalCommaGreen> for GenericArgListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        GenericArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ExprGreen> for GenericArgListElementOrSeparatorGreen {
    fn from(value: ExprGreen) -> Self {
        GenericArgListElementOrSeparatorGreen::Element(value)
    }
}
impl GenericArgListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            GenericArgListElementOrSeparatorGreen::Separator(green) => green.0,
            GenericArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgListGreen(pub GreenId);
impl TypedSyntaxNode for GenericArgList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgList);
    type StablePtr = GenericArgListPtr;
    type Green = GenericArgListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericArgListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::GenericArgList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericArgListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionWrappedGenericParamList {
    Empty(OptionWrappedGenericParamListEmpty),
    WrappedGenericParamList(WrappedGenericParamList),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionWrappedGenericParamListPtr(pub SyntaxStablePtrId);
impl OptionWrappedGenericParamListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
impl From<OptionWrappedGenericParamListEmptyPtr> for OptionWrappedGenericParamListPtr {
    fn from(value: OptionWrappedGenericParamListEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<WrappedGenericParamListPtr> for OptionWrappedGenericParamListPtr {
    fn from(value: WrappedGenericParamListPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionWrappedGenericParamListEmptyGreen> for OptionWrappedGenericParamListGreen {
    fn from(value: OptionWrappedGenericParamListEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<WrappedGenericParamListGreen> for OptionWrappedGenericParamListGreen {
    fn from(value: WrappedGenericParamListGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionWrappedGenericParamListGreen(pub GreenId);
impl TypedSyntaxNode for OptionWrappedGenericParamList {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionWrappedGenericParamListPtr;
    type Green = OptionWrappedGenericParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionWrappedGenericParamListEmpty => OptionWrappedGenericParamList::Empty(
                OptionWrappedGenericParamListEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::WrappedGenericParamList => {
                OptionWrappedGenericParamList::WrappedGenericParamList(
                    WrappedGenericParamList::from_syntax_node(db, node),
                )
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionWrappedGenericParamList"
            ),
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionWrappedGenericParamList::Empty(x) => x.as_syntax_node(),
            OptionWrappedGenericParamList::WrappedGenericParamList(x) => x.as_syntax_node(),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionWrappedGenericParamListPtr(self.as_syntax_node().0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionWrappedGenericParamListEmpty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl OptionWrappedGenericParamListEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionWrappedGenericParamListEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        OptionWrappedGenericParamListEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionWrappedGenericParamListEmpty,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl OptionWrappedGenericParamListEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionWrappedGenericParamListEmptyPtr(pub SyntaxStablePtrId);
impl OptionWrappedGenericParamListEmptyPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionWrappedGenericParamListEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionWrappedGenericParamListEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionWrappedGenericParamListEmpty);
    type StablePtr = OptionWrappedGenericParamListEmptyPtr;
    type Green = OptionWrappedGenericParamListEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionWrappedGenericParamListEmptyGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::OptionWrappedGenericParamListEmpty,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionWrappedGenericParamListEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionWrappedGenericParamListEmpty
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionWrappedGenericParamListEmptyPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct WrappedGenericParamList {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl WrappedGenericParamList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        langle: TerminalLTGreen,
        generic_params: GenericParamListGreen,
        rangle: TerminalGTGreen,
    ) -> WrappedGenericParamListGreen {
        let children: Vec<GreenId> = vec![langle.0, generic_params.0, rangle.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        WrappedGenericParamListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::WrappedGenericParamList,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl WrappedGenericParamList {
    pub fn langle(&self, db: &dyn SyntaxGroup) -> TerminalLT {
        TerminalLT::from_syntax_node(db, self.children[0].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> GenericParamList {
        GenericParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rangle(&self, db: &dyn SyntaxGroup) -> TerminalGT {
        TerminalGT::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct WrappedGenericParamListPtr(pub SyntaxStablePtrId);
impl WrappedGenericParamListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct WrappedGenericParamListGreen(pub GreenId);
impl TypedSyntaxNode for WrappedGenericParamList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::WrappedGenericParamList);
    type StablePtr = WrappedGenericParamListPtr;
    type Green = WrappedGenericParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        WrappedGenericParamListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::WrappedGenericParamList,
            details: GreenNodeDetails::Node {
                children: vec![
                    TerminalLT::missing(db).0,
                    GenericParamList::missing(db).0,
                    TerminalGT::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::WrappedGenericParamList,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::WrappedGenericParamList
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        WrappedGenericParamListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericParamList(ElementList<GenericParam, 2>);
impl Deref for GenericParamList {
    type Target = ElementList<GenericParam, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl GenericParamList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<GenericParamListElementOrSeparatorGreen>,
    ) -> GenericParamListGreen {
        let width = children.iter().map(|id| db.lookup_intern_green(id.id()).width()).sum();
        GenericParamListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::GenericParamList,
            details: GreenNodeDetails::Node {
                children: children.iter().map(|x| x.id()).collect(),
                width,
            },
        }))
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamListPtr(pub SyntaxStablePtrId);
impl GenericParamListPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum GenericParamListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(GenericParamGreen),
}
impl From<TerminalCommaGreen> for GenericParamListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        GenericParamListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<GenericParamGreen> for GenericParamListElementOrSeparatorGreen {
    fn from(value: GenericParamGreen) -> Self {
        GenericParamListElementOrSeparatorGreen::Element(value)
    }
}
impl GenericParamListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            GenericParamListElementOrSeparatorGreen::Separator(green) => green.0,
            GenericParamListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamListGreen(pub GreenId);
impl TypedSyntaxNode for GenericParamList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamList);
    type StablePtr = GenericParamListPtr;
    type Green = GenericParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericParamListGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::GenericParamList,
            details: GreenNodeDetails::Node { children: vec![], width: 0 },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericParamListPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericParam {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl GenericParam {
    pub fn new_green(db: &dyn SyntaxGroup, name: TerminalIdentifierGreen) -> GenericParamGreen {
        let children: Vec<GreenId> = vec![name.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        GenericParamGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::GenericParam,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl GenericParam {
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamPtr(pub SyntaxStablePtrId);
impl GenericParamPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = db.lookup_intern_stable_ptr(self.0);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamGreen(pub GreenId);
impl TypedSyntaxNode for GenericParam {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParam);
    type StablePtr = GenericParamPtr;
    type Green = GenericParamGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericParamGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::GenericParam,
            details: GreenNodeDetails::Node {
                children: vec![TerminalIdentifier::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParam,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParam
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericParamPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenIdentifier {
    node: SyntaxNode,
}
impl Token for TokenIdentifier {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenIdentifierGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenIdentifier,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenIdentifierPtr(pub SyntaxStablePtrId);
impl TokenIdentifierPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenIdentifierGreen(pub GreenId);
impl TokenIdentifierGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenIdentifier {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenIdentifier);
    type StablePtr = TokenIdentifierPtr;
    type Green = TokenIdentifierGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenIdentifierGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenIdentifier)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenIdentifierPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalIdentifier {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalIdentifier {
    const KIND: SyntaxKind = SyntaxKind::TerminalIdentifier;
    type TokenType = TokenIdentifier;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalIdentifier as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalIdentifierGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalIdentifier,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalIdentifier {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenIdentifier {
        TokenIdentifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalIdentifierPtr(pub SyntaxStablePtrId);
impl TerminalIdentifierPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalIdentifierGreen(pub GreenId);
impl TypedSyntaxNode for TerminalIdentifier {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalIdentifier);
    type StablePtr = TerminalIdentifierPtr;
    type Green = TerminalIdentifierGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalIdentifierGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalIdentifier,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenIdentifier::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalIdentifier,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalIdentifier
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalIdentifierPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLiteralNumber {
    node: SyntaxNode,
}
impl Token for TokenLiteralNumber {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLiteralNumberGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenLiteralNumber,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLiteralNumberPtr(pub SyntaxStablePtrId);
impl TokenLiteralNumberPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLiteralNumberGreen(pub GreenId);
impl TokenLiteralNumberGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenLiteralNumber {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLiteralNumber);
    type StablePtr = TokenLiteralNumberPtr;
    type Green = TokenLiteralNumberGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLiteralNumberGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenLiteralNumber
            ),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLiteralNumberPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLiteralNumber {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalLiteralNumber {
    const KIND: SyntaxKind = SyntaxKind::TerminalLiteralNumber;
    type TokenType = TokenLiteralNumber;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLiteralNumber as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalLiteralNumberGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLiteralNumber,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLiteralNumber {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLiteralNumber {
        TokenLiteralNumber::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLiteralNumberPtr(pub SyntaxStablePtrId);
impl TerminalLiteralNumberPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLiteralNumberGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLiteralNumber {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLiteralNumber);
    type StablePtr = TerminalLiteralNumberPtr;
    type Green = TerminalLiteralNumberGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLiteralNumberGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLiteralNumber,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenLiteralNumber::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLiteralNumber,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLiteralNumber
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLiteralNumberPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenShortString {
    node: SyntaxNode,
}
impl Token for TokenShortString {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenShortStringGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenShortString,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenShortStringPtr(pub SyntaxStablePtrId);
impl TokenShortStringPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenShortStringGreen(pub GreenId);
impl TokenShortStringGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenShortString {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenShortString);
    type StablePtr = TokenShortStringPtr;
    type Green = TokenShortStringGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenShortStringGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenShortString)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenShortStringPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalShortString {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalShortString {
    const KIND: SyntaxKind = SyntaxKind::TerminalShortString;
    type TokenType = TokenShortString;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalShortString as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalShortStringGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalShortString,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalShortString {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenShortString {
        TokenShortString::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalShortStringPtr(pub SyntaxStablePtrId);
impl TerminalShortStringPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalShortStringGreen(pub GreenId);
impl TypedSyntaxNode for TerminalShortString {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalShortString);
    type StablePtr = TerminalShortStringPtr;
    type Green = TerminalShortStringGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalShortStringGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalShortString,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenShortString::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalShortString,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalShortString
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalShortStringPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenFalse {
    node: SyntaxNode,
}
impl Token for TokenFalse {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenFalseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenFalse,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenFalsePtr(pub SyntaxStablePtrId);
impl TokenFalsePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenFalseGreen(pub GreenId);
impl TokenFalseGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenFalse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenFalse);
    type StablePtr = TokenFalsePtr;
    type Green = TokenFalseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenFalseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenFalse)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenFalsePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalFalse {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalFalse {
    const KIND: SyntaxKind = SyntaxKind::TerminalFalse;
    type TokenType = TokenFalse;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalFalse as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalFalseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalFalse,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalFalse {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenFalse {
        TokenFalse::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalFalsePtr(pub SyntaxStablePtrId);
impl TerminalFalsePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalFalseGreen(pub GreenId);
impl TypedSyntaxNode for TerminalFalse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalFalse);
    type StablePtr = TerminalFalsePtr;
    type Green = TerminalFalseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalFalseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalFalse,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenFalse::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalFalse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalFalse
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalFalsePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenTrue {
    node: SyntaxNode,
}
impl Token for TokenTrue {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenTrueGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenTrue,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTruePtr(pub SyntaxStablePtrId);
impl TokenTruePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTrueGreen(pub GreenId);
impl TokenTrueGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenTrue {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTrue);
    type StablePtr = TokenTruePtr;
    type Green = TokenTrueGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenTrueGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenTrue)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenTruePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalTrue {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalTrue {
    const KIND: SyntaxKind = SyntaxKind::TerminalTrue;
    type TokenType = TokenTrue;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalTrue as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalTrueGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalTrue,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalTrue {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenTrue {
        TokenTrue::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTruePtr(pub SyntaxStablePtrId);
impl TerminalTruePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTrueGreen(pub GreenId);
impl TypedSyntaxNode for TerminalTrue {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalTrue);
    type StablePtr = TerminalTruePtr;
    type Green = TerminalTrueGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalTrueGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalTrue,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenTrue::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalTrue,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalTrue
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalTruePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenExtern {
    node: SyntaxNode,
}
impl Token for TokenExtern {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenExternGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenExtern,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenExternPtr(pub SyntaxStablePtrId);
impl TokenExternPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenExternGreen(pub GreenId);
impl TokenExternGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenExtern {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenExtern);
    type StablePtr = TokenExternPtr;
    type Green = TokenExternGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenExternGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenExtern)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenExternPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalExtern {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalExtern {
    const KIND: SyntaxKind = SyntaxKind::TerminalExtern;
    type TokenType = TokenExtern;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalExtern as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalExternGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalExtern,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalExtern {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenExtern {
        TokenExtern::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalExternPtr(pub SyntaxStablePtrId);
impl TerminalExternPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalExternGreen(pub GreenId);
impl TypedSyntaxNode for TerminalExtern {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalExtern);
    type StablePtr = TerminalExternPtr;
    type Green = TerminalExternGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalExternGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalExtern,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenExtern::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalExtern,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalExtern
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalExternPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenType {
    node: SyntaxNode,
}
impl Token for TokenType {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenTypeGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenType,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTypePtr(pub SyntaxStablePtrId);
impl TokenTypePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTypeGreen(pub GreenId);
impl TokenTypeGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenType {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenType);
    type StablePtr = TokenTypePtr;
    type Green = TokenTypeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenTypeGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenType)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenTypePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalType {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalType {
    const KIND: SyntaxKind = SyntaxKind::TerminalType;
    type TokenType = TokenType;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalType as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalTypeGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalType,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalType {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenType {
        TokenType::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTypePtr(pub SyntaxStablePtrId);
impl TerminalTypePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTypeGreen(pub GreenId);
impl TypedSyntaxNode for TerminalType {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalType);
    type StablePtr = TerminalTypePtr;
    type Green = TerminalTypeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalTypeGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalType,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenType::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalType,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalType
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalTypePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenFunction {
    node: SyntaxNode,
}
impl Token for TokenFunction {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenFunctionGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenFunction,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenFunctionPtr(pub SyntaxStablePtrId);
impl TokenFunctionPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenFunctionGreen(pub GreenId);
impl TokenFunctionGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenFunction {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenFunction);
    type StablePtr = TokenFunctionPtr;
    type Green = TokenFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenFunctionGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenFunction)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenFunctionPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalFunction {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalFunction {
    const KIND: SyntaxKind = SyntaxKind::TerminalFunction;
    type TokenType = TokenFunction;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalFunction as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalFunctionGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalFunction,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalFunction {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenFunction {
        TokenFunction::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalFunctionPtr(pub SyntaxStablePtrId);
impl TerminalFunctionPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalFunctionGreen(pub GreenId);
impl TypedSyntaxNode for TerminalFunction {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalFunction);
    type StablePtr = TerminalFunctionPtr;
    type Green = TerminalFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalFunctionGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalFunction,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenFunction::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalFunction,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalFunction
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalFunctionPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenModule {
    node: SyntaxNode,
}
impl Token for TokenModule {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenModuleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenModule,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenModulePtr(pub SyntaxStablePtrId);
impl TokenModulePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenModuleGreen(pub GreenId);
impl TokenModuleGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenModule {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenModule);
    type StablePtr = TokenModulePtr;
    type Green = TokenModuleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenModuleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenModule)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenModulePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalModule {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalModule {
    const KIND: SyntaxKind = SyntaxKind::TerminalModule;
    type TokenType = TokenModule;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalModule as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalModuleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalModule,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalModule {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenModule {
        TokenModule::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalModulePtr(pub SyntaxStablePtrId);
impl TerminalModulePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalModuleGreen(pub GreenId);
impl TypedSyntaxNode for TerminalModule {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalModule);
    type StablePtr = TerminalModulePtr;
    type Green = TerminalModuleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalModuleGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalModule,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenModule::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalModule,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalModule
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalModulePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenEnum {
    node: SyntaxNode,
}
impl Token for TokenEnum {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEnumGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenEnum,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEnumPtr(pub SyntaxStablePtrId);
impl TokenEnumPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEnumGreen(pub GreenId);
impl TokenEnumGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenEnum {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEnum);
    type StablePtr = TokenEnumPtr;
    type Green = TokenEnumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenEnumGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEnum)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenEnumPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalEnum {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalEnum {
    const KIND: SyntaxKind = SyntaxKind::TerminalEnum;
    type TokenType = TokenEnum;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalEnum as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalEnumGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalEnum,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalEnum {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenEnum {
        TokenEnum::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEnumPtr(pub SyntaxStablePtrId);
impl TerminalEnumPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEnumGreen(pub GreenId);
impl TypedSyntaxNode for TerminalEnum {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEnum);
    type StablePtr = TerminalEnumPtr;
    type Green = TerminalEnumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalEnumGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalEnum,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenEnum::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEnum,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEnum
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalEnumPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenStruct {
    node: SyntaxNode,
}
impl Token for TokenStruct {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenStructGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenStruct,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenStructPtr(pub SyntaxStablePtrId);
impl TokenStructPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenStructGreen(pub GreenId);
impl TokenStructGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenStruct {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenStruct);
    type StablePtr = TokenStructPtr;
    type Green = TokenStructGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenStructGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenStruct)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenStructPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalStruct {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalStruct {
    const KIND: SyntaxKind = SyntaxKind::TerminalStruct;
    type TokenType = TokenStruct;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalStruct as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalStructGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalStruct,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalStruct {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenStruct {
        TokenStruct::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalStructPtr(pub SyntaxStablePtrId);
impl TerminalStructPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalStructGreen(pub GreenId);
impl TypedSyntaxNode for TerminalStruct {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalStruct);
    type StablePtr = TerminalStructPtr;
    type Green = TerminalStructGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalStructGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalStruct,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenStruct::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalStruct,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalStruct
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalStructPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenTrait {
    node: SyntaxNode,
}
impl Token for TokenTrait {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenTraitGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenTrait,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTraitPtr(pub SyntaxStablePtrId);
impl TokenTraitPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTraitGreen(pub GreenId);
impl TokenTraitGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenTrait {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTrait);
    type StablePtr = TokenTraitPtr;
    type Green = TokenTraitGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenTraitGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenTrait)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenTraitPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalTrait {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalTrait {
    const KIND: SyntaxKind = SyntaxKind::TerminalTrait;
    type TokenType = TokenTrait;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalTrait as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalTraitGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalTrait,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalTrait {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenTrait {
        TokenTrait::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTraitPtr(pub SyntaxStablePtrId);
impl TerminalTraitPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTraitGreen(pub GreenId);
impl TypedSyntaxNode for TerminalTrait {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalTrait);
    type StablePtr = TerminalTraitPtr;
    type Green = TerminalTraitGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalTraitGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalTrait,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenTrait::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalTrait,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalTrait
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalTraitPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenImpl {
    node: SyntaxNode,
}
impl Token for TokenImpl {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenImplGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenImpl,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenImplPtr(pub SyntaxStablePtrId);
impl TokenImplPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenImplGreen(pub GreenId);
impl TokenImplGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenImpl {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenImpl);
    type StablePtr = TokenImplPtr;
    type Green = TokenImplGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenImplGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenImpl)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenImplPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalImpl {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalImpl {
    const KIND: SyntaxKind = SyntaxKind::TerminalImpl;
    type TokenType = TokenImpl;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalImpl as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalImplGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalImpl,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalImpl {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenImpl {
        TokenImpl::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalImplPtr(pub SyntaxStablePtrId);
impl TerminalImplPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalImplGreen(pub GreenId);
impl TypedSyntaxNode for TerminalImpl {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalImpl);
    type StablePtr = TerminalImplPtr;
    type Green = TerminalImplGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalImplGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalImpl,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenImpl::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalImpl,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalImpl
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalImplPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenOf {
    node: SyntaxNode,
}
impl Token for TokenOf {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenOfGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenOf,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOfPtr(pub SyntaxStablePtrId);
impl TokenOfPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOfGreen(pub GreenId);
impl TokenOfGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenOf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenOf);
    type StablePtr = TokenOfPtr;
    type Green = TokenOfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenOfGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenOf)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenOfPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalOf {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalOf {
    const KIND: SyntaxKind = SyntaxKind::TerminalOf;
    type TokenType = TokenOf;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalOf as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalOfGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalOf,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalOf {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenOf {
        TokenOf::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOfPtr(pub SyntaxStablePtrId);
impl TerminalOfPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOfGreen(pub GreenId);
impl TypedSyntaxNode for TerminalOf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalOf);
    type StablePtr = TerminalOfPtr;
    type Green = TerminalOfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalOfGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalOf,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenOf::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalOf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalOf
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalOfPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLet {
    node: SyntaxNode,
}
impl Token for TokenLet {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLetGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenLet,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLetPtr(pub SyntaxStablePtrId);
impl TokenLetPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLetGreen(pub GreenId);
impl TokenLetGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenLet {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLet);
    type StablePtr = TokenLetPtr;
    type Green = TokenLetGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLetGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLet)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLetPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLet {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalLet {
    const KIND: SyntaxKind = SyntaxKind::TerminalLet;
    type TokenType = TokenLet;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLet as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalLetGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLet,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLet {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLet {
        TokenLet::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLetPtr(pub SyntaxStablePtrId);
impl TerminalLetPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLetGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLet {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLet);
    type StablePtr = TerminalLetPtr;
    type Green = TerminalLetGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLetGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLet,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenLet::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLet,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLet
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLetPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenReturn {
    node: SyntaxNode,
}
impl Token for TokenReturn {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenReturnGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenReturn,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenReturnPtr(pub SyntaxStablePtrId);
impl TokenReturnPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenReturnGreen(pub GreenId);
impl TokenReturnGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenReturn {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenReturn);
    type StablePtr = TokenReturnPtr;
    type Green = TokenReturnGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenReturnGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenReturn)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenReturnPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalReturn {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalReturn {
    const KIND: SyntaxKind = SyntaxKind::TerminalReturn;
    type TokenType = TokenReturn;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalReturn as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalReturnGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalReturn,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalReturn {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenReturn {
        TokenReturn::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalReturnPtr(pub SyntaxStablePtrId);
impl TerminalReturnPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalReturnGreen(pub GreenId);
impl TypedSyntaxNode for TerminalReturn {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalReturn);
    type StablePtr = TerminalReturnPtr;
    type Green = TerminalReturnGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalReturnGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalReturn,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenReturn::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalReturn,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalReturn
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalReturnPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMatch {
    node: SyntaxNode,
}
impl Token for TokenMatch {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMatchGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMatch,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMatchPtr(pub SyntaxStablePtrId);
impl TokenMatchPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMatchGreen(pub GreenId);
impl TokenMatchGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenMatch {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMatch);
    type StablePtr = TokenMatchPtr;
    type Green = TokenMatchGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMatchGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMatch)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMatchPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMatch {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalMatch {
    const KIND: SyntaxKind = SyntaxKind::TerminalMatch;
    type TokenType = TokenMatch;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMatch as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalMatchGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMatch,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMatch {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMatch {
        TokenMatch::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMatchPtr(pub SyntaxStablePtrId);
impl TerminalMatchPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMatchGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMatch {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMatch);
    type StablePtr = TerminalMatchPtr;
    type Green = TerminalMatchGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMatchGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMatch,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenMatch::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMatch,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMatch
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMatchPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenIf {
    node: SyntaxNode,
}
impl Token for TokenIf {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenIfGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenIf,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenIfPtr(pub SyntaxStablePtrId);
impl TokenIfPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenIfGreen(pub GreenId);
impl TokenIfGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenIf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenIf);
    type StablePtr = TokenIfPtr;
    type Green = TokenIfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenIfGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenIf)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenIfPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalIf {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalIf {
    const KIND: SyntaxKind = SyntaxKind::TerminalIf;
    type TokenType = TokenIf;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalIf as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalIfGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalIf,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalIf {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenIf {
        TokenIf::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalIfPtr(pub SyntaxStablePtrId);
impl TerminalIfPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalIfGreen(pub GreenId);
impl TypedSyntaxNode for TerminalIf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalIf);
    type StablePtr = TerminalIfPtr;
    type Green = TerminalIfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalIfGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalIf,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenIf::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalIf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalIf
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalIfPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenElse {
    node: SyntaxNode,
}
impl Token for TokenElse {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenElseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenElse,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenElsePtr(pub SyntaxStablePtrId);
impl TokenElsePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenElseGreen(pub GreenId);
impl TokenElseGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenElse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenElse);
    type StablePtr = TokenElsePtr;
    type Green = TokenElseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenElseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenElse)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenElsePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalElse {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalElse {
    const KIND: SyntaxKind = SyntaxKind::TerminalElse;
    type TokenType = TokenElse;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalElse as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalElseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalElse,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalElse {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenElse {
        TokenElse::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalElsePtr(pub SyntaxStablePtrId);
impl TerminalElsePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalElseGreen(pub GreenId);
impl TypedSyntaxNode for TerminalElse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalElse);
    type StablePtr = TerminalElsePtr;
    type Green = TerminalElseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalElseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalElse,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenElse::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalElse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalElse
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalElsePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenUse {
    node: SyntaxNode,
}
impl Token for TokenUse {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenUseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenUse,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenUsePtr(pub SyntaxStablePtrId);
impl TokenUsePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenUseGreen(pub GreenId);
impl TokenUseGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenUse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenUse);
    type StablePtr = TokenUsePtr;
    type Green = TokenUseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenUseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenUse)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenUsePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalUse {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalUse {
    const KIND: SyntaxKind = SyntaxKind::TerminalUse;
    type TokenType = TokenUse;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalUse as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalUseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalUse,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalUse {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenUse {
        TokenUse::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalUsePtr(pub SyntaxStablePtrId);
impl TerminalUsePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalUseGreen(pub GreenId);
impl TypedSyntaxNode for TerminalUse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalUse);
    type StablePtr = TerminalUsePtr;
    type Green = TerminalUseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalUseGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalUse,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenUse::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalUse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalUse
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalUsePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenImplicits {
    node: SyntaxNode,
}
impl Token for TokenImplicits {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenImplicitsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenImplicits,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenImplicitsPtr(pub SyntaxStablePtrId);
impl TokenImplicitsPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenImplicitsGreen(pub GreenId);
impl TokenImplicitsGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenImplicits {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenImplicits);
    type StablePtr = TokenImplicitsPtr;
    type Green = TokenImplicitsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenImplicitsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenImplicits)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenImplicitsPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalImplicits {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalImplicits {
    const KIND: SyntaxKind = SyntaxKind::TerminalImplicits;
    type TokenType = TokenImplicits;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalImplicits as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalImplicitsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalImplicits,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalImplicits {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenImplicits {
        TokenImplicits::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalImplicitsPtr(pub SyntaxStablePtrId);
impl TerminalImplicitsPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalImplicitsGreen(pub GreenId);
impl TypedSyntaxNode for TerminalImplicits {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalImplicits);
    type StablePtr = TerminalImplicitsPtr;
    type Green = TerminalImplicitsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalImplicitsGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalImplicits,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenImplicits::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalImplicits,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalImplicits
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalImplicitsPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenRef {
    node: SyntaxNode,
}
impl Token for TokenRef {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRefGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenRef,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRefPtr(pub SyntaxStablePtrId);
impl TokenRefPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRefGreen(pub GreenId);
impl TokenRefGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenRef {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRef);
    type StablePtr = TokenRefPtr;
    type Green = TokenRefGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenRefGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRef)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenRefPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalRef {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalRef {
    const KIND: SyntaxKind = SyntaxKind::TerminalRef;
    type TokenType = TokenRef;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalRef as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalRefGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalRef,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalRef {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenRef {
        TokenRef::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRefPtr(pub SyntaxStablePtrId);
impl TerminalRefPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRefGreen(pub GreenId);
impl TypedSyntaxNode for TerminalRef {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRef);
    type StablePtr = TerminalRefPtr;
    type Green = TerminalRefGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalRefGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalRef,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenRef::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRef,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRef
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalRefPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMut {
    node: SyntaxNode,
}
impl Token for TokenMut {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMutGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMut,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMutPtr(pub SyntaxStablePtrId);
impl TokenMutPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMutGreen(pub GreenId);
impl TokenMutGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenMut {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMut);
    type StablePtr = TokenMutPtr;
    type Green = TokenMutGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMutGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMut)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMutPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMut {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalMut {
    const KIND: SyntaxKind = SyntaxKind::TerminalMut;
    type TokenType = TokenMut;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMut as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalMutGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMut,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMut {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMut {
        TokenMut::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMutPtr(pub SyntaxStablePtrId);
impl TerminalMutPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMutGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMut {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMut);
    type StablePtr = TerminalMutPtr;
    type Green = TerminalMutGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMutGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMut,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenMut::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMut,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMut
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMutPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenNoPanic {
    node: SyntaxNode,
}
impl Token for TokenNoPanic {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNoPanicGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenNoPanic,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNoPanicPtr(pub SyntaxStablePtrId);
impl TokenNoPanicPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNoPanicGreen(pub GreenId);
impl TokenNoPanicGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenNoPanic {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNoPanic);
    type StablePtr = TokenNoPanicPtr;
    type Green = TokenNoPanicGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenNoPanicGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNoPanic)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenNoPanicPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalNoPanic {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalNoPanic {
    const KIND: SyntaxKind = SyntaxKind::TerminalNoPanic;
    type TokenType = TokenNoPanic;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalNoPanic as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalNoPanicGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalNoPanic,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalNoPanic {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenNoPanic {
        TokenNoPanic::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNoPanicPtr(pub SyntaxStablePtrId);
impl TerminalNoPanicPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNoPanicGreen(pub GreenId);
impl TypedSyntaxNode for TerminalNoPanic {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalNoPanic);
    type StablePtr = TerminalNoPanicPtr;
    type Green = TerminalNoPanicGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalNoPanicGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalNoPanic,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenNoPanic::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalNoPanic,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalNoPanic
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalNoPanicPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenAnd {
    node: SyntaxNode,
}
impl Token for TokenAnd {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenAndGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenAnd,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAndPtr(pub SyntaxStablePtrId);
impl TokenAndPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAndGreen(pub GreenId);
impl TokenAndGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenAnd {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenAnd);
    type StablePtr = TokenAndPtr;
    type Green = TokenAndGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenAndGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenAnd)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenAndPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalAnd {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalAnd {
    const KIND: SyntaxKind = SyntaxKind::TerminalAnd;
    type TokenType = TokenAnd;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalAnd as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalAndGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalAnd,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalAnd {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenAnd {
        TokenAnd::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAndPtr(pub SyntaxStablePtrId);
impl TerminalAndPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAndGreen(pub GreenId);
impl TypedSyntaxNode for TerminalAnd {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalAnd);
    type StablePtr = TerminalAndPtr;
    type Green = TerminalAndGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalAndGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalAnd,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenAnd::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalAnd,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalAnd
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalAndPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenAndAnd {
    node: SyntaxNode,
}
impl Token for TokenAndAnd {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenAndAndGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenAndAnd,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAndAndPtr(pub SyntaxStablePtrId);
impl TokenAndAndPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAndAndGreen(pub GreenId);
impl TokenAndAndGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenAndAnd {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenAndAnd);
    type StablePtr = TokenAndAndPtr;
    type Green = TokenAndAndGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenAndAndGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenAndAnd)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenAndAndPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalAndAnd {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalAndAnd {
    const KIND: SyntaxKind = SyntaxKind::TerminalAndAnd;
    type TokenType = TokenAndAnd;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalAndAnd as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalAndAndGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalAndAnd,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalAndAnd {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenAndAnd {
        TokenAndAnd::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAndAndPtr(pub SyntaxStablePtrId);
impl TerminalAndAndPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAndAndGreen(pub GreenId);
impl TypedSyntaxNode for TerminalAndAnd {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalAndAnd);
    type StablePtr = TerminalAndAndPtr;
    type Green = TerminalAndAndGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalAndAndGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalAndAnd,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenAndAnd::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalAndAnd,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalAndAnd
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalAndAndPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenOr {
    node: SyntaxNode,
}
impl Token for TokenOr {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenOrGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenOr,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOrPtr(pub SyntaxStablePtrId);
impl TokenOrPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOrGreen(pub GreenId);
impl TokenOrGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenOr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenOr);
    type StablePtr = TokenOrPtr;
    type Green = TokenOrGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenOrGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenOr)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenOrPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalOr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalOr {
    const KIND: SyntaxKind = SyntaxKind::TerminalOr;
    type TokenType = TokenOr;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalOr as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalOrGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalOr,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalOr {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenOr {
        TokenOr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOrPtr(pub SyntaxStablePtrId);
impl TerminalOrPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOrGreen(pub GreenId);
impl TypedSyntaxNode for TerminalOr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalOr);
    type StablePtr = TerminalOrPtr;
    type Green = TerminalOrGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalOrGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalOr,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenOr::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalOr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalOr
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalOrPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenOrOr {
    node: SyntaxNode,
}
impl Token for TokenOrOr {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenOrOrGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenOrOr,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOrOrPtr(pub SyntaxStablePtrId);
impl TokenOrOrPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOrOrGreen(pub GreenId);
impl TokenOrOrGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenOrOr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenOrOr);
    type StablePtr = TokenOrOrPtr;
    type Green = TokenOrOrGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenOrOrGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenOrOr)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenOrOrPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalOrOr {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalOrOr {
    const KIND: SyntaxKind = SyntaxKind::TerminalOrOr;
    type TokenType = TokenOrOr;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalOrOr as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalOrOrGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalOrOr,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalOrOr {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenOrOr {
        TokenOrOr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOrOrPtr(pub SyntaxStablePtrId);
impl TerminalOrOrPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOrOrGreen(pub GreenId);
impl TypedSyntaxNode for TerminalOrOr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalOrOr);
    type StablePtr = TerminalOrOrPtr;
    type Green = TerminalOrOrGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalOrOrGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalOrOr,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenOrOr::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalOrOr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalOrOr
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalOrOrPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenEqEq {
    node: SyntaxNode,
}
impl Token for TokenEqEq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEqEqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenEqEq,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEqEqPtr(pub SyntaxStablePtrId);
impl TokenEqEqPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEqEqGreen(pub GreenId);
impl TokenEqEqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenEqEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEqEq);
    type StablePtr = TokenEqEqPtr;
    type Green = TokenEqEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenEqEqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEqEq)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenEqEqPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalEqEq {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalEqEq {
    const KIND: SyntaxKind = SyntaxKind::TerminalEqEq;
    type TokenType = TokenEqEq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalEqEq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalEqEqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalEqEq,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalEqEq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenEqEq {
        TokenEqEq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEqEqPtr(pub SyntaxStablePtrId);
impl TerminalEqEqPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEqEqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalEqEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEqEq);
    type StablePtr = TerminalEqEqPtr;
    type Green = TerminalEqEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalEqEqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalEqEq,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenEqEq::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEqEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEqEq
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalEqEqPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenNeq {
    node: SyntaxNode,
}
impl Token for TokenNeq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNeqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenNeq,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNeqPtr(pub SyntaxStablePtrId);
impl TokenNeqPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNeqGreen(pub GreenId);
impl TokenNeqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenNeq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNeq);
    type StablePtr = TokenNeqPtr;
    type Green = TokenNeqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenNeqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNeq)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenNeqPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalNeq {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalNeq {
    const KIND: SyntaxKind = SyntaxKind::TerminalNeq;
    type TokenType = TokenNeq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalNeq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalNeqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalNeq,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalNeq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenNeq {
        TokenNeq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNeqPtr(pub SyntaxStablePtrId);
impl TerminalNeqPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNeqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalNeq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalNeq);
    type StablePtr = TerminalNeqPtr;
    type Green = TerminalNeqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalNeqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalNeq,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenNeq::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalNeq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalNeq
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalNeqPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenGE {
    node: SyntaxNode,
}
impl Token for TokenGE {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenGEGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenGE,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenGEPtr(pub SyntaxStablePtrId);
impl TokenGEPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenGEGreen(pub GreenId);
impl TokenGEGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenGE {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenGE);
    type StablePtr = TokenGEPtr;
    type Green = TokenGEGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenGEGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenGE)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenGEPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalGE {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalGE {
    const KIND: SyntaxKind = SyntaxKind::TerminalGE;
    type TokenType = TokenGE;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalGE as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalGEGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalGE,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalGE {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenGE {
        TokenGE::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalGEPtr(pub SyntaxStablePtrId);
impl TerminalGEPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalGEGreen(pub GreenId);
impl TypedSyntaxNode for TerminalGE {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalGE);
    type StablePtr = TerminalGEPtr;
    type Green = TerminalGEGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalGEGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalGE,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenGE::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalGE,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalGE
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalGEPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenGT {
    node: SyntaxNode,
}
impl Token for TokenGT {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenGTGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenGT,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenGTPtr(pub SyntaxStablePtrId);
impl TokenGTPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenGTGreen(pub GreenId);
impl TokenGTGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenGT {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenGT);
    type StablePtr = TokenGTPtr;
    type Green = TokenGTGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenGTGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenGT)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenGTPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalGT {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalGT {
    const KIND: SyntaxKind = SyntaxKind::TerminalGT;
    type TokenType = TokenGT;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalGT as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalGTGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalGT,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalGT {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenGT {
        TokenGT::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalGTPtr(pub SyntaxStablePtrId);
impl TerminalGTPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalGTGreen(pub GreenId);
impl TypedSyntaxNode for TerminalGT {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalGT);
    type StablePtr = TerminalGTPtr;
    type Green = TerminalGTGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalGTGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalGT,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenGT::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalGT,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalGT
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalGTPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLE {
    node: SyntaxNode,
}
impl Token for TokenLE {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLEGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenLE,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLEPtr(pub SyntaxStablePtrId);
impl TokenLEPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLEGreen(pub GreenId);
impl TokenLEGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenLE {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLE);
    type StablePtr = TokenLEPtr;
    type Green = TokenLEGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLEGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLE)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLEPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLE {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalLE {
    const KIND: SyntaxKind = SyntaxKind::TerminalLE;
    type TokenType = TokenLE;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLE as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalLEGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLE,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLE {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLE {
        TokenLE::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLEPtr(pub SyntaxStablePtrId);
impl TerminalLEPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLEGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLE {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLE);
    type StablePtr = TerminalLEPtr;
    type Green = TerminalLEGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLEGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLE,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenLE::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLE,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLE
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLEPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLT {
    node: SyntaxNode,
}
impl Token for TokenLT {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLTGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenLT,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLTPtr(pub SyntaxStablePtrId);
impl TokenLTPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLTGreen(pub GreenId);
impl TokenLTGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenLT {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLT);
    type StablePtr = TokenLTPtr;
    type Green = TokenLTGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLTGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLT)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLTPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLT {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalLT {
    const KIND: SyntaxKind = SyntaxKind::TerminalLT;
    type TokenType = TokenLT;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLT as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalLTGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLT,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLT {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLT {
        TokenLT::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLTPtr(pub SyntaxStablePtrId);
impl TerminalLTPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLTGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLT {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLT);
    type StablePtr = TerminalLTPtr;
    type Green = TerminalLTGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLTGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLT,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenLT::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLT,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLT
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLTPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenNot {
    node: SyntaxNode,
}
impl Token for TokenNot {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenNot,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNotPtr(pub SyntaxStablePtrId);
impl TokenNotPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNotGreen(pub GreenId);
impl TokenNotGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenNot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNot);
    type StablePtr = TokenNotPtr;
    type Green = TokenNotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenNotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNot)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenNotPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalNot {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalNot {
    const KIND: SyntaxKind = SyntaxKind::TerminalNot;
    type TokenType = TokenNot;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalNot as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalNotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalNot,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalNot {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenNot {
        TokenNot::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNotPtr(pub SyntaxStablePtrId);
impl TerminalNotPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNotGreen(pub GreenId);
impl TypedSyntaxNode for TerminalNot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalNot);
    type StablePtr = TerminalNotPtr;
    type Green = TerminalNotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalNotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalNot,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenNot::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalNot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalNot
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalNotPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenPlus {
    node: SyntaxNode,
}
impl Token for TokenPlus {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenPlusGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenPlus,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenPlusPtr(pub SyntaxStablePtrId);
impl TokenPlusPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenPlusGreen(pub GreenId);
impl TokenPlusGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenPlus {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenPlus);
    type StablePtr = TokenPlusPtr;
    type Green = TokenPlusGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenPlusGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenPlus)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenPlusPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalPlus {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalPlus {
    const KIND: SyntaxKind = SyntaxKind::TerminalPlus;
    type TokenType = TokenPlus;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalPlus as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalPlusGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalPlus,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalPlus {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenPlus {
        TokenPlus::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalPlusPtr(pub SyntaxStablePtrId);
impl TerminalPlusPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalPlusGreen(pub GreenId);
impl TypedSyntaxNode for TerminalPlus {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalPlus);
    type StablePtr = TerminalPlusPtr;
    type Green = TerminalPlusGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalPlusGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalPlus,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenPlus::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalPlus,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalPlus
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalPlusPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMinus {
    node: SyntaxNode,
}
impl Token for TokenMinus {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMinusGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMinus,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMinusPtr(pub SyntaxStablePtrId);
impl TokenMinusPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMinusGreen(pub GreenId);
impl TokenMinusGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenMinus {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMinus);
    type StablePtr = TokenMinusPtr;
    type Green = TokenMinusGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMinusGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMinus)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMinusPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMinus {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalMinus {
    const KIND: SyntaxKind = SyntaxKind::TerminalMinus;
    type TokenType = TokenMinus;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMinus as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalMinusGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMinus,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMinus {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMinus {
        TokenMinus::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMinusPtr(pub SyntaxStablePtrId);
impl TerminalMinusPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMinusGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMinus {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMinus);
    type StablePtr = TerminalMinusPtr;
    type Green = TerminalMinusGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMinusGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMinus,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenMinus::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMinus,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMinus
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMinusPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMul {
    node: SyntaxNode,
}
impl Token for TokenMul {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMulGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMul,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMulPtr(pub SyntaxStablePtrId);
impl TokenMulPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMulGreen(pub GreenId);
impl TokenMulGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenMul {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMul);
    type StablePtr = TokenMulPtr;
    type Green = TokenMulGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMulGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMul)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMulPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMul {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalMul {
    const KIND: SyntaxKind = SyntaxKind::TerminalMul;
    type TokenType = TokenMul;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMul as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalMulGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMul,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMul {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMul {
        TokenMul::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMulPtr(pub SyntaxStablePtrId);
impl TerminalMulPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMulGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMul {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMul);
    type StablePtr = TerminalMulPtr;
    type Green = TerminalMulGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMulGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMul,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenMul::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMul,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMul
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMulPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenDiv {
    node: SyntaxNode,
}
impl Token for TokenDiv {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDivGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenDiv,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDivPtr(pub SyntaxStablePtrId);
impl TokenDivPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDivGreen(pub GreenId);
impl TokenDivGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenDiv {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDiv);
    type StablePtr = TokenDivPtr;
    type Green = TokenDivGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenDivGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDiv)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenDivPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalDiv {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalDiv {
    const KIND: SyntaxKind = SyntaxKind::TerminalDiv;
    type TokenType = TokenDiv;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalDiv as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalDivGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalDiv,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalDiv {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenDiv {
        TokenDiv::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDivPtr(pub SyntaxStablePtrId);
impl TerminalDivPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDivGreen(pub GreenId);
impl TypedSyntaxNode for TerminalDiv {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDiv);
    type StablePtr = TerminalDivPtr;
    type Green = TerminalDivGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalDivGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalDiv,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenDiv::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDiv,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDiv
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalDivPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMod {
    node: SyntaxNode,
}
impl Token for TokenMod {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenModGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMod,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenModPtr(pub SyntaxStablePtrId);
impl TokenModPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenModGreen(pub GreenId);
impl TokenModGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenMod {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMod);
    type StablePtr = TokenModPtr;
    type Green = TokenModGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenModGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMod)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenModPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMod {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalMod {
    const KIND: SyntaxKind = SyntaxKind::TerminalMod;
    type TokenType = TokenMod;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMod as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalModGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMod,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMod {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMod {
        TokenMod::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalModPtr(pub SyntaxStablePtrId);
impl TerminalModPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalModGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMod {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMod);
    type StablePtr = TerminalModPtr;
    type Green = TerminalModGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalModGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMod,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenMod::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMod,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMod
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalModPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenColon {
    node: SyntaxNode,
}
impl Token for TokenColon {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenColonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenColon,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenColonPtr(pub SyntaxStablePtrId);
impl TokenColonPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenColonGreen(pub GreenId);
impl TokenColonGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenColon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenColon);
    type StablePtr = TokenColonPtr;
    type Green = TokenColonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenColonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenColon)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenColonPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalColon {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalColon {
    const KIND: SyntaxKind = SyntaxKind::TerminalColon;
    type TokenType = TokenColon;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalColon as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalColonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalColon,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalColon {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenColon {
        TokenColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalColonPtr(pub SyntaxStablePtrId);
impl TerminalColonPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalColonGreen(pub GreenId);
impl TypedSyntaxNode for TerminalColon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalColon);
    type StablePtr = TerminalColonPtr;
    type Green = TerminalColonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalColonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalColon,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenColon::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalColon,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalColon
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalColonPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenColonColon {
    node: SyntaxNode,
}
impl Token for TokenColonColon {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenColonColonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenColonColon,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenColonColonPtr(pub SyntaxStablePtrId);
impl TokenColonColonPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenColonColonGreen(pub GreenId);
impl TokenColonColonGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenColonColon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenColonColon);
    type StablePtr = TokenColonColonPtr;
    type Green = TokenColonColonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenColonColonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenColonColon)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenColonColonPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalColonColon {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalColonColon {
    const KIND: SyntaxKind = SyntaxKind::TerminalColonColon;
    type TokenType = TokenColonColon;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalColonColon as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalColonColonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalColonColon,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalColonColon {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenColonColon {
        TokenColonColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalColonColonPtr(pub SyntaxStablePtrId);
impl TerminalColonColonPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalColonColonGreen(pub GreenId);
impl TypedSyntaxNode for TerminalColonColon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalColonColon);
    type StablePtr = TerminalColonColonPtr;
    type Green = TerminalColonColonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalColonColonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalColonColon,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenColonColon::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalColonColon,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalColonColon
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalColonColonPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenComma {
    node: SyntaxNode,
}
impl Token for TokenComma {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenCommaGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenComma,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenCommaPtr(pub SyntaxStablePtrId);
impl TokenCommaPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenCommaGreen(pub GreenId);
impl TokenCommaGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenComma {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenComma);
    type StablePtr = TokenCommaPtr;
    type Green = TokenCommaGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenCommaGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenComma)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenCommaPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalComma {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalComma {
    const KIND: SyntaxKind = SyntaxKind::TerminalComma;
    type TokenType = TokenComma;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalComma as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalCommaGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalComma,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalComma {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenComma {
        TokenComma::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalCommaPtr(pub SyntaxStablePtrId);
impl TerminalCommaPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalCommaGreen(pub GreenId);
impl TypedSyntaxNode for TerminalComma {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalComma);
    type StablePtr = TerminalCommaPtr;
    type Green = TerminalCommaGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalCommaGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalComma,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenComma::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalComma,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalComma
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalCommaPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenDot {
    node: SyntaxNode,
}
impl Token for TokenDot {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenDot,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDotPtr(pub SyntaxStablePtrId);
impl TokenDotPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDotGreen(pub GreenId);
impl TokenDotGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenDot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDot);
    type StablePtr = TokenDotPtr;
    type Green = TokenDotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenDotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDot)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenDotPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalDot {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalDot {
    const KIND: SyntaxKind = SyntaxKind::TerminalDot;
    type TokenType = TokenDot;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalDot as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalDotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalDot,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalDot {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenDot {
        TokenDot::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDotPtr(pub SyntaxStablePtrId);
impl TerminalDotPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDotGreen(pub GreenId);
impl TypedSyntaxNode for TerminalDot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDot);
    type StablePtr = TerminalDotPtr;
    type Green = TerminalDotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalDotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalDot,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenDot::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDot
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalDotPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenDotDot {
    node: SyntaxNode,
}
impl Token for TokenDotDot {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDotDotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenDotDot,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDotDotPtr(pub SyntaxStablePtrId);
impl TokenDotDotPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDotDotGreen(pub GreenId);
impl TokenDotDotGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenDotDot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDotDot);
    type StablePtr = TokenDotDotPtr;
    type Green = TokenDotDotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenDotDotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDotDot)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenDotDotPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalDotDot {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalDotDot {
    const KIND: SyntaxKind = SyntaxKind::TerminalDotDot;
    type TokenType = TokenDotDot;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalDotDot as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalDotDotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalDotDot,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalDotDot {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenDotDot {
        TokenDotDot::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDotDotPtr(pub SyntaxStablePtrId);
impl TerminalDotDotPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDotDotGreen(pub GreenId);
impl TypedSyntaxNode for TerminalDotDot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDotDot);
    type StablePtr = TerminalDotDotPtr;
    type Green = TerminalDotDotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalDotDotGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalDotDot,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenDotDot::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDotDot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDotDot
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalDotDotPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenEq {
    node: SyntaxNode,
}
impl Token for TokenEq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenEq,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEqPtr(pub SyntaxStablePtrId);
impl TokenEqPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEqGreen(pub GreenId);
impl TokenEqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEq);
    type StablePtr = TokenEqPtr;
    type Green = TokenEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenEqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEq)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenEqPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalEq {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalEq {
    const KIND: SyntaxKind = SyntaxKind::TerminalEq;
    type TokenType = TokenEq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalEq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalEqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalEq,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalEq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenEq {
        TokenEq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEqPtr(pub SyntaxStablePtrId);
impl TerminalEqPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEq);
    type StablePtr = TerminalEqPtr;
    type Green = TerminalEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalEqGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalEq,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenEq::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEq
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalEqPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenSemicolon {
    node: SyntaxNode,
}
impl Token for TokenSemicolon {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSemicolonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenSemicolon,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSemicolonPtr(pub SyntaxStablePtrId);
impl TokenSemicolonPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSemicolonGreen(pub GreenId);
impl TokenSemicolonGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenSemicolon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSemicolon);
    type StablePtr = TokenSemicolonPtr;
    type Green = TokenSemicolonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenSemicolonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenSemicolon)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenSemicolonPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalSemicolon {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalSemicolon {
    const KIND: SyntaxKind = SyntaxKind::TerminalSemicolon;
    type TokenType = TokenSemicolon;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalSemicolon as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalSemicolonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalSemicolon,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalSemicolon {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenSemicolon {
        TokenSemicolon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalSemicolonPtr(pub SyntaxStablePtrId);
impl TerminalSemicolonPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalSemicolonGreen(pub GreenId);
impl TypedSyntaxNode for TerminalSemicolon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalSemicolon);
    type StablePtr = TerminalSemicolonPtr;
    type Green = TerminalSemicolonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalSemicolonGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalSemicolon,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenSemicolon::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalSemicolon,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalSemicolon
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalSemicolonPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenQuestionMark {
    node: SyntaxNode,
}
impl Token for TokenQuestionMark {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenQuestionMarkGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenQuestionMark,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenQuestionMarkPtr(pub SyntaxStablePtrId);
impl TokenQuestionMarkPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenQuestionMarkGreen(pub GreenId);
impl TokenQuestionMarkGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenQuestionMark {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenQuestionMark);
    type StablePtr = TokenQuestionMarkPtr;
    type Green = TokenQuestionMarkGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenQuestionMarkGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenQuestionMark)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenQuestionMarkPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalQuestionMark {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalQuestionMark {
    const KIND: SyntaxKind = SyntaxKind::TerminalQuestionMark;
    type TokenType = TokenQuestionMark;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalQuestionMark as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalQuestionMarkGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalQuestionMark,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalQuestionMark {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenQuestionMark {
        TokenQuestionMark::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalQuestionMarkPtr(pub SyntaxStablePtrId);
impl TerminalQuestionMarkPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalQuestionMarkGreen(pub GreenId);
impl TypedSyntaxNode for TerminalQuestionMark {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalQuestionMark);
    type StablePtr = TerminalQuestionMarkPtr;
    type Green = TerminalQuestionMarkGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalQuestionMarkGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalQuestionMark,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenQuestionMark::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalQuestionMark,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalQuestionMark
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalQuestionMarkPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenUnderscore {
    node: SyntaxNode,
}
impl Token for TokenUnderscore {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenUnderscoreGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenUnderscore,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenUnderscorePtr(pub SyntaxStablePtrId);
impl TokenUnderscorePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenUnderscoreGreen(pub GreenId);
impl TokenUnderscoreGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenUnderscore {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenUnderscore);
    type StablePtr = TokenUnderscorePtr;
    type Green = TokenUnderscoreGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenUnderscoreGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenUnderscore)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenUnderscorePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalUnderscore {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalUnderscore {
    const KIND: SyntaxKind = SyntaxKind::TerminalUnderscore;
    type TokenType = TokenUnderscore;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalUnderscore as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalUnderscoreGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalUnderscore,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalUnderscore {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenUnderscore {
        TokenUnderscore::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalUnderscorePtr(pub SyntaxStablePtrId);
impl TerminalUnderscorePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalUnderscoreGreen(pub GreenId);
impl TypedSyntaxNode for TerminalUnderscore {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalUnderscore);
    type StablePtr = TerminalUnderscorePtr;
    type Green = TerminalUnderscoreGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalUnderscoreGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalUnderscore,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenUnderscore::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalUnderscore,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalUnderscore
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalUnderscorePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLBrace {
    node: SyntaxNode,
}
impl Token for TokenLBrace {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLBraceGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenLBrace,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLBracePtr(pub SyntaxStablePtrId);
impl TokenLBracePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLBraceGreen(pub GreenId);
impl TokenLBraceGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenLBrace {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLBrace);
    type StablePtr = TokenLBracePtr;
    type Green = TokenLBraceGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLBraceGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLBrace)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLBracePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLBrace {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalLBrace {
    const KIND: SyntaxKind = SyntaxKind::TerminalLBrace;
    type TokenType = TokenLBrace;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLBrace as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalLBraceGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLBrace,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLBrace {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLBrace {
        TokenLBrace::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLBracePtr(pub SyntaxStablePtrId);
impl TerminalLBracePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLBraceGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLBrace {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLBrace);
    type StablePtr = TerminalLBracePtr;
    type Green = TerminalLBraceGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLBraceGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLBrace,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenLBrace::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLBrace,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLBrace
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLBracePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenRBrace {
    node: SyntaxNode,
}
impl Token for TokenRBrace {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRBraceGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenRBrace,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRBracePtr(pub SyntaxStablePtrId);
impl TokenRBracePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRBraceGreen(pub GreenId);
impl TokenRBraceGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenRBrace {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRBrace);
    type StablePtr = TokenRBracePtr;
    type Green = TokenRBraceGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenRBraceGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRBrace)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenRBracePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalRBrace {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalRBrace {
    const KIND: SyntaxKind = SyntaxKind::TerminalRBrace;
    type TokenType = TokenRBrace;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalRBrace as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalRBraceGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalRBrace,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalRBrace {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenRBrace {
        TokenRBrace::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRBracePtr(pub SyntaxStablePtrId);
impl TerminalRBracePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRBraceGreen(pub GreenId);
impl TypedSyntaxNode for TerminalRBrace {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRBrace);
    type StablePtr = TerminalRBracePtr;
    type Green = TerminalRBraceGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalRBraceGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalRBrace,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenRBrace::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRBrace,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRBrace
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalRBracePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLBrack {
    node: SyntaxNode,
}
impl Token for TokenLBrack {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLBrackGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenLBrack,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLBrackPtr(pub SyntaxStablePtrId);
impl TokenLBrackPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLBrackGreen(pub GreenId);
impl TokenLBrackGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenLBrack {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLBrack);
    type StablePtr = TokenLBrackPtr;
    type Green = TokenLBrackGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLBrackGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLBrack)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLBrackPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLBrack {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalLBrack {
    const KIND: SyntaxKind = SyntaxKind::TerminalLBrack;
    type TokenType = TokenLBrack;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLBrack as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalLBrackGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLBrack,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLBrack {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLBrack {
        TokenLBrack::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLBrackPtr(pub SyntaxStablePtrId);
impl TerminalLBrackPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLBrackGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLBrack {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLBrack);
    type StablePtr = TerminalLBrackPtr;
    type Green = TerminalLBrackGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLBrackGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLBrack,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenLBrack::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLBrack,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLBrack
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLBrackPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenRBrack {
    node: SyntaxNode,
}
impl Token for TokenRBrack {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRBrackGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenRBrack,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRBrackPtr(pub SyntaxStablePtrId);
impl TokenRBrackPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRBrackGreen(pub GreenId);
impl TokenRBrackGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenRBrack {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRBrack);
    type StablePtr = TokenRBrackPtr;
    type Green = TokenRBrackGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenRBrackGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRBrack)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenRBrackPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalRBrack {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalRBrack {
    const KIND: SyntaxKind = SyntaxKind::TerminalRBrack;
    type TokenType = TokenRBrack;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalRBrack as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalRBrackGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalRBrack,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalRBrack {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenRBrack {
        TokenRBrack::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRBrackPtr(pub SyntaxStablePtrId);
impl TerminalRBrackPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRBrackGreen(pub GreenId);
impl TypedSyntaxNode for TerminalRBrack {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRBrack);
    type StablePtr = TerminalRBrackPtr;
    type Green = TerminalRBrackGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalRBrackGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalRBrack,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenRBrack::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRBrack,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRBrack
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalRBrackPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLParen {
    node: SyntaxNode,
}
impl Token for TokenLParen {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLParenGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenLParen,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLParenPtr(pub SyntaxStablePtrId);
impl TokenLParenPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLParenGreen(pub GreenId);
impl TokenLParenGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenLParen {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLParen);
    type StablePtr = TokenLParenPtr;
    type Green = TokenLParenGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLParenGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLParen)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLParenPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLParen {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalLParen {
    const KIND: SyntaxKind = SyntaxKind::TerminalLParen;
    type TokenType = TokenLParen;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLParen as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalLParenGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLParen,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLParen {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLParen {
        TokenLParen::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLParenPtr(pub SyntaxStablePtrId);
impl TerminalLParenPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLParenGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLParen {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLParen);
    type StablePtr = TerminalLParenPtr;
    type Green = TerminalLParenGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLParenGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalLParen,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenLParen::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLParen,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLParen
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLParenPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenRParen {
    node: SyntaxNode,
}
impl Token for TokenRParen {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRParenGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenRParen,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRParenPtr(pub SyntaxStablePtrId);
impl TokenRParenPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRParenGreen(pub GreenId);
impl TokenRParenGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenRParen {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRParen);
    type StablePtr = TokenRParenPtr;
    type Green = TokenRParenGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenRParenGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRParen)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenRParenPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalRParen {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalRParen {
    const KIND: SyntaxKind = SyntaxKind::TerminalRParen;
    type TokenType = TokenRParen;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalRParen as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalRParenGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalRParen,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalRParen {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenRParen {
        TokenRParen::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRParenPtr(pub SyntaxStablePtrId);
impl TerminalRParenPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRParenGreen(pub GreenId);
impl TypedSyntaxNode for TerminalRParen {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRParen);
    type StablePtr = TerminalRParenPtr;
    type Green = TerminalRParenGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalRParenGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalRParen,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenRParen::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRParen,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRParen
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalRParenPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenArrow {
    node: SyntaxNode,
}
impl Token for TokenArrow {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenArrowGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenArrow,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenArrowPtr(pub SyntaxStablePtrId);
impl TokenArrowPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenArrowGreen(pub GreenId);
impl TokenArrowGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenArrow {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenArrow);
    type StablePtr = TokenArrowPtr;
    type Green = TokenArrowGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenArrowGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenArrow)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenArrowPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalArrow {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalArrow {
    const KIND: SyntaxKind = SyntaxKind::TerminalArrow;
    type TokenType = TokenArrow;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalArrow as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalArrowGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalArrow,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalArrow {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenArrow {
        TokenArrow::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalArrowPtr(pub SyntaxStablePtrId);
impl TerminalArrowPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalArrowGreen(pub GreenId);
impl TypedSyntaxNode for TerminalArrow {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalArrow);
    type StablePtr = TerminalArrowPtr;
    type Green = TerminalArrowGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalArrowGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalArrow,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenArrow::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalArrow,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalArrow
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalArrowPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMatchArrow {
    node: SyntaxNode,
}
impl Token for TokenMatchArrow {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMatchArrowGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMatchArrow,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMatchArrowPtr(pub SyntaxStablePtrId);
impl TokenMatchArrowPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMatchArrowGreen(pub GreenId);
impl TokenMatchArrowGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenMatchArrow {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMatchArrow);
    type StablePtr = TokenMatchArrowPtr;
    type Green = TokenMatchArrowGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMatchArrowGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMatchArrow)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMatchArrowPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMatchArrow {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalMatchArrow {
    const KIND: SyntaxKind = SyntaxKind::TerminalMatchArrow;
    type TokenType = TokenMatchArrow;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMatchArrow as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalMatchArrowGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMatchArrow,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMatchArrow {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMatchArrow {
        TokenMatchArrow::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMatchArrowPtr(pub SyntaxStablePtrId);
impl TerminalMatchArrowPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMatchArrowGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMatchArrow {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMatchArrow);
    type StablePtr = TerminalMatchArrowPtr;
    type Green = TerminalMatchArrowGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMatchArrowGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalMatchArrow,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenMatchArrow::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMatchArrow,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMatchArrow
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMatchArrowPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenEndOfFile {
    node: SyntaxNode,
}
impl Token for TokenEndOfFile {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEndOfFileGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenEndOfFile,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEndOfFilePtr(pub SyntaxStablePtrId);
impl TokenEndOfFilePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEndOfFileGreen(pub GreenId);
impl TokenEndOfFileGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenEndOfFile {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEndOfFile);
    type StablePtr = TokenEndOfFilePtr;
    type Green = TokenEndOfFileGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenEndOfFileGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEndOfFile)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenEndOfFilePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalEndOfFile {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalEndOfFile {
    const KIND: SyntaxKind = SyntaxKind::TerminalEndOfFile;
    type TokenType = TokenEndOfFile;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalEndOfFile as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalEndOfFileGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalEndOfFile,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalEndOfFile {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenEndOfFile {
        TokenEndOfFile::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEndOfFilePtr(pub SyntaxStablePtrId);
impl TerminalEndOfFilePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEndOfFileGreen(pub GreenId);
impl TypedSyntaxNode for TerminalEndOfFile {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEndOfFile);
    type StablePtr = TerminalEndOfFilePtr;
    type Green = TerminalEndOfFileGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalEndOfFileGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalEndOfFile,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenEndOfFile::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEndOfFile,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEndOfFile
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalEndOfFilePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenBadCharacters {
    node: SyntaxNode,
}
impl Token for TokenBadCharacters {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenBadCharactersGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenBadCharacters,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenBadCharactersPtr(pub SyntaxStablePtrId);
impl TokenBadCharactersPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenBadCharactersGreen(pub GreenId);
impl TokenBadCharactersGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenBadCharacters {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenBadCharacters);
    type StablePtr = TokenBadCharactersPtr;
    type Green = TokenBadCharactersGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenBadCharactersGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenBadCharacters
            ),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenBadCharactersPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalBadCharacters {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalBadCharacters {
    const KIND: SyntaxKind = SyntaxKind::TerminalBadCharacters;
    type TokenType = TokenBadCharacters;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalBadCharacters as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalBadCharactersGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalBadCharacters,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalBadCharacters {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenBadCharacters {
        TokenBadCharacters::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalBadCharactersPtr(pub SyntaxStablePtrId);
impl TerminalBadCharactersPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalBadCharactersGreen(pub GreenId);
impl TypedSyntaxNode for TerminalBadCharacters {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalBadCharacters);
    type StablePtr = TerminalBadCharactersPtr;
    type Green = TerminalBadCharactersGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalBadCharactersGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalBadCharacters,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenBadCharacters::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalBadCharacters,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalBadCharacters
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalBadCharactersPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenHash {
    node: SyntaxNode,
}
impl Token for TokenHash {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenHashGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenHash,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenHashPtr(pub SyntaxStablePtrId);
impl TokenHashPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenHashGreen(pub GreenId);
impl TokenHashGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenHash {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenHash);
    type StablePtr = TokenHashPtr;
    type Green = TokenHashGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenHashGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenHash)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenHashPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalHash {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal for TerminalHash {
    const KIND: SyntaxKind = SyntaxKind::TerminalHash;
    type TokenType = TokenHash;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalHash as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        TerminalHashGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalHash,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalHash {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenHash {
        TokenHash::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalHashPtr(pub SyntaxStablePtrId);
impl TerminalHashPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalHashGreen(pub GreenId);
impl TypedSyntaxNode for TerminalHash {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalHash);
    type StablePtr = TerminalHashPtr;
    type Green = TerminalHashGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalHashGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TerminalHash,
            details: GreenNodeDetails::Node {
                children: vec![
                    Trivia::missing(db).0,
                    TokenHash::missing(db).0,
                    Trivia::missing(db).0,
                ],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalHash,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalHash
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalHashPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct SyntaxFile {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl SyntaxFile {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        items: ItemListGreen,
        eof: TerminalEndOfFileGreen,
    ) -> SyntaxFileGreen {
        let children: Vec<GreenId> = vec![items.0, eof.0];
        let width = children.iter().copied().map(|id| db.lookup_intern_green(id).width()).sum();
        SyntaxFileGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::SyntaxFile,
            details: GreenNodeDetails::Node { children, width },
        }))
    }
}
impl SyntaxFile {
    pub fn items(&self, db: &dyn SyntaxGroup) -> ItemList {
        ItemList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn eof(&self, db: &dyn SyntaxGroup) -> TerminalEndOfFile {
        TerminalEndOfFile::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct SyntaxFilePtr(pub SyntaxStablePtrId);
impl SyntaxFilePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct SyntaxFileGreen(pub GreenId);
impl TypedSyntaxNode for SyntaxFile {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::SyntaxFile);
    type StablePtr = SyntaxFilePtr;
    type Green = SyntaxFileGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        SyntaxFileGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::SyntaxFile,
            details: GreenNodeDetails::Node {
                children: vec![ItemList::missing(db).0, TerminalEndOfFile::missing(db).0],
                width: 0,
            },
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::SyntaxFile,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::SyntaxFile
        );
        let children = node.children(db).collect();
        Self { node, children }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        SyntaxFilePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenSingleLineComment {
    node: SyntaxNode,
}
impl Token for TokenSingleLineComment {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSingleLineCommentGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenSingleLineComment,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSingleLineCommentPtr(pub SyntaxStablePtrId);
impl TokenSingleLineCommentPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSingleLineCommentGreen(pub GreenId);
impl TokenSingleLineCommentGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenSingleLineComment {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSingleLineComment);
    type StablePtr = TokenSingleLineCommentPtr;
    type Green = TokenSingleLineCommentGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenSingleLineCommentGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenSingleLineComment
            ),
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenSingleLineCommentPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenWhitespace {
    node: SyntaxNode,
}
impl Token for TokenWhitespace {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenWhitespaceGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenWhitespace,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenWhitespacePtr(pub SyntaxStablePtrId);
impl TokenWhitespacePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenWhitespaceGreen(pub GreenId);
impl TokenWhitespaceGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenWhitespace {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenWhitespace);
    type StablePtr = TokenWhitespacePtr;
    type Green = TokenWhitespaceGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenWhitespaceGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenWhitespace)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenWhitespacePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenNewline {
    node: SyntaxNode,
}
impl Token for TokenNewline {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNewlineGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenNewline,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNewlinePtr(pub SyntaxStablePtrId);
impl TokenNewlinePtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNewlineGreen(pub GreenId);
impl TokenNewlineGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenNewline {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNewline);
    type StablePtr = TokenNewlinePtr;
    type Green = TokenNewlineGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenNewlineGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNewline)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenNewlinePtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMissing {
    node: SyntaxNode,
}
impl Token for TokenMissing {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMissingGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMissingPtr(pub SyntaxStablePtrId);
impl TokenMissingPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMissingGreen(pub GreenId);
impl TokenMissingGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenMissing {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMissing);
    type StablePtr = TokenMissingPtr;
    type Green = TokenMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMissingGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMissing)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMissingPtr(self.node.0.stable_ptr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenSkipped {
    node: SyntaxNode,
}
impl Token for TokenSkipped {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSkippedGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenSkipped,
            details: GreenNodeDetails::Token(text),
        }))
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.node.0.green).details, GreenNodeDetails::Token)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSkippedPtr(pub SyntaxStablePtrId);
impl TokenSkippedPtr {
    pub fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSkippedGreen(pub GreenId);
impl TokenSkippedGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(db.lookup_intern_green(self.0).details, GreenNodeDetails::Token)
    }
}
impl TypedSyntaxNode for TokenSkipped {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSkipped);
    type StablePtr = TokenSkippedPtr;
    type Green = TokenSkippedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenSkippedGreen(db.intern_green(GreenNode {
            kind: SyntaxKind::TokenMissing,
            details: GreenNodeDetails::Token("".into()),
        }))
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match db.lookup_intern_green(node.0.green).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenSkipped)
            }
        }
    }
    fn from_ptr(db: &dyn SyntaxGroup, root: &SyntaxFile, ptr: Self::StablePtr) -> Self {
        Self::from_syntax_node(db, root.as_syntax_node().lookup_ptr(db, ptr.0))
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenSkippedPtr(self.node.0.stable_ptr)
    }
}
