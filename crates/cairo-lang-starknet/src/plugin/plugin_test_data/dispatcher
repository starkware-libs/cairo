//! > Test expansion of a dispatcher.

//! > test_runner_name
ExpandContractTestRunner

//! > cairo_code
#[abi]
trait IContract {
    fn get_something(arg: felt, num: felt) -> felt;

    fn empty();

    fn bad_sig(ref arg1: felt, ref arg2: felt) -> felt;

    #[event]
    fn my_event();
}

//! > generated_cairo_code
#[abi]
trait IContract {
    fn get_something(arg: felt, num: felt) -> felt;

    fn empty();

    fn bad_sig(ref arg1: felt, ref arg2: felt) -> felt;

    #[event]
    fn my_event();
}
trait IContractDispatcher<T> {
    fn get_something(self: T, arg: felt, num: felt) -> felt;
    fn empty(self: T, );
}

#[derive(Copy, Drop)]
struct IContractContractCaller {
    contract_address: starknet::ContractAddress,
}

impl IContractContractCallerDispatcherImpl of IContractDispatcher::<IContractContractCaller> {
    fn get_something(self: IContractContractCaller, arg: felt, num: felt) -> felt {
        let mut calldata = array::ArrayTrait::new();
        serde::Serde::<felt>::serialize(ref calldata, arg);
        serde::Serde::<felt>::serialize(ref calldata, num);

        let mut ret_data = array::ArrayTrait::span(
            @starknet::SyscallResultTrait::unwrap_syscall(
                starknet::call_contract_syscall(
                    self.contract_address,
                    0x3c52d61651de3dcab6ceaa9f6505f7aed8f1ffc0f694ce2a9ed76e758d87a3,
                    calldata,
                )
            )
        );

        option::OptionTrait::expect(
            serde::Serde::<felt>::deserialize(ref ret_data),
            'Returned data too short',
        )
    }

    fn empty(self: IContractContractCaller, ) {
        let mut calldata = array::ArrayTrait::new();

        let mut ret_data = array::ArrayTrait::span(
            @starknet::SyscallResultTrait::unwrap_syscall(
                starknet::call_contract_syscall(
                    self.contract_address,
                    0x1fc3f77ebc090777f567969ad9823cf6334ab888acb385ca72668ec5adbde80,
                    calldata,
                )
            )
        );

    }

}

#[derive(Copy, Drop)]
struct IContractLibraryCaller {
    class_hash: starknet::ClassHash,
}

impl IContractLibraryCallerDispatcherImpl of IContractDispatcher::<IContractLibraryCaller> {
    fn get_something(self: IContractLibraryCaller, arg: felt, num: felt) -> felt {
        let mut calldata = array::ArrayTrait::new();
        serde::Serde::<felt>::serialize(ref calldata, arg);
        serde::Serde::<felt>::serialize(ref calldata, num);

        let mut ret_data = array::ArrayTrait::span(
            @starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::library_call_syscall(
                    self.class_hash,
                    0x3c52d61651de3dcab6ceaa9f6505f7aed8f1ffc0f694ce2a9ed76e758d87a3,
                    calldata,
                )
            )
        );

        option::OptionTrait::expect(
            serde::Serde::<felt>::deserialize(ref ret_data),
            'Returned data too short',
        )
    }

    fn empty(self: IContractLibraryCaller, ) {
        let mut calldata = array::ArrayTrait::new();

        let mut ret_data = array::ArrayTrait::span(
            @starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::library_call_syscall(
                    self.class_hash,
                    0x1fc3f77ebc090777f567969ad9823cf6334ab888acb385ca72668ec5adbde80,
                    calldata,
                )
            )
        );

    }

}

//! > expected_diagnostics
error: Plugin diagnostic: `ref` parameters are not supported in the ABI of a contract.
 --> lib.cairo:7:16
    fn bad_sig(ref arg1: felt, ref arg2: felt) -> felt;
               ^*^

error: Plugin diagnostic: `ref` parameters are not supported in the ABI of a contract.
 --> lib.cairo:7:32
    fn bad_sig(ref arg1: felt, ref arg2: felt) -> felt;
                               ^*^
