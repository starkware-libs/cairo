//! > Test first param must be self.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    fn foo() {}

    #[external(v0)]
    fn bar(_n: u32) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    fn foo() {}

    #[external(v0)]
    fn bar(_n: u32) {}
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x198f4bc6efa8417922f8041d6e73821af41c6bbf15f1c93084da188702456b;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: The first parameter of an entry point must be `self`.
 --> lib.cairo:7:11
    fn foo() {}
          ^^

error: Plugin diagnostic: The first parameter of an entry point must be `self`.
 --> lib.cairo:10:12
    fn bar(_n: u32) {}
           ^*****^

warning: Plugin diagnostic: Failed to generate ABI: Entrypoints must have a self first param.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

warning: Plugin diagnostic: Failed to generate ABI: Entrypoints must have a self first param.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

//! > ==========================================================================

//! > Test invalid constructor name.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[constructor]
    fn invalid_constructor_name(ref self: ContractState) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[constructor]
    fn invalid_constructor_name(ref self: ContractState) {}
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x3bd690d1a73da0d8c43f46ecc3a006978d8343a075e91a1c7a24529e7d244a;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__invalid_constructor_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    invalid_constructor_name(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
    pub use super::__wrapper__invalid_constructor_name as invalid_constructor_name;
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: The constructor function must be called `constructor`.
 --> lib.cairo:7:8
    fn invalid_constructor_name(ref self: ContractState) {}
       ^**********************^

//! > ==========================================================================

//! > Test non-v0 external function.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo_v0(ref self: ContractState, x: (felt252, felt252)) {}
    #[external]
    fn foo(ref self: ContractState, x: (felt252, felt252)) {}
    #[external(v1)]
    fn foo_v1(ref self: ContractState, x: (felt252, felt252)) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo_v0(ref self: ContractState, x: (felt252, felt252)) {}
    #[external]
    fn foo(ref self: ContractState, x: (felt252, felt252)) {}
    #[external(v1)]
    fn foo_v1(ref self: ContractState, x: (felt252, felt252)) {}
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x547f368ac55821b57d7da42588a2985edb69dd87af9e9c16e740d6e14b2420;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__foo_v0(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo_v0(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__foo_v1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo_v1(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo_v0 as foo_v0;
    pub use super::__wrapper__foo as foo;
    pub use super::__wrapper__foo_v1 as foo_v1;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:7:5
    #[external]
    ^*********^

error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:9:5
    #[external(v1)]
    ^*************^

//! > ==========================================================================

//! > Test diagnostics of non-serializable parameter in entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState, x: super::MyType) {}
}
#[derive(Drop)]
struct MyType {}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState, x: super::MyType) {}
}
#[derive(Drop)]
struct MyType {}

lib.cairo:8:1
#[derive(Drop)]
^*************^
impls:

impl MyTypeDrop of core::traits::Drop::<MyType>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x16fce813e4d7f676441c2cffa36b5101b7e75cb787a8aec7259094fdbacb80e;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<super::MyType>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
error: Trait has no implementation in context: core::serde::Serde::<test::MyType>.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

//! > ==========================================================================

//! > Test diagnostics of non-serializable return type in entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState) -> (felt252, felt252) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState) -> (felt252, felt252) {}
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x2c31752790f50b7f25195fc7cc9dcc1234d7af736c5ed771c69ddc8bb9fd8d4;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = foo(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<(felt252, felt252)>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
error: Unexpected return type. Expected: "(core::felt252, core::felt252)", found: "()".
 --> lib.cairo:6:59
    fn foo(ref self: ContractState) -> (felt252, felt252) {}
                                                          ^^

//! > ==========================================================================

//! > Test diagnostics of generic entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo<T>(ref self: ContractState, x: T) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo<T>(ref self: ContractState, x: T) {}
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x2bcbd7e08add1bbb62c174729940be27dbe922f83afd842f02af5355af726a1;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<T>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: Contract entry points cannot have generic arguments
 --> lib.cairo:6:11
    fn foo<T>(ref self: ContractState, x: T) {}
          ^*^

warning: Plugin diagnostic: Failed to generate ABI: Got unexpected type.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

error: Type not found.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

error: Type annotations needed. Failed to infer ?2.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

error: Variable not dropped.
 --> lib.cairo:6:40
    fn foo<T>(ref self: ContractState, x: T) {}
                                       ^
note: Trait has no implementation in context: core::traits::Drop::<T>.
note: Trait has no implementation in context: core::traits::Destruct::<T>.

//! > ==========================================================================

//! > Test multiple diagnostics from entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(
        ref self: ContractState, x: (felt252, felt252), y: (felt252, felt252)
    ) -> (felt252, felt252) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(
        ref self: ContractState, x: (felt252, felt252), y: (felt252, felt252)
    ) -> (felt252, felt252) {}
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x37db5b411e79068f08f0832de46108b618c2f188115ac652f78be4f6dfcdeb4;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let __arg_y = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = foo(ref contract_state, __arg_x, __arg_y);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<(felt252, felt252)>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
error: Unexpected return type. Expected: "(core::felt252, core::felt252)", found: "()".
 --> lib.cairo:8:29
    ) -> (felt252, felt252) {}
                            ^^

//! > ==========================================================================

//! > Test account contract_entry point on a non-account contract.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn __validate__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_declare__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_deploy__(ref self: ContractState) {}
    #[external(v0)]
    fn __execute__(ref self: ContractState) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn __validate__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_declare__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_deploy__(ref self: ContractState) {}
    #[external(v0)]
    fn __execute__(ref self: ContractState) {}
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x291a42fae50c99636dc1d6bc0c4e28fdb0e21f47c26aa0d5e22c21d993823d8;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper____validate__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper____validate_declare__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate_declare__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper____validate_deploy__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate_deploy__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper____execute__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __execute__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper____validate__ as __validate__;
    pub use super::__wrapper____validate_declare__ as __validate_declare__;
    pub use super::__wrapper____validate_deploy__ as __validate_deploy__;
    pub use super::__wrapper____execute__ as __execute__;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
warning: Plugin diagnostic: Failed to generate ABI: `__validate__` is a reserved entry point names for account contracts only.
 --> lib.cairo:5:5
    #[external(v0)]
    ^*************^

warning: Plugin diagnostic: Failed to generate ABI: `__execute__` is a reserved entry point names for account contracts only.
 --> lib.cairo:11:5
    #[external(v0)]
    ^*************^

//! > ==========================================================================

//! > Test raw_outputs diagnostics.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    #[raw_output]
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}

    #[external(v0)]
    #[raw_output]
    fn bar1(ref self: ContractState, a: felt252) -> felt252 {
        0
    }

    #[external(v0)]
    #[raw_output]
    fn bar2(ref self: ContractState, a: felt252) {}

    // Should generate diagnostic as path resolving is not supported.
    #[external(v0)]
    #[raw_output]
    fn bar3(ref self: ContractState, a: felt252) -> core::Array::<felt252> {
        array::array_new()
    }

    // Should generate diagnostic as alias resolving is not supported.
    type my_felt252_array_type = Array::<felt252>;
    #[external(v0)]
    #[raw_output]
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
        array::array_new()
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    #[raw_output]
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}

    #[external(v0)]
    #[raw_output]
    fn bar1(ref self: ContractState, a: felt252) -> felt252 {
        0
    }

    #[external(v0)]
    #[raw_output]
    fn bar2(ref self: ContractState, a: felt252) {}

    // Should generate diagnostic as path resolving is not supported.
    #[external(v0)]
    #[raw_output]
    fn bar3(ref self: ContractState, a: felt252) -> core::Array::<felt252> {
        array::array_new()
    }

    // Should generate diagnostic as alias resolving is not supported.
    type my_felt252_array_type = Array::<felt252>;
    #[external(v0)]
    #[raw_output]
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
        array::array_new()
    }
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x1fe1d7e90cfe8c4fc07093ee454571079f241cebea881fdbe6d42ab30f16735;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: `raw_output` functions cannot have `ref` parameters.
 --> lib.cairo:8:37
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                    ^*^

error: Plugin diagnostic: `raw_output` functions cannot have `ref` parameters.
 --> lib.cairo:8:53
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                                    ^*^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:8:69
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                                                    ^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:12:53
    fn bar1(ref self: ContractState, a: felt252) -> felt252 {
                                                    ^*****^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:18:50
    fn bar2(ref self: ContractState, a: felt252) {}
                                                 ^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:23:53
    fn bar3(ref self: ContractState, a: felt252) -> core::Array::<felt252> {
                                                    ^********************^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:31:53
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
                                                    ^*******************^

//! > ==========================================================================

//! > Test reusage of storage var name diagnostics.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: false)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
          pub same_name: felt252,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub same_name: starknet::storage::StorageBase<felt252>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub same_name: starknet::storage::StorageBase<starknet::storage::Mutable<felt252>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           same_name: starknet::storage::StorageBase{ address: selector!("same_name") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           same_name: starknet::storage::StorageBase{ address: selector!("same_name") },
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x271c051b9d25373bc88ddfddfb1c29cc601d7014c5343fe167b82768570a896;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics

//! > ==========================================================================

//! > Contract with no storage.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    fn same_name() -> felt252 {
        1
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Contracts must define a 'Storage' struct.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

//! > ==========================================================================

//! > Not annotated storage struct.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: 'Storage' struct must be annotated with #[storage].
 --> lib.cairo:3:5
    struct Storage {
    ^**************^

//! > ==========================================================================

//! > Non v0 impls.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    #[generate_trait]
    impl AImpl of ATrait {}

    #[external(v1)]
    #[generate_trait]
    impl BImpl of BTrait {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    #[generate_trait]
    impl AImpl of ATrait {}

    #[external(v1)]
    #[generate_trait]
    impl BImpl of BTrait {}
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x1f35904b8fc9bed6ac08457ded74e522aa254844ebb1d7da8eaff06532a8b4d;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:5:5
    #[external(v0)]
    ^*************^
generate_trait:

    trait ATrait {}


lib.cairo:9:5
    #[external(v1)]
    ^*************^
generate_trait:

    trait BTrait {}


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:5:5
    #[external(v0)]
    ^*************^

error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:9:5
    #[external(v1)]
    ^*************^

warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:9:5
    #[external(v1)]
    ^*************^

//! > ==========================================================================

//! > old contract attribute.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[contract]
mod test_contract {}

#[abi]
trait ContractAbi {}

//! > generated_cairo_code
lib.cairo:

#[contract]
mod test_contract {}

#[abi]
trait ContractAbi {}

//! > expected_diagnostics
error: Plugin diagnostic: The 'contract' attribute was deprecated, please use `starknet::contract` instead.
 --> lib.cairo:1:1
#[contract]
^*********^

error: Plugin diagnostic: Unsupported attribute.
 --> lib.cairo:1:1
#[contract]
^*********^

error: Plugin diagnostic: The 'abi' attribute for traits was deprecated, please use `starknet::interface` instead.
 --> lib.cairo:4:1
#[abi]
^****^

//! > ==========================================================================

//! > Attributes in external impl.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait InterfaceTrait<TContractState> {
    fn foo_external1(self: @TContractState);
    fn foo_l1_handler1(self: @TContractState);
    fn foo_constructor1(self: @TContractState);
}

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    impl Impl2 of super::InterfaceTrait<ContractState> {
        #[external(v0)]
        fn foo_external1(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler1(self: @ContractState) {}
        #[constructor]
        fn foo_constructor1(self: @ContractState) {}
    }

    #[generate_trait]
    #[external(v0)]
    impl Impl1 of NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState) {}
        #[constructor]
        fn foo_constructor2(self: @ContractState) {}
    }
}

//! > expected_diagnostics
warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:13:5
    #[external(v0)]
    ^*************^

error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:15:9
        #[external(v0)]
        ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:17:9
        #[l1_handler]
        ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:19:9
        #[constructor]
        ^************^

warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:24:5
    #[external(v0)]
    ^*************^

error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:26:9
        #[external(v0)]
        ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:28:9
        #[l1_handler]
        ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:30:9
        #[constructor]
        ^************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait InterfaceTrait<TContractState> {
    fn foo_external1(self: @TContractState);
    fn foo_l1_handler1(self: @TContractState);
    fn foo_constructor1(self: @TContractState);
}

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    impl Impl2 of super::InterfaceTrait<ContractState> {
        #[external(v0)]
        fn foo_external1(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler1(self: @ContractState) {}
        #[constructor]
        fn foo_constructor1(self: @ContractState) {}
    }

    #[generate_trait]
    #[external(v0)]
    impl Impl1 of NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState) {}
        #[constructor]
        fn foo_constructor2(self: @ContractState) {}
    }
}

lib.cairo:1:1
#[starknet::interface]
^********************^
InterfaceTraitDispatcherTrait:

trait InterfaceTraitDispatcherTrait<T> {
    fn foo_external1(self: T);
    fn foo_l1_handler1(self: T);
    fn foo_constructor1(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceTraitDispatcherImpl of InterfaceTraitDispatcherTrait<InterfaceTraitDispatcher> {
    fn foo_external1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_l1_handler1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_constructor1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceTraitLibraryDispatcherImpl of InterfaceTraitDispatcherTrait<InterfaceTraitLibraryDispatcher> {
    fn foo_external1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_l1_handler1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_constructor1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait InterfaceTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo_external1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo_l1_handler1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo_constructor1(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceTraitSafeLibraryDispatcherImpl of InterfaceTraitSafeDispatcherTrait<InterfaceTraitSafeLibraryDispatcher> {
    fn foo_external1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_l1_handler1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_constructor1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceTraitSafeDispatcherImpl of InterfaceTraitSafeDispatcherTrait<InterfaceTraitSafeDispatcher> {
    fn foo_external1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_l1_handler1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_constructor1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceTraitDispatcherCopy of core::traits::Copy::<InterfaceTraitDispatcher>;
impl InterfaceTraitDispatcherDrop of core::traits::Drop::<InterfaceTraitDispatcher>;
impl InterfaceTraitDispatcherSerde of core::serde::Serde::<InterfaceTraitDispatcher> {
    fn serialize(self: @InterfaceTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitDispatcher> {
        core::option::Option::Some(InterfaceTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceTraitDispatcher of starknet::Store::<InterfaceTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl InterfaceTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceTraitDispatcher> {
type SubPointersType = InterfaceTraitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceTraitDispatcher>) -> InterfaceTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableInterfaceTraitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceTraitDispatcher> {
type SubPointersType = MutableInterfaceTraitDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceTraitDispatcher>>) -> MutableInterfaceTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceTraitLibraryDispatcherCopy of core::traits::Copy::<InterfaceTraitLibraryDispatcher>;
impl InterfaceTraitLibraryDispatcherDrop of core::traits::Drop::<InterfaceTraitLibraryDispatcher>;
impl InterfaceTraitLibraryDispatcherSerde of core::serde::Serde::<InterfaceTraitLibraryDispatcher> {
    fn serialize(self: @InterfaceTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitLibraryDispatcher> {
        core::option::Option::Some(InterfaceTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceTraitLibraryDispatcher of starknet::Store::<InterfaceTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl InterfaceTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceTraitLibraryDispatcher> {
type SubPointersType = InterfaceTraitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceTraitLibraryDispatcher>) -> InterfaceTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableInterfaceTraitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceTraitLibraryDispatcher> {
type SubPointersType = MutableInterfaceTraitLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceTraitLibraryDispatcher>>) -> MutableInterfaceTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceTraitSafeLibraryDispatcherCopy of core::traits::Copy::<InterfaceTraitSafeLibraryDispatcher>;
impl InterfaceTraitSafeLibraryDispatcherDrop of core::traits::Drop::<InterfaceTraitSafeLibraryDispatcher>;
impl InterfaceTraitSafeLibraryDispatcherSerde of core::serde::Serde::<InterfaceTraitSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitSafeLibraryDispatcher> {
        core::option::Option::Some(InterfaceTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceTraitSafeLibraryDispatcher of starknet::Store::<InterfaceTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl InterfaceTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceTraitSafeLibraryDispatcher> {
type SubPointersType = InterfaceTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceTraitSafeLibraryDispatcher>) -> InterfaceTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableInterfaceTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceTraitSafeLibraryDispatcher> {
type SubPointersType = MutableInterfaceTraitSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceTraitSafeLibraryDispatcher>>) -> MutableInterfaceTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceTraitSafeDispatcherCopy of core::traits::Copy::<InterfaceTraitSafeDispatcher>;
impl InterfaceTraitSafeDispatcherDrop of core::traits::Drop::<InterfaceTraitSafeDispatcher>;
impl InterfaceTraitSafeDispatcherSerde of core::serde::Serde::<InterfaceTraitSafeDispatcher> {
    fn serialize(self: @InterfaceTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitSafeDispatcher> {
        core::option::Option::Some(InterfaceTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceTraitSafeDispatcher of starknet::Store::<InterfaceTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl InterfaceTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceTraitSafeDispatcher> {
type SubPointersType = InterfaceTraitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceTraitSafeDispatcher>) -> InterfaceTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableInterfaceTraitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceTraitSafeDispatcher> {
type SubPointersType = MutableInterfaceTraitSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceTraitSafeDispatcher>>) -> MutableInterfaceTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceTraitDispatcherSubPointersDrop of core::traits::Drop::<InterfaceTraitDispatcherSubPointers>;
impl InterfaceTraitDispatcherSubPointersCopy of core::traits::Copy::<InterfaceTraitDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceTraitDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceTraitDispatcherSubPointers>;
impl MutableInterfaceTraitDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceTraitDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceTraitLibraryDispatcherSubPointers>;
impl InterfaceTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceTraitLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceTraitLibraryDispatcherSubPointers>;
impl MutableInterfaceTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceTraitLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceTraitSafeLibraryDispatcherSubPointers>;
impl InterfaceTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceTraitSafeLibraryDispatcherSubPointers>;
impl MutableInterfaceTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<InterfaceTraitSafeDispatcherSubPointers>;
impl InterfaceTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<InterfaceTraitSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceTraitSafeDispatcherSubPointers>;
impl MutableInterfaceTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceTraitSafeDispatcherSubPointers>;


lib.cairo:8:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0xb2b80f78cee80a1a53222a998e318822f6d9d701bdc8037948c5964158503c;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__Impl2__foo_external1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_external1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__Impl2__foo_l1_handler1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_l1_handler1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__Impl2__foo_constructor1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_constructor1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__Impl1__foo_external2(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_external2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__Impl1__foo_l1_handler2(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_l1_handler2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__Impl1__foo_constructor2(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_constructor2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__Impl2__foo_external1 as foo_external1;
    pub use super::__wrapper__Impl2__foo_l1_handler1 as foo_l1_handler1;
    pub use super::__wrapper__Impl2__foo_constructor1 as foo_constructor1;
    pub use super::__wrapper__Impl1__foo_external2 as foo_external2;
    pub use super::__wrapper__Impl1__foo_l1_handler2 as foo_l1_handler2;
    pub use super::__wrapper__Impl1__foo_constructor2 as foo_constructor2;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:23:5
    #[generate_trait]
    ^***************^
generate_trait:

    trait NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState);
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState);
        #[constructor]
        fn foo_constructor2(self: @ContractState);
    }


lib.cairo:8:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:8:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:8:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:8:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > ==========================================================================

//! > "Event" enum without #[event].

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[derive(Drop, starknet::Event)]
    enum Event {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[derive(Drop, starknet::Event)]
    enum Event {}
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:



#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x820d41c225755fd6813443e1db69b44d323763bb1bdc6c58da9d8011855f0b;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:5:1

^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:6:20
    #[derive(Drop, starknet::Event)]
                   ^*************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: Contract type that is named `Event` must be marked with #[event].
 --> lib.cairo:7:10
    enum Event {}
         ^***^

//! > ==========================================================================

//! > #[event] enum that isn't named "Event".

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[event]
    #[derive(Drop, starknet::Event)]
    enum MyEvent {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[event]
    #[derive(Drop, starknet::Event)]
    enum MyEvent {}
}

lib.cairo:1:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x1786cd1474db7f1bf61efa820fedb6cc8a9892313c56a8ab854a488db0d2879;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:5:1

^
impls:

impl MyEventDrop of core::traits::Drop::<MyEvent>;


lib.cairo:7:20
    #[derive(Drop, starknet::Event)]
                   ^*************^
starknet_derive:

impl MyEventIsEvent of starknet::Event<MyEvent> {
    fn append_keys_and_data(
        self: @MyEvent, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<MyEvent> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:1:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: Contract type that is marked with #[event] must be named `Event`.
 --> lib.cairo:8:10
    enum MyEvent {}
         ^*****^

//! > ==========================================================================

//! > Test `starknet::interface` trait with no body.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T>;

//! > expected_diagnostics
error: Plugin diagnostic: Starknet interfaces without body are not supported.
 --> lib.cairo:2:19
trait IContract<T>;
                  ^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T>;

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad generic params.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract2Generics<T, S> {}

#[starknet::interface]
trait IContract0Generics {}

#[starknet::interface]
trait IContractNonTypeGenerics<+Destruct<u32>> {}

//! > expected_diagnostics
error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:2:25
trait IContract2Generics<T, S> {}
                        ^****^

error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:5:26
trait IContract0Generics {}
                         ^

error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:8:31
trait IContractNonTypeGenerics<+Destruct<u32>> {}
                              ^**************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract2Generics<T, S> {}

#[starknet::interface]
trait IContract0Generics {}

#[starknet::interface]
trait IContractNonTypeGenerics<+Destruct<u32>> {}

//! > ==========================================================================

//! > Test `starknet::interface` trait with non-self param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
    fn no_params() -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: The first parameter must be named `self`.
 --> lib.cairo:3:21
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
                    ^***************^

error: Plugin diagnostic: The first parameter must be named `self`.
 --> lib.cairo:4:22
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
                     ^************^

error: Plugin diagnostic: `starknet::interface` functions must have a `self` parameter.
 --> lib.cairo:5:5
    fn no_params() -> felt252;
    ^***********************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
    fn no_params() -> felt252;
}

lib.cairo:1:1
#[starknet::interface]
^********************^
IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IContractDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractDispatcher> {
type SubPointersType = IContractDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractDispatcher>) -> IContractDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIContractDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractDispatcher> {
type SubPointersType = MutableIContractDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractDispatcher>>) -> MutableIContractDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IContractLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractLibraryDispatcher> {
type SubPointersType = IContractLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractLibraryDispatcher>) -> IContractLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIContractLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractLibraryDispatcher> {
type SubPointersType = MutableIContractLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractLibraryDispatcher>>) -> MutableIContractLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeLibraryDispatcher> {
type SubPointersType = IContractSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeLibraryDispatcher>) -> IContractSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractSafeLibraryDispatcher> {
type SubPointersType = MutableIContractSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeLibraryDispatcher>>) -> MutableIContractSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IContractSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeDispatcher> {
type SubPointersType = IContractSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeDispatcher>) -> IContractSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIContractSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractSafeDispatcher> {
type SubPointersType = MutableIContractSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeDispatcher>>) -> MutableIContractSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractDispatcherSubPointersDrop of core::traits::Drop::<IContractDispatcherSubPointers>;
impl IContractDispatcherSubPointersCopy of core::traits::Copy::<IContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractDispatcherSubPointers>;
impl MutableIContractDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointers>;
impl IContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractLibraryDispatcherSubPointers>;
impl MutableIContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointers>;
impl IContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractSafeLibraryDispatcherSubPointers>;
impl MutableIContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeDispatcherSubPointers>;
impl IContractSafeDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractSafeDispatcherSubPointers>;
impl MutableIContractSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractSafeDispatcherSubPointers>;

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad non-first param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn foo(
        ref self: T,
        ref param_ref: felt252,
        t_param: T,
        arr_param: Array<T>,
        snap_param: @T,
        tup_param: (felt252, T),
    ) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> lib.cairo:5:9
        ref param_ref: felt252,
        ^*^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:6:18
        t_param: T,
                 ^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:7:20
        arr_param: Array<T>,
                   ^******^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:8:21
        snap_param: @T,
                    ^^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:9:20
        tup_param: (felt252, T),
                   ^**********^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn foo(
        ref self: T,
        ref param_ref: felt252,
        t_param: T,
        arr_param: Array<T>,
        snap_param: @T,
        tup_param: (felt252, T),
    ) -> felt252;
}

lib.cairo:1:1
#[starknet::interface]
^********************^
IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IContractDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractDispatcher> {
type SubPointersType = IContractDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractDispatcher>) -> IContractDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIContractDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractDispatcher> {
type SubPointersType = MutableIContractDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractDispatcher>>) -> MutableIContractDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IContractLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractLibraryDispatcher> {
type SubPointersType = IContractLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractLibraryDispatcher>) -> IContractLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIContractLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractLibraryDispatcher> {
type SubPointersType = MutableIContractLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractLibraryDispatcher>>) -> MutableIContractLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeLibraryDispatcher> {
type SubPointersType = IContractSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeLibraryDispatcher>) -> IContractSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractSafeLibraryDispatcher> {
type SubPointersType = MutableIContractSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeLibraryDispatcher>>) -> MutableIContractSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IContractSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeDispatcher> {
type SubPointersType = IContractSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeDispatcher>) -> IContractSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIContractSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractSafeDispatcher> {
type SubPointersType = MutableIContractSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeDispatcher>>) -> MutableIContractSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractDispatcherSubPointersDrop of core::traits::Drop::<IContractDispatcherSubPointers>;
impl IContractDispatcherSubPointersCopy of core::traits::Copy::<IContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractDispatcherSubPointers>;
impl MutableIContractDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointers>;
impl IContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractLibraryDispatcherSubPointers>;
impl MutableIContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointers>;
impl IContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractSafeLibraryDispatcherSubPointers>;
impl MutableIContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeDispatcherSubPointers>;
impl IContractSafeDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractSafeDispatcherSubPointers>;
impl MutableIContractSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractSafeDispatcherSubPointers>;

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad modifiers for self param.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:3:24
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
                       ^*****^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
}

lib.cairo:1:1
#[starknet::interface]
^********************^
IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IContractDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractDispatcher> {
type SubPointersType = IContractDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractDispatcher>) -> IContractDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIContractDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractDispatcher> {
type SubPointersType = MutableIContractDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractDispatcher>>) -> MutableIContractDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IContractLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractLibraryDispatcher> {
type SubPointersType = IContractLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractLibraryDispatcher>) -> IContractLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIContractLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractLibraryDispatcher> {
type SubPointersType = MutableIContractLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractLibraryDispatcher>>) -> MutableIContractLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeLibraryDispatcher> {
type SubPointersType = IContractSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeLibraryDispatcher>) -> IContractSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractSafeLibraryDispatcher> {
type SubPointersType = MutableIContractSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeLibraryDispatcher>>) -> MutableIContractSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IContractSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeDispatcher> {
type SubPointersType = IContractSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeDispatcher>) -> IContractSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIContractSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractSafeDispatcher> {
type SubPointersType = MutableIContractSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeDispatcher>>) -> MutableIContractSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractDispatcherSubPointersDrop of core::traits::Drop::<IContractDispatcherSubPointers>;
impl IContractDispatcherSubPointersCopy of core::traits::Copy::<IContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractDispatcherSubPointers>;
impl MutableIContractDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointers>;
impl IContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractLibraryDispatcherSubPointers>;
impl MutableIContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointers>;
impl IContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractSafeLibraryDispatcherSubPointers>;
impl MutableIContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeDispatcherSubPointers>;
impl IContractSafeDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractSafeDispatcherSubPointers>;
impl MutableIContractSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractSafeDispatcherSubPointers>;

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad self param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn foo(ref self: u32, other: felt252) -> felt252;
    fn bar(self: @u32, other: felt252) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:3:12
    fn foo(ref self: u32, other: felt252) -> felt252;
           ^***********^

error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:4:12
    fn bar(self: @u32, other: felt252) -> felt252;
           ^********^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn foo(ref self: u32, other: felt252) -> felt252;
    fn bar(self: @u32, other: felt252) -> felt252;
}

lib.cairo:1:1
#[starknet::interface]
^********************^
IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IContractDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractDispatcher> {
type SubPointersType = IContractDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractDispatcher>) -> IContractDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIContractDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractDispatcher> {
type SubPointersType = MutableIContractDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractDispatcher>>) -> MutableIContractDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IContractLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractLibraryDispatcher> {
type SubPointersType = IContractLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractLibraryDispatcher>) -> IContractLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIContractLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractLibraryDispatcher> {
type SubPointersType = MutableIContractLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractLibraryDispatcher>>) -> MutableIContractLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeLibraryDispatcher> {
type SubPointersType = IContractSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeLibraryDispatcher>) -> IContractSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractSafeLibraryDispatcher> {
type SubPointersType = MutableIContractSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeLibraryDispatcher>>) -> MutableIContractSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IContractSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IContractSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeDispatcher> {
type SubPointersType = IContractSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeDispatcher>) -> IContractSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IContractSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIContractSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIContractSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IContractSafeDispatcher> {
type SubPointersType = MutableIContractSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeDispatcher>>) -> MutableIContractSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIContractSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractDispatcherSubPointersDrop of core::traits::Drop::<IContractDispatcherSubPointers>;
impl IContractDispatcherSubPointersCopy of core::traits::Copy::<IContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractDispatcherSubPointers>;
impl MutableIContractDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointers>;
impl IContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractLibraryDispatcherSubPointers>;
impl MutableIContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointers>;
impl IContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractSafeLibraryDispatcherSubPointers>;
impl MutableIContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl IContractSafeDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeDispatcherSubPointers>;
impl IContractSafeDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableIContractSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIContractSafeDispatcherSubPointers>;
impl MutableIContractSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIContractSafeDispatcherSubPointers>;

//! > ==========================================================================

//! > Test `starknet::embeddable` impl with (disallowed) attributes for its methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::embeddable]
impl EmbeddableImpl<TContractState> of Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {}
    #[l1_handler]
    fn foo2(self: @TContractState) {}
    #[constructor]
    fn foo3(self: @TContractState) {}
}

//! > expected_diagnostics
error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:9:5
    #[external(v0)]
    ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:11:5
    #[l1_handler]
    ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:13:5
    #[constructor]
    ^************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::embeddable]
impl EmbeddableImpl<TContractState> of Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {}
    #[l1_handler]
    fn foo2(self: @TContractState) {}
    #[constructor]
    fn foo3(self: @TContractState) {}
}

lib.cairo:1:1
#[starknet::interface]
^********************^
InterfaceDispatcherTrait:

trait InterfaceDispatcherTrait<T> {
    fn foo1(self: T);
    fn foo2(self: T);
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceDispatcherImpl of InterfaceDispatcherTrait<InterfaceDispatcher> {
    fn foo1(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceLibraryDispatcherImpl of InterfaceDispatcherTrait<InterfaceLibraryDispatcher> {
    fn foo1(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait InterfaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo2(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceSafeLibraryDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeLibraryDispatcher> {
    fn foo1(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceSafeDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeDispatcher> {
    fn foo1(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:7:1
#[starknet::embeddable]
^*********************^
embeddable:

trait UnsafeNewContractStateTraitForEmbeddableImpl<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo1<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo2<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo3<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo3(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



mod __external_EmbeddableImpl {
    pub use super::__wrapper__EmbeddableImpl__foo1 as foo1;
    pub use super::__wrapper__EmbeddableImpl__foo2 as foo2;
    pub use super::__wrapper__EmbeddableImpl__foo3 as foo3;
}

mod __l1_handler_EmbeddableImpl {
}

mod __constructor_EmbeddableImpl {
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceDispatcherCopy of core::traits::Copy::<InterfaceDispatcher>;
impl InterfaceDispatcherDrop of core::traits::Drop::<InterfaceDispatcher>;
impl InterfaceDispatcherSerde of core::serde::Serde::<InterfaceDispatcher> {
    fn serialize(self: @InterfaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceDispatcher> {
        core::option::Option::Some(InterfaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceDispatcher of starknet::Store::<InterfaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl InterfaceDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceDispatcher> {
type SubPointersType = InterfaceDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceDispatcher>) -> InterfaceDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableInterfaceDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceDispatcher> {
type SubPointersType = MutableInterfaceDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceDispatcher>>) -> MutableInterfaceDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceLibraryDispatcherCopy of core::traits::Copy::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherDrop of core::traits::Drop::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherSerde of core::serde::Serde::<InterfaceLibraryDispatcher> {
    fn serialize(self: @InterfaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceLibraryDispatcher> {
        core::option::Option::Some(InterfaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceLibraryDispatcher of starknet::Store::<InterfaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl InterfaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceLibraryDispatcher> {
type SubPointersType = InterfaceLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceLibraryDispatcher>) -> InterfaceLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableInterfaceLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceLibraryDispatcher> {
type SubPointersType = MutableInterfaceLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceLibraryDispatcher>>) -> MutableInterfaceLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceSafeLibraryDispatcherCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherSerde of core::serde::Serde::<InterfaceSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeLibraryDispatcher> {
        core::option::Option::Some(InterfaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceSafeLibraryDispatcher of starknet::Store::<InterfaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl InterfaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceSafeLibraryDispatcher> {
type SubPointersType = InterfaceSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceSafeLibraryDispatcher>) -> InterfaceSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableInterfaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceSafeLibraryDispatcher> {
type SubPointersType = MutableInterfaceSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceSafeLibraryDispatcher>>) -> MutableInterfaceSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceSafeDispatcherCopy of core::traits::Copy::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherDrop of core::traits::Drop::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherSerde of core::serde::Serde::<InterfaceSafeDispatcher> {
    fn serialize(self: @InterfaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeDispatcher> {
        core::option::Option::Some(InterfaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceSafeDispatcher of starknet::Store::<InterfaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl InterfaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceSafeDispatcher> {
type SubPointersType = InterfaceSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceSafeDispatcher>) -> InterfaceSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableInterfaceSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceSafeDispatcher> {
type SubPointersType = MutableInterfaceSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceSafeDispatcher>>) -> MutableInterfaceSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceDispatcherSubPointersDrop of core::traits::Drop::<InterfaceDispatcherSubPointers>;
impl InterfaceDispatcherSubPointersCopy of core::traits::Copy::<InterfaceDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceDispatcherSubPointers>;
impl MutableInterfaceDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceLibraryDispatcherSubPointers>;
impl InterfaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceLibraryDispatcherSubPointers>;
impl MutableInterfaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcherSubPointers>;
impl InterfaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceSafeLibraryDispatcherSubPointers>;
impl MutableInterfaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceSafeDispatcherSubPointersDrop of core::traits::Drop::<InterfaceSafeDispatcherSubPointers>;
impl InterfaceSafeDispatcherSubPointersCopy of core::traits::Copy::<InterfaceSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceSafeDispatcherSubPointers>;
impl MutableInterfaceSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceSafeDispatcherSubPointers>;

//! > ==========================================================================

//! > Test `embeddable_as` impl with (disallowed) attributes for its methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::component]
mod component {
    #[storage]
    struct Storage {}

    #[embeddable_as(MyEmbeddableImpl)]
    impl MyImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of super::Interface<ComponentState<TContractState>> {
        #[external(v0)]
        fn foo1(self: @ComponentState<TContractState>) {}
        #[l1_handler]
        fn foo2(self: @ComponentState<TContractState>) {}
        #[constructor]
        fn foo3(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::contract]
mod contract {
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_storage: super::component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::component::Event,
    }

    component!(path: super::component, storage: component_storage, event: CompEvent);

    #[abi(embed_v0)]
    impl MyEmbeddedImpl = super::component::MyEmbeddableImpl<ContractState>;
}

//! > expected_diagnostics
error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:16:9
        #[external(v0)]
        ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:18:9
        #[l1_handler]
        ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:20:9
        #[constructor]
        ^************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::component]
mod component {
    #[storage]
    struct Storage {}

    #[embeddable_as(MyEmbeddableImpl)]
    impl MyImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of super::Interface<ComponentState<TContractState>> {
        #[external(v0)]
        fn foo1(self: @ComponentState<TContractState>) {}
        #[l1_handler]
        fn foo2(self: @ComponentState<TContractState>) {}
        #[constructor]
        fn foo3(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::contract]
mod contract {
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_storage: super::component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::component::Event,
    }

    component!(path: super::component, storage: component_storage, event: CompEvent);

    #[abi(embed_v0)]
    impl MyEmbeddedImpl = super::component::MyEmbeddableImpl<ContractState>;
}

lib.cairo:1:1
#[starknet::interface]
^********************^
InterfaceDispatcherTrait:

trait InterfaceDispatcherTrait<T> {
    fn foo1(self: T);
    fn foo2(self: T);
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceDispatcherImpl of InterfaceDispatcherTrait<InterfaceDispatcher> {
    fn foo1(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceLibraryDispatcherImpl of InterfaceDispatcherTrait<InterfaceLibraryDispatcher> {
    fn foo1(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait InterfaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo2(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceSafeLibraryDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeLibraryDispatcher> {
    fn foo1(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceSafeDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeDispatcher> {
    fn foo1(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceDispatcherCopy of core::traits::Copy::<InterfaceDispatcher>;
impl InterfaceDispatcherDrop of core::traits::Drop::<InterfaceDispatcher>;
impl InterfaceDispatcherSerde of core::serde::Serde::<InterfaceDispatcher> {
    fn serialize(self: @InterfaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceDispatcher> {
        core::option::Option::Some(InterfaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceDispatcher of starknet::Store::<InterfaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl InterfaceDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceDispatcher> {
type SubPointersType = InterfaceDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceDispatcher>) -> InterfaceDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableInterfaceDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceDispatcher> {
type SubPointersType = MutableInterfaceDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceDispatcher>>) -> MutableInterfaceDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceLibraryDispatcherCopy of core::traits::Copy::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherDrop of core::traits::Drop::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherSerde of core::serde::Serde::<InterfaceLibraryDispatcher> {
    fn serialize(self: @InterfaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceLibraryDispatcher> {
        core::option::Option::Some(InterfaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceLibraryDispatcher of starknet::Store::<InterfaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl InterfaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceLibraryDispatcher> {
type SubPointersType = InterfaceLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceLibraryDispatcher>) -> InterfaceLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableInterfaceLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceLibraryDispatcher> {
type SubPointersType = MutableInterfaceLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceLibraryDispatcher>>) -> MutableInterfaceLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceSafeLibraryDispatcherCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherSerde of core::serde::Serde::<InterfaceSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeLibraryDispatcher> {
        core::option::Option::Some(InterfaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceSafeLibraryDispatcher of starknet::Store::<InterfaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl InterfaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceSafeLibraryDispatcher> {
type SubPointersType = InterfaceSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceSafeLibraryDispatcher>) -> InterfaceSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableInterfaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceSafeLibraryDispatcher> {
type SubPointersType = MutableInterfaceSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceSafeLibraryDispatcher>>) -> MutableInterfaceSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceSafeDispatcherCopy of core::traits::Copy::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherDrop of core::traits::Drop::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherSerde of core::serde::Serde::<InterfaceSafeDispatcher> {
    fn serialize(self: @InterfaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeDispatcher> {
        core::option::Option::Some(InterfaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreInterfaceSafeDispatcher of starknet::Store::<InterfaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct InterfaceSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl InterfaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceSafeDispatcher> {
type SubPointersType = InterfaceSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceSafeDispatcher>) -> InterfaceSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                InterfaceSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableInterfaceSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableInterfaceSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<InterfaceSafeDispatcher> {
type SubPointersType = MutableInterfaceSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceSafeDispatcher>>) -> MutableInterfaceSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableInterfaceSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceDispatcherSubPointersDrop of core::traits::Drop::<InterfaceDispatcherSubPointers>;
impl InterfaceDispatcherSubPointersCopy of core::traits::Copy::<InterfaceDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceDispatcherSubPointers>;
impl MutableInterfaceDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceLibraryDispatcherSubPointers>;
impl InterfaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceLibraryDispatcherSubPointers>;
impl MutableInterfaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcherSubPointers>;
impl InterfaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceSafeLibraryDispatcherSubPointers>;
impl MutableInterfaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl InterfaceSafeDispatcherSubPointersDrop of core::traits::Drop::<InterfaceSafeDispatcherSubPointers>;
impl InterfaceSafeDispatcherSubPointersCopy of core::traits::Copy::<InterfaceSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableInterfaceSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableInterfaceSafeDispatcherSubPointers>;
impl MutableInterfaceSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableInterfaceSafeDispatcherSubPointers>;


lib.cairo:7:1
#[starknet::component]
^********************^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
pub impl MyEmbeddableImpl<
            TContractState, impl X: HasComponent<TContractState>
, impl TContractStateDrop: Drop<TContractState>
> of super::Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo1(component)
    }
    #[l1_handler]
    fn foo2(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo2(component)
    }
    #[constructor]
    fn foo3(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo3(component)
    }
}

lib.cairo:7:1
#[starknet::component]
^********************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:7:1
#[starknet::component]
^********************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:7:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;


lib.cairo:7:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;


lib.cairo:12:5
    #[embeddable_as(MyEmbeddableImpl)]
    ^********************************^
embeddable:

pub trait UnsafeNewContractStateTraitForMyEmbeddableImpl<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo1<TContractState, impl X: HasComponent<TContractState>
, impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo2<TContractState, impl X: HasComponent<TContractState>
, impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo3<TContractState, impl X: HasComponent<TContractState>
, impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo3(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



pub mod __external_MyEmbeddableImpl {
    pub use super::__wrapper__MyEmbeddableImpl__foo1 as foo1;
    pub use super::__wrapper__MyEmbeddableImpl__foo2 as foo2;
    pub use super::__wrapper__MyEmbeddableImpl__foo3 as foo3;
}

pub mod __l1_handler_MyEmbeddableImpl {
}

pub mod __constructor_MyEmbeddableImpl {
}


lib.cairo:25:1
#[starknet::contract]
^*******************^
contract:



#[phantom]
pub struct Storage {
          pub component_storage: super::component::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub component_storage: starknet::storage::StorageBase<super::component::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub component_storage: starknet::storage::StorageBase<starknet::storage::Mutable<super::component::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           component_storage: starknet::storage::StorageBase{ address: selector!("component_storage") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           component_storage: starknet::storage::StorageBase{ address: selector!("component_storage") },
        }
    }
}
pub struct ContractState {
        pub component_storage: super::component::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
            component_storage: super::component::unsafe_new_component_state::<ContractState>(),
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x291a893aaae68e6364fac8003da0089f1c976946ebe457ce78ed62b5e680be2;

impl ContractStateMyEmbeddableImpl of
    super::component::UnsafeNewContractStateTraitForMyEmbeddableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}

pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_component of super::component::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @super::component::ComponentState<ContractState> {
                 @super::component::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> super::component::ComponentState<ContractState> {
        super::component::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @super::component::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: super::component::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, super::component::Event>>(ref self: super::component::ComponentState<ContractState>, event: S) {
        let event: super::component::Event = core::traits::Into::into(event);
        let mut contract = super::component::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::CompEvent(event));
    }
}


lib.cairo:32:1

^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:34:20
    #[derive(Drop, starknet::Event)]
                   ^*************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::CompEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("CompEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("CompEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::CompEvent(val));
        }
        Option::None
    }
}
impl EventCompEventIntoEvent of Into<super::component::Event, Event> {
    fn into(self: super::component::Event) -> Event {
        Event::CompEvent(self)
    }
}



lib.cairo:25:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:25:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > ==========================================================================

//! > Test `#[abi(..)]` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[generate_trait]
impl SomeImpl<T> of SomeTrait<T> {
    fn foo(self: @T) {}
}
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[abi(v0)]
    impl Alias = super::SomeImpl<ContractState>;

    #[abi(embed)]
    impl InlineImpl of super::SomeTrait<ContractState> {
        fn foo(self: @ContractState) {}
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The 'abi' attribute for impl aliases only supports the 'embed_v0' argument.
 --> lib.cairo:10:5
    #[abi(v0)]
    ^********^

error: Plugin diagnostic: The 'abi' attribute for impls only supports the 'per_item' or 'embed_v0' argument.
 --> lib.cairo:13:5
    #[abi(embed)]
    ^***********^

//! > generated_cairo_code
lib.cairo:

#[generate_trait]
impl SomeImpl<T> of SomeTrait<T> {
    fn foo(self: @T) {}
}
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[abi(v0)]
    impl Alias = super::SomeImpl<ContractState>;

    #[abi(embed)]
    impl InlineImpl of super::SomeTrait<ContractState> {
        fn foo(self: @ContractState) {}
    }
}

lib.cairo:1:1
#[generate_trait]
^***************^
generate_trait:

trait SomeTrait<T> {
    fn foo(self: @T);
}


lib.cairo:5:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x7bfb361123ab6c75c9b1db29acd3b69ea425da0db94322a959835a160c41da;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:5:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:5:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:5:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:5:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > ==========================================================================

//! > Test `get_dep_component!` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

trait NotHasComponentTrait {}
impl NotHasComponent of NotHasComponentTrait {}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
    fn foo4(self: @TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(@self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component!(self, Comp1).foo1();
            get_dep_component!(Comp1, @self).foo1();
            get_dep_component!(@self, @self).foo1();
            get_dep_component!(Comp1, Comp1).foo1();
            get_dep_component!(@self, Comp2).foo1();
            get_dep_component!(@self, super::NotHasComponent).foo1();
            let not_contract_state: felt252 = 0;
            get_dep_component!(not_contract_state, Comp1).foo1();
            get_dep_component!(@self, NonExistingImpl).foo1();
        }
        fn foo4(self: @ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(self, Comp1).foo1();
        }
    }
}

//! > expected_diagnostics
error: Unexpected argument type. Expected: "@test::component3::ComponentState::<?2>", found: "test::component3::ComponentState::<TContractState>".
It is possible that the type inference failed because the types differ in the number of snapshots.
Consider adding or removing snapshots.
 --> lib.cairo:55:32
            get_dep_component!(self, Comp1).foo1();
                               ^**^

error: Expected variable or constant, found impl.
 --> lib.cairo:56:32
            get_dep_component!(Comp1, @self).foo1();
                               ^***^

error: Identifier not found.
 --> lib.cairo:56:40
            get_dep_component!(Comp1, @self).foo1();
                                       ^**^

error: Identifier not found.
 --> lib.cairo:57:40
            get_dep_component!(@self, @self).foo1();
                                       ^**^

error: Expected variable or constant, found impl.
 --> lib.cairo:58:32
            get_dep_component!(Comp1, Comp1).foo1();
                               ^***^

error: Method `foo1` not found on type `@test::component2::ComponentState::<TContractState>`. Did you import the correct trait and impl?
 --> lib.cairo:59:46
            get_dep_component!(@self, Comp2).foo1();
                                             ^**^

error: Invalid path.
 --> lib.cairo:60:13
            get_dep_component!(@self, super::NotHasComponent).foo1();
            ^***********************************************^

error: Unexpected argument type. Expected: "@test::component3::ComponentState::<?14>", found: "core::felt252".
It is possible that the type inference failed because the types differ in the number of snapshots.
Consider adding or removing snapshots.
 --> lib.cairo:62:32
            get_dep_component!(not_contract_state, Comp1).foo1();
                               ^****************^

error: Identifier not found.
 --> lib.cairo:63:39
            get_dep_component!(@self, NonExistingImpl).foo1();
                                      ^*************^

//! > generated_cairo_code
lib.cairo:

#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

trait NotHasComponentTrait {}
impl NotHasComponent of NotHasComponentTrait {}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
    fn foo4(self: @TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(@self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component!(self, Comp1).foo1();
            get_dep_component!(Comp1, @self).foo1();
            get_dep_component!(@self, @self).foo1();
            get_dep_component!(Comp1, Comp1).foo1();
            get_dep_component!(@self, Comp2).foo1();
            get_dep_component!(@self, super::NotHasComponent).foo1();
            let not_contract_state: felt252 = 0;
            get_dep_component!(not_contract_state, Comp1).foo1();
            get_dep_component!(@self, NonExistingImpl).foo1();
        }
        fn foo4(self: @ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(self, Comp1).foo1();
        }
    }
}

lib.cairo:30:1
#[starknet::interface]
^********************^
Comp3TraitDispatcherTrait:

trait Comp3TraitDispatcherTrait<T> {
    fn foo3(self: T);
    fn foo4(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitDispatcher> {
    fn foo3(self: Comp3TraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo4(self: Comp3TraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitLibraryDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitLibraryDispatcher> {
    fn foo3(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo4(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Comp3TraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo4(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitSafeLibraryDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeLibraryDispatcher> {
    fn foo3(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo4(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitSafeDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeDispatcher> {
    fn foo3(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo4(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitDispatcherCopy of core::traits::Copy::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherDrop of core::traits::Drop::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherSerde of core::serde::Serde::<Comp3TraitDispatcher> {
    fn serialize(self: @Comp3TraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitDispatcher> {
        core::option::Option::Some(Comp3TraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:30:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreComp3TraitDispatcher of starknet::Store::<Comp3TraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Comp3TraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Comp3TraitDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitDispatcher> {
type SubPointersType = Comp3TraitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitDispatcher>) -> Comp3TraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Comp3TraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableComp3TraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableComp3TraitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Comp3TraitDispatcher> {
type SubPointersType = MutableComp3TraitDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitDispatcher>>) -> MutableComp3TraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableComp3TraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitLibraryDispatcher> {
    fn serialize(self: @Comp3TraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:30:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreComp3TraitLibraryDispatcher of starknet::Store::<Comp3TraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Comp3TraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Comp3TraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitLibraryDispatcher> {
type SubPointersType = Comp3TraitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitLibraryDispatcher>) -> Comp3TraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Comp3TraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableComp3TraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableComp3TraitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Comp3TraitLibraryDispatcher> {
type SubPointersType = MutableComp3TraitLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitLibraryDispatcher>>) -> MutableComp3TraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableComp3TraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitSafeLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitSafeLibraryDispatcher> {
    fn serialize(self: @Comp3TraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:30:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreComp3TraitSafeLibraryDispatcher of starknet::Store::<Comp3TraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Comp3TraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Comp3TraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitSafeLibraryDispatcher> {
type SubPointersType = Comp3TraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitSafeLibraryDispatcher>) -> Comp3TraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Comp3TraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableComp3TraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableComp3TraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Comp3TraitSafeLibraryDispatcher> {
type SubPointersType = MutableComp3TraitSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitSafeLibraryDispatcher>>) -> MutableComp3TraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableComp3TraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitSafeDispatcherCopy of core::traits::Copy::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherDrop of core::traits::Drop::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherSerde of core::serde::Serde::<Comp3TraitSafeDispatcher> {
    fn serialize(self: @Comp3TraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeDispatcher> {
        core::option::Option::Some(Comp3TraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:30:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreComp3TraitSafeDispatcher of starknet::Store::<Comp3TraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Comp3TraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Comp3TraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitSafeDispatcher> {
type SubPointersType = Comp3TraitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitSafeDispatcher>) -> Comp3TraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Comp3TraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableComp3TraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableComp3TraitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Comp3TraitSafeDispatcher> {
type SubPointersType = MutableComp3TraitSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitSafeDispatcher>>) -> MutableComp3TraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableComp3TraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitDispatcherSubPointers>;
impl Comp3TraitDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl MutableComp3TraitDispatcherSubPointersDrop of core::traits::Drop::<MutableComp3TraitDispatcherSubPointers>;
impl MutableComp3TraitDispatcherSubPointersCopy of core::traits::Copy::<MutableComp3TraitDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitLibraryDispatcherSubPointers>;
impl Comp3TraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitLibraryDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl MutableComp3TraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableComp3TraitLibraryDispatcherSubPointers>;
impl MutableComp3TraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableComp3TraitLibraryDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcherSubPointers>;
impl Comp3TraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl MutableComp3TraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableComp3TraitSafeLibraryDispatcherSubPointers>;
impl MutableComp3TraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableComp3TraitSafeLibraryDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitSafeDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitSafeDispatcherSubPointers>;
impl Comp3TraitSafeDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitSafeDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^********************^
impls:

impl MutableComp3TraitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableComp3TraitSafeDispatcherSubPointers>;
impl MutableComp3TraitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableComp3TraitSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::component]
^********************^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



lib.cairo:6:5
    #[generate_trait]
    ^***************^
generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo1(self: @ComponentState<TContractState>);
    }


lib.cairo:1:1
#[starknet::component]
^********************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::component]
^********************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;


lib.cairo:1:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;


lib.cairo:14:1
#[starknet::component]
^********************^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



lib.cairo:19:5
    #[generate_trait]
    ^***************^
generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo2(self: @ComponentState<TContractState>);
    }


lib.cairo:14:1
#[starknet::component]
^********************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:14:1
#[starknet::component]
^********************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:14:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;


lib.cairo:14:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;


lib.cairo:36:1
#[starknet::component]
^********************^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
pub impl Comp3<
            TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>

> of super::Comp3Trait<TContractState> {
    
    fn foo3(ref self: TContractState) {
        let mut component = HasComponent::get_component_mut(ref self);
        Comp3Impl::foo3(ref component)
    }
    
    fn foo4(self: @TContractState) {
        let component = HasComponent::get_component(self);
        Comp3Impl::foo4(component)
    }
}

lib.cairo:36:1
#[starknet::component]
^********************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:36:1
#[starknet::component]
^********************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:36:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;


lib.cairo:36:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;


lib.cairo:42:5
    #[embeddable_as(Comp3)]
    ^*********************^
embeddable:

pub trait UnsafeNewContractStateTraitForComp3<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__Comp3__foo3<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo3(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__Comp3__foo4<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo4(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



pub mod __external_Comp3 {
    pub use super::__wrapper__Comp3__foo3 as foo3;
    pub use super::__wrapper__Comp3__foo4 as foo4;
}

pub mod __l1_handler_Comp3 {
}

pub mod __constructor_Comp3 {
}

//! > ==========================================================================

//! > Test `get_dep_component_mut!` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component_mut!(ref self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component_mut!(Comp1, self).foo1();
            get_dep_component_mut!(ref self, self).foo1();
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
            get_dep_component_mut!(ref self, Comp2).foo1();
            get_dep_component_mut!(self, Comp1).foo1();
            get_dep_component_mut!(mut self, Comp1).foo1();
            get_dep_component_mut!(ref ref self, Comp1).foo1();
            get_dep_component_mut!(ref mut self, Comp1).foo1();
        }
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:51:36
            get_dep_component_mut!(Comp1, self).foo1();
                                   ^***^

error: Identifier not found.
 --> lib.cairo:52:46
            get_dep_component_mut!(ref self, self).foo1();
                                             ^**^

error: Expected variable or constant, found impl.
 --> lib.cairo:53:40
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
                                       ^***^

error: ref argument must be a variable.
 --> lib.cairo:53:40
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
                                       ^***^

error: Method `foo1` could not be called on type `test::component2::ComponentState::<TContractState>`.
Candidate `Comp1HelperTrait::foo1` inference failed with: Type mismatch: `test::component2::ComponentState::<TContractState>` and `@test::component1::ComponentState::<?8>`.
 --> lib.cairo:54:53
            get_dep_component_mut!(ref self, Comp2).foo1();
                                                    ^**^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:55:36
            get_dep_component_mut!(self, Comp1).foo1();
                                   ^**^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:56:40
            get_dep_component_mut!(mut self, Comp1).foo1();
                                       ^**^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:57:44
            get_dep_component_mut!(ref ref self, Comp1).foo1();
                                           ^**^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:58:44
            get_dep_component_mut!(ref mut self, Comp1).foo1();
                                           ^**^

error: Type annotations needed. Failed to infer ?2.
 --> lib.cairo:51:49
            get_dep_component_mut!(Comp1, self).foo1();
                                                ^**^

//! > generated_cairo_code
lib.cairo:

#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component_mut!(ref self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component_mut!(Comp1, self).foo1();
            get_dep_component_mut!(ref self, self).foo1();
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
            get_dep_component_mut!(ref self, Comp2).foo1();
            get_dep_component_mut!(self, Comp1).foo1();
            get_dep_component_mut!(mut self, Comp1).foo1();
            get_dep_component_mut!(ref ref self, Comp1).foo1();
            get_dep_component_mut!(ref mut self, Comp1).foo1();
        }
    }
}

lib.cairo:27:1
#[starknet::interface]
^********************^
Comp3TraitDispatcherTrait:

trait Comp3TraitDispatcherTrait<T> {
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitDispatcher> {
    fn foo3(self: Comp3TraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitLibraryDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitLibraryDispatcher> {
    fn foo3(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Comp3TraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitSafeLibraryDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeLibraryDispatcher> {
    fn foo3(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitSafeDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeDispatcher> {
    fn foo3(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitDispatcherCopy of core::traits::Copy::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherDrop of core::traits::Drop::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherSerde of core::serde::Serde::<Comp3TraitDispatcher> {
    fn serialize(self: @Comp3TraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitDispatcher> {
        core::option::Option::Some(Comp3TraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:27:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreComp3TraitDispatcher of starknet::Store::<Comp3TraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Comp3TraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Comp3TraitDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitDispatcher> {
type SubPointersType = Comp3TraitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitDispatcher>) -> Comp3TraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Comp3TraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableComp3TraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableComp3TraitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Comp3TraitDispatcher> {
type SubPointersType = MutableComp3TraitDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitDispatcher>>) -> MutableComp3TraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableComp3TraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitLibraryDispatcher> {
    fn serialize(self: @Comp3TraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:27:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreComp3TraitLibraryDispatcher of starknet::Store::<Comp3TraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Comp3TraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Comp3TraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitLibraryDispatcher> {
type SubPointersType = Comp3TraitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitLibraryDispatcher>) -> Comp3TraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Comp3TraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableComp3TraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableComp3TraitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Comp3TraitLibraryDispatcher> {
type SubPointersType = MutableComp3TraitLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitLibraryDispatcher>>) -> MutableComp3TraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableComp3TraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitSafeLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitSafeLibraryDispatcher> {
    fn serialize(self: @Comp3TraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:27:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreComp3TraitSafeLibraryDispatcher of starknet::Store::<Comp3TraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Comp3TraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Comp3TraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitSafeLibraryDispatcher> {
type SubPointersType = Comp3TraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitSafeLibraryDispatcher>) -> Comp3TraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Comp3TraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableComp3TraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableComp3TraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Comp3TraitSafeLibraryDispatcher> {
type SubPointersType = MutableComp3TraitSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitSafeLibraryDispatcher>>) -> MutableComp3TraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableComp3TraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitSafeDispatcherCopy of core::traits::Copy::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherDrop of core::traits::Drop::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherSerde of core::serde::Serde::<Comp3TraitSafeDispatcher> {
    fn serialize(self: @Comp3TraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeDispatcher> {
        core::option::Option::Some(Comp3TraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:27:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreComp3TraitSafeDispatcher of starknet::Store::<Comp3TraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Comp3TraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Comp3TraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitSafeDispatcher> {
type SubPointersType = Comp3TraitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitSafeDispatcher>) -> Comp3TraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Comp3TraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableComp3TraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableComp3TraitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Comp3TraitSafeDispatcher> {
type SubPointersType = MutableComp3TraitSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitSafeDispatcher>>) -> MutableComp3TraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableComp3TraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitDispatcherSubPointers>;
impl Comp3TraitDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl MutableComp3TraitDispatcherSubPointersDrop of core::traits::Drop::<MutableComp3TraitDispatcherSubPointers>;
impl MutableComp3TraitDispatcherSubPointersCopy of core::traits::Copy::<MutableComp3TraitDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitLibraryDispatcherSubPointers>;
impl Comp3TraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitLibraryDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl MutableComp3TraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableComp3TraitLibraryDispatcherSubPointers>;
impl MutableComp3TraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableComp3TraitLibraryDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcherSubPointers>;
impl Comp3TraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl MutableComp3TraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableComp3TraitSafeLibraryDispatcherSubPointers>;
impl MutableComp3TraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableComp3TraitSafeLibraryDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl Comp3TraitSafeDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitSafeDispatcherSubPointers>;
impl Comp3TraitSafeDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitSafeDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^********************^
impls:

impl MutableComp3TraitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableComp3TraitSafeDispatcherSubPointers>;
impl MutableComp3TraitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableComp3TraitSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::component]
^********************^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



lib.cairo:6:5
    #[generate_trait]
    ^***************^
generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo1(self: @ComponentState<TContractState>);
    }


lib.cairo:1:1
#[starknet::component]
^********************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::component]
^********************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;


lib.cairo:1:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;


lib.cairo:14:1
#[starknet::component]
^********************^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



lib.cairo:19:5
    #[generate_trait]
    ^***************^
generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo2(self: @ComponentState<TContractState>);
    }


lib.cairo:14:1
#[starknet::component]
^********************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:14:1
#[starknet::component]
^********************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:14:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;


lib.cairo:14:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;


lib.cairo:32:1
#[starknet::component]
^********************^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
pub impl Comp3<
            TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>

> of super::Comp3Trait<TContractState> {
    
    fn foo3(ref self: TContractState) {
        let mut component = HasComponent::get_component_mut(ref self);
        Comp3Impl::foo3(ref component)
    }
}

lib.cairo:32:1
#[starknet::component]
^********************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:32:1
#[starknet::component]
^********************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:32:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;


lib.cairo:32:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;


lib.cairo:38:5
    #[embeddable_as(Comp3)]
    ^*********************^
embeddable:

pub trait UnsafeNewContractStateTraitForComp3<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__Comp3__foo3<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo3(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



pub mod __external_Comp3 {
    pub use super::__wrapper__Comp3__foo3 as foo3;
}

pub mod __l1_handler_Comp3 {
}

pub mod __constructor_Comp3 {
}

//! > ==========================================================================

//! > Test write on a non ref contract state.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState);
}

#[starknet::contract]
mod contract {
    use super::ContractTrait;
    #[storage]
    struct Storage {
        a_member: felt252
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) {
            // Should raise diagnostics
            self.a_member.write(0);
        }
    }
}

//! > expected_diagnostics
error: Method `write` could not be called on type `core::starknet::storage::StorageBase::<core::felt252>`.
Candidate `StorageMapWriteAccessTrait::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StorageMapWriteAccessTrait::<core::starknet::storage::StorageBase::<core::felt252>>.
Candidate `StoragePointerWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StoragePointerWriteAccess::<core::starknet::storage::StorageBase::<core::felt252>>.
 --> lib.cairo:18:27
            self.a_member.write(0);
                          ^***^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState);
}

#[starknet::contract]
mod contract {
    use super::ContractTrait;
    #[storage]
    struct Storage {
        a_member: felt252
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) {
            // Should raise diagnostics
            self.a_member.write(0);
        }
    }
}

lib.cairo:1:1
#[starknet::interface]
^********************^
ContractTraitDispatcherTrait:

trait ContractTraitDispatcherTrait<T> {
    fn foo(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitDispatcher> {
    fn foo(self: ContractTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitLibraryDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitLibraryDispatcher> {
    fn foo(self: ContractTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait ContractTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitSafeLibraryDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeLibraryDispatcher> {
    fn foo(self: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitSafeDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeDispatcher> {
    fn foo(self: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitDispatcherCopy of core::traits::Copy::<ContractTraitDispatcher>;
impl ContractTraitDispatcherDrop of core::traits::Drop::<ContractTraitDispatcher>;
impl ContractTraitDispatcherSerde of core::serde::Serde::<ContractTraitDispatcher> {
    fn serialize(self: @ContractTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitDispatcher> {
        core::option::Option::Some(ContractTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitDispatcher of starknet::Store::<ContractTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl ContractTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitDispatcher> {
type SubPointersType = ContractTraitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitDispatcher>) -> ContractTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableContractTraitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitDispatcher> {
type SubPointersType = MutableContractTraitDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitDispatcher>>) -> MutableContractTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitLibraryDispatcherCopy of core::traits::Copy::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherDrop of core::traits::Drop::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherSerde of core::serde::Serde::<ContractTraitLibraryDispatcher> {
    fn serialize(self: @ContractTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitLibraryDispatcher> {
        core::option::Option::Some(ContractTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitLibraryDispatcher of starknet::Store::<ContractTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl ContractTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitLibraryDispatcher> {
type SubPointersType = ContractTraitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitLibraryDispatcher>) -> ContractTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableContractTraitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitLibraryDispatcher> {
type SubPointersType = MutableContractTraitLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitLibraryDispatcher>>) -> MutableContractTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeLibraryDispatcherCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherSerde of core::serde::Serde::<ContractTraitSafeLibraryDispatcher> {
    fn serialize(self: @ContractTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeLibraryDispatcher> {
        core::option::Option::Some(ContractTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitSafeLibraryDispatcher of starknet::Store::<ContractTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl ContractTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeLibraryDispatcher> {
type SubPointersType = ContractTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeLibraryDispatcher>) -> ContractTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableContractTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitSafeLibraryDispatcher> {
type SubPointersType = MutableContractTraitSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeLibraryDispatcher>>) -> MutableContractTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeDispatcherCopy of core::traits::Copy::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherDrop of core::traits::Drop::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherSerde of core::serde::Serde::<ContractTraitSafeDispatcher> {
    fn serialize(self: @ContractTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeDispatcher> {
        core::option::Option::Some(ContractTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitSafeDispatcher of starknet::Store::<ContractTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl ContractTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeDispatcher> {
type SubPointersType = ContractTraitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeDispatcher>) -> ContractTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableContractTraitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitSafeDispatcher> {
type SubPointersType = MutableContractTraitSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeDispatcher>>) -> MutableContractTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitDispatcherSubPointers>;
impl ContractTraitDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitDispatcherSubPointers>;
impl MutableContractTraitDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitLibraryDispatcherSubPointers>;
impl ContractTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitLibraryDispatcherSubPointers>;
impl MutableContractTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcherSubPointers>;
impl ContractTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitSafeLibraryDispatcherSubPointers>;
impl MutableContractTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeDispatcherSubPointers>;
impl ContractTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitSafeDispatcherSubPointers>;
impl MutableContractTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitSafeDispatcherSubPointers>;


lib.cairo:6:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
          pub a_member: felt252,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub a_member: starknet::storage::StorageBase<felt252>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub a_member: starknet::storage::StorageBase<starknet::storage::Mutable<felt252>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           a_member: starknet::storage::StorageBase{ address: selector!("a_member") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           a_member: starknet::storage::StorageBase{ address: selector!("a_member") },
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x3b1a0f089233a1d0d98b6d9576c2636903d23c1b78085851496af3bff605a30;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractInterfaceImpl__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ContractInterfaceImpl::foo(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractInterfaceImpl__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:6:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:6:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:6:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:6:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > ==========================================================================

//! > Test write on a non ref component state.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::component]
mod test_component {
    #[storage]
    struct Storage {
        data: u32
    }
}

#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState);
}

#[starknet::contract]
mod contract {
    component!(path: super::test_component, storage: component_member, event: CompEvent);

    use super::ContractTrait;
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_member: super::test_component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::test_component::Event,
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) {
            // Should raise diagnostics
            self.component_member.data.write();
        }
    }
}

//! > expected_diagnostics
error: Method `write` could not be called on type `core::starknet::storage::StorageBase::<core::integer::u32>`.
Candidate `StorageMapWriteAccessTrait::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StorageMapWriteAccessTrait::<core::starknet::storage::StorageBase::<core::integer::u32>>.
Candidate `StoragePointerWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StoragePointerWriteAccess::<core::starknet::storage::StorageBase::<core::integer::u32>>.
 --> lib.cairo:35:40
            self.component_member.data.write();
                                       ^***^

//! > generated_cairo_code
lib.cairo:

#[starknet::component]
mod test_component {
    #[storage]
    struct Storage {
        data: u32
    }
}

#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState);
}

#[starknet::contract]
mod contract {
    component!(path: super::test_component, storage: component_member, event: CompEvent);

    use super::ContractTrait;
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_member: super::test_component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::test_component::Event,
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) {
            // Should raise diagnostics
            self.component_member.data.write();
        }
    }
}

lib.cairo:9:1
#[starknet::interface]
^********************^
ContractTraitDispatcherTrait:

trait ContractTraitDispatcherTrait<T> {
    fn foo(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitDispatcher> {
    fn foo(self: ContractTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitLibraryDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitLibraryDispatcher> {
    fn foo(self: ContractTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait ContractTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitSafeLibraryDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeLibraryDispatcher> {
    fn foo(self: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitSafeDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeDispatcher> {
    fn foo(self: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitDispatcherCopy of core::traits::Copy::<ContractTraitDispatcher>;
impl ContractTraitDispatcherDrop of core::traits::Drop::<ContractTraitDispatcher>;
impl ContractTraitDispatcherSerde of core::serde::Serde::<ContractTraitDispatcher> {
    fn serialize(self: @ContractTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitDispatcher> {
        core::option::Option::Some(ContractTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:9:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitDispatcher of starknet::Store::<ContractTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl ContractTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitDispatcher> {
type SubPointersType = ContractTraitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitDispatcher>) -> ContractTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableContractTraitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitDispatcher> {
type SubPointersType = MutableContractTraitDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitDispatcher>>) -> MutableContractTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitLibraryDispatcherCopy of core::traits::Copy::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherDrop of core::traits::Drop::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherSerde of core::serde::Serde::<ContractTraitLibraryDispatcher> {
    fn serialize(self: @ContractTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitLibraryDispatcher> {
        core::option::Option::Some(ContractTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:9:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitLibraryDispatcher of starknet::Store::<ContractTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl ContractTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitLibraryDispatcher> {
type SubPointersType = ContractTraitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitLibraryDispatcher>) -> ContractTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableContractTraitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitLibraryDispatcher> {
type SubPointersType = MutableContractTraitLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitLibraryDispatcher>>) -> MutableContractTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeLibraryDispatcherCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherSerde of core::serde::Serde::<ContractTraitSafeLibraryDispatcher> {
    fn serialize(self: @ContractTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeLibraryDispatcher> {
        core::option::Option::Some(ContractTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:9:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitSafeLibraryDispatcher of starknet::Store::<ContractTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl ContractTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeLibraryDispatcher> {
type SubPointersType = ContractTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeLibraryDispatcher>) -> ContractTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableContractTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitSafeLibraryDispatcher> {
type SubPointersType = MutableContractTraitSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeLibraryDispatcher>>) -> MutableContractTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeDispatcherCopy of core::traits::Copy::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherDrop of core::traits::Drop::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherSerde of core::serde::Serde::<ContractTraitSafeDispatcher> {
    fn serialize(self: @ContractTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeDispatcher> {
        core::option::Option::Some(ContractTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:9:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitSafeDispatcher of starknet::Store::<ContractTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl ContractTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeDispatcher> {
type SubPointersType = ContractTraitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeDispatcher>) -> ContractTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableContractTraitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitSafeDispatcher> {
type SubPointersType = MutableContractTraitSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeDispatcher>>) -> MutableContractTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitDispatcherSubPointers>;
impl ContractTraitDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitDispatcherSubPointers>;
impl MutableContractTraitDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitLibraryDispatcherSubPointers>;
impl ContractTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitLibraryDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitLibraryDispatcherSubPointers>;
impl MutableContractTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitLibraryDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcherSubPointers>;
impl ContractTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitSafeLibraryDispatcherSubPointers>;
impl MutableContractTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeDispatcherSubPointers>;
impl ContractTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitSafeDispatcherSubPointers>;
impl MutableContractTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::component]
^********************^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
          pub data: u32,
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
    pub data: starknet::storage::StorageBase<u32>,
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
    pub data: starknet::storage::StorageBase<starknet::storage::Mutable<u32>>,
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
           data: starknet::storage::StorageBase{ address: selector!("data") },
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
           data: starknet::storage::StorageBase{ address: selector!("data") },
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



lib.cairo:1:1
#[starknet::component]
^********************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::component]
^********************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;


lib.cairo:1:1
#[starknet::component]
^********************^
impls:

impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;


lib.cairo:14:1
#[starknet::contract]
^*******************^
contract:



#[phantom]
pub struct Storage {
          pub component_member: super::test_component::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub component_member: starknet::storage::StorageBase<super::test_component::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub component_member: starknet::storage::StorageBase<starknet::storage::Mutable<super::test_component::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           component_member: starknet::storage::StorageBase{ address: selector!("component_member") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           component_member: starknet::storage::StorageBase{ address: selector!("component_member") },
        }
    }
}
pub struct ContractState {
        pub component_member: super::test_component::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
            component_member: super::test_component::unsafe_new_component_state::<ContractState>(),
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x3653c75be8955a10e60ac6743eb49d095f4656c3a082b05e48756e24f1671f2;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractInterfaceImpl__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ContractInterfaceImpl::foo(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractInterfaceImpl__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_test_component of super::test_component::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @super::test_component::ComponentState<ContractState> {
                 @super::test_component::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> super::test_component::ComponentState<ContractState> {
        super::test_component::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @super::test_component::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: super::test_component::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, super::test_component::Event>>(ref self: super::test_component::ComponentState<ContractState>, event: S) {
        let event: super::test_component::Event = core::traits::Into::into(event);
        let mut contract = super::test_component::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::CompEvent(event));
    }
}


lib.cairo:24:1

^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:26:20
    #[derive(Drop, starknet::Event)]
                   ^*************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::CompEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("CompEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("CompEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::CompEvent(val));
        }
        Option::None
    }
}
impl EventCompEventIntoEvent of Into<super::test_component::Event, Event> {
    fn into(self: super::test_component::Event) -> Event {
        Event::CompEvent(self)
    }
}



lib.cairo:14:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:14:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;

//! > ==========================================================================

//! > Test sub pointers of a non `DeriveStorage` type.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
struct u256Pair {
    a: u256,
    b: u256
}

impl u256PairStore of starknet::Store<u256Pair> {
    fn read(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress
    ) -> starknet::SyscallResult<u256Pair> {
        let a = starknet::Store::<u256>::read(address_domain, base)?;
        let b = starknet::Store::<u256>::read_at_offset(address_domain, base, 2)?;
        starknet::SyscallResult::Ok(u256Pair { a, b })
    }
    fn write(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: u256Pair
    ) -> starknet::SyscallResult<()> {
        starknet::Store::<u256>::write(address_domain, base, value.a)?;
        starknet::Store::<u256>::write_at_offset(address_domain, base, 2, value.b)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8
    ) -> starknet::SyscallResult<u256Pair> {
        let a = starknet::Store::<u256>::read_at_offset(address_domain, base, offset)?;
        let b = starknet::Store::<u256>::read_at_offset(address_domain, base, offset + 2)?;
        starknet::SyscallResult::Ok(u256Pair { a, b })
    }
    fn write_at_offset(
        address_domain: u32,
        base: starknet::storage_access::StorageBaseAddress,
        offset: u8,
        value: u256Pair
    ) -> starknet::SyscallResult<()> {
        starknet::Store::<u256>::write_at_offset(address_domain, base, offset, value.a)?;
        starknet::Store::<u256>::write_at_offset(address_domain, base, offset + 2, value.b)?;
        starknet::SyscallResult::Ok(())
    }
    fn size() -> u8 {
        4
    }
}

#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState) -> u256;
}

#[starknet::contract]
mod contract {
    use super::ContractTrait;
    #[storage]
    struct Storage {
        u256_pair: super::u256Pair
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) -> u256 {
            self.u256_pair.a.read()
        }
    }
}

//! > expected_diagnostics
error: Type "core::starknet::storage::StorageBase::<test::u256Pair>" has no member "a"
 --> lib.cairo:59:28
            self.u256_pair.a.read()
                           ^

error: Ambiguous method call. More than one applicable trait function with a suitable self type was found: StorageMapReadAccessTrait::read and StoragePointerReadAccess::read. Consider adding type annotations or explicitly refer to the impl function.
 --> lib.cairo:59:30
            self.u256_pair.a.read()
                             ^**^

//! > generated_cairo_code
lib.cairo:

struct u256Pair {
    a: u256,
    b: u256
}

impl u256PairStore of starknet::Store<u256Pair> {
    fn read(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress
    ) -> starknet::SyscallResult<u256Pair> {
        let a = starknet::Store::<u256>::read(address_domain, base)?;
        let b = starknet::Store::<u256>::read_at_offset(address_domain, base, 2)?;
        starknet::SyscallResult::Ok(u256Pair { a, b })
    }
    fn write(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: u256Pair
    ) -> starknet::SyscallResult<()> {
        starknet::Store::<u256>::write(address_domain, base, value.a)?;
        starknet::Store::<u256>::write_at_offset(address_domain, base, 2, value.b)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8
    ) -> starknet::SyscallResult<u256Pair> {
        let a = starknet::Store::<u256>::read_at_offset(address_domain, base, offset)?;
        let b = starknet::Store::<u256>::read_at_offset(address_domain, base, offset + 2)?;
        starknet::SyscallResult::Ok(u256Pair { a, b })
    }
    fn write_at_offset(
        address_domain: u32,
        base: starknet::storage_access::StorageBaseAddress,
        offset: u8,
        value: u256Pair
    ) -> starknet::SyscallResult<()> {
        starknet::Store::<u256>::write_at_offset(address_domain, base, offset, value.a)?;
        starknet::Store::<u256>::write_at_offset(address_domain, base, offset + 2, value.b)?;
        starknet::SyscallResult::Ok(())
    }
    fn size() -> u8 {
        4
    }
}

#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState) -> u256;
}

#[starknet::contract]
mod contract {
    use super::ContractTrait;
    #[storage]
    struct Storage {
        u256_pair: super::u256Pair
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) -> u256 {
            self.u256_pair.a.read()
        }
    }
}

lib.cairo:43:1
#[starknet::interface]
^********************^
ContractTraitDispatcherTrait:

trait ContractTraitDispatcherTrait<T> {
    fn foo(self: T) -> u256;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitDispatcher> {
    fn foo(self: ContractTraitDispatcher) -> u256 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<u256>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitLibraryDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitLibraryDispatcher> {
    fn foo(self: ContractTraitLibraryDispatcher) -> u256 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<u256>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

trait ContractTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo(self: T) -> starknet::SyscallResult<u256>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitSafeLibraryDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeLibraryDispatcher> {
    fn foo(self: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<u256> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<u256>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitSafeDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeDispatcher> {
    fn foo(self: ContractTraitSafeDispatcher) -> starknet::SyscallResult<u256> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<u256>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitDispatcherCopy of core::traits::Copy::<ContractTraitDispatcher>;
impl ContractTraitDispatcherDrop of core::traits::Drop::<ContractTraitDispatcher>;
impl ContractTraitDispatcherSerde of core::serde::Serde::<ContractTraitDispatcher> {
    fn serialize(self: @ContractTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitDispatcher> {
        core::option::Option::Some(ContractTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:43:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitDispatcher of starknet::Store::<ContractTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl ContractTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitDispatcher> {
type SubPointersType = ContractTraitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitDispatcher>) -> ContractTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableContractTraitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitDispatcher> {
type SubPointersType = MutableContractTraitDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitDispatcher>>) -> MutableContractTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitLibraryDispatcherCopy of core::traits::Copy::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherDrop of core::traits::Drop::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherSerde of core::serde::Serde::<ContractTraitLibraryDispatcher> {
    fn serialize(self: @ContractTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitLibraryDispatcher> {
        core::option::Option::Some(ContractTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:43:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitLibraryDispatcher of starknet::Store::<ContractTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl ContractTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitLibraryDispatcher> {
type SubPointersType = ContractTraitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitLibraryDispatcher>) -> ContractTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableContractTraitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitLibraryDispatcher> {
type SubPointersType = MutableContractTraitLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitLibraryDispatcher>>) -> MutableContractTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeLibraryDispatcherCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherSerde of core::serde::Serde::<ContractTraitSafeLibraryDispatcher> {
    fn serialize(self: @ContractTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeLibraryDispatcher> {
        core::option::Option::Some(ContractTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:43:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitSafeLibraryDispatcher of starknet::Store::<ContractTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl ContractTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeLibraryDispatcher> {
type SubPointersType = ContractTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeLibraryDispatcher>) -> ContractTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableContractTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitSafeLibraryDispatcher> {
type SubPointersType = MutableContractTraitSafeLibraryDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeLibraryDispatcher>>) -> MutableContractTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeDispatcherCopy of core::traits::Copy::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherDrop of core::traits::Drop::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherSerde of core::serde::Serde::<ContractTraitSafeDispatcher> {
    fn serialize(self: @ContractTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeDispatcher> {
        core::option::Option::Some(ContractTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:43:1
#[starknet::interface]
^********************^
starknet_derive:

impl StoreContractTraitSafeDispatcher of starknet::Store::<ContractTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct ContractTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl ContractTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeDispatcher> {
type SubPointersType = ContractTraitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeDispatcher>) -> ContractTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                ContractTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableContractTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableContractTraitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<ContractTraitSafeDispatcher> {
type SubPointersType = MutableContractTraitSafeDispatcherSubPointers;
   fn mutable_sub_pointers(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeDispatcher>>) -> MutableContractTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableContractTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitDispatcherSubPointers>;
impl ContractTraitDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitDispatcherSubPointers>;
impl MutableContractTraitDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitLibraryDispatcherSubPointers>;
impl ContractTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitLibraryDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitLibraryDispatcherSubPointers>;
impl MutableContractTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitLibraryDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcherSubPointers>;
impl ContractTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitSafeLibraryDispatcherSubPointers>;
impl MutableContractTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl ContractTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeDispatcherSubPointers>;
impl ContractTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^********************^
impls:

impl MutableContractTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableContractTraitSafeDispatcherSubPointers>;
impl MutableContractTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableContractTraitSafeDispatcherSubPointers>;


lib.cairo:48:1
#[starknet::contract]
^*******************^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
          pub u256_pair: super::u256Pair,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub u256_pair: starknet::storage::StorageBase<super::u256Pair>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub u256_pair: starknet::storage::StorageBase<starknet::storage::Mutable<super::u256Pair>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           u256_pair: starknet::storage::StorageBase{ address: selector!("u256_pair") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           u256_pair: starknet::storage::StorageBase{ address: selector!("u256_pair") },
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x1ef205582bfa9cd0a088bc1b88a40d43b5ed2c42cf4087763c93ef1eb5803a6;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractInterfaceImpl__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractInterfaceImpl::foo(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u256>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractInterfaceImpl__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:48:1
#[starknet::contract]
^*******************^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:48:1
#[starknet::contract]
^*******************^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:48:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;


lib.cairo:48:1
#[starknet::contract]
^*******************^
impls:

impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
