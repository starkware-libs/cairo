//! > Test first param must be self.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    fn foo() {}

    #[external(v0)]
    fn bar(_n: u32) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    fn foo() {}

    #[external(v0)]
    fn bar(_n: u32) {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x198f4bc6efa8417922f8041d6e73821af41c6bbf15f1c93084da188702456b;


    mod __external {
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The first parameter of an entry point must be `self`.
 --> lib.cairo:7:11
    fn foo() {}
          ^^

error: Plugin diagnostic: The first parameter of an entry point must be `self`.
 --> lib.cairo:10:12
    fn bar(_n: u32) {}
           ^*****^

//! > ==========================================================================

//! > Test invalid constructor name.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[constructor]
    fn invalid_constructor_name(ref self: ContractState) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[constructor]
    fn invalid_constructor_name(ref self: ContractState) {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x3bd690d1a73da0d8c43f46ecc3a006978d8343a075e91a1c7a24529e7d244a;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__invalid_constructor_name(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    invalid_constructor_name(ref contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}


    mod __external {
    }

    mod __l1_handler {
    }

    mod __constructor {
        use super::__wrapper__invalid_constructor_name as invalid_constructor_name;
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The constructor function must be called `constructor`.
 --> lib.cairo:7:8
    fn invalid_constructor_name(ref self: ContractState) {}
       ^**********************^

//! > ==========================================================================

//! > Test diagnostics non legacy storage variable.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        mapping: Map::<felt252, felt252>,
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        mapping: Map::<felt252, felt252>,
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
        mapping: mapping::ContractMemberState,
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
            mapping: mapping::ContractMemberState {},
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x14b80a3dbe8461b938c026ddbb0c5d189ca6e45d333ff1ecaecfe92dce54d9d;


    mod __external {
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Non `LegacyMap` mapping is not yet supported.
 --> lib.cairo:5:18
        mapping: Map::<felt252, felt252>,
                 ^*********************^

error: Plugin diagnostic: Identifier not found.
 --> lib.cairo:5:9
        mapping: Map::<felt252, felt252>,
        ^*****^

error: Invalid drop trait implementation, Candidate impl core::traits::SnapshotDrop::<?0> has an unused generic parameter..
 --> lib.cairo[contract]:9:5
    impl ContractStateDrop of Drop<ContractState> {}
    ^**********************************************^

error: Plugin diagnostic: Identifier not found.
 --> lib.cairo:5:9
        mapping: Map::<felt252, felt252>,
        ^*****^

//! > ==========================================================================

//! > Test non-v0 external function.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo_v0(ref self: ContractState, x: (felt252, felt252)) {
    }
    #[external]
    fn foo(ref self: ContractState, x: (felt252, felt252)) {
    }
    #[external(v1)]
    fn foo_v1(ref self: ContractState, x: (felt252, felt252)) {
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo_v0(ref self: ContractState, x: (felt252, felt252)) {
    }
    #[external]
    fn foo(ref self: ContractState, x: (felt252, felt252)) {
    }
    #[external(v1)]
    fn foo_v1(ref self: ContractState, x: (felt252, felt252)) {
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0xdee30876537447b8a21b901cf0379b47de6b9fcb087ab5e54f097e822f243c;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo_v0(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    let __arg_x = option::OptionTraitImpl::expect(
        serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo_v0(ref contract_state, __arg_x);
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    let __arg_x = option::OptionTraitImpl::expect(
        serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo_v1(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    let __arg_x = option::OptionTraitImpl::expect(
        serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo_v1(ref contract_state, __arg_x);
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}


    mod __external {
        use super::__wrapper__foo_v0 as foo_v0;
        use super::__wrapper__foo as foo;
        use super::__wrapper__foo_v1 as foo_v1;
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:8:5
    #[external]
    ^*********^

error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:11:5
    #[external(v1)]
    ^*************^

//! > ==========================================================================

//! > Test diagnostics of non-serializable parameter in entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState, x: super::MyType) {
    }
}
#[derive(Drop)]
struct MyType{}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState, x: super::MyType) {
    }
}
#[derive(Drop)]
struct MyType{}

impls:

impl MyTypeDrop of Drop::<MyType>;


contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0xd3b97940b766b03f59196c092939b4f964559ef1cd235415d018804dbdcfe3;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    let __arg_x = option::OptionTraitImpl::expect(
        serde::Serde::<super::MyType>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}


    mod __external {
        use super::__wrapper__foo as foo;
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::serde::Serde::<test::MyType>
 --> lib.cairo[contract]:33:40
        serde::Serde::<super::MyType>::deserialize(ref data),
                                       ^*********^

//! > ==========================================================================

//! > Test diagnostics of non-serializable return type in entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState) -> (felt252, felt252) {
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState) -> (felt252, felt252) {
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x114e2e703df7c3eba53b970519666cfce0ede18d79e35b62fa95c0ecb6601fc;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = foo(ref contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    serde::Serde::<(felt252, felt252)>::serialize(@res, ref arr);
    array::ArrayTrait::span(@arr)
}


    mod __external {
        use super::__wrapper__foo as foo;
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "(core::felt252, core::felt252)", found: "()".
 --> lib.cairo:6:59
    fn foo(ref self: ContractState) -> (felt252, felt252) {
                                                          ^

//! > ==========================================================================

//! > Test diagnostics of generic entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo<T>(ref self: ContractState, x: T) {
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo<T>(ref self: ContractState, x: T) {
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x2cc0463f1cfda138e64b2f35959f33601b5e1076814981ef2444d17ce259dfb;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    let __arg_x = option::OptionTraitImpl::expect(
        serde::Serde::<T>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}


    mod __external {
        use super::__wrapper__foo as foo;
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Contract entry points cannot have generic arguments
 --> lib.cairo:6:11
    fn foo<T>(ref self: ContractState, x: T) {
          ^*^

error: Type not found.
 --> lib.cairo[contract]:33:24
        serde::Serde::<T>::deserialize(ref data),
                       ^

error: Type annotations needed. Failed to infer ?2
 --> lib.cairo[contract]:32:27
    let __arg_x = option::OptionTraitImpl::expect(
                          ^*************^

error: Variable not dropped.
 --> lib.cairo:6:40
    fn foo<T>(ref self: ContractState, x: T) {
                                       ^
note: Trait has no implementation in context: core::traits::Drop::<T>
note: Trait has no implementation in context: core::traits::Destruct::<T>

//! > ==========================================================================

//! > Test multiple diagnostics from entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState, x: (felt252, felt252), y: (felt252, felt252)) -> (felt252, felt252) {
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState, x: (felt252, felt252), y: (felt252, felt252)) -> (felt252, felt252) {
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x34ebdf0a4defb7a8b628dda81a7dc347d8d3459040c2e1165ae0f7856bb7a29;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    let __arg_x = option::OptionTraitImpl::expect(
        serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let __arg_y = option::OptionTraitImpl::expect(
        serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = foo(ref contract_state, __arg_x, __arg_y);
    let mut arr = array::array_new();
    // References.
    // Result.
    serde::Serde::<(felt252, felt252)>::serialize(@res, ref arr);
    array::ArrayTrait::span(@arr)
}


    mod __external {
        use super::__wrapper__foo as foo;
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "(core::felt252, core::felt252)", found: "()".
 --> lib.cairo:6:105
    fn foo(ref self: ContractState, x: (felt252, felt252), y: (felt252, felt252)) -> (felt252, felt252) {
                                                                                                        ^

//! > ==========================================================================

//! > Test account contract_entry point on a non-account contract.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: *)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn __validate__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_declare__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_deploy__(ref self: ContractState) {}
    #[external(v0)]
    fn __execute__(ref self: ContractState) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn __validate__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_declare__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_deploy__(ref self: ContractState) {}
    #[external(v0)]
    fn __execute__(ref self: ContractState) {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x291a42fae50c99636dc1d6bc0c4e28fdb0e21f47c26aa0d5e22c21d993823d8;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper____validate__(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate__(ref contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper____validate_declare__(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate_declare__(ref contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper____validate_deploy__(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate_deploy__(ref contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper____execute__(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __execute__(ref contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}


    mod __external {
        use super::__wrapper____validate__ as __validate__;
        use super::__wrapper____validate_declare__ as __validate_declare__;
        use super::__wrapper____validate_deploy__ as __validate_deploy__;
        use super::__wrapper____execute__ as __execute__;
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Test raw_outputs diagnostics.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    #[raw_output]
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}

    #[external(v0)]
    #[raw_output]
    fn bar1(ref self: ContractState, a: felt252) -> felt252 { 0 }

    #[external(v0)]
    #[raw_output]
    fn bar2(ref self: ContractState, a: felt252) {}

    // Should generate diagnostic as path resolving is not supported.
    #[external(v0)]
    #[raw_output]
    fn bar3(ref self: ContractState, a: felt252) -> core::Array::<felt252> {
         array::array_new()
    }

    // Should generate diagnostic as alias resolving is not supported.
    type my_felt252_array_type = Array::<felt252>;
    #[external(v0)]
    #[raw_output]
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
        array::array_new()
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    #[raw_output]
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}

    #[external(v0)]
    #[raw_output]
    fn bar1(ref self: ContractState, a: felt252) -> felt252 { 0 }

    #[external(v0)]
    #[raw_output]
    fn bar2(ref self: ContractState, a: felt252) {}

    // Should generate diagnostic as path resolving is not supported.
    #[external(v0)]
    #[raw_output]
    fn bar3(ref self: ContractState, a: felt252) -> core::Array::<felt252> {
         array::array_new()
    }

    // Should generate diagnostic as alias resolving is not supported.
    type my_felt252_array_type = Array::<felt252>;
    #[external(v0)]
    #[raw_output]
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
        array::array_new()
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x36b41c3fffa5f7f882a01476ca45292d6254f8dc075e4837185259a4d5d8351;


    mod __external {
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: `raw_output` functions cannot have `ref` parameters.
 --> lib.cairo:8:37
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                    ^*^

error: Plugin diagnostic: `raw_output` functions cannot have `ref` parameters.
 --> lib.cairo:8:53
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                                    ^*^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:8:69
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                                                    ^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:12:53
    fn bar1(ref self: ContractState, a: felt252) -> felt252 { 0 }
                                                    ^*****^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:16:50
    fn bar2(ref self: ContractState, a: felt252) {}
                                                 ^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:21:53
    fn bar3(ref self: ContractState, a: felt252) -> core::Array::<felt252> {
                                                    ^********************^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:29:53
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
                                                    ^*******************^

//! > ==========================================================================

//! > Test reusage of storage var name diagnostics.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
        same_name: same_name::ContractMemberState,
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
            same_name: same_name::ContractMemberState {},
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
    use same_name::InternalContractMemberStateTrait as same_nameContractMemberStateTrait;
    mod same_name {
        #[derive(Copy, Drop)]
        struct ContractMemberState {}
        trait InternalContractMemberStateTrait {
            fn address(self: @ContractMemberState) -> starknet::StorageBaseAddress;
            fn read(self: @ContractMemberState) -> felt252;
            fn write(ref self: ContractMemberState, value: felt252);
        }

        impl InternalContractMemberStateImpl of InternalContractMemberStateTrait {
            fn address(self: @ContractMemberState) -> starknet::StorageBaseAddress {
                starknet::storage_base_address_const::<0x26673b81123c540a9238f376b833c3914834c3c0cdf4e609f834963616d3ef9>()
            }
            fn read(self: @ContractMemberState) -> felt252 {
                // Only address_domain 0 is currently supported.
                let address_domain = 0_u32;
                starknet::SyscallResultTraitImpl::unwrap_syscall(
                    starknet::Store::<felt252>::read(
                        address_domain,
                        InternalContractMemberStateImpl::address(self),
                    )
                )
            }
            fn write(ref self: ContractMemberState, value: felt252) {
                // Only address_domain 0 is currently supported.
                let address_domain = 0_u32;
                starknet::SyscallResultTraitImpl::unwrap_syscall(
                    starknet::Store::<felt252>::write(
                        address_domain,
                        InternalContractMemberStateImpl::address(@self),
                        value,
                    )
                )
            }
        }
    }
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x271c051b9d25373bc88ddfddfb1c29cc601d7014c5343fe167b82768570a896;


    mod __external {
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The name `same_name` is defined multiple times.
 --> lib.cairo:5:9
        same_name: felt252,
        ^*******^

//! > ==========================================================================

//! > Contract with no storage.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    fn same_name() -> felt252 {
        1
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Contracts must define a 'Storage' struct.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

//! > ==========================================================================

//! > Not annotated storage struct.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: 'Storage' struct must be annotated with #[storage].
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

//! > ==========================================================================

//! > Non v0 impls.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
    }
    #[external(v0)]
    #[generate_trait]
    impl AImpl of ATrait {}

    #[external(v1)]
    #[generate_trait]
    impl BImpl of BTrait {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
    }
    #[external(v0)]
    #[generate_trait]
    impl AImpl of ATrait {}

    #[external(v1)]
    #[generate_trait]
    impl BImpl of BTrait {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x3d8335ac3c47c73a6e9c5c10ea897e897b215aba4c18ccab86db3595169e73c;


    mod __external {
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



generate_trait:

    trait ATrait {}


generate_trait:

    trait BTrait {}


impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:10:5
    #[external(v1)]
    ^*************^

//! > ==========================================================================

//! > old contract attribute.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[contract]
mod test_contract {

}

#[abi]
trait ContractAbi {

}

//! > generated_cairo_code
lib.cairo:

#[contract]
mod test_contract {

}

#[abi]
trait ContractAbi {

}

//! > expected_diagnostics
error: Plugin diagnostic: Unsupported attribute.
 --> lib.cairo:1:1
#[contract]
^*********^

error: Plugin diagnostic: The 'contract' attribute was deprecated, please use `starknet::contract` instead.
 --> lib.cairo:1:1
#[contract]
^*********^

error: Plugin diagnostic: The 'abi' attribute for traits was deprecated, please use `starknet::interface` instead.
 --> lib.cairo:6:1
#[abi]
^****^

//! > ==========================================================================

//! > Attributes in external impl.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait InterfaceTrait<TContractState> {
    fn foo_external1(self: @TContractState);
    fn foo_l1_handler1(self: @TContractState);
    fn foo_constructor1(self: @TContractState);
}

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
    }

    #[external(v0)]
    impl Impl2 of super::InterfaceTrait<ContractState> {
        #[external(v0)]
        fn foo_external1(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler1(self: @ContractState) {}
        #[constructor]
        fn foo_constructor1(self: @ContractState) {}
    }

    #[generate_trait]
    #[external(v0)]
    impl Impl1 of NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState) {}
        #[constructor]
        fn foo_constructor2(self: @ContractState) {}
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:16:9
        #[external(v0)]
        ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:18:9
        #[l1_handler]
        ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:20:9
        #[constructor]
        ^************^

error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:27:9
        #[external(v0)]
        ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:29:9
        #[l1_handler]
        ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:31:9
        #[constructor]
        ^************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait InterfaceTrait<TContractState> {
    fn foo_external1(self: @TContractState);
    fn foo_l1_handler1(self: @TContractState);
    fn foo_constructor1(self: @TContractState);
}

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
    }

    #[external(v0)]
    impl Impl2 of super::InterfaceTrait<ContractState> {
        #[external(v0)]
        fn foo_external1(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler1(self: @ContractState) {}
        #[constructor]
        fn foo_constructor1(self: @ContractState) {}
    }

    #[generate_trait]
    #[external(v0)]
    impl Impl1 of NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState) {}
        #[constructor]
        fn foo_constructor2(self: @ContractState) {}
    }
}

InterfaceTraitDispatcherTrait:

trait InterfaceTraitDispatcherTrait<T> {
    fn foo_external1(self: T);
    fn foo_l1_handler1(self: T);
    fn foo_constructor1(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitDispatcher {
    contract_address: starknet::ContractAddress,
}

impl InterfaceTraitDispatcherImpl of InterfaceTraitDispatcherTrait<InterfaceTraitDispatcher> {
    fn foo_external1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo_external1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo_l1_handler1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo_l1_handler1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo_constructor1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo_constructor1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl InterfaceTraitLibraryDispatcherImpl of InterfaceTraitDispatcherTrait<InterfaceTraitLibraryDispatcher> {
    fn foo_external1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_external1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo_l1_handler1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_l1_handler1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo_constructor1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_constructor1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }

}

trait InterfaceTraitSafeDispatcherTrait<T> {
    fn foo_external1(self: T) -> starknet::SyscallResult<()>;
    fn foo_l1_handler1(self: T) -> starknet::SyscallResult<()>;
    fn foo_constructor1(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitSafeLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl InterfaceTraitSafeLibraryDispatcherImpl of InterfaceTraitSafeDispatcherTrait<InterfaceTraitSafeLibraryDispatcher> {
    fn foo_external1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_external1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo_l1_handler1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_l1_handler1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo_constructor1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_constructor1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitSafeDispatcher {
    contract_address: starknet::ContractAddress,
}

impl InterfaceTraitSafeDispatcherImpl of InterfaceTraitSafeDispatcherTrait<InterfaceTraitSafeDispatcher> {
    fn foo_external1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo_external1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo_l1_handler1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo_l1_handler1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo_constructor1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo_constructor1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }

}


impls:

impl InterfaceTraitDispatcherCopy of Copy::<InterfaceTraitDispatcher>;
impl InterfaceTraitDispatcherDrop of Drop::<InterfaceTraitDispatcher>;
impl InterfaceTraitDispatcherSerde of Serde::<InterfaceTraitDispatcher> {
    fn serialize(self: @InterfaceTraitDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceTraitDispatcher> {
        Option::Some(InterfaceTraitDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceTraitDispatcher of starknet::Store::<InterfaceTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl InterfaceTraitLibraryDispatcherCopy of Copy::<InterfaceTraitLibraryDispatcher>;
impl InterfaceTraitLibraryDispatcherDrop of Drop::<InterfaceTraitLibraryDispatcher>;
impl InterfaceTraitLibraryDispatcherSerde of Serde::<InterfaceTraitLibraryDispatcher> {
    fn serialize(self: @InterfaceTraitLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceTraitLibraryDispatcher> {
        Option::Some(InterfaceTraitLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceTraitLibraryDispatcher of starknet::Store::<InterfaceTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceTraitSafeLibraryDispatcherCopy of Copy::<InterfaceTraitSafeLibraryDispatcher>;
impl InterfaceTraitSafeLibraryDispatcherDrop of Drop::<InterfaceTraitSafeLibraryDispatcher>;
impl InterfaceTraitSafeLibraryDispatcherSerde of Serde::<InterfaceTraitSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceTraitSafeLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceTraitSafeLibraryDispatcher> {
        Option::Some(InterfaceTraitSafeLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceTraitSafeLibraryDispatcher of starknet::Store::<InterfaceTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceTraitSafeDispatcherCopy of Copy::<InterfaceTraitSafeDispatcher>;
impl InterfaceTraitSafeDispatcherDrop of Drop::<InterfaceTraitSafeDispatcher>;
impl InterfaceTraitSafeDispatcherSerde of Serde::<InterfaceTraitSafeDispatcher> {
    fn serialize(self: @InterfaceTraitSafeDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceTraitSafeDispatcher> {
        Option::Some(InterfaceTraitSafeDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceTraitSafeDispatcher of starknet::Store::<InterfaceTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0xf88f1c8a0a8d514425e46be98fb5ba0ba2db1093397ff93bd36d471ed4b970;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl2__foo_external1(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_external1(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl2__foo_l1_handler1(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_l1_handler1(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl2__foo_constructor1(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_constructor1(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl1__foo_external2(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_external2(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl1__foo_l1_handler2(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_l1_handler2(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl1__foo_constructor2(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_constructor2(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}


    mod __external {
        use super::__wrapper__Impl2__foo_external1 as foo_external1;
        use super::__wrapper__Impl2__foo_l1_handler1 as foo_l1_handler1;
        use super::__wrapper__Impl2__foo_constructor1 as foo_constructor1;
        use super::__wrapper__Impl1__foo_external2 as foo_external2;
        use super::__wrapper__Impl1__foo_l1_handler2 as foo_l1_handler2;
        use super::__wrapper__Impl1__foo_constructor2 as foo_constructor2;
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



generate_trait:

    trait NonInterfaceTrait {
        fn foo_external2(self: @ContractState);
        fn foo_l1_handler2(self: @ContractState);
        fn foo_constructor2(self: @ContractState);
    }


impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > ==========================================================================

//! > "Event" enum without #[event].

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
    }

    #[derive(Drop, starknet::Event)]
    enum Event {
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
    }

    #[derive(Drop, starknet::Event)]
    enum Event {
    }
}

contract:



    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x6c97de948ac6fb043d95e7e280901efdd422607b3b71dafd3abf300622647b;


    mod __external {
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Contract type that is named `Event` must be marked with #[event].
 --> lib.cairo:8:10
    enum Event {
         ^***^

//! > ==========================================================================

//! > #[event] enum that isn't named "Event".

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum MyEvent {
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum MyEvent {
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x2e575c45381314b9946066629db110dd30bb5e0b081753f226075310e440696;


    mod __external {
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl MyEventDrop of Drop::<MyEvent>;


starknet_derive:

impl MyEventIsEvent of starknet::Event<MyEvent> {
    fn append_keys_and_data(
        self: @MyEvent, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<MyEvent> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Contract type that is marked with #[event] must be named `Event`.
 --> lib.cairo:9:10
    enum MyEvent {
         ^*****^

//! > ==========================================================================

//! > Test `starknet::interface` trait with no body.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T>;

//! > expected_diagnostics
error: Plugin diagnostic: Starknet interfaces without body are not supported.
 --> lib.cairo:2:19
trait IContract<T>;
                  ^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T>;

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad generic params.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract2Generics<T, S> {
}

#[starknet::interface]
trait IContract0Generics {
}

#[starknet::interface]
trait IContractNonTypeGenerics<+Destruct<u32>> {
}

//! > expected_diagnostics
error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:2:25
trait IContract2Generics<T, S> {
                        ^****^

error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:6:26
trait IContract0Generics {
                         ^

error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:10:31
trait IContractNonTypeGenerics<+Destruct<u32>> {
                              ^**************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract2Generics<T, S> {
}

#[starknet::interface]
trait IContract0Generics {
}

#[starknet::interface]
trait IContractNonTypeGenerics<+Destruct<u32>> {
}

//! > ==========================================================================

//! > Test `starknet::interface` trait with non-self param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
    fn no_params() -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: The first parameter must be named `self`.
 --> lib.cairo:3:21
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
                    ^***************^

error: Plugin diagnostic: The first parameter must be named `self`.
 --> lib.cairo:4:22
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
                     ^************^

error: Plugin diagnostic: `starknet::interface` functions must have a `self` parameter.
 --> lib.cairo:5:5
    fn no_params() -> felt252;
    ^***********************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
    fn no_params() -> felt252;
}

IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


impls:

impl IContractDispatcherCopy of Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractDispatcher> {
        Option::Some(IContractDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl IContractLibraryDispatcherCopy of Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractLibraryDispatcher> {
        Option::Some(IContractLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeLibraryDispatcherCopy of Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractSafeLibraryDispatcher> {
        Option::Some(IContractSafeLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeDispatcherCopy of Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractSafeDispatcher> {
        Option::Some(IContractSafeDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad non-first param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn foo(
        ref self: T,
        ref param_ref: felt252,
        t_param: T,
        arr_param: Array<T>,
        snap_param: @T,
        tup_param: (felt252, T),
    ) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> lib.cairo:5:9
        ref param_ref: felt252,
        ^*^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:6:18
        t_param: T,
                 ^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:7:20
        arr_param: Array<T>,
                   ^******^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:8:21
        snap_param: @T,
                    ^^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:9:20
        tup_param: (felt252, T),
                   ^**********^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn foo(
        ref self: T,
        ref param_ref: felt252,
        t_param: T,
        arr_param: Array<T>,
        snap_param: @T,
        tup_param: (felt252, T),
    ) -> felt252;
}

IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


impls:

impl IContractDispatcherCopy of Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractDispatcher> {
        Option::Some(IContractDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl IContractLibraryDispatcherCopy of Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractLibraryDispatcher> {
        Option::Some(IContractLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeLibraryDispatcherCopy of Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractSafeLibraryDispatcher> {
        Option::Some(IContractSafeLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeDispatcherCopy of Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractSafeDispatcher> {
        Option::Some(IContractSafeDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad modifiers for self param.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:3:24
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
                       ^*****^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
}

IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


impls:

impl IContractDispatcherCopy of Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractDispatcher> {
        Option::Some(IContractDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl IContractLibraryDispatcherCopy of Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractLibraryDispatcher> {
        Option::Some(IContractLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeLibraryDispatcherCopy of Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractSafeLibraryDispatcher> {
        Option::Some(IContractSafeLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeDispatcherCopy of Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractSafeDispatcher> {
        Option::Some(IContractSafeDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad self param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn foo(ref self: u32, other: felt252) -> felt252;
    fn bar(self: @u32, other: felt252) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:3:12
    fn foo(ref self: u32, other: felt252) -> felt252;
           ^***********^

error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:4:12
    fn bar(self: @u32, other: felt252) -> felt252;
           ^********^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn foo(ref self: u32, other: felt252) -> felt252;
    fn bar(self: @u32, other: felt252) -> felt252;
}

IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


impls:

impl IContractDispatcherCopy of Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractDispatcher> {
        Option::Some(IContractDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl IContractLibraryDispatcherCopy of Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractLibraryDispatcher> {
        Option::Some(IContractLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeLibraryDispatcherCopy of Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractSafeLibraryDispatcher> {
        Option::Some(IContractSafeLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeDispatcherCopy of Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<IContractSafeDispatcher> {
        Option::Some(IContractSafeDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

//! > ==========================================================================

//! > Test `starknet::embeddable` impl with (disallowed) attributes for its methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::embeddable]
impl EmbeddableImpl<TContractState> of Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {}
    #[l1_handler]
    fn foo2(self: @TContractState) {}
    #[constructor]
    fn foo3(self: @TContractState) {}
}

//! > expected_diagnostics
error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:9:5
    #[external(v0)]
    ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:11:5
    #[l1_handler]
    ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:13:5
    #[constructor]
    ^************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::embeddable]
impl EmbeddableImpl<TContractState> of Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {}
    #[l1_handler]
    fn foo2(self: @TContractState) {}
    #[constructor]
    fn foo3(self: @TContractState) {}
}

InterfaceDispatcherTrait:

trait InterfaceDispatcherTrait<T> {
    fn foo1(self: T);
    fn foo2(self: T);
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceDispatcher {
    contract_address: starknet::ContractAddress,
}

impl InterfaceDispatcherImpl of InterfaceDispatcherTrait<InterfaceDispatcher> {
    fn foo1(self: InterfaceDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo2(self: InterfaceDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo3(self: InterfaceDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl InterfaceLibraryDispatcherImpl of InterfaceDispatcherTrait<InterfaceLibraryDispatcher> {
    fn foo1(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo2(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo3(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }

}

trait InterfaceSafeDispatcherTrait<T> {
    fn foo1(self: T) -> starknet::SyscallResult<()>;
    fn foo2(self: T) -> starknet::SyscallResult<()>;
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl InterfaceSafeLibraryDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeLibraryDispatcher> {
    fn foo1(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeDispatcher {
    contract_address: starknet::ContractAddress,
}

impl InterfaceSafeDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeDispatcher> {
    fn foo1(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }

}


embeddable:

trait UnsafeNewContractStateTraitForEmbeddableImpl<TContractState> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo1<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo1(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo2<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo2(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo3<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo3(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}



mod __external_EmbeddableImpl {
        use super::__wrapper__EmbeddableImpl__foo1 as foo1;
        use super::__wrapper__EmbeddableImpl__foo2 as foo2;
        use super::__wrapper__EmbeddableImpl__foo3 as foo3;
}

mod __l1_handler_EmbeddableImpl {
}

mod __constructor_EmbeddableImpl {
}


impls:

impl InterfaceDispatcherCopy of Copy::<InterfaceDispatcher>;
impl InterfaceDispatcherDrop of Drop::<InterfaceDispatcher>;
impl InterfaceDispatcherSerde of Serde::<InterfaceDispatcher> {
    fn serialize(self: @InterfaceDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceDispatcher> {
        Option::Some(InterfaceDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceDispatcher of starknet::Store::<InterfaceDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl InterfaceLibraryDispatcherCopy of Copy::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherDrop of Drop::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherSerde of Serde::<InterfaceLibraryDispatcher> {
    fn serialize(self: @InterfaceLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceLibraryDispatcher> {
        Option::Some(InterfaceLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceLibraryDispatcher of starknet::Store::<InterfaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceSafeLibraryDispatcherCopy of Copy::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherDrop of Drop::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherSerde of Serde::<InterfaceSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceSafeLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceSafeLibraryDispatcher> {
        Option::Some(InterfaceSafeLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceSafeLibraryDispatcher of starknet::Store::<InterfaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceSafeDispatcherCopy of Copy::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherDrop of Drop::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherSerde of Serde::<InterfaceSafeDispatcher> {
    fn serialize(self: @InterfaceSafeDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceSafeDispatcher> {
        Option::Some(InterfaceSafeDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceSafeDispatcher of starknet::Store::<InterfaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

//! > ==========================================================================

//! > Test `embeddable_as` impl with (disallowed) attributes for its methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::component]
mod component {
    #[storage]
    struct Storage {}

    #[embeddable_as(MyEmbeddableImpl)]
    impl MyImpl<TContractState, impl X: HasComponent<TContractState>> of super::Interface::<ComponentState::<TContractState>> {
        #[external(v0)]
        fn foo1(self: @ComponentState<TContractState>) {}
        #[l1_handler]
        fn foo2(self: @ComponentState<TContractState>) {}
        #[constructor]
        fn foo3(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::contract]
mod contract {
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_storage: super::component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::component::Event,
    }

    component!(path: super::component, storage: component_storage, event: CompEvent);

    #[abi(embed_v0)]
    impl MyEmbeddedImpl = super::component::MyEmbeddableImpl<ContractState>;
}

//! > expected_diagnostics
error: Plugin diagnostic: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:14:9
        #[external(v0)]
        ^*************^

error: Plugin diagnostic: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:16:9
        #[l1_handler]
        ^***********^

error: Plugin diagnostic: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:18:9
        #[constructor]
        ^************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::component]
mod component {
    #[storage]
    struct Storage {}

    #[embeddable_as(MyEmbeddableImpl)]
    impl MyImpl<TContractState, impl X: HasComponent<TContractState>> of super::Interface::<ComponentState::<TContractState>> {
        #[external(v0)]
        fn foo1(self: @ComponentState<TContractState>) {}
        #[l1_handler]
        fn foo2(self: @ComponentState<TContractState>) {}
        #[constructor]
        fn foo3(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::contract]
mod contract {
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_storage: super::component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::component::Event,
    }

    component!(path: super::component, storage: component_storage, event: CompEvent);

    #[abi(embed_v0)]
    impl MyEmbeddedImpl = super::component::MyEmbeddableImpl<ContractState>;
}

InterfaceDispatcherTrait:

trait InterfaceDispatcherTrait<T> {
    fn foo1(self: T);
    fn foo2(self: T);
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceDispatcher {
    contract_address: starknet::ContractAddress,
}

impl InterfaceDispatcherImpl of InterfaceDispatcherTrait<InterfaceDispatcher> {
    fn foo1(self: InterfaceDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo2(self: InterfaceDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo3(self: InterfaceDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl InterfaceLibraryDispatcherImpl of InterfaceDispatcherTrait<InterfaceLibraryDispatcher> {
    fn foo1(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo2(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }
    fn foo3(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }

}

trait InterfaceSafeDispatcherTrait<T> {
    fn foo1(self: T) -> starknet::SyscallResult<()>;
    fn foo2(self: T) -> starknet::SyscallResult<()>;
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl InterfaceSafeLibraryDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeLibraryDispatcher> {
    fn foo1(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeDispatcher {
    contract_address: starknet::ContractAddress,
}

impl InterfaceSafeDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeDispatcher> {
    fn foo1(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }

}


impls:

impl InterfaceDispatcherCopy of Copy::<InterfaceDispatcher>;
impl InterfaceDispatcherDrop of Drop::<InterfaceDispatcher>;
impl InterfaceDispatcherSerde of Serde::<InterfaceDispatcher> {
    fn serialize(self: @InterfaceDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceDispatcher> {
        Option::Some(InterfaceDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceDispatcher of starknet::Store::<InterfaceDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl InterfaceLibraryDispatcherCopy of Copy::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherDrop of Drop::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherSerde of Serde::<InterfaceLibraryDispatcher> {
    fn serialize(self: @InterfaceLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceLibraryDispatcher> {
        Option::Some(InterfaceLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceLibraryDispatcher of starknet::Store::<InterfaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceSafeLibraryDispatcherCopy of Copy::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherDrop of Drop::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherSerde of Serde::<InterfaceSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceSafeLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceSafeLibraryDispatcher> {
        Option::Some(InterfaceSafeLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceSafeLibraryDispatcher of starknet::Store::<InterfaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceSafeDispatcherCopy of Copy::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherDrop of Drop::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherSerde of Serde::<InterfaceSafeDispatcher> {
    fn serialize(self: @InterfaceSafeDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<InterfaceSafeDispatcher> {
        Option::Some(InterfaceSafeDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceSafeDispatcher of starknet::Store::<InterfaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


component:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ComponentState<TContractState> {
    }
    impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
    #[inline(always)]
    fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
        ComponentState::<TContractState> {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
        unsafe_new_component_state::<TContractState>()
    }
    

use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait,
};
trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
impl MyEmbeddableImpl<
    TContractState, impl X: HasComponent<TContractState>, impl TContractStateDrop: Drop<TContractState>
> of super::Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo1(component)
    }
    #[l1_handler]
    fn foo2(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo2(component)
    }
    #[constructor]
    fn foo3(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo3(component)
    }
}

impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



embeddable:

trait UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo1<TContractState, impl X: HasComponent<TContractState>, impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo1(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo2<TContractState, impl X: HasComponent<TContractState>, impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo2(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo3<TContractState, impl X: HasComponent<TContractState>, impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo3(@contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}



mod __external_MyEmbeddableImpl {
        use super::__wrapper__MyEmbeddableImpl__foo1 as foo1;
        use super::__wrapper__MyEmbeddableImpl__foo2 as foo2;
        use super::__wrapper__MyEmbeddableImpl__foo3 as foo3;
}

mod __l1_handler_MyEmbeddableImpl {
}

mod __constructor_MyEmbeddableImpl {
}


contract:



    struct ContractState {
        component_storage: super::component::ComponentState<ContractState>,
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
            component_storage: super::component::unsafe_new_component_state::<ContractState>(),
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x291a893aaae68e6364fac8003da0089f1c976946ebe457ce78ed62b5e680be2;

impl ContractStateMyEmbeddableImpl of
    super::component::UnsafeNewContractStateTraitForMyEmbeddableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}

    mod __external {
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_component of super::component::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @super::component::ComponentState<ContractState> {
        self.component_storage
    }
    fn get_component_mut(ref self: ContractState) -> super::component::ComponentState<ContractState> {
        super::component::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @super::component::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: super::component::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: traits::Into<S, super::component::Event>>(ref self: super::component::ComponentState<ContractState>, event: S) {
        let event: super::component::Event = traits::Into::into(event);
        let mut contract = super::component::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::CompEvent(event));
    }
}


impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::CompEvent(val) => {
                array::ArrayTrait::append(ref keys, selector!("CompEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        if selector == selector!("CompEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::CompEvent(val));
        }
        Option::None
    }
}
impl EventCompEventIntoEvent of Into<super::component::Event, Event> {
    fn into(self: super::component::Event) -> Event {
        Event::CompEvent(self)
    }
}

//! > ==========================================================================

//! > Test `#[abi(..)]` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[generate_trait]
impl SomeImpl<T> of SomeTrait<T> {
    fn foo(self: @T) {}
}
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[abi(v0)]
    impl Alias = super::SomeImpl<ContractState>;

    #[abi(embed)]
    impl InlineImpl of super::SomeTrait<ContractState> {
        fn foo(self: @ContractState) {}
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The 'abi' attribute for impl aliases only supports the 'embed_v0' argument.
 --> lib.cairo:10:5
    #[abi(v0)]
    ^********^

error: Plugin diagnostic: The 'abi' attribute for impls only supports the 'per_item' or 'embed_v0' argument.
 --> lib.cairo:13:5
    #[abi(embed)]
    ^***********^

//! > generated_cairo_code
lib.cairo:

#[generate_trait]
impl SomeImpl<T> of SomeTrait<T> {
    fn foo(self: @T) {}
}
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[abi(v0)]
    impl Alias = super::SomeImpl<ContractState>;

    #[abi(embed)]
    impl InlineImpl of super::SomeTrait<ContractState> {
        fn foo(self: @ContractState) {}
    }
}

generate_trait:

trait SomeTrait<T> {
    fn foo(self: @T);
}


contract:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(test)]
const TEST_CLASS_HASH: felt252 = 0x7bfb361123ab6c75c9b1db29acd3b69ea425da0db94322a959835a160c41da;


    mod __external {
    }

    mod __l1_handler {
    }

    mod __constructor {
    }

    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = traits::Into::into(event);
            let mut keys = Default::<array::Array>::default();
            let mut data = Default::<array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTraitImpl::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    array::ArrayTrait::span(@keys),
                    array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > ==========================================================================

//! > Test `get_dep_component!` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {
        }
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {
        }
    }
}

trait NotHasComponentTrait {
}
impl NotHasComponent of NotHasComponentTrait{
}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(self, Comp1).foo1();
            
            // Should raise diagnostics
            get_dep_component!(Comp1, self).foo1();
            get_dep_component!(self, self).foo1();
            get_dep_component!(Comp1, Comp1).foo1();
            get_dep_component!(self, Comp2).foo1();
            get_dep_component!(self, Comp1).foo1();
            get_dep_component!(self, super::NotHasComponent).foo1();
            let not_contract_state: felt252 = 0;
            get_dep_component!(not_contract_state, Comp1).foo1();
            get_dep_component!(self, NonExistingImpl).foo1();
            
        }
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Expected variable or constant, found impl.
 --> lib.cairo:58:32
            get_dep_component!(Comp1, self).foo1();
                               ^***^

error: Plugin diagnostic: Identifier not found.
 --> lib.cairo:58:39
            get_dep_component!(Comp1, self).foo1();
                                      ^**^

error: Plugin diagnostic: Identifier not found.
 --> lib.cairo:59:38
            get_dep_component!(self, self).foo1();
                                     ^**^

error: Plugin diagnostic: Expected variable or constant, found impl.
 --> lib.cairo:60:32
            get_dep_component!(Comp1, Comp1).foo1();
                               ^***^

error: Method `foo1` not found on type "@test::component2::ComponentState::<TContractState>". Did you import the correct trait and impl?
 --> lib.cairo:61:45
            get_dep_component!(self, Comp2).foo1();
                                            ^**^

error: Invalid path.
 --> lib.cairo[get_dep_component_inline_macro]:4:41
                super::NotHasComponent::get_component(__get_dep_component_macro_temp_contract__)
                                        ^***********^

error: Unexpected argument type. Expected: "@test::component3::ComponentState::<?14>", found: "@core::felt252".
 --> lib.cairo[get_dep_component_inline_macro]:3:92
                let __get_dep_component_macro_temp_contract__ = HasComponent::get_contract(@not_contract_state);
                                                                                           ^*****************^

error: Plugin diagnostic: Identifier not found.
 --> lib.cairo:66:38
            get_dep_component!(self, NonExistingImpl).foo1();
                                     ^*************^

error: Type annotations needed. Failed to infer ?2
 --> lib.cairo[get_dep_component_inline_macro]:3:65
                let __get_dep_component_macro_temp_contract__ = HasComponent::get_contract(@Comp1);
                                                                ^**********^

//! > generated_cairo_code
lib.cairo:

#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {
        }
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {
        }
    }
}

trait NotHasComponentTrait {
}
impl NotHasComponent of NotHasComponentTrait{
}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(self, Comp1).foo1();
            
            // Should raise diagnostics
            get_dep_component!(Comp1, self).foo1();
            get_dep_component!(self, self).foo1();
            get_dep_component!(Comp1, Comp1).foo1();
            get_dep_component!(self, Comp2).foo1();
            get_dep_component!(self, Comp1).foo1();
            get_dep_component!(self, super::NotHasComponent).foo1();
            let not_contract_state: felt252 = 0;
            get_dep_component!(not_contract_state, Comp1).foo1();
            get_dep_component!(self, NonExistingImpl).foo1();
            
        }
    }
}

Comp3TraitDispatcherTrait:

trait Comp3TraitDispatcherTrait<T> {
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitDispatcher {
    contract_address: starknet::ContractAddress,
}

impl Comp3TraitDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitDispatcher> {
    fn foo3(self: Comp3TraitDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl Comp3TraitLibraryDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitLibraryDispatcher> {
    fn foo3(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }

}

trait Comp3TraitSafeDispatcherTrait<T> {
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl Comp3TraitSafeLibraryDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeLibraryDispatcher> {
    fn foo3(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeDispatcher {
    contract_address: starknet::ContractAddress,
}

impl Comp3TraitSafeDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeDispatcher> {
    fn foo3(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }

}


impls:

impl Comp3TraitDispatcherCopy of Copy::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherDrop of Drop::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherSerde of Serde::<Comp3TraitDispatcher> {
    fn serialize(self: @Comp3TraitDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<Comp3TraitDispatcher> {
        Option::Some(Comp3TraitDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitDispatcher of starknet::Store::<Comp3TraitDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl Comp3TraitLibraryDispatcherCopy of Copy::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherDrop of Drop::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherSerde of Serde::<Comp3TraitLibraryDispatcher> {
    fn serialize(self: @Comp3TraitLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<Comp3TraitLibraryDispatcher> {
        Option::Some(Comp3TraitLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitLibraryDispatcher of starknet::Store::<Comp3TraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl Comp3TraitSafeLibraryDispatcherCopy of Copy::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherDrop of Drop::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherSerde of Serde::<Comp3TraitSafeLibraryDispatcher> {
    fn serialize(self: @Comp3TraitSafeLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<Comp3TraitSafeLibraryDispatcher> {
        Option::Some(Comp3TraitSafeLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitSafeLibraryDispatcher of starknet::Store::<Comp3TraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl Comp3TraitSafeDispatcherCopy of Copy::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherDrop of Drop::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherSerde of Serde::<Comp3TraitSafeDispatcher> {
    fn serialize(self: @Comp3TraitSafeDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<Comp3TraitSafeDispatcher> {
        Option::Some(Comp3TraitSafeDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitSafeDispatcher of starknet::Store::<Comp3TraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


component:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ComponentState<TContractState> {
    }
    impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
    #[inline(always)]
    fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
        ComponentState::<TContractState> {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
        unsafe_new_component_state::<TContractState>()
    }
    

use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait,
};
trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo1(self: @ComponentState<TContractState>);
    }


impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo2(self: @ComponentState<TContractState>);
    }


component:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ComponentState<TContractState> {
    }
    impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
    #[inline(always)]
    fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
        ComponentState::<TContractState> {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
        unsafe_new_component_state::<TContractState>()
    }
    

use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait,
};
trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
impl Comp3<
            TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>

> of super::Comp3Trait<TContractState> {
    
    fn foo3(ref self: TContractState) {
        let mut component = HasComponent::get_component_mut(ref self);
        Comp3Impl::foo3(ref component)
    }
}

impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



embeddable:

trait UnsafeNewContractStateTraitForComp3<TContractState> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Comp3__foo3<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo3(ref contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}



mod __external_Comp3 {
        use super::__wrapper__Comp3__foo3 as foo3;
}

mod __l1_handler_Comp3 {
}

mod __constructor_Comp3 {
}

//! > ==========================================================================

//! > Test `get_dep_component_mut!` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {
        }
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {
        }
    }
}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component_mut!(ref self, Comp1).foo1();
            
            // Should raise diagnostics
            get_dep_component_mut!(Comp1, self).foo1();
            get_dep_component_mut!(ref self, self).foo1();
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
            get_dep_component_mut!(ref self, Comp2).foo1();
            get_dep_component_mut!(self, Comp1).foo1();
            get_dep_component_mut!(mut self, Comp1).foo1();
            get_dep_component_mut!(ref ref self, Comp1).foo1();
            get_dep_component_mut!(ref mut self, Comp1).foo1();
        }
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:53:13
            get_dep_component_mut!(Comp1, self).foo1();
            ^*********************************^

error: Inline macro `get_dep_component_mut` failed.
 --> lib.cairo:53:13
            get_dep_component_mut!(Comp1, self).foo1();
            ^*********************************^

error: Plugin diagnostic: Identifier not found.
 --> lib.cairo:54:46
            get_dep_component_mut!(ref self, self).foo1();
                                             ^**^

error: Plugin diagnostic: Expected variable or constant, found impl.
 --> lib.cairo:55:40
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
                                       ^***^

error: Plugin diagnostic: ref argument must be a variable.
 --> lib.cairo:55:40
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
                                       ^***^

error: Method `foo1` not found on type "test::component2::ComponentState::<TContractState>". Did you import the correct trait and impl?
 --> lib.cairo:56:53
            get_dep_component_mut!(ref self, Comp2).foo1();
                                                    ^**^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:57:13
            get_dep_component_mut!(self, Comp1).foo1();
            ^*********************************^

error: Inline macro `get_dep_component_mut` failed.
 --> lib.cairo:57:13
            get_dep_component_mut!(self, Comp1).foo1();
            ^*********************************^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:58:13
            get_dep_component_mut!(mut self, Comp1).foo1();
            ^*************************************^

error: Inline macro `get_dep_component_mut` failed.
 --> lib.cairo:58:13
            get_dep_component_mut!(mut self, Comp1).foo1();
            ^*************************************^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:59:13
            get_dep_component_mut!(ref ref self, Comp1).foo1();
            ^*****************************************^

error: Inline macro `get_dep_component_mut` failed.
 --> lib.cairo:59:13
            get_dep_component_mut!(ref ref self, Comp1).foo1();
            ^*****************************************^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:60:13
            get_dep_component_mut!(ref mut self, Comp1).foo1();
            ^*****************************************^

error: Inline macro `get_dep_component_mut` failed.
 --> lib.cairo:60:13
            get_dep_component_mut!(ref mut self, Comp1).foo1();
            ^*****************************************^

error: Type annotations needed. Failed to infer ?2
 --> lib.cairo:53:49
            get_dep_component_mut!(Comp1, self).foo1();
                                                ^**^

//! > generated_cairo_code
lib.cairo:

#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {
        }
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {
        }
    }
}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component_mut!(ref self, Comp1).foo1();
            
            // Should raise diagnostics
            get_dep_component_mut!(Comp1, self).foo1();
            get_dep_component_mut!(ref self, self).foo1();
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
            get_dep_component_mut!(ref self, Comp2).foo1();
            get_dep_component_mut!(self, Comp1).foo1();
            get_dep_component_mut!(mut self, Comp1).foo1();
            get_dep_component_mut!(ref ref self, Comp1).foo1();
            get_dep_component_mut!(ref mut self, Comp1).foo1();
        }
    }
}

Comp3TraitDispatcherTrait:

trait Comp3TraitDispatcherTrait<T> {
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitDispatcher {
    contract_address: starknet::ContractAddress,
}

impl Comp3TraitDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitDispatcher> {
    fn foo3(self: Comp3TraitDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl Comp3TraitLibraryDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitLibraryDispatcher> {
    fn foo3(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = starknet::SyscallResultTrait::unwrap_syscall(ret_data);
        ()
    }

}

trait Comp3TraitSafeDispatcherTrait<T> {
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeLibraryDispatcher {
    class_hash: starknet::ClassHash,
}

impl Comp3TraitSafeLibraryDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeLibraryDispatcher> {
    fn foo3(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeDispatcher {
    contract_address: starknet::ContractAddress,
}

impl Comp3TraitSafeDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeDispatcher> {
    fn foo3(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = traits::Default::default();

        let mut ret_data = starknet::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            array::ArrayTrait::span(@__calldata__),
        );
        let mut ret_data = ret_data?;
        Result::Ok(())
    }

}


impls:

impl Comp3TraitDispatcherCopy of Copy::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherDrop of Drop::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherSerde of Serde::<Comp3TraitDispatcher> {
    fn serialize(self: @Comp3TraitDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<Comp3TraitDispatcher> {
        Option::Some(Comp3TraitDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitDispatcher of starknet::Store::<Comp3TraitDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl Comp3TraitLibraryDispatcherCopy of Copy::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherDrop of Drop::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherSerde of Serde::<Comp3TraitLibraryDispatcher> {
    fn serialize(self: @Comp3TraitLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<Comp3TraitLibraryDispatcher> {
        Option::Some(Comp3TraitLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitLibraryDispatcher of starknet::Store::<Comp3TraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl Comp3TraitSafeLibraryDispatcherCopy of Copy::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherDrop of Drop::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherSerde of Serde::<Comp3TraitSafeLibraryDispatcher> {
    fn serialize(self: @Comp3TraitSafeLibraryDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<Comp3TraitSafeLibraryDispatcher> {
        Option::Some(Comp3TraitSafeLibraryDispatcher {
            class_hash: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitSafeLibraryDispatcher of starknet::Store::<Comp3TraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl Comp3TraitSafeDispatcherCopy of Copy::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherDrop of Drop::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherSerde of Serde::<Comp3TraitSafeDispatcher> {
    fn serialize(self: @Comp3TraitSafeDispatcher, ref output: array::Array<felt252>) {
        serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: array::Span<felt252>) -> Option<Comp3TraitSafeDispatcher> {
        Option::Some(Comp3TraitSafeDispatcher {
            contract_address: serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitSafeDispatcher of starknet::Store::<Comp3TraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::StorageBaseAddress, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::StorageBaseAddress, offset: u8, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


component:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ComponentState<TContractState> {
    }
    impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
    #[inline(always)]
    fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
        ComponentState::<TContractState> {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
        unsafe_new_component_state::<TContractState>()
    }
    

use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait,
};
trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo1(self: @ComponentState<TContractState>);
    }


impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo2(self: @ComponentState<TContractState>);
    }


component:

#[event]
#[derive(Drop, starknet::Event)]
enum Event {}


    struct ComponentState<TContractState> {
    }
    impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
    #[inline(always)]
    fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
        ComponentState::<TContractState> {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
        unsafe_new_component_state::<TContractState>()
    }
    

use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait,
};
trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
impl Comp3<
            TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>

> of super::Comp3Trait<TContractState> {
    
    fn foo3(ref self: TContractState) {
        let mut component = HasComponent::get_component_mut(ref self);
        Comp3Impl::foo3(ref component)
    }
}

impls:

impl EventDrop of Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



embeddable:

trait UnsafeNewContractStateTraitForComp3<TContractState> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Comp3__foo3<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    internal::require_implicit::<System>();
    internal::revoke_ap_tracking();
    option::OptionTraitImpl::expect(gas::withdraw_gas(), 'Out of gas');
    
    assert(array::SpanTrait::is_empty(data), 'Input too long for arguments');
    option::OptionTraitImpl::expect(
        gas::withdraw_gas_all(get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo3(ref contract_state, );
    let mut arr = array::array_new();
    // References.
    // Result.
    array::ArrayTrait::span(@arr)
}



mod __external_Comp3 {
        use super::__wrapper__Comp3__foo3 as foo3;
}

mod __l1_handler_Comp3 {
}

mod __constructor_Comp3 {
}
