//! > Test first param must be self.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    fn foo() {}

    #[external(v0)]
    fn bar(_n: u32) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    fn foo() {}

    #[external(v0)]
    fn bar(_n: u32) {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x198f4bc6efa8417922f8041d6e73821af41c6bbf15f1c93084da188702456b;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The first parameter of an entry point must be `self`.
 --> lib.cairo:7:11
    fn foo() {}
          ^^

error: Plugin diagnostic: The first parameter of an entry point must be `self`.
 --> lib.cairo:10:12
    fn bar(_n: u32) {}
           ^*****^

warning: Plugin diagnostic: Failed to generate ABI: Entrypoints must have a self first param.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

warning: Plugin diagnostic: Failed to generate ABI: Entrypoints must have a self first param.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

//! > ==========================================================================

//! > Test invalid constructor name.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[constructor]
    fn invalid_constructor_name(ref self: ContractState) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[constructor]
    fn invalid_constructor_name(ref self: ContractState) {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x3bd690d1a73da0d8c43f46ecc3a006978d8343a075e91a1c7a24529e7d244a;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__invalid_constructor_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    invalid_constructor_name(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
    pub use super::__wrapper__invalid_constructor_name as invalid_constructor_name;
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The constructor function must be called `constructor`.
 --> lib.cairo:7:8
    fn invalid_constructor_name(ref self: ContractState) {}
       ^**********************^

//! > ==========================================================================

//! > Test diagnostics non legacy storage variable.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        mapping: Map::<felt252, felt252>,
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        mapping: Map::<felt252, felt252>,
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
        pub mapping: __member_module_mapping::ContractMemberState,
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
            mapping: __member_module_mapping::ContractMemberState {},
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x14b80a3dbe8461b938c026ddbb0c5d189ca6e45d333ff1ecaecfe92dce54d9d;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Non `LegacyMap` mapping is not yet supported.
 --> lib.cairo:5:18
        mapping: Map::<felt252, felt252>,
                 ^*********************^

error: Identifier not found.
 --> lib.cairo:5:9
        mapping: Map::<felt252, felt252>,
        ^*****^

error: Invalid drop trait implementation, Candidate impl core::traits::SnapshotDrop::<?0> has an unused generic parameter..
 --> lib.cairo[contract]:9:5
    impl ContractStateDrop of Drop<ContractState> {}
    ^**********************************************^

error: Identifier not found.
 --> lib.cairo:5:9
        mapping: Map::<felt252, felt252>,
        ^*****^

//! > ==========================================================================

//! > Test non-v0 external function.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo_v0(ref self: ContractState, x: (felt252, felt252)) {}
    #[external]
    fn foo(ref self: ContractState, x: (felt252, felt252)) {}
    #[external(v1)]
    fn foo_v1(ref self: ContractState, x: (felt252, felt252)) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo_v0(ref self: ContractState, x: (felt252, felt252)) {}
    #[external]
    fn foo(ref self: ContractState, x: (felt252, felt252)) {}
    #[external(v1)]
    fn foo_v1(ref self: ContractState, x: (felt252, felt252)) {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x547f368ac55821b57d7da42588a2985edb69dd87af9e9c16e740d6e14b2420;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo_v0(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo_v0(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo_v1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo_v1(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo_v0 as foo_v0;
    pub use super::__wrapper__foo as foo;
    pub use super::__wrapper__foo_v1 as foo_v1;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:7:5
    #[external]
    ^*********^

error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:9:5
    #[external(v1)]
    ^*************^

//! > ==========================================================================

//! > Test diagnostics of non-serializable parameter in entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState, x: super::MyType) {}
}
#[derive(Drop)]
struct MyType {}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState, x: super::MyType) {}
}
#[derive(Drop)]
struct MyType {}

impls:

impl MyTypeDrop of core::traits::Drop::<MyType>;


contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x16fce813e4d7f676441c2cffa36b5101b7e75cb787a8aec7259094fdbacb80e;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<super::MyType>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::serde::Serde::<test::MyType>
 --> lib.cairo[contract]:33:46
        core::serde::Serde::<super::MyType>::deserialize(ref data),
                                             ^*********^

//! > ==========================================================================

//! > Test diagnostics of non-serializable return type in entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState) -> (felt252, felt252) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState) -> (felt252, felt252) {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x2c31752790f50b7f25195fc7cc9dcc1234d7af736c5ed771c69ddc8bb9fd8d4;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = foo(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<(felt252, felt252)>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "(core::felt252, core::felt252)", found: "()".
 --> lib.cairo:6:59
    fn foo(ref self: ContractState) -> (felt252, felt252) {}
                                                          ^^

//! > ==========================================================================

//! > Test diagnostics of generic entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo<T>(ref self: ContractState, x: T) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo<T>(ref self: ContractState, x: T) {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x2bcbd7e08add1bbb62c174729940be27dbe922f83afd842f02af5355af726a1;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<T>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Contract entry points cannot have generic arguments
 --> lib.cairo:6:11
    fn foo<T>(ref self: ContractState, x: T) {}
          ^*^

warning: Plugin diagnostic: Failed to generate ABI: Got unexpected type.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

error: Type not found.
 --> lib.cairo[contract]:33:30
        core::serde::Serde::<T>::deserialize(ref data),
                             ^

error: Type annotations needed. Failed to infer ?2
 --> lib.cairo[contract]:32:33
    let __arg_x = core::option::OptionTraitImpl::expect(
                                ^*************^

error: Variable not dropped.
 --> lib.cairo:6:40
    fn foo<T>(ref self: ContractState, x: T) {}
                                       ^
note: Trait has no implementation in context: core::traits::Drop::<T>
note: Trait has no implementation in context: core::traits::Destruct::<T>

//! > ==========================================================================

//! > Test multiple diagnostics from entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(
        ref self: ContractState, x: (felt252, felt252), y: (felt252, felt252)
    ) -> (felt252, felt252) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(
        ref self: ContractState, x: (felt252, felt252), y: (felt252, felt252)
    ) -> (felt252, felt252) {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x37db5b411e79068f08f0832de46108b618c2f188115ac652f78be4f6dfcdeb4;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let __arg_y = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = foo(ref contract_state, __arg_x, __arg_y);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<(felt252, felt252)>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "(core::felt252, core::felt252)", found: "()".
 --> lib.cairo:8:29
    ) -> (felt252, felt252) {}
                            ^^

//! > ==========================================================================

//! > Test account contract_entry point on a non-account contract.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn __validate__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_declare__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_deploy__(ref self: ContractState) {}
    #[external(v0)]
    fn __execute__(ref self: ContractState) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn __validate__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_declare__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_deploy__(ref self: ContractState) {}
    #[external(v0)]
    fn __execute__(ref self: ContractState) {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x291a42fae50c99636dc1d6bc0c4e28fdb0e21f47c26aa0d5e22c21d993823d8;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper____validate__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper____validate_declare__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate_declare__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper____validate_deploy__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate_deploy__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper____execute__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __execute__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper____validate__ as __validate__;
    pub use super::__wrapper____validate_declare__ as __validate_declare__;
    pub use super::__wrapper____validate_deploy__ as __validate_deploy__;
    pub use super::__wrapper____execute__ as __execute__;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
warning: Plugin diagnostic: Failed to generate ABI: `__validate__` is a reserved entry point names for account contracts only.
 --> lib.cairo:5:5
    #[external(v0)]
    ^*************^

warning: Plugin diagnostic: Failed to generate ABI: `__execute__` is a reserved entry point names for account contracts only.
 --> lib.cairo:11:5
    #[external(v0)]
    ^*************^

//! > ==========================================================================

//! > Test raw_outputs diagnostics.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    #[raw_output]
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}

    #[external(v0)]
    #[raw_output]
    fn bar1(ref self: ContractState, a: felt252) -> felt252 {
        0
    }

    #[external(v0)]
    #[raw_output]
    fn bar2(ref self: ContractState, a: felt252) {}

    // Should generate diagnostic as path resolving is not supported.
    #[external(v0)]
    #[raw_output]
    fn bar3(ref self: ContractState, a: felt252) -> core::Array::<felt252> {
        array::array_new()
    }

    // Should generate diagnostic as alias resolving is not supported.
    type my_felt252_array_type = Array::<felt252>;
    #[external(v0)]
    #[raw_output]
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
        array::array_new()
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    #[raw_output]
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}

    #[external(v0)]
    #[raw_output]
    fn bar1(ref self: ContractState, a: felt252) -> felt252 {
        0
    }

    #[external(v0)]
    #[raw_output]
    fn bar2(ref self: ContractState, a: felt252) {}

    // Should generate diagnostic as path resolving is not supported.
    #[external(v0)]
    #[raw_output]
    fn bar3(ref self: ContractState, a: felt252) -> core::Array::<felt252> {
        array::array_new()
    }

    // Should generate diagnostic as alias resolving is not supported.
    type my_felt252_array_type = Array::<felt252>;
    #[external(v0)]
    #[raw_output]
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
        array::array_new()
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x1fe1d7e90cfe8c4fc07093ee454571079f241cebea881fdbe6d42ab30f16735;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: `raw_output` functions cannot have `ref` parameters.
 --> lib.cairo:8:37
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                    ^*^

error: Plugin diagnostic: `raw_output` functions cannot have `ref` parameters.
 --> lib.cairo:8:53
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                                    ^*^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:8:69
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                                                    ^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:12:53
    fn bar1(ref self: ContractState, a: felt252) -> felt252 {
                                                    ^*****^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:18:50
    fn bar2(ref self: ContractState, a: felt252) {}
                                                 ^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:23:53
    fn bar3(ref self: ContractState, a: felt252) -> core::Array::<felt252> {
                                                    ^********************^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:31:53
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
                                                    ^*******************^

//! > ==========================================================================

//! > Test reusage of storage var name diagnostics.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: false)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
        pub same_name: __member_module_same_name::ContractMemberState,
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
            same_name: __member_module_same_name::ContractMemberState {},
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
    pub use __member_module_same_name::InternalContractMemberStateTrait as same_nameContractMemberStateTrait;
    pub mod __member_module_same_name {
        #[derive(Copy, Drop)]
        pub struct ContractMemberState {}
        pub trait InternalContractMemberStateTrait {
            fn address(self: @ContractMemberState) -> starknet::storage_access::StorageBaseAddress;
            fn read(self: @ContractMemberState) -> felt252;
            fn write(ref self: ContractMemberState, value: felt252);
        }

        impl InternalContractMemberStateImpl of InternalContractMemberStateTrait {
            fn address(self: @ContractMemberState) -> starknet::storage_access::StorageBaseAddress {
                starknet::storage_access::storage_base_address_const::<0x26673b81123c540a9238f376b833c3914834c3c0cdf4e609f834963616d3ef9>()
            }
            fn read(self: @ContractMemberState) -> felt252 {
                // Only address_domain 0 is currently supported.
                let address_domain = 0_u32;
                starknet::SyscallResultTrait::unwrap_syscall(
                    starknet::Store::<felt252>::read(
                        address_domain,
                        InternalContractMemberStateImpl::address(self),
                    )
                )
            }
            fn write(ref self: ContractMemberState, value: felt252) {
                // Only address_domain 0 is currently supported.
                let address_domain = 0_u32;
                starknet::SyscallResultTrait::unwrap_syscall(
                    starknet::Store::<felt252>::write(
                        address_domain,
                        InternalContractMemberStateImpl::address(@self),
                        value,
                    )
                )
            }
        }
    }
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x271c051b9d25373bc88ddfddfb1c29cc601d7014c5343fe167b82768570a896;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Contract with no storage.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    fn same_name() -> felt252 {
        1
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Contracts must define a 'Storage' struct.
 --> lib.cairo:1:1
#[starknet::contract]
^*******************^

//! > ==========================================================================

//! > Not annotated storage struct.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: 'Storage' struct must be annotated with #[storage].
 --> lib.cairo:3:5
    struct Storage {
    ^**************^

//! > ==========================================================================

//! > Non v0 impls.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    #[generate_trait]
    impl AImpl of ATrait {}

    #[external(v1)]
    #[generate_trait]
    impl BImpl of BTrait {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    #[generate_trait]
    impl AImpl of ATrait {}

    #[external(v1)]
    #[generate_trait]
    impl BImpl of BTrait {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x1f35904b8fc9bed6ac08457ded74e522aa254844ebb1d7da8eaff06532a8b4d;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



generate_trait:

    trait ATrait {}


generate_trait:

    trait BTrait {}


impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:5:5
    #[external(v0)]
    ^*************^

error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:9:5
    #[external(v1)]
    ^*************^

warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:9:5
    #[external(v1)]
    ^*************^

//! > ==========================================================================

//! > old contract attribute.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[contract]
mod test_contract {}

#[abi]
trait ContractAbi {}

//! > generated_cairo_code
lib.cairo:

#[contract]
mod test_contract {}

#[abi]
trait ContractAbi {}

//! > expected_diagnostics
error: Plugin diagnostic: The 'contract' attribute was deprecated, please use `starknet::contract` instead.
 --> lib.cairo:1:1
#[contract]
^*********^

error: Plugin diagnostic: Unsupported attribute.
 --> lib.cairo:1:1
#[contract]
^*********^

error: Plugin diagnostic: The 'abi' attribute for traits was deprecated, please use `starknet::interface` instead.
 --> lib.cairo:4:1
#[abi]
^****^

//! > ==========================================================================

//! > Attributes in external impl.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait InterfaceTrait<TContractState> {
    fn foo_external1(self: @TContractState);
    fn foo_l1_handler1(self: @TContractState);
    fn foo_constructor1(self: @TContractState);
}

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    impl Impl2 of super::InterfaceTrait<ContractState> {
        #[external(v0)]
        fn foo_external1(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler1(self: @ContractState) {}
        #[constructor]
        fn foo_constructor1(self: @ContractState) {}
    }

    #[generate_trait]
    #[external(v0)]
    impl Impl1 of NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState) {}
        #[constructor]
        fn foo_constructor2(self: @ContractState) {}
    }
}

//! > expected_diagnostics
warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:13:5
    #[external(v0)]
    ^*************^

error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:15:9
        #[external(v0)]
        ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:17:9
        #[l1_handler]
        ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:19:9
        #[constructor]
        ^************^

warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:24:5
    #[external(v0)]
    ^*************^

error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:26:9
        #[external(v0)]
        ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:28:9
        #[l1_handler]
        ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:30:9
        #[constructor]
        ^************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait InterfaceTrait<TContractState> {
    fn foo_external1(self: @TContractState);
    fn foo_l1_handler1(self: @TContractState);
    fn foo_constructor1(self: @TContractState);
}

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    impl Impl2 of super::InterfaceTrait<ContractState> {
        #[external(v0)]
        fn foo_external1(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler1(self: @ContractState) {}
        #[constructor]
        fn foo_constructor1(self: @ContractState) {}
    }

    #[generate_trait]
    #[external(v0)]
    impl Impl1 of NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState) {}
        #[constructor]
        fn foo_constructor2(self: @ContractState) {}
    }
}

InterfaceTraitDispatcherTrait:

trait InterfaceTraitDispatcherTrait<T> {
    fn foo_external1(self: T);
    fn foo_l1_handler1(self: T);
    fn foo_constructor1(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceTraitDispatcherImpl of InterfaceTraitDispatcherTrait<InterfaceTraitDispatcher> {
    fn foo_external1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_l1_handler1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_constructor1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceTraitLibraryDispatcherImpl of InterfaceTraitDispatcherTrait<InterfaceTraitLibraryDispatcher> {
    fn foo_external1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_l1_handler1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_constructor1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait InterfaceTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo_external1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo_l1_handler1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo_constructor1(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceTraitSafeLibraryDispatcherImpl of InterfaceTraitSafeDispatcherTrait<InterfaceTraitSafeLibraryDispatcher> {
    fn foo_external1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_l1_handler1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_constructor1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceTraitSafeDispatcherImpl of InterfaceTraitSafeDispatcherTrait<InterfaceTraitSafeDispatcher> {
    fn foo_external1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_l1_handler1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_constructor1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


impls:

impl InterfaceTraitDispatcherCopy of core::traits::Copy::<InterfaceTraitDispatcher>;
impl InterfaceTraitDispatcherDrop of core::traits::Drop::<InterfaceTraitDispatcher>;
impl InterfaceTraitDispatcherSerde of core::serde::Serde::<InterfaceTraitDispatcher> {
    fn serialize(self: @InterfaceTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitDispatcher> {
        core::option::Option::Some(InterfaceTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceTraitDispatcher of starknet::Store::<InterfaceTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl InterfaceTraitLibraryDispatcherCopy of core::traits::Copy::<InterfaceTraitLibraryDispatcher>;
impl InterfaceTraitLibraryDispatcherDrop of core::traits::Drop::<InterfaceTraitLibraryDispatcher>;
impl InterfaceTraitLibraryDispatcherSerde of core::serde::Serde::<InterfaceTraitLibraryDispatcher> {
    fn serialize(self: @InterfaceTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitLibraryDispatcher> {
        core::option::Option::Some(InterfaceTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceTraitLibraryDispatcher of starknet::Store::<InterfaceTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceTraitSafeLibraryDispatcherCopy of core::traits::Copy::<InterfaceTraitSafeLibraryDispatcher>;
impl InterfaceTraitSafeLibraryDispatcherDrop of core::traits::Drop::<InterfaceTraitSafeLibraryDispatcher>;
impl InterfaceTraitSafeLibraryDispatcherSerde of core::serde::Serde::<InterfaceTraitSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitSafeLibraryDispatcher> {
        core::option::Option::Some(InterfaceTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceTraitSafeLibraryDispatcher of starknet::Store::<InterfaceTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceTraitSafeDispatcherCopy of core::traits::Copy::<InterfaceTraitSafeDispatcher>;
impl InterfaceTraitSafeDispatcherDrop of core::traits::Drop::<InterfaceTraitSafeDispatcher>;
impl InterfaceTraitSafeDispatcherSerde of core::serde::Serde::<InterfaceTraitSafeDispatcher> {
    fn serialize(self: @InterfaceTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitSafeDispatcher> {
        core::option::Option::Some(InterfaceTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceTraitSafeDispatcher of starknet::Store::<InterfaceTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0xb2b80f78cee80a1a53222a998e318822f6d9d701bdc8037948c5964158503c;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl2__foo_external1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_external1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl2__foo_l1_handler1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_l1_handler1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl2__foo_constructor1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_constructor1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl1__foo_external2(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_external2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl1__foo_l1_handler2(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_l1_handler2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Impl1__foo_constructor2(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_constructor2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__Impl2__foo_external1 as foo_external1;
    pub use super::__wrapper__Impl2__foo_l1_handler1 as foo_l1_handler1;
    pub use super::__wrapper__Impl2__foo_constructor1 as foo_constructor1;
    pub use super::__wrapper__Impl1__foo_external2 as foo_external2;
    pub use super::__wrapper__Impl1__foo_l1_handler2 as foo_l1_handler2;
    pub use super::__wrapper__Impl1__foo_constructor2 as foo_constructor2;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



generate_trait:

    trait NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState);
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState);
        #[constructor]
        fn foo_constructor2(self: @ContractState);
    }


impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > ==========================================================================

//! > "Event" enum without #[event].

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[derive(Drop, starknet::Event)]
    enum Event {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[derive(Drop, starknet::Event)]
    enum Event {}
}

contract:



    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x820d41c225755fd6813443e1db69b44d323763bb1bdc6c58da9d8011855f0b;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Contract type that is named `Event` must be marked with #[event].
 --> lib.cairo:7:10
    enum Event {}
         ^***^

//! > ==========================================================================

//! > #[event] enum that isn't named "Event".

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[event]
    #[derive(Drop, starknet::Event)]
    enum MyEvent {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[event]
    #[derive(Drop, starknet::Event)]
    enum MyEvent {}
}

contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x1786cd1474db7f1bf61efa820fedb6cc8a9892313c56a8ab854a488db0d2879;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl MyEventDrop of core::traits::Drop::<MyEvent>;


starknet_derive:

impl MyEventIsEvent of starknet::Event<MyEvent> {
    fn append_keys_and_data(
        self: @MyEvent, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<MyEvent> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Contract type that is marked with #[event] must be named `Event`.
 --> lib.cairo:8:10
    enum MyEvent {}
         ^*****^

//! > ==========================================================================

//! > Test `starknet::interface` trait with no body.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T>;

//! > expected_diagnostics
error: Plugin diagnostic: Starknet interfaces without body are not supported.
 --> lib.cairo:2:19
trait IContract<T>;
                  ^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T>;

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad generic params.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract2Generics<T, S> {}

#[starknet::interface]
trait IContract0Generics {}

#[starknet::interface]
trait IContractNonTypeGenerics<+Destruct<u32>> {}

//! > expected_diagnostics
error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:2:25
trait IContract2Generics<T, S> {}
                        ^****^

error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:5:26
trait IContract0Generics {}
                         ^

error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:8:31
trait IContractNonTypeGenerics<+Destruct<u32>> {}
                              ^**************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract2Generics<T, S> {}

#[starknet::interface]
trait IContract0Generics {}

#[starknet::interface]
trait IContractNonTypeGenerics<+Destruct<u32>> {}

//! > ==========================================================================

//! > Test `starknet::interface` trait with non-self param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
    fn no_params() -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: The first parameter must be named `self`.
 --> lib.cairo:3:21
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
                    ^***************^

error: Plugin diagnostic: The first parameter must be named `self`.
 --> lib.cairo:4:22
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
                     ^************^

error: Plugin diagnostic: `starknet::interface` functions must have a `self` parameter.
 --> lib.cairo:5:5
    fn no_params() -> felt252;
    ^***********************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
    fn no_params() -> felt252;
}

IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad non-first param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn foo(
        ref self: T,
        ref param_ref: felt252,
        t_param: T,
        arr_param: Array<T>,
        snap_param: @T,
        tup_param: (felt252, T),
    ) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> lib.cairo:5:9
        ref param_ref: felt252,
        ^*^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:6:18
        t_param: T,
                 ^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:7:20
        arr_param: Array<T>,
                   ^******^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:8:21
        snap_param: @T,
                    ^^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:9:20
        tup_param: (felt252, T),
                   ^**********^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn foo(
        ref self: T,
        ref param_ref: felt252,
        t_param: T,
        arr_param: Array<T>,
        snap_param: @T,
        tup_param: (felt252, T),
    ) -> felt252;
}

IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad modifiers for self param.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:3:24
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
                       ^*****^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
}

IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad self param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn foo(ref self: u32, other: felt252) -> felt252;
    fn bar(self: @u32, other: felt252) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:3:12
    fn foo(ref self: u32, other: felt252) -> felt252;
           ^***********^

error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:4:12
    fn bar(self: @u32, other: felt252) -> felt252;
           ^********^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn foo(ref self: u32, other: felt252) -> felt252;
    fn bar(self: @u32, other: felt252) -> felt252;
}

IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

//! > ==========================================================================

//! > Test `starknet::embeddable` impl with (disallowed) attributes for its methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::embeddable]
impl EmbeddableImpl<TContractState> of Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {}
    #[l1_handler]
    fn foo2(self: @TContractState) {}
    #[constructor]
    fn foo3(self: @TContractState) {}
}

//! > expected_diagnostics
error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:9:5
    #[external(v0)]
    ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:11:5
    #[l1_handler]
    ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:13:5
    #[constructor]
    ^************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::embeddable]
impl EmbeddableImpl<TContractState> of Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {}
    #[l1_handler]
    fn foo2(self: @TContractState) {}
    #[constructor]
    fn foo3(self: @TContractState) {}
}

InterfaceDispatcherTrait:

trait InterfaceDispatcherTrait<T> {
    fn foo1(self: T);
    fn foo2(self: T);
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceDispatcherImpl of InterfaceDispatcherTrait<InterfaceDispatcher> {
    fn foo1(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceLibraryDispatcherImpl of InterfaceDispatcherTrait<InterfaceLibraryDispatcher> {
    fn foo1(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait InterfaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo2(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceSafeLibraryDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeLibraryDispatcher> {
    fn foo1(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceSafeDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeDispatcher> {
    fn foo1(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


embeddable:

trait UnsafeNewContractStateTraitForEmbeddableImpl<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo1<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo2<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo3<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo3(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



mod __external_EmbeddableImpl {
    pub use super::__wrapper__EmbeddableImpl__foo1 as foo1;
    pub use super::__wrapper__EmbeddableImpl__foo2 as foo2;
    pub use super::__wrapper__EmbeddableImpl__foo3 as foo3;
}

mod __l1_handler_EmbeddableImpl {
}

mod __constructor_EmbeddableImpl {
}


impls:

impl InterfaceDispatcherCopy of core::traits::Copy::<InterfaceDispatcher>;
impl InterfaceDispatcherDrop of core::traits::Drop::<InterfaceDispatcher>;
impl InterfaceDispatcherSerde of core::serde::Serde::<InterfaceDispatcher> {
    fn serialize(self: @InterfaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceDispatcher> {
        core::option::Option::Some(InterfaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceDispatcher of starknet::Store::<InterfaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl InterfaceLibraryDispatcherCopy of core::traits::Copy::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherDrop of core::traits::Drop::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherSerde of core::serde::Serde::<InterfaceLibraryDispatcher> {
    fn serialize(self: @InterfaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceLibraryDispatcher> {
        core::option::Option::Some(InterfaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceLibraryDispatcher of starknet::Store::<InterfaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceSafeLibraryDispatcherCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherSerde of core::serde::Serde::<InterfaceSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeLibraryDispatcher> {
        core::option::Option::Some(InterfaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceSafeLibraryDispatcher of starknet::Store::<InterfaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceSafeDispatcherCopy of core::traits::Copy::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherDrop of core::traits::Drop::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherSerde of core::serde::Serde::<InterfaceSafeDispatcher> {
    fn serialize(self: @InterfaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeDispatcher> {
        core::option::Option::Some(InterfaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceSafeDispatcher of starknet::Store::<InterfaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

//! > ==========================================================================

//! > Test `embeddable_as` impl with (disallowed) attributes for its methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::component]
mod component {
    #[storage]
    struct Storage {}

    #[embeddable_as(MyEmbeddableImpl)]
    impl MyImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of super::Interface<ComponentState<TContractState>> {
        #[external(v0)]
        fn foo1(self: @ComponentState<TContractState>) {}
        #[l1_handler]
        fn foo2(self: @ComponentState<TContractState>) {}
        #[constructor]
        fn foo3(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::contract]
mod contract {
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_storage: super::component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::component::Event,
    }

    component!(path: super::component, storage: component_storage, event: CompEvent);

    #[abi(embed_v0)]
    impl MyEmbeddedImpl = super::component::MyEmbeddableImpl<ContractState>;
}

//! > expected_diagnostics
error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:16:9
        #[external(v0)]
        ^*************^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:18:9
        #[l1_handler]
        ^***********^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:20:9
        #[constructor]
        ^************^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::component]
mod component {
    #[storage]
    struct Storage {}

    #[embeddable_as(MyEmbeddableImpl)]
    impl MyImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of super::Interface<ComponentState<TContractState>> {
        #[external(v0)]
        fn foo1(self: @ComponentState<TContractState>) {}
        #[l1_handler]
        fn foo2(self: @ComponentState<TContractState>) {}
        #[constructor]
        fn foo3(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::contract]
mod contract {
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_storage: super::component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::component::Event,
    }

    component!(path: super::component, storage: component_storage, event: CompEvent);

    #[abi(embed_v0)]
    impl MyEmbeddedImpl = super::component::MyEmbeddableImpl<ContractState>;
}

InterfaceDispatcherTrait:

trait InterfaceDispatcherTrait<T> {
    fn foo1(self: T);
    fn foo2(self: T);
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceDispatcherImpl of InterfaceDispatcherTrait<InterfaceDispatcher> {
    fn foo1(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceLibraryDispatcherImpl of InterfaceDispatcherTrait<InterfaceLibraryDispatcher> {
    fn foo1(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait InterfaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo2(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceSafeLibraryDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeLibraryDispatcher> {
    fn foo1(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceSafeDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeDispatcher> {
    fn foo1(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


impls:

impl InterfaceDispatcherCopy of core::traits::Copy::<InterfaceDispatcher>;
impl InterfaceDispatcherDrop of core::traits::Drop::<InterfaceDispatcher>;
impl InterfaceDispatcherSerde of core::serde::Serde::<InterfaceDispatcher> {
    fn serialize(self: @InterfaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceDispatcher> {
        core::option::Option::Some(InterfaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceDispatcher of starknet::Store::<InterfaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl InterfaceLibraryDispatcherCopy of core::traits::Copy::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherDrop of core::traits::Drop::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherSerde of core::serde::Serde::<InterfaceLibraryDispatcher> {
    fn serialize(self: @InterfaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceLibraryDispatcher> {
        core::option::Option::Some(InterfaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceLibraryDispatcher of starknet::Store::<InterfaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceSafeLibraryDispatcherCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherSerde of core::serde::Serde::<InterfaceSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeLibraryDispatcher> {
        core::option::Option::Some(InterfaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceSafeLibraryDispatcher of starknet::Store::<InterfaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl InterfaceSafeDispatcherCopy of core::traits::Copy::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherDrop of core::traits::Drop::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherSerde of core::serde::Serde::<InterfaceSafeDispatcher> {
    fn serialize(self: @InterfaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeDispatcher> {
        core::option::Option::Some(InterfaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreInterfaceSafeDispatcher of starknet::Store::<InterfaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ComponentState<TContractState> {
    }
    impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
    #[inline(always)]
    pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
        ComponentState::<TContractState> {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
        unsafe_new_component_state::<TContractState>()
    }
    

use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait,
};
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
pub impl MyEmbeddableImpl<
            TContractState, impl X: HasComponent<TContractState>
, impl TContractStateDrop: Drop<TContractState>
> of super::Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo1(component)
    }
    #[l1_handler]
    fn foo2(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo2(component)
    }
    #[constructor]
    fn foo3(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo3(component)
    }
}

impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



embeddable:

pub trait UnsafeNewContractStateTraitForMyEmbeddableImpl<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo1<TContractState, impl X: HasComponent<TContractState>
, impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo2<TContractState, impl X: HasComponent<TContractState>
, impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo3<TContractState, impl X: HasComponent<TContractState>
, impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo3(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



pub mod __external_MyEmbeddableImpl {
    pub use super::__wrapper__MyEmbeddableImpl__foo1 as foo1;
    pub use super::__wrapper__MyEmbeddableImpl__foo2 as foo2;
    pub use super::__wrapper__MyEmbeddableImpl__foo3 as foo3;
}

pub mod __l1_handler_MyEmbeddableImpl {
}

pub mod __constructor_MyEmbeddableImpl {
}


contract:



    pub struct ContractState {
        pub component_storage: super::component::ComponentState<ContractState>,
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
            component_storage: super::component::unsafe_new_component_state::<ContractState>(),
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x291a893aaae68e6364fac8003da0089f1c976946ebe457ce78ed62b5e680be2;

impl ContractStateMyEmbeddableImpl of
    super::component::UnsafeNewContractStateTraitForMyEmbeddableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}

pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_component of super::component::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @super::component::ComponentState<ContractState> {
        self.component_storage
    }
    fn get_component_mut(ref self: ContractState) -> super::component::ComponentState<ContractState> {
        super::component::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @super::component::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: super::component::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, super::component::Event>>(ref self: super::component::ComponentState<ContractState>, event: S) {
        let event: super::component::Event = core::traits::Into::into(event);
        let mut contract = super::component::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::CompEvent(event));
    }
}


impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::CompEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("CompEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("CompEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::CompEvent(val));
        }
        Option::None
    }
}
impl EventCompEventIntoEvent of Into<super::component::Event, Event> {
    fn into(self: super::component::Event) -> Event {
        Event::CompEvent(self)
    }
}

//! > ==========================================================================

//! > Test `#[abi(..)]` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[generate_trait]
impl SomeImpl<T> of SomeTrait<T> {
    fn foo(self: @T) {}
}
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[abi(v0)]
    impl Alias = super::SomeImpl<ContractState>;

    #[abi(embed)]
    impl InlineImpl of super::SomeTrait<ContractState> {
        fn foo(self: @ContractState) {}
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The 'abi' attribute for impl aliases only supports the 'embed_v0' argument.
 --> lib.cairo:10:5
    #[abi(v0)]
    ^********^

error: Plugin diagnostic: The 'abi' attribute for impls only supports the 'per_item' or 'embed_v0' argument.
 --> lib.cairo:13:5
    #[abi(embed)]
    ^***********^

//! > generated_cairo_code
lib.cairo:

#[generate_trait]
impl SomeImpl<T> of SomeTrait<T> {
    fn foo(self: @T) {}
}
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[abi(v0)]
    impl Alias = super::SomeImpl<ContractState>;

    #[abi(embed)]
    impl InlineImpl of super::SomeTrait<ContractState> {
        fn foo(self: @ContractState) {}
    }
}

generate_trait:

trait SomeTrait<T> {
    fn foo(self: @T);
}


contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ContractState {
    }
    impl ContractStateDrop of Drop<ContractState> {}
    #[inline(always)]
    pub fn unsafe_new_contract_state() -> ContractState {
        ContractState {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn contract_state_for_testing() -> ContractState {
        unsafe_new_contract_state()
    }
    
use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait
};
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: felt252 = 0x7bfb361123ab6c75c9b1db29acd3b69ea425da0db94322a959835a160c41da;


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}

//! > ==========================================================================

//! > Test `get_dep_component!` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

trait NotHasComponentTrait {}
impl NotHasComponent of NotHasComponentTrait {}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
    fn foo4(self: @TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(@self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component!(self, Comp1).foo1();
            get_dep_component!(Comp1, @self).foo1();
            get_dep_component!(@self, @self).foo1();
            get_dep_component!(Comp1, Comp1).foo1();
            get_dep_component!(@self, Comp2).foo1();
            get_dep_component!(@self, super::NotHasComponent).foo1();
            let not_contract_state: felt252 = 0;
            get_dep_component!(not_contract_state, Comp1).foo1();
            get_dep_component!(@self, NonExistingImpl).foo1();
        }
        fn foo4(self: @ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(self, Comp1).foo1();
        }
    }
}

//! > expected_diagnostics
error: Unexpected argument type. Expected: "@test::component3::ComponentState::<?2>", found: "test::component3::ComponentState::<TContractState>".
It is possible that the type inference failed because the types differ in the number of snapshots.
Consider adding or removing snapshots.
 --> lib.cairo:55:32
            get_dep_component!(self, Comp1).foo1();
                               ^**^

error: Expected variable or constant, found impl.
 --> lib.cairo:56:32
            get_dep_component!(Comp1, @self).foo1();
                               ^***^

error: Identifier not found.
 --> lib.cairo:56:40
            get_dep_component!(Comp1, @self).foo1();
                                       ^**^

error: Identifier not found.
 --> lib.cairo:57:40
            get_dep_component!(@self, @self).foo1();
                                       ^**^

error: Expected variable or constant, found impl.
 --> lib.cairo:58:32
            get_dep_component!(Comp1, Comp1).foo1();
                               ^***^

error: Method `foo1` not found on type `@test::component2::ComponentState::<TContractState>`. Did you import the correct trait and impl?
 --> lib.cairo:59:46
            get_dep_component!(@self, Comp2).foo1();
                                             ^**^

error: Invalid path.
 --> lib.cairo[get_dep_component_inline_macro]:4:41
                super::NotHasComponent::get_component(__get_dep_component_macro_temp_contract__)
                                        ^***********^

error: Unexpected argument type. Expected: "@test::component3::ComponentState::<?14>", found: "core::felt252".
It is possible that the type inference failed because the types differ in the number of snapshots.
Consider adding or removing snapshots.
 --> lib.cairo:62:32
            get_dep_component!(not_contract_state, Comp1).foo1();
                               ^****************^

error: Identifier not found.
 --> lib.cairo:63:39
            get_dep_component!(@self, NonExistingImpl).foo1();
                                      ^*************^

//! > generated_cairo_code
lib.cairo:

#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

trait NotHasComponentTrait {}
impl NotHasComponent of NotHasComponentTrait {}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
    fn foo4(self: @TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(@self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component!(self, Comp1).foo1();
            get_dep_component!(Comp1, @self).foo1();
            get_dep_component!(@self, @self).foo1();
            get_dep_component!(Comp1, Comp1).foo1();
            get_dep_component!(@self, Comp2).foo1();
            get_dep_component!(@self, super::NotHasComponent).foo1();
            let not_contract_state: felt252 = 0;
            get_dep_component!(not_contract_state, Comp1).foo1();
            get_dep_component!(@self, NonExistingImpl).foo1();
        }
        fn foo4(self: @ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(self, Comp1).foo1();
        }
    }
}

Comp3TraitDispatcherTrait:

trait Comp3TraitDispatcherTrait<T> {
    fn foo3(self: T);
    fn foo4(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitDispatcher> {
    fn foo3(self: Comp3TraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo4(self: Comp3TraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitLibraryDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitLibraryDispatcher> {
    fn foo3(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo4(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Comp3TraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo4(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitSafeLibraryDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeLibraryDispatcher> {
    fn foo3(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo4(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitSafeDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeDispatcher> {
    fn foo3(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo4(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


impls:

impl Comp3TraitDispatcherCopy of core::traits::Copy::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherDrop of core::traits::Drop::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherSerde of core::serde::Serde::<Comp3TraitDispatcher> {
    fn serialize(self: @Comp3TraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitDispatcher> {
        core::option::Option::Some(Comp3TraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitDispatcher of starknet::Store::<Comp3TraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl Comp3TraitLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitLibraryDispatcher> {
    fn serialize(self: @Comp3TraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitLibraryDispatcher of starknet::Store::<Comp3TraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl Comp3TraitSafeLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitSafeLibraryDispatcher> {
    fn serialize(self: @Comp3TraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitSafeLibraryDispatcher of starknet::Store::<Comp3TraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl Comp3TraitSafeDispatcherCopy of core::traits::Copy::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherDrop of core::traits::Drop::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherSerde of core::serde::Serde::<Comp3TraitSafeDispatcher> {
    fn serialize(self: @Comp3TraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeDispatcher> {
        core::option::Option::Some(Comp3TraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitSafeDispatcher of starknet::Store::<Comp3TraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ComponentState<TContractState> {
    }
    impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
    #[inline(always)]
    pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
        ComponentState::<TContractState> {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
        unsafe_new_component_state::<TContractState>()
    }
    

use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait,
};
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo1(self: @ComponentState<TContractState>);
    }


impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo2(self: @ComponentState<TContractState>);
    }


component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ComponentState<TContractState> {
    }
    impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
    #[inline(always)]
    pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
        ComponentState::<TContractState> {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
        unsafe_new_component_state::<TContractState>()
    }
    

use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait,
};
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
pub impl Comp3<
            TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>

> of super::Comp3Trait<TContractState> {
    
    fn foo3(ref self: TContractState) {
        let mut component = HasComponent::get_component_mut(ref self);
        Comp3Impl::foo3(ref component)
    }
    
    fn foo4(self: @TContractState) {
        let component = HasComponent::get_component(self);
        Comp3Impl::foo4(component)
    }
}

impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



embeddable:

pub trait UnsafeNewContractStateTraitForComp3<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Comp3__foo3<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo3(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Comp3__foo4<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo4(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



pub mod __external_Comp3 {
    pub use super::__wrapper__Comp3__foo3 as foo3;
    pub use super::__wrapper__Comp3__foo4 as foo4;
}

pub mod __l1_handler_Comp3 {
}

pub mod __constructor_Comp3 {
}

//! > ==========================================================================

//! > Test `get_dep_component_mut!` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component_mut!(ref self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component_mut!(Comp1, self).foo1();
            get_dep_component_mut!(ref self, self).foo1();
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
            get_dep_component_mut!(ref self, Comp2).foo1();
            get_dep_component_mut!(self, Comp1).foo1();
            get_dep_component_mut!(mut self, Comp1).foo1();
            get_dep_component_mut!(ref ref self, Comp1).foo1();
            get_dep_component_mut!(ref mut self, Comp1).foo1();
        }
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:51:36
            get_dep_component_mut!(Comp1, self).foo1();
                                   ^***^

error: Identifier not found.
 --> lib.cairo:52:46
            get_dep_component_mut!(ref self, self).foo1();
                                             ^**^

error: Expected variable or constant, found impl.
 --> lib.cairo:53:40
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
                                       ^***^

error: ref argument must be a variable.
 --> lib.cairo:53:40
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
                                       ^***^

error: Method `foo1` could not be called on type `test::component2::ComponentState::<TContractState>`.
Candidate `Comp1HelperTrait::foo1` inference failed with: Type mismatch: `test::component2::ComponentState::<TContractState>` and `@test::component1::ComponentState::<?8>`
 --> lib.cairo:54:53
            get_dep_component_mut!(ref self, Comp2).foo1();
                                                    ^**^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:55:36
            get_dep_component_mut!(self, Comp1).foo1();
                                   ^**^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:56:40
            get_dep_component_mut!(mut self, Comp1).foo1();
                                       ^**^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:57:44
            get_dep_component_mut!(ref ref self, Comp1).foo1();
                                           ^**^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:58:44
            get_dep_component_mut!(ref mut self, Comp1).foo1();
                                           ^**^

error: Type annotations needed. Failed to infer ?2
 --> lib.cairo:51:49
            get_dep_component_mut!(Comp1, self).foo1();
                                                ^**^

//! > generated_cairo_code
lib.cairo:

#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component_mut!(ref self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component_mut!(Comp1, self).foo1();
            get_dep_component_mut!(ref self, self).foo1();
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
            get_dep_component_mut!(ref self, Comp2).foo1();
            get_dep_component_mut!(self, Comp1).foo1();
            get_dep_component_mut!(mut self, Comp1).foo1();
            get_dep_component_mut!(ref ref self, Comp1).foo1();
            get_dep_component_mut!(ref mut self, Comp1).foo1();
        }
    }
}

Comp3TraitDispatcherTrait:

trait Comp3TraitDispatcherTrait<T> {
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitDispatcher> {
    fn foo3(self: Comp3TraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitLibraryDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitLibraryDispatcher> {
    fn foo3(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Comp3TraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitSafeLibraryDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeLibraryDispatcher> {
    fn foo3(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitSafeDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeDispatcher> {
    fn foo3(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


impls:

impl Comp3TraitDispatcherCopy of core::traits::Copy::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherDrop of core::traits::Drop::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherSerde of core::serde::Serde::<Comp3TraitDispatcher> {
    fn serialize(self: @Comp3TraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitDispatcher> {
        core::option::Option::Some(Comp3TraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitDispatcher of starknet::Store::<Comp3TraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


impls:

impl Comp3TraitLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitLibraryDispatcher> {
    fn serialize(self: @Comp3TraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitLibraryDispatcher of starknet::Store::<Comp3TraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl Comp3TraitSafeLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitSafeLibraryDispatcher> {
    fn serialize(self: @Comp3TraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitSafeLibraryDispatcher of starknet::Store::<Comp3TraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}


impls:

impl Comp3TraitSafeDispatcherCopy of core::traits::Copy::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherDrop of core::traits::Drop::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherSerde of core::serde::Serde::<Comp3TraitSafeDispatcher> {
    fn serialize(self: @Comp3TraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeDispatcher> {
        core::option::Option::Some(Comp3TraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


starknet_derive:

impl StoreComp3TraitSafeDispatcher of starknet::Store::<Comp3TraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}


component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ComponentState<TContractState> {
    }
    impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
    #[inline(always)]
    pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
        ComponentState::<TContractState> {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
        unsafe_new_component_state::<TContractState>()
    }
    

use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait,
};
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo1(self: @ComponentState<TContractState>);
    }


impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>
    > {
        fn foo2(self: @ComponentState<TContractState>);
    }


component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


    pub struct ComponentState<TContractState> {
    }
    impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
    #[inline(always)]
    pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
        ComponentState::<TContractState> {
        }
    }
    #[cfg(test)]
    #[inline(always)]
    pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
        unsafe_new_component_state::<TContractState>()
    }
    

use starknet::storage::{
    StorageMapMemberAddressTrait, StorageMemberAddressTrait,
    StorageMapMemberAccessTrait, StorageMemberAccessTrait,
};
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
pub impl Comp3<
            TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>

> of super::Comp3Trait<TContractState> {
    
    fn foo3(ref self: TContractState) {
        let mut component = HasComponent::get_component_mut(ref self);
        Comp3Impl::foo3(ref component)
    }
}

impls:

impl EventDrop of core::traits::Drop::<Event>;


starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



embeddable:

pub trait UnsafeNewContractStateTraitForComp3<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, EcOp, Poseidon, SegmentArena, GasBuiltin, System)]
fn __wrapper__Comp3__foo3<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo3(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



pub mod __external_Comp3 {
    pub use super::__wrapper__Comp3__foo3 as foo3;
}

pub mod __l1_handler_Comp3 {
}

pub mod __constructor_Comp3 {
}
