//! > Test first param must be self.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    fn foo() {}

    #[external(v0)]
    fn bar(_n: u32) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    fn foo() {}

    #[external(v0)]
    fn bar(_n: u32) {}
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x198f4bc6efa8417922f8041d6e73821af41c6bbf15f1c93084da188702456b.try_into().unwrap();


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: The first parameter of an entry point must be `self`.
 --> lib.cairo:7:11
    fn foo() {}
          ^^

error: Plugin diagnostic: The first parameter of an entry point must be `self`.
 --> lib.cairo:10:12
    fn bar(_n: u32) {}
           ^^^^^^^

warning: Plugin diagnostic: Failed to generate ABI: Entrypoints must have a self first param.
 --> lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > Test invalid constructor name.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[constructor]
    fn invalid_constructor_name(ref self: ContractState) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[constructor]
    fn invalid_constructor_name(ref self: ContractState) {}
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x3bd690d1a73da0d8c43f46ecc3a006978d8343a075e91a1c7a24529e7d244a.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__invalid_constructor_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    invalid_constructor_name(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
    pub use super::__wrapper__invalid_constructor_name as invalid_constructor_name;
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: The constructor function must be called `constructor`.
 --> lib.cairo:7:8
    fn invalid_constructor_name(ref self: ContractState) {}
       ^^^^^^^^^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > Test non-v0 external function.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo_v0(ref self: ContractState, x: (felt252, felt252)) {}
    #[external]
    fn foo(ref self: ContractState, x: (felt252, felt252)) {}
    #[external(v1)]
    fn foo_v1(ref self: ContractState, x: (felt252, felt252)) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo_v0(ref self: ContractState, x: (felt252, felt252)) {}
    #[external]
    fn foo(ref self: ContractState, x: (felt252, felt252)) {}
    #[external(v1)]
    fn foo_v1(ref self: ContractState, x: (felt252, felt252)) {}
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x547f368ac55821b57d7da42588a2985edb69dd87af9e9c16e740d6e14b2420.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__foo_v0(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo_v0(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__foo_v1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo_v1(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo_v0 as foo_v0;
    pub use super::__wrapper__foo as foo;
    pub use super::__wrapper__foo_v1 as foo_v1;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:7:5
    #[external]
    ^^^^^^^^^^^

error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:9:5
    #[external(v1)]
    ^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > Test diagnostics of non-serializable parameter in entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState, x: super::MyType) {}
}
#[derive(Drop)]
struct MyType {}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState, x: super::MyType) {}
}
#[derive(Drop)]
struct MyType {}

lib.cairo:8:10
#[derive(Drop)]
         ^^^^
impls:

impl MyTypeDrop of core::traits::Drop::<MyType>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x16fce813e4d7f676441c2cffa36b5101b7e75cb787a8aec7259094fdbacb80e.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<super::MyType>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
error: Trait has no implementation in context: core::serde::Serde::<test::MyType>.
 --> lib.cairo:5:5-6:56
      #[external(v0)]
 _____^
|     fn foo(ref self: ContractState, x: super::MyType) {}
|________________________________________________________^

//! > ==========================================================================

//! > Test diagnostics of non-serializable return type in entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState) -> (felt252, felt252) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(ref self: ContractState) -> (felt252, felt252) {}
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x2c31752790f50b7f25195fc7cc9dcc1234d7af736c5ed771c69ddc8bb9fd8d4.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = foo(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<(felt252, felt252)>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
error: Unexpected return type. Expected: "(core::felt252, core::felt252)", found: "()".
 --> lib.cairo:6:40
    fn foo(ref self: ContractState) -> (felt252, felt252) {}
                                       ^^^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > Test diagnostics of generic entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo<T>(ref self: ContractState, x: T) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo<T>(ref self: ContractState, x: T) {}
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x2bcbd7e08add1bbb62c174729940be27dbe922f83afd842f02af5355af726a1.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<T>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo(ref contract_state, __arg_x);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: Contract entry points cannot have generic arguments
 --> lib.cairo:6:11
    fn foo<T>(ref self: ContractState, x: T) {}
          ^^^

warning: Plugin diagnostic: Failed to generate ABI: Got unexpected type.
 --> lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^

error[E0006]: Type not found.
 --> lib.cairo:5:5-6:47
      #[external(v0)]
 _____^
|     fn foo<T>(ref self: ContractState, x: T) {}
|_______________________________________________^

error: Variable not dropped.
 --> lib.cairo:6:40
    fn foo<T>(ref self: ContractState, x: T) {}
                                       ^
note: Trait has no implementation in context: core::traits::Drop::<T>.
note: Trait has no implementation in context: core::traits::Destruct::<T>.

//! > ==========================================================================

//! > Test multiple diagnostics from entry point.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(
        ref self: ContractState, x: (felt252, felt252), y: (felt252, felt252),
    ) -> (felt252, felt252) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn foo(
        ref self: ContractState, x: (felt252, felt252), y: (felt252, felt252),
    ) -> (felt252, felt252) {}
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x51e947dc07c2918ff505d4f848310fd40dc215c7a78b8e0ec19a8c6ab47ce3.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_x = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let __arg_y = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<(felt252, felt252)>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = foo(ref contract_state, __arg_x, __arg_y);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<(felt252, felt252)>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
error: Unexpected return type. Expected: "(core::felt252, core::felt252)", found: "()".
 --> lib.cairo:8:10
    ) -> (felt252, felt252) {}
         ^^^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > Test account contract_entry point on a non-account contract.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn __validate__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_declare__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_deploy__(ref self: ContractState) {}
    #[external(v0)]
    fn __execute__(ref self: ContractState) {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    fn __validate__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_declare__(ref self: ContractState) {}
    #[external(v0)]
    fn __validate_deploy__(ref self: ContractState) {}
    #[external(v0)]
    fn __execute__(ref self: ContractState) {}
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x291a42fae50c99636dc1d6bc0c4e28fdb0e21f47c26aa0d5e22c21d993823d8.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper____validate__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper____validate_declare__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate_declare__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper____validate_deploy__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __validate_deploy__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper____execute__(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    __execute__(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper____validate__ as __validate__;
    pub use super::__wrapper____validate_declare__ as __validate_declare__;
    pub use super::__wrapper____validate_deploy__ as __validate_deploy__;
    pub use super::__wrapper____execute__ as __execute__;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
warning: Plugin diagnostic: Failed to generate ABI: `__validate__` is a reserved entry point name for account contracts only (marked with `#[starknet::contract(account)]`).
 --> lib.cairo:5:5-6:47
      #[external(v0)]
 _____^
|     fn __validate__(ref self: ContractState) {}
|_______________________________________________^

warning: Plugin diagnostic: Failed to generate ABI: `__execute__` is a reserved entry point name for account contracts only (marked with `#[starknet::contract(account)]`).
 --> lib.cairo:11:5-12:46
      #[external(v0)]
 _____^
|     fn __execute__(ref self: ContractState) {}
|______________________________________________^

//! > ==========================================================================

//! > Test raw_outputs diagnostics.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    #[raw_output]
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}

    #[external(v0)]
    #[raw_output]
    fn bar1(ref self: ContractState, a: felt252) -> felt252 {
        0
    }

    #[external(v0)]
    #[raw_output]
    fn bar2(ref self: ContractState, a: felt252) {}

    // Should generate diagnostic as path resolving is not supported.
    #[external(v0)]
    #[raw_output]
    fn bar3(ref self: ContractState, a: felt252) -> core::Array<felt252> {
        array::array_new()
    }

    // Should generate diagnostic as alias resolving is not supported.
    type my_felt252_array_type = Array::<felt252>;
    #[external(v0)]
    #[raw_output]
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
        array::array_new()
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    #[raw_output]
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}

    #[external(v0)]
    #[raw_output]
    fn bar1(ref self: ContractState, a: felt252) -> felt252 {
        0
    }

    #[external(v0)]
    #[raw_output]
    fn bar2(ref self: ContractState, a: felt252) {}

    // Should generate diagnostic as path resolving is not supported.
    #[external(v0)]
    #[raw_output]
    fn bar3(ref self: ContractState, a: felt252) -> core::Array<felt252> {
        array::array_new()
    }

    // Should generate diagnostic as alias resolving is not supported.
    type my_felt252_array_type = Array::<felt252>;
    #[external(v0)]
    #[raw_output]
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
        array::array_new()
    }
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0xe6da8c1c7f4f4eacbcd1e253492a549cdbe26d925524eeed0c44aaaf75d668.try_into().unwrap();


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: `raw_output` functions cannot have `ref` parameters.
 --> lib.cairo:8:37
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                    ^^^

error: Plugin diagnostic: `raw_output` functions cannot have `ref` parameters.
 --> lib.cairo:8:53
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                                    ^^^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:8:69
    fn foo(ref self: ContractState, ref a: felt252, ref b: felt252) {}
                                                                    ^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:12:53
    fn bar1(ref self: ContractState, a: felt252) -> felt252 {
                                                    ^^^^^^^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:18:50
    fn bar2(ref self: ContractState, a: felt252) {}
                                                 ^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:23:53
    fn bar3(ref self: ContractState, a: felt252) -> core::Array<felt252> {
                                                    ^^^^^^^^^^^^^^^^^^^^

error: Plugin diagnostic: `raw_output` functions must return `Span::<felt252>`.
 --> lib.cairo:31:53
    fn bar4(ref self: ContractState, a: felt252) -> my_felt252_array_type {
                                                    ^^^^^^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > Test reusage of storage var name diagnostics.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: false)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
        pub same_name: felt252,
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
    pub same_name: starknet::storage::StorageBase<felt252>,
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let __same_name_value__ = starknet::storage::StorageBase {__base_address__: selector!("same_name")};
        StorageStorageBase {
           same_name: __same_name_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
    pub same_name: starknet::storage::StorageBase<starknet::storage::Mutable::<felt252>>,
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let __same_name_value__ = starknet::storage::StorageBase {__base_address__: selector!("same_name")};
        StorageStorageBaseMut {
           same_name: __same_name_value__,
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x271c051b9d25373bc88ddfddfb1c29cc601d7014c5343fe167b82768570a896.try_into().unwrap();


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics

//! > ==========================================================================

//! > Contract with no storage.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    fn same_name() -> felt252 {
        1
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Contracts must define a 'Storage' struct.
 --> lib.cairo:1:1-6:1
  #[starknet::contract]
 _^
| ...
| }
|_^

//! > ==========================================================================

//! > Not annotated storage struct.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    struct Storage {
        same_name: felt252,
    }
    fn same_name() -> felt252 {
        1
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: 'Storage' struct must be annotated with #[storage].
 --> lib.cairo:3:5-5:5
      struct Storage {
 _____^
|         same_name: felt252,
|     }
|_____^

//! > ==========================================================================

//! > Non v0 impls.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    #[generate_trait]
    impl AImpl of ATrait {}

    #[external(v1)]
    #[generate_trait]
    impl BImpl of BTrait {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}
    #[external(v0)]
    #[generate_trait]
    impl AImpl of ATrait {}

    #[external(v1)]
    #[generate_trait]
    impl BImpl of BTrait {}
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x1f35904b8fc9bed6ac08457ded74e522aa254844ebb1d7da8eaff06532a8b4d.try_into().unwrap();


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:5:5-7:27
      #[external(v0)]
 _____^
|     #[generate_trait]
|     impl AImpl of ATrait {}
|___________________________^
generate_trait:

    trait ATrait {}


lib.cairo:9:5-11:27
      #[external(v1)]
 _____^
|     #[generate_trait]
|     impl BImpl of BTrait {}
|___________________________^
generate_trait:

    trait BTrait {}


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:5:5
    #[external(v0)]
    ^^^^^^^^^^^^^^^

error: Plugin diagnostic: Only #[external(v0)] is supported.
 --> lib.cairo:9:5
    #[external(v1)]
    ^^^^^^^^^^^^^^^

warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:9:5
    #[external(v1)]
    ^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > old contract attribute.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[contract]
mod test_contract {}

#[abi]
trait ContractAbi {}

//! > generated_cairo_code
lib.cairo:

#[contract]
mod test_contract {}

#[abi]
trait ContractAbi {}

//! > expected_diagnostics
error: Plugin diagnostic: The 'contract' attribute was deprecated, please use `starknet::contract` instead.
 --> lib.cairo:1:1-2:20
  #[contract]
 _^
| mod test_contract {}
|____________________^

error: Plugin diagnostic: Unsupported attribute.
 --> lib.cairo:1:1
#[contract]
^^^^^^^^^^^

error: Plugin diagnostic: The 'abi' attribute for traits was deprecated, please use `starknet::interface` instead.
 --> lib.cairo:4:1-5:20
  #[abi]
 _^
| trait ContractAbi {}
|____________________^

//! > ==========================================================================

//! > Attributes in external impl.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait InterfaceTrait<TContractState> {
    fn foo_external1(self: @TContractState);
    fn foo_l1_handler1(self: @TContractState);
    fn foo_constructor1(self: @TContractState);
}

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    impl Impl2 of super::InterfaceTrait<ContractState> {
        #[external(v0)]
        fn foo_external1(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler1(self: @ContractState) {}
        #[constructor]
        fn foo_constructor1(self: @ContractState) {}
    }

    #[generate_trait]
    #[external(v0)]
    impl Impl1 of NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState) {}
        #[constructor]
        fn foo_constructor2(self: @ContractState) {}
    }
}

//! > expected_diagnostics
warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:13:5
    #[external(v0)]
    ^^^^^^^^^^^^^^^

error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:15:9
        #[external(v0)]
        ^^^^^^^^^^^^^^^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:17:9
        #[l1_handler]
        ^^^^^^^^^^^^^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:19:9
        #[constructor]
        ^^^^^^^^^^^^^^

warning: Plugin diagnostic: The 'external' attribute on impls is deprecated. Use 'abi(per_item)' or 'abi(embed_v0)'.
 --> lib.cairo:24:5
    #[external(v0)]
    ^^^^^^^^^^^^^^^

error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:26:9
        #[external(v0)]
        ^^^^^^^^^^^^^^^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:28:9
        #[l1_handler]
        ^^^^^^^^^^^^^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[external(v0)]`.
 --> lib.cairo:30:9
        #[constructor]
        ^^^^^^^^^^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait InterfaceTrait<TContractState> {
    fn foo_external1(self: @TContractState);
    fn foo_l1_handler1(self: @TContractState);
    fn foo_constructor1(self: @TContractState);
}

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[external(v0)]
    impl Impl2 of super::InterfaceTrait<ContractState> {
        #[external(v0)]
        fn foo_external1(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler1(self: @ContractState) {}
        #[constructor]
        fn foo_constructor1(self: @ContractState) {}
    }

    #[generate_trait]
    #[external(v0)]
    impl Impl1 of NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState) {}
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState) {}
        #[constructor]
        fn foo_constructor2(self: @ContractState) {}
    }
}

lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
InterfaceTraitDispatcherTrait:

trait InterfaceTraitDispatcherTrait<T> {
    fn foo_external1(self: T);
    fn foo_l1_handler1(self: T);
    fn foo_constructor1(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceTraitDispatcherImpl of InterfaceTraitDispatcherTrait<InterfaceTraitDispatcher> {
    fn foo_external1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_l1_handler1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_constructor1(self: InterfaceTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceTraitLibraryDispatcherImpl of InterfaceTraitDispatcherTrait<InterfaceTraitLibraryDispatcher> {
    fn foo_external1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_l1_handler1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo_constructor1(self: InterfaceTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait InterfaceTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo_external1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo_l1_handler1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo_constructor1(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceTraitSafeLibraryDispatcherImpl of InterfaceTraitSafeDispatcherTrait<InterfaceTraitSafeLibraryDispatcher> {
    fn foo_external1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_l1_handler1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_constructor1(self: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceTraitSafeDispatcherImpl of InterfaceTraitSafeDispatcherTrait<InterfaceTraitSafeDispatcher> {
    fn foo_external1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_external1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_l1_handler1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_l1_handler1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo_constructor1(self: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo_constructor1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitDispatcherCopy of core::traits::Copy::<InterfaceTraitDispatcher>;
impl InterfaceTraitDispatcherDrop of core::traits::Drop::<InterfaceTraitDispatcher>;
impl InterfaceTraitDispatcherSerde of core::serde::Serde::<InterfaceTraitDispatcher> {
    fn serialize(self: @InterfaceTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitDispatcher> {
        core::option::Option::Some(InterfaceTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceTraitDispatcher of starknet::Store::<InterfaceTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceTraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceTraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceTraitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl InterfaceTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceTraitDispatcher> {
    type SubPointersType = InterfaceTraitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceTraitDispatcher>) -> InterfaceTraitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceTraitDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceTraitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl InterfaceTraitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceTraitDispatcher> {
    type SubPointersType = InterfaceTraitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceTraitDispatcher>>) -> InterfaceTraitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceTraitDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitLibraryDispatcherCopy of core::traits::Copy::<InterfaceTraitLibraryDispatcher>;
impl InterfaceTraitLibraryDispatcherDrop of core::traits::Drop::<InterfaceTraitLibraryDispatcher>;
impl InterfaceTraitLibraryDispatcherSerde of core::serde::Serde::<InterfaceTraitLibraryDispatcher> {
    fn serialize(self: @InterfaceTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitLibraryDispatcher> {
        core::option::Option::Some(InterfaceTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceTraitLibraryDispatcher of starknet::Store::<InterfaceTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceTraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceTraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceTraitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl InterfaceTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceTraitLibraryDispatcher> {
    type SubPointersType = InterfaceTraitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceTraitLibraryDispatcher>) -> InterfaceTraitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceTraitLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceTraitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl InterfaceTraitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceTraitLibraryDispatcher> {
    type SubPointersType = InterfaceTraitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceTraitLibraryDispatcher>>) -> InterfaceTraitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceTraitLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitSafeLibraryDispatcherCopy of core::traits::Copy::<InterfaceTraitSafeLibraryDispatcher>;
impl InterfaceTraitSafeLibraryDispatcherDrop of core::traits::Drop::<InterfaceTraitSafeLibraryDispatcher>;
impl InterfaceTraitSafeLibraryDispatcherSerde of core::serde::Serde::<InterfaceTraitSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitSafeLibraryDispatcher> {
        core::option::Option::Some(InterfaceTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceTraitSafeLibraryDispatcher of starknet::Store::<InterfaceTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceTraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceTraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceTraitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl InterfaceTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceTraitSafeLibraryDispatcher> {
    type SubPointersType = InterfaceTraitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceTraitSafeLibraryDispatcher>) -> InterfaceTraitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceTraitSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceTraitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl InterfaceTraitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceTraitSafeLibraryDispatcher> {
    type SubPointersType = InterfaceTraitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceTraitSafeLibraryDispatcher>>) -> InterfaceTraitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceTraitSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitSafeDispatcherCopy of core::traits::Copy::<InterfaceTraitSafeDispatcher>;
impl InterfaceTraitSafeDispatcherDrop of core::traits::Drop::<InterfaceTraitSafeDispatcher>;
impl InterfaceTraitSafeDispatcherSerde of core::serde::Serde::<InterfaceTraitSafeDispatcher> {
    fn serialize(self: @InterfaceTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceTraitSafeDispatcher> {
        core::option::Option::Some(InterfaceTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceTraitSafeDispatcher of starknet::Store::<InterfaceTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceTraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceTraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceTraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceTraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceTraitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl InterfaceTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceTraitSafeDispatcher> {
    type SubPointersType = InterfaceTraitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceTraitSafeDispatcher>) -> InterfaceTraitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceTraitSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceTraitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl InterfaceTraitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceTraitSafeDispatcher> {
    type SubPointersType = InterfaceTraitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceTraitSafeDispatcher>>) -> InterfaceTraitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceTraitSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitDispatcherSubPointersDrop of core::traits::Drop::<InterfaceTraitDispatcherSubPointers>;
impl InterfaceTraitDispatcherSubPointersCopy of core::traits::Copy::<InterfaceTraitDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceTraitDispatcherSubPointersMut>;
impl InterfaceTraitDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceTraitDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceTraitLibraryDispatcherSubPointers>;
impl InterfaceTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceTraitLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceTraitLibraryDispatcherSubPointersMut>;
impl InterfaceTraitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceTraitLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceTraitSafeLibraryDispatcherSubPointers>;
impl InterfaceTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceTraitSafeLibraryDispatcherSubPointersMut>;
impl InterfaceTraitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceTraitSafeLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<InterfaceTraitSafeDispatcherSubPointers>;
impl InterfaceTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<InterfaceTraitSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceTraitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceTraitSafeDispatcherSubPointersMut>;
impl InterfaceTraitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceTraitSafeDispatcherSubPointersMut>;


lib.cairo:8:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0xb2b80f78cee80a1a53222a998e318822f6d9d701bdc8037948c5964158503c.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__Impl2__foo_external1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_external1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__Impl2__foo_l1_handler1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_l1_handler1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__Impl2__foo_constructor1(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl2::foo_constructor1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__Impl1__foo_external2(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_external2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__Impl1__foo_l1_handler2(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_l1_handler2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__Impl1__foo_constructor2(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Impl1::foo_constructor2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__Impl2__foo_external1 as foo_external1;
    pub use super::__wrapper__Impl2__foo_l1_handler1 as foo_l1_handler1;
    pub use super::__wrapper__Impl2__foo_constructor1 as foo_constructor1;
    pub use super::__wrapper__Impl1__foo_external2 as foo_external2;
    pub use super::__wrapper__Impl1__foo_l1_handler2 as foo_l1_handler2;
    pub use super::__wrapper__Impl1__foo_constructor2 as foo_constructor2;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:23:5-32:5
      #[generate_trait]
 _____^
| ...
|     }
|_____^
generate_trait:

    trait NonInterfaceTrait {
        #[external(v0)]
        fn foo_external2(self: @ContractState);
        #[l1_handler]
        fn foo_l1_handler2(self: @ContractState);
        #[constructor]
        fn foo_constructor2(self: @ContractState);
    }


lib.cairo:8:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:8:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:10:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:10:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > ==========================================================================

//! > "Event" enum without #[event].

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[derive(Drop, starknet::Event)]
    enum Event {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[derive(Drop, starknet::Event)]
    enum Event {}
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:



#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x820d41c225755fd6813443e1db69b44d323763bb1bdc6c58da9d8011855f0b.try_into().unwrap();


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:6:14
    #[derive(Drop, starknet::Event)]
             ^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:6:20
    #[derive(Drop, starknet::Event)]
                   ^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: Contract type that is named `Event` must be marked with #[event].
 --> lib.cairo:7:10
    enum Event {}
         ^^^^^

//! > ==========================================================================

//! > #[event] enum that isn't named "Event".

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[event]
    #[derive(Drop, starknet::Event)]
    enum MyEvent {}
}

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[event]
    #[derive(Drop, starknet::Event)]
    enum MyEvent {}
}

lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x1786cd1474db7f1bf61efa820fedb6cc8a9892313c56a8ab854a488db0d2879.try_into().unwrap();


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:7:14
    #[derive(Drop, starknet::Event)]
             ^^^^
impls:

impl MyEventDrop of core::traits::Drop::<MyEvent>;


lib.cairo:7:20
    #[derive(Drop, starknet::Event)]
                   ^^^^^^^^^^^^^^^
starknet_derive:

impl MyEventIsEvent of starknet::Event<MyEvent> {
    fn append_keys_and_data(
        self: @MyEvent, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<MyEvent> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > expected_diagnostics
error: Plugin diagnostic: Contract type that is marked with #[event] must be named `Event`.
 --> lib.cairo:8:10
    enum MyEvent {}
         ^^^^^^^

//! > ==========================================================================

//! > Test `starknet::interface` trait with no body.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T>;

//! > expected_diagnostics
error: Plugin diagnostic: Starknet interfaces without body are not supported.
 --> lib.cairo:2:19
trait IContract<T>;
                  ^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T>;

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad generic params.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract2Generics<T, S> {}

#[starknet::interface]
trait IContract0Generics {}

#[starknet::interface]
trait IContractNonTypeGenerics<+Destruct<u32>> {}

//! > expected_diagnostics
error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:2:25
trait IContract2Generics<T, S> {}
                        ^^^^^^

error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:5:26
trait IContract0Generics {}
                         ^

error: Plugin diagnostic: Starknet interfaces must have exactly one generic parameter, which is a type.
 --> lib.cairo:8:31
trait IContractNonTypeGenerics<+Destruct<u32>> {}
                              ^^^^^^^^^^^^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract2Generics<T, S> {}

#[starknet::interface]
trait IContract0Generics {}

#[starknet::interface]
trait IContractNonTypeGenerics<+Destruct<u32>> {}

//! > ==========================================================================

//! > Test `starknet::interface` trait with non-self param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
    fn no_params() -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: The first parameter must be named `self`.
 --> lib.cairo:3:21
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
                    ^^^^^^^^^^^^^^^^^

error: Plugin diagnostic: The first parameter must be named `self`.
 --> lib.cairo:4:22
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
                     ^^^^^^^^^^^^^^

error: Plugin diagnostic: `starknet::interface` functions must have a `self` parameter.
 --> lib.cairo:5:5
    fn no_params() -> felt252;
    ^^^^^^^^^^^^^^^^^^^^^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn ref_bad_name(ref wrong_name: T, other: felt252) -> felt252;
    fn snap_bad_name(wrong_name: @T, other: felt252) -> felt252;
    fn no_params() -> felt252;
}

lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl IContractDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractDispatcher> {
    type SubPointersType = IContractDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractDispatcher>) -> IContractDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl IContractDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractDispatcher> {
    type SubPointersType = IContractDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractDispatcher>>) -> IContractDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl IContractLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractLibraryDispatcher> {
    type SubPointersType = IContractLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractLibraryDispatcher>) -> IContractLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl IContractLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractLibraryDispatcher> {
    type SubPointersType = IContractLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractLibraryDispatcher>>) -> IContractLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl IContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeLibraryDispatcher> {
    type SubPointersType = IContractSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeLibraryDispatcher>) -> IContractSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl IContractSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractSafeLibraryDispatcher> {
    type SubPointersType = IContractSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeLibraryDispatcher>>) -> IContractSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl IContractSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeDispatcher> {
    type SubPointersType = IContractSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeDispatcher>) -> IContractSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl IContractSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractSafeDispatcher> {
    type SubPointersType = IContractSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeDispatcher>>) -> IContractSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherSubPointersDrop of core::traits::Drop::<IContractDispatcherSubPointers>;
impl IContractDispatcherSubPointersCopy of core::traits::Copy::<IContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherSubPointersMutDrop of core::traits::Drop::<IContractDispatcherSubPointersMut>;
impl IContractDispatcherSubPointersMutCopy of core::traits::Copy::<IContractDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointers>;
impl IContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointersMut>;
impl IContractLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointers>;
impl IContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointersMut>;
impl IContractSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeDispatcherSubPointers>;
impl IContractSafeDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IContractSafeDispatcherSubPointersMut>;
impl IContractSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IContractSafeDispatcherSubPointersMut>;

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad non-first param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn foo(
        ref self: T,
        ref param_ref: felt252,
        t_param: T,
        arr_param: Array<T>,
        snap_param: @T,
        tup_param: (felt252, T),
    ) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> lib.cairo:5:9
        ref param_ref: felt252,
        ^^^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:6:18
        t_param: T,
                 ^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:7:20
        arr_param: Array<T>,
                   ^^^^^^^^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:8:21
        snap_param: @T,
                    ^^

error: Plugin diagnostic: `starknet::interface` functions don't support parameters that depend on the trait's generic param type.
 --> lib.cairo:9:20
        tup_param: (felt252, T),
                   ^^^^^^^^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn foo(
        ref self: T,
        ref param_ref: felt252,
        t_param: T,
        arr_param: Array<T>,
        snap_param: @T,
        tup_param: (felt252, T),
    ) -> felt252;
}

lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl IContractDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractDispatcher> {
    type SubPointersType = IContractDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractDispatcher>) -> IContractDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl IContractDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractDispatcher> {
    type SubPointersType = IContractDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractDispatcher>>) -> IContractDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl IContractLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractLibraryDispatcher> {
    type SubPointersType = IContractLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractLibraryDispatcher>) -> IContractLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl IContractLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractLibraryDispatcher> {
    type SubPointersType = IContractLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractLibraryDispatcher>>) -> IContractLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl IContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeLibraryDispatcher> {
    type SubPointersType = IContractSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeLibraryDispatcher>) -> IContractSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl IContractSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractSafeLibraryDispatcher> {
    type SubPointersType = IContractSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeLibraryDispatcher>>) -> IContractSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl IContractSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeDispatcher> {
    type SubPointersType = IContractSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeDispatcher>) -> IContractSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl IContractSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractSafeDispatcher> {
    type SubPointersType = IContractSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeDispatcher>>) -> IContractSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherSubPointersDrop of core::traits::Drop::<IContractDispatcherSubPointers>;
impl IContractDispatcherSubPointersCopy of core::traits::Copy::<IContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherSubPointersMutDrop of core::traits::Drop::<IContractDispatcherSubPointersMut>;
impl IContractDispatcherSubPointersMutCopy of core::traits::Copy::<IContractDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointers>;
impl IContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointersMut>;
impl IContractLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointers>;
impl IContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointersMut>;
impl IContractSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeDispatcherSubPointers>;
impl IContractSafeDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IContractSafeDispatcherSubPointersMut>;
impl IContractSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IContractSafeDispatcherSubPointersMut>;

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad modifiers for self param.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:3:24
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
                       ^^^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn non_ref_or_snap(self: T, other: felt252) -> felt252;
}

lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl IContractDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractDispatcher> {
    type SubPointersType = IContractDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractDispatcher>) -> IContractDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl IContractDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractDispatcher> {
    type SubPointersType = IContractDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractDispatcher>>) -> IContractDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl IContractLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractLibraryDispatcher> {
    type SubPointersType = IContractLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractLibraryDispatcher>) -> IContractLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl IContractLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractLibraryDispatcher> {
    type SubPointersType = IContractLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractLibraryDispatcher>>) -> IContractLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl IContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeLibraryDispatcher> {
    type SubPointersType = IContractSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeLibraryDispatcher>) -> IContractSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl IContractSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractSafeLibraryDispatcher> {
    type SubPointersType = IContractSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeLibraryDispatcher>>) -> IContractSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl IContractSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeDispatcher> {
    type SubPointersType = IContractSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeDispatcher>) -> IContractSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl IContractSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractSafeDispatcher> {
    type SubPointersType = IContractSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeDispatcher>>) -> IContractSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherSubPointersDrop of core::traits::Drop::<IContractDispatcherSubPointers>;
impl IContractDispatcherSubPointersCopy of core::traits::Copy::<IContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherSubPointersMutDrop of core::traits::Drop::<IContractDispatcherSubPointersMut>;
impl IContractDispatcherSubPointersMutCopy of core::traits::Copy::<IContractDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointers>;
impl IContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointersMut>;
impl IContractLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointers>;
impl IContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointersMut>;
impl IContractSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeDispatcherSubPointers>;
impl IContractSafeDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IContractSafeDispatcherSubPointersMut>;
impl IContractSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IContractSafeDispatcherSubPointersMut>;

//! > ==========================================================================

//! > Test `starknet::interface` trait with bad self param in methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait IContract<T> {
    fn foo(ref self: u32, other: felt252) -> felt252;
    fn bar(self: @u32, other: felt252) -> felt252;
}

//! > expected_diagnostics
error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:3:12
    fn foo(ref self: u32, other: felt252) -> felt252;
           ^^^^^^^^^^^^^

error: Plugin diagnostic: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> lib.cairo:4:12
    fn bar(self: @u32, other: felt252) -> felt252;
           ^^^^^^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait IContract<T> {
    fn foo(ref self: u32, other: felt252) -> felt252;
    fn bar(self: @u32, other: felt252) -> felt252;
}

lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
IContractDispatcherTrait:

trait IContractDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractDispatcherImpl of IContractDispatcherTrait<IContractDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractLibraryDispatcherImpl of IContractDispatcherTrait<IContractLibraryDispatcher> {

}

trait IContractSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IContractSafeLibraryDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IContractSafeDispatcherImpl of IContractSafeDispatcherTrait<IContractSafeDispatcher> {

}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherCopy of core::traits::Copy::<IContractDispatcher>;
impl IContractDispatcherDrop of core::traits::Drop::<IContractDispatcher>;
impl IContractDispatcherSerde of core::serde::Serde::<IContractDispatcher> {
    fn serialize(self: @IContractDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractDispatcher> {
        core::option::Option::Some(IContractDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractDispatcher of starknet::Store::<IContractDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl IContractDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractDispatcher> {
    type SubPointersType = IContractDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractDispatcher>) -> IContractDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl IContractDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractDispatcher> {
    type SubPointersType = IContractDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractDispatcher>>) -> IContractDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherCopy of core::traits::Copy::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherDrop of core::traits::Drop::<IContractLibraryDispatcher>;
impl IContractLibraryDispatcherSerde of core::serde::Serde::<IContractLibraryDispatcher> {
    fn serialize(self: @IContractLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractLibraryDispatcher> {
        core::option::Option::Some(IContractLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractLibraryDispatcher of starknet::Store::<IContractLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl IContractLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractLibraryDispatcher> {
    type SubPointersType = IContractLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractLibraryDispatcher>) -> IContractLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl IContractLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractLibraryDispatcher> {
    type SubPointersType = IContractLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractLibraryDispatcher>>) -> IContractLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherCopy of core::traits::Copy::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherDrop of core::traits::Drop::<IContractSafeLibraryDispatcher>;
impl IContractSafeLibraryDispatcherSerde of core::serde::Serde::<IContractSafeLibraryDispatcher> {
    fn serialize(self: @IContractSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeLibraryDispatcher> {
        core::option::Option::Some(IContractSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractSafeLibraryDispatcher of starknet::Store::<IContractSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl IContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeLibraryDispatcher> {
    type SubPointersType = IContractSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeLibraryDispatcher>) -> IContractSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl IContractSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractSafeLibraryDispatcher> {
    type SubPointersType = IContractSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeLibraryDispatcher>>) -> IContractSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherCopy of core::traits::Copy::<IContractSafeDispatcher>;
impl IContractSafeDispatcherDrop of core::traits::Drop::<IContractSafeDispatcher>;
impl IContractSafeDispatcherSerde of core::serde::Serde::<IContractSafeDispatcher> {
    fn serialize(self: @IContractSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IContractSafeDispatcher> {
        core::option::Option::Some(IContractSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreIContractSafeDispatcher of starknet::Store::<IContractSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let IContractSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IContractSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            IContractSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IContractSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let IContractSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl IContractSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IContractSafeDispatcher> {
    type SubPointersType = IContractSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IContractSafeDispatcher>) -> IContractSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct IContractSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl IContractSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IContractSafeDispatcher> {
    type SubPointersType = IContractSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IContractSafeDispatcher>>) -> IContractSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IContractSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherSubPointersDrop of core::traits::Drop::<IContractDispatcherSubPointers>;
impl IContractDispatcherSubPointersCopy of core::traits::Copy::<IContractDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractDispatcherSubPointersMutDrop of core::traits::Drop::<IContractDispatcherSubPointersMut>;
impl IContractDispatcherSubPointersMutCopy of core::traits::Copy::<IContractDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointers>;
impl IContractLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IContractLibraryDispatcherSubPointersMut>;
impl IContractLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IContractLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointers>;
impl IContractSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IContractSafeLibraryDispatcherSubPointersMut>;
impl IContractSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IContractSafeLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherSubPointersDrop of core::traits::Drop::<IContractSafeDispatcherSubPointers>;
impl IContractSafeDispatcherSubPointersCopy of core::traits::Copy::<IContractSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl IContractSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IContractSafeDispatcherSubPointersMut>;
impl IContractSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IContractSafeDispatcherSubPointersMut>;

//! > ==========================================================================

//! > Test `starknet::embeddable` impl with (disallowed) attributes for its methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::embeddable]
impl EmbeddableImpl<TContractState> of Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {}
    #[l1_handler]
    fn foo2(self: @TContractState) {}
    #[constructor]
    fn foo3(self: @TContractState) {}
}

//! > expected_diagnostics
error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:9:5
    #[external(v0)]
    ^^^^^^^^^^^^^^^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:11:5
    #[l1_handler]
    ^^^^^^^^^^^^^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:13:5
    #[constructor]
    ^^^^^^^^^^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::embeddable]
impl EmbeddableImpl<TContractState> of Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {}
    #[l1_handler]
    fn foo2(self: @TContractState) {}
    #[constructor]
    fn foo3(self: @TContractState) {}
}

lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
InterfaceDispatcherTrait:

trait InterfaceDispatcherTrait<T> {
    fn foo1(self: T);
    fn foo2(self: T);
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceDispatcherImpl of InterfaceDispatcherTrait<InterfaceDispatcher> {
    fn foo1(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceLibraryDispatcherImpl of InterfaceDispatcherTrait<InterfaceLibraryDispatcher> {
    fn foo1(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait InterfaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo2(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceSafeLibraryDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeLibraryDispatcher> {
    fn foo1(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceSafeDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeDispatcher> {
    fn foo1(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:7:1-15:1
  #[starknet::embeddable]
 _^
| ...
| }
|_^
embeddable:

trait UnsafeNewContractStateTraitForEmbeddableImpl<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo1<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo2<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__EmbeddableImpl__foo3<TContractState, impl UnsafeNewContractState: UnsafeNewContractStateTraitForEmbeddableImpl<TContractState>, impl TContractStateDrop: Drop<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    EmbeddableImpl::<TContractState>::foo3(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



mod __external_EmbeddableImpl {
    pub use super::__wrapper__EmbeddableImpl__foo1 as foo1;
    pub use super::__wrapper__EmbeddableImpl__foo2 as foo2;
    pub use super::__wrapper__EmbeddableImpl__foo3 as foo3;
}

mod __l1_handler_EmbeddableImpl {
}

mod __constructor_EmbeddableImpl {
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceDispatcherCopy of core::traits::Copy::<InterfaceDispatcher>;
impl InterfaceDispatcherDrop of core::traits::Drop::<InterfaceDispatcher>;
impl InterfaceDispatcherSerde of core::serde::Serde::<InterfaceDispatcher> {
    fn serialize(self: @InterfaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceDispatcher> {
        core::option::Option::Some(InterfaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceDispatcher of starknet::Store::<InterfaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl InterfaceDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceDispatcher> {
    type SubPointersType = InterfaceDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceDispatcher>) -> InterfaceDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl InterfaceDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceDispatcher> {
    type SubPointersType = InterfaceDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceDispatcher>>) -> InterfaceDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceLibraryDispatcherCopy of core::traits::Copy::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherDrop of core::traits::Drop::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherSerde of core::serde::Serde::<InterfaceLibraryDispatcher> {
    fn serialize(self: @InterfaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceLibraryDispatcher> {
        core::option::Option::Some(InterfaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceLibraryDispatcher of starknet::Store::<InterfaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl InterfaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceLibraryDispatcher> {
    type SubPointersType = InterfaceLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceLibraryDispatcher>) -> InterfaceLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl InterfaceLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceLibraryDispatcher> {
    type SubPointersType = InterfaceLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceLibraryDispatcher>>) -> InterfaceLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeLibraryDispatcherCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherSerde of core::serde::Serde::<InterfaceSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeLibraryDispatcher> {
        core::option::Option::Some(InterfaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceSafeLibraryDispatcher of starknet::Store::<InterfaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl InterfaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceSafeLibraryDispatcher> {
    type SubPointersType = InterfaceSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceSafeLibraryDispatcher>) -> InterfaceSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl InterfaceSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceSafeLibraryDispatcher> {
    type SubPointersType = InterfaceSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceSafeLibraryDispatcher>>) -> InterfaceSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeDispatcherCopy of core::traits::Copy::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherDrop of core::traits::Drop::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherSerde of core::serde::Serde::<InterfaceSafeDispatcher> {
    fn serialize(self: @InterfaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeDispatcher> {
        core::option::Option::Some(InterfaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceSafeDispatcher of starknet::Store::<InterfaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl InterfaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceSafeDispatcher> {
    type SubPointersType = InterfaceSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceSafeDispatcher>) -> InterfaceSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl InterfaceSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceSafeDispatcher> {
    type SubPointersType = InterfaceSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceSafeDispatcher>>) -> InterfaceSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceDispatcherSubPointersDrop of core::traits::Drop::<InterfaceDispatcherSubPointers>;
impl InterfaceDispatcherSubPointersCopy of core::traits::Copy::<InterfaceDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceDispatcherSubPointersMut>;
impl InterfaceDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceLibraryDispatcherSubPointers>;
impl InterfaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceLibraryDispatcherSubPointersMut>;
impl InterfaceLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcherSubPointers>;
impl InterfaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcherSubPointersMut>;
impl InterfaceSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeDispatcherSubPointersDrop of core::traits::Drop::<InterfaceSafeDispatcherSubPointers>;
impl InterfaceSafeDispatcherSubPointersCopy of core::traits::Copy::<InterfaceSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceSafeDispatcherSubPointersMut>;
impl InterfaceSafeDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceSafeDispatcherSubPointersMut>;

//! > ==========================================================================

//! > Test `embeddable_as` impl with (disallowed) attributes for its methods.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::component]
mod component {
    #[storage]
    struct Storage {}

    #[embeddable_as(MyEmbeddableImpl)]
    impl MyImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of super::Interface<ComponentState<TContractState>> {
        #[external(v0)]
        fn foo1(self: @ComponentState<TContractState>) {}
        #[l1_handler]
        fn foo2(self: @ComponentState<TContractState>) {}
        #[constructor]
        fn foo3(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::contract]
mod contract {
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_storage: super::component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::component::Event,
    }

    component!(path: super::component, storage: component_storage, event: CompEvent);

    #[abi(embed_v0)]
    impl MyEmbeddedImpl = super::component::MyEmbeddableImpl<ContractState>;
}

//! > expected_diagnostics
error: Plugin diagnostic: The `external` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:16:9
        #[external(v0)]
        ^^^^^^^^^^^^^^^

error: Plugin diagnostic: The `l1_handler` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:18:9
        #[l1_handler]
        ^^^^^^^^^^^^^

error: Plugin diagnostic: The `constructor` attribute is not allowed inside an impl marked as `#[embeddable]`.
 --> lib.cairo:20:9
        #[constructor]
        ^^^^^^^^^^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait Interface<TContractState> {
    fn foo1(self: @TContractState);
    fn foo2(self: @TContractState);
    fn foo3(self: @TContractState);
}
#[starknet::component]
mod component {
    #[storage]
    struct Storage {}

    #[embeddable_as(MyEmbeddableImpl)]
    impl MyImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of super::Interface<ComponentState<TContractState>> {
        #[external(v0)]
        fn foo1(self: @ComponentState<TContractState>) {}
        #[l1_handler]
        fn foo2(self: @ComponentState<TContractState>) {}
        #[constructor]
        fn foo3(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::contract]
mod contract {
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_storage: super::component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::component::Event,
    }

    component!(path: super::component, storage: component_storage, event: CompEvent);

    #[abi(embed_v0)]
    impl MyEmbeddedImpl = super::component::MyEmbeddableImpl<ContractState>;
}

lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
InterfaceDispatcherTrait:

trait InterfaceDispatcherTrait<T> {
    fn foo1(self: T);
    fn foo2(self: T);
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceDispatcherImpl of InterfaceDispatcherTrait<InterfaceDispatcher> {
    fn foo1(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceLibraryDispatcherImpl of InterfaceDispatcherTrait<InterfaceLibraryDispatcher> {
    fn foo1(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo2(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo3(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait InterfaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo1(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo2(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceSafeLibraryDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeLibraryDispatcher> {
    fn foo1(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceSafeDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeDispatcher> {
    fn foo1(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo1"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo2(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo2"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo3(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceDispatcherCopy of core::traits::Copy::<InterfaceDispatcher>;
impl InterfaceDispatcherDrop of core::traits::Drop::<InterfaceDispatcher>;
impl InterfaceDispatcherSerde of core::serde::Serde::<InterfaceDispatcher> {
    fn serialize(self: @InterfaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceDispatcher> {
        core::option::Option::Some(InterfaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceDispatcher of starknet::Store::<InterfaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl InterfaceDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceDispatcher> {
    type SubPointersType = InterfaceDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceDispatcher>) -> InterfaceDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl InterfaceDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceDispatcher> {
    type SubPointersType = InterfaceDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceDispatcher>>) -> InterfaceDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceLibraryDispatcherCopy of core::traits::Copy::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherDrop of core::traits::Drop::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherSerde of core::serde::Serde::<InterfaceLibraryDispatcher> {
    fn serialize(self: @InterfaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceLibraryDispatcher> {
        core::option::Option::Some(InterfaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceLibraryDispatcher of starknet::Store::<InterfaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl InterfaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceLibraryDispatcher> {
    type SubPointersType = InterfaceLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceLibraryDispatcher>) -> InterfaceLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl InterfaceLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceLibraryDispatcher> {
    type SubPointersType = InterfaceLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceLibraryDispatcher>>) -> InterfaceLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeLibraryDispatcherCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherSerde of core::serde::Serde::<InterfaceSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeLibraryDispatcher> {
        core::option::Option::Some(InterfaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceSafeLibraryDispatcher of starknet::Store::<InterfaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl InterfaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceSafeLibraryDispatcher> {
    type SubPointersType = InterfaceSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceSafeLibraryDispatcher>) -> InterfaceSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl InterfaceSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceSafeLibraryDispatcher> {
    type SubPointersType = InterfaceSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceSafeLibraryDispatcher>>) -> InterfaceSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeDispatcherCopy of core::traits::Copy::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherDrop of core::traits::Drop::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherSerde of core::serde::Serde::<InterfaceSafeDispatcher> {
    fn serialize(self: @InterfaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeDispatcher> {
        core::option::Option::Some(InterfaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceSafeDispatcher of starknet::Store::<InterfaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl InterfaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceSafeDispatcher> {
    type SubPointersType = InterfaceSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceSafeDispatcher>) -> InterfaceSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl InterfaceSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceSafeDispatcher> {
    type SubPointersType = InterfaceSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceSafeDispatcher>>) -> InterfaceSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceDispatcherSubPointersDrop of core::traits::Drop::<InterfaceDispatcherSubPointers>;
impl InterfaceDispatcherSubPointersCopy of core::traits::Copy::<InterfaceDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceDispatcherSubPointersMut>;
impl InterfaceDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceLibraryDispatcherSubPointers>;
impl InterfaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceLibraryDispatcherSubPointersMut>;
impl InterfaceLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcherSubPointers>;
impl InterfaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcherSubPointersMut>;
impl InterfaceSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeDispatcherSubPointersDrop of core::traits::Drop::<InterfaceSafeDispatcherSubPointers>;
impl InterfaceSafeDispatcherSubPointersCopy of core::traits::Copy::<InterfaceSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceSafeDispatcherSubPointersMut>;
impl InterfaceSafeDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceSafeDispatcherSubPointersMut>;


lib.cairo:7:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::Deref<@ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
pub impl MyEmbeddableImpl<
            TContractState, impl X: HasComponent<TContractState>,
impl TContractStateDrop: Drop<TContractState>
> of super::Interface<TContractState> {
    #[external(v0)]
    fn foo1(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo1(component)
    }
    #[l1_handler]
    fn foo2(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo2(component)
    }
    #[constructor]
    fn foo3(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::foo3(component)
    }
}

lib.cairo:7:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:7:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:9:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:9:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;


lib.cairo:12:5
    #[embeddable_as(MyEmbeddableImpl)]
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
embeddable:

pub trait UnsafeNewContractStateTraitForMyEmbeddableImpl<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo1<TContractState, impl X: HasComponent<TContractState>,
impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo1(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo2<TContractState, impl X: HasComponent<TContractState>,
impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo2(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__foo3<TContractState, impl X: HasComponent<TContractState>,
impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::foo3(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



pub mod __external_MyEmbeddableImpl {
    pub use super::__wrapper__MyEmbeddableImpl__foo1 as foo1;
    pub use super::__wrapper__MyEmbeddableImpl__foo2 as foo2;
    pub use super::__wrapper__MyEmbeddableImpl__foo3 as foo3;
}

pub mod __l1_handler_MyEmbeddableImpl {
}

pub mod __constructor_MyEmbeddableImpl {
}


lib.cairo:25:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:



#[phantom]
pub struct Storage {
        #[substorage(v0)]
        pub component_storage: super::component::Storage,
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
        #[substorage(v0)]
    pub component_storage: starknet::storage::FlattenedStorage<super::component::Storage>,
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let __component_storage_value__ = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           component_storage: __component_storage_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
        #[substorage(v0)]
    pub component_storage: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<super::component::Storage>>,
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let __component_storage_value__ = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           component_storage: __component_storage_value__,
        }
    }
}

pub struct ContractState {
        #[substorage(v0)]
        pub component_storage: super::component::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
            component_storage: super::component::unsafe_new_component_state::<ContractState>(),
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x291a893aaae68e6364fac8003da0089f1c976946ebe457ce78ed62b5e680be2.try_into().unwrap();

impl ContractStateMyEmbeddableImpl of
    super::component::UnsafeNewContractStateTraitForMyEmbeddableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}

pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_component of super::component::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @super::component::ComponentState<ContractState> {
                 @super::component::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> super::component::ComponentState<ContractState> {
        super::component::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @super::component::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: super::component::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, super::component::Event>>(ref self: super::component::ComponentState<ContractState>, event: S) {
        let event: super::component::Event = core::traits::Into::into(event);
        let mut contract = super::component::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::CompEvent(event));
    }
}


lib.cairo:34:14
    #[derive(Drop, starknet::Event)]
             ^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:34:20
    #[derive(Drop, starknet::Event)]
                   ^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::CompEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("CompEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("CompEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::CompEvent(val));
        }
        Option::None
    }
}
impl EventCompEventIntoEvent of Into<super::component::Event, Event> {
    fn into(self: super::component::Event) -> Event {
        Event::CompEvent(self)
    }
}



lib.cairo:27:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:27:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > ==========================================================================

//! > Test `#[abi(..)]` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[generate_trait]
impl SomeImpl<T> of SomeTrait<T> {
    fn foo(self: @T) {}
}
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[abi(v0)]
    impl Alias = super::SomeImpl<ContractState>;

    #[abi(embed)]
    impl InlineImpl of super::SomeTrait<ContractState> {
        fn foo(self: @ContractState) {}
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The 'abi' attribute for impl aliases only supports the 'embed_v0' argument.
 --> lib.cairo:10:5-11:48
      #[abi(v0)]
 _____^
|     impl Alias = super::SomeImpl<ContractState>;
|________________________________________________^

error: Plugin diagnostic: The 'abi' attribute for impls only supports the 'per_item' or 'embed_v0' argument.
 --> lib.cairo:13:5
    #[abi(embed)]
    ^^^^^^^^^^^^^

//! > generated_cairo_code
lib.cairo:

#[generate_trait]
impl SomeImpl<T> of SomeTrait<T> {
    fn foo(self: @T) {}
}
#[starknet::contract]
mod test_contract {
    #[storage]
    struct Storage {}

    #[abi(v0)]
    impl Alias = super::SomeImpl<ContractState>;

    #[abi(embed)]
    impl InlineImpl of super::SomeTrait<ContractState> {
        fn foo(self: @ContractState) {}
    }
}

lib.cairo:1:1-4:1
  #[generate_trait]
 _^
| ...
| }
|_^
generate_trait:

trait SomeTrait<T> {
    fn foo(self: @T);
}


lib.cairo:5:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x7bfb361123ab6c75c9b1db29acd3b69ea425da0db94322a959835a160c41da.try_into().unwrap();


pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:5:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:5:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:7:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:7:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > ==========================================================================

//! > Test `get_dep_component!` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

trait NotHasComponentTrait {}
impl NotHasComponent of NotHasComponentTrait {}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
    fn foo4(self: @TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>,
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(@self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component!(self, Comp1).foo1();
            get_dep_component!(Comp1, @self).foo1();
            get_dep_component!(@self, @self).foo1();
            get_dep_component!(Comp1, Comp1).foo1();
            get_dep_component!(@self, Comp2).foo1();
            get_dep_component!(@self, super::NotHasComponent).foo1();
            let not_contract_state: felt252 = 0;
            get_dep_component!(not_contract_state, Comp1).foo1();
            get_dep_component!(@self, NonExistingImpl).foo1();
        }
        fn foo4(self: @ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(self, Comp1).foo1();
        }
    }
}

//! > expected_diagnostics
error: Unexpected argument type. Expected: "@test::component3::ComponentState::<?2>", found: "test::component3::ComponentState::<TContractState>".
It is possible that the type inference failed because the types differ in the number of snapshots.
Consider adding or removing snapshots.
 --> lib.cairo:55:32
            get_dep_component!(self, Comp1).foo1();
                               ^^^^

error: Expected variable or constant, found impl.
 --> lib.cairo:56:32
            get_dep_component!(Comp1, @self).foo1();
                               ^^^^^

error[E0006]: Identifier not found.
 --> lib.cairo:56:40
            get_dep_component!(Comp1, @self).foo1();
                                       ^^^^

error[E0006]: Identifier not found.
 --> lib.cairo:57:40
            get_dep_component!(@self, @self).foo1();
                                       ^^^^

error: Expected variable or constant, found impl.
 --> lib.cairo:58:32
            get_dep_component!(Comp1, Comp1).foo1();
                               ^^^^^

error[E0002]: Method `foo1` not found on type `@test::component2::ComponentState::<TContractState>`. Did you import the correct trait and impl?
 --> lib.cairo:59:46
            get_dep_component!(@self, Comp2).foo1();
                                             ^^^^

error: Invalid path.
 --> lib.cairo:60:13
            get_dep_component!(@self, super::NotHasComponent).foo1();
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Unexpected argument type. Expected: "@test::component3::ComponentState::<?14>", found: "core::felt252".
It is possible that the type inference failed because the types differ in the number of snapshots.
Consider adding or removing snapshots.
 --> lib.cairo:62:32
            get_dep_component!(not_contract_state, Comp1).foo1();
                               ^^^^^^^^^^^^^^^^^^

error[E0006]: Identifier not found.
 --> lib.cairo:63:39
            get_dep_component!(@self, NonExistingImpl).foo1();
                                      ^^^^^^^^^^^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

trait NotHasComponentTrait {}
impl NotHasComponent of NotHasComponentTrait {}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
    fn foo4(self: @TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>,
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(@self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component!(self, Comp1).foo1();
            get_dep_component!(Comp1, @self).foo1();
            get_dep_component!(@self, @self).foo1();
            get_dep_component!(Comp1, Comp1).foo1();
            get_dep_component!(@self, Comp2).foo1();
            get_dep_component!(@self, super::NotHasComponent).foo1();
            let not_contract_state: felt252 = 0;
            get_dep_component!(not_contract_state, Comp1).foo1();
            get_dep_component!(@self, NonExistingImpl).foo1();
        }
        fn foo4(self: @ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component!(self, Comp1).foo1();
        }
    }
}

lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
Comp3TraitDispatcherTrait:

trait Comp3TraitDispatcherTrait<T> {
    fn foo3(self: T);
    fn foo4(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitDispatcher> {
    fn foo3(self: Comp3TraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo4(self: Comp3TraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitLibraryDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitLibraryDispatcher> {
    fn foo3(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }
    fn foo4(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Comp3TraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
    #[unstable(feature: "safe_dispatcher")]
    fn foo4(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitSafeLibraryDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeLibraryDispatcher> {
    fn foo3(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo4(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitSafeDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeDispatcher> {
    fn foo3(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }
    fn foo4(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo4"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitDispatcherCopy of core::traits::Copy::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherDrop of core::traits::Drop::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherSerde of core::serde::Serde::<Comp3TraitDispatcher> {
    fn serialize(self: @Comp3TraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitDispatcher> {
        core::option::Option::Some(Comp3TraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreComp3TraitDispatcher of starknet::Store::<Comp3TraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let Comp3TraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let Comp3TraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl Comp3TraitDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitDispatcher> {
    type SubPointersType = Comp3TraitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitDispatcher>) -> Comp3TraitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl Comp3TraitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Comp3TraitDispatcher> {
    type SubPointersType = Comp3TraitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitDispatcher>>) -> Comp3TraitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitLibraryDispatcher> {
    fn serialize(self: @Comp3TraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreComp3TraitLibraryDispatcher of starknet::Store::<Comp3TraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let Comp3TraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let Comp3TraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl Comp3TraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitLibraryDispatcher> {
    type SubPointersType = Comp3TraitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitLibraryDispatcher>) -> Comp3TraitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl Comp3TraitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Comp3TraitLibraryDispatcher> {
    type SubPointersType = Comp3TraitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitLibraryDispatcher>>) -> Comp3TraitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitSafeLibraryDispatcher> {
    fn serialize(self: @Comp3TraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreComp3TraitSafeLibraryDispatcher of starknet::Store::<Comp3TraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let Comp3TraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let Comp3TraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl Comp3TraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitSafeLibraryDispatcher> {
    type SubPointersType = Comp3TraitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitSafeLibraryDispatcher>) -> Comp3TraitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl Comp3TraitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Comp3TraitSafeLibraryDispatcher> {
    type SubPointersType = Comp3TraitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitSafeLibraryDispatcher>>) -> Comp3TraitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeDispatcherCopy of core::traits::Copy::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherDrop of core::traits::Drop::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherSerde of core::serde::Serde::<Comp3TraitSafeDispatcher> {
    fn serialize(self: @Comp3TraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeDispatcher> {
        core::option::Option::Some(Comp3TraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreComp3TraitSafeDispatcher of starknet::Store::<Comp3TraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let Comp3TraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let Comp3TraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl Comp3TraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitSafeDispatcher> {
    type SubPointersType = Comp3TraitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitSafeDispatcher>) -> Comp3TraitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl Comp3TraitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Comp3TraitSafeDispatcher> {
    type SubPointersType = Comp3TraitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitSafeDispatcher>>) -> Comp3TraitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitDispatcherSubPointers>;
impl Comp3TraitDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitDispatcherSubPointersMutDrop of core::traits::Drop::<Comp3TraitDispatcherSubPointersMut>;
impl Comp3TraitDispatcherSubPointersMutCopy of core::traits::Copy::<Comp3TraitDispatcherSubPointersMut>;


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitLibraryDispatcherSubPointers>;
impl Comp3TraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitLibraryDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Comp3TraitLibraryDispatcherSubPointersMut>;
impl Comp3TraitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Comp3TraitLibraryDispatcherSubPointersMut>;


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcherSubPointers>;
impl Comp3TraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcherSubPointersMut>;
impl Comp3TraitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcherSubPointersMut>;


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitSafeDispatcherSubPointers>;
impl Comp3TraitSafeDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitSafeDispatcherSubPointers>;


lib.cairo:30:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Comp3TraitSafeDispatcherSubPointersMut>;
impl Comp3TraitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Comp3TraitSafeDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::Deref<@ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



lib.cairo:6:5-11:5
      #[generate_trait]
 _____^
| ...
|     }
|_____^
generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>,
    > {
        fn foo1(self: @ComponentState<TContractState>);
    }


lib.cairo:1:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;


lib.cairo:14:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::Deref<@ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



lib.cairo:19:5-24:5
      #[generate_trait]
 _____^
| ...
|     }
|_____^
generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>,
    > {
        fn foo2(self: @ComponentState<TContractState>);
    }


lib.cairo:14:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:14:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:16:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:16:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;


lib.cairo:36:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::Deref<@ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
pub impl Comp3<
            TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>,

> of super::Comp3Trait<TContractState> {
    
    fn foo3(ref self: TContractState) {
        let mut component = HasComponent::get_component_mut(ref self);
        Comp3Impl::foo3(ref component)
    }
    
    fn foo4(self: @TContractState) {
        let component = HasComponent::get_component(self);
        Comp3Impl::foo4(component)
    }
}

lib.cairo:36:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:36:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:39:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:39:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;


lib.cairo:42:5
    #[embeddable_as(Comp3)]
    ^^^^^^^^^^^^^^^^^^^^^^^
embeddable:

pub trait UnsafeNewContractStateTraitForComp3<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__Comp3__foo3<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>,impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo3(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__Comp3__foo4<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>,impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo4(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



pub mod __external_Comp3 {
    pub use super::__wrapper__Comp3__foo3 as foo3;
    pub use super::__wrapper__Comp3__foo4 as foo4;
}

pub mod __l1_handler_Comp3 {
}

pub mod __constructor_Comp3 {
}

//! > ==========================================================================

//! > Test `get_dep_component_mut!` bad arguments.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>,
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component_mut!(ref self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component_mut!(Comp1, self).foo1();
            get_dep_component_mut!(ref self, self).foo1();
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
            get_dep_component_mut!(ref self, Comp2).foo1();
            get_dep_component_mut!(self, Comp1).foo1();
            get_dep_component_mut!(mut self, Comp1).foo1();
            get_dep_component_mut!(ref ref self, Comp1).foo1();
            get_dep_component_mut!(ref mut self, Comp1).foo1();
        }
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:51:36
            get_dep_component_mut!(Comp1, self).foo1();
                                   ^^^^^

error[E0006]: Identifier not found.
 --> lib.cairo:52:46
            get_dep_component_mut!(ref self, self).foo1();
                                             ^^^^

error: Expected variable or constant, found impl.
 --> lib.cairo:53:40
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
                                       ^^^^^

error: ref argument must be a variable.
 --> lib.cairo:53:40
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
                                       ^^^^^

error[E0002]: Method `foo1` could not be called on type `test::component2::ComponentState::<TContractState>`.
Candidate `test::component1::Comp1HelperTrait::foo1` inference failed with: Type mismatch: `test::component2::ComponentState::<TContractState>` and `@test::component1::ComponentState::<?8>`.
 --> lib.cairo:54:53
            get_dep_component_mut!(ref self, Comp2).foo1();
                                                    ^^^^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:55:36
            get_dep_component_mut!(self, Comp1).foo1();
                                   ^^^^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:56:40
            get_dep_component_mut!(mut self, Comp1).foo1();
                                       ^^^^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:57:44
            get_dep_component_mut!(ref ref self, Comp1).foo1();
                                           ^^^^

error: Plugin diagnostic: The first argument of `get_dep_component_mut` macro must have only a `ref` modifier.
 --> lib.cairo:58:44
            get_dep_component_mut!(ref mut self, Comp1).foo1();
                                           ^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::component]
mod component1 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of Comp1HelperTrait<TContractState, X> {
        fn foo1(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::component]
mod component2 {
    #[storage]
    struct Storage {}

    #[generate_trait]
    impl Comp1HelperImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of Comp1HelperTrait<TContractState, X> {
        fn foo2(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::interface]
trait Comp3Trait<TContractState> {
    fn foo3(ref self: TContractState);
}

#[starknet::component]
mod component3 {
    use super::component1::Comp1HelperImpl;
    #[storage]
    struct Storage {}

    #[embeddable_as(Comp3)]
    impl Comp3Impl<
        TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>,
    > of super::Comp3Trait<ComponentState<TContractState>> {
        fn foo3(ref self: ComponentState<TContractState>) {
            // No diagnostics
            get_dep_component_mut!(ref self, Comp1).foo1();

            // Should raise diagnostics
            get_dep_component_mut!(Comp1, self).foo1();
            get_dep_component_mut!(ref self, self).foo1();
            get_dep_component_mut!(ref Comp1, Comp1).foo1();
            get_dep_component_mut!(ref self, Comp2).foo1();
            get_dep_component_mut!(self, Comp1).foo1();
            get_dep_component_mut!(mut self, Comp1).foo1();
            get_dep_component_mut!(ref ref self, Comp1).foo1();
            get_dep_component_mut!(ref mut self, Comp1).foo1();
        }
    }
}

lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
Comp3TraitDispatcherTrait:

trait Comp3TraitDispatcherTrait<T> {
    fn foo3(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitDispatcher> {
    fn foo3(self: Comp3TraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitLibraryDispatcherImpl of Comp3TraitDispatcherTrait<Comp3TraitLibraryDispatcher> {
    fn foo3(self: Comp3TraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Comp3TraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo3(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Comp3TraitSafeLibraryDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeLibraryDispatcher> {
    fn foo3(self: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Comp3TraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Comp3TraitSafeDispatcherImpl of Comp3TraitSafeDispatcherTrait<Comp3TraitSafeDispatcher> {
    fn foo3(self: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo3"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitDispatcherCopy of core::traits::Copy::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherDrop of core::traits::Drop::<Comp3TraitDispatcher>;
impl Comp3TraitDispatcherSerde of core::serde::Serde::<Comp3TraitDispatcher> {
    fn serialize(self: @Comp3TraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitDispatcher> {
        core::option::Option::Some(Comp3TraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreComp3TraitDispatcher of starknet::Store::<Comp3TraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let Comp3TraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let Comp3TraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl Comp3TraitDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitDispatcher> {
    type SubPointersType = Comp3TraitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitDispatcher>) -> Comp3TraitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl Comp3TraitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Comp3TraitDispatcher> {
    type SubPointersType = Comp3TraitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitDispatcher>>) -> Comp3TraitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitLibraryDispatcher>;
impl Comp3TraitLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitLibraryDispatcher> {
    fn serialize(self: @Comp3TraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreComp3TraitLibraryDispatcher of starknet::Store::<Comp3TraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let Comp3TraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let Comp3TraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl Comp3TraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitLibraryDispatcher> {
    type SubPointersType = Comp3TraitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitLibraryDispatcher>) -> Comp3TraitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl Comp3TraitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Comp3TraitLibraryDispatcher> {
    type SubPointersType = Comp3TraitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitLibraryDispatcher>>) -> Comp3TraitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeLibraryDispatcherCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcher>;
impl Comp3TraitSafeLibraryDispatcherSerde of core::serde::Serde::<Comp3TraitSafeLibraryDispatcher> {
    fn serialize(self: @Comp3TraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeLibraryDispatcher> {
        core::option::Option::Some(Comp3TraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreComp3TraitSafeLibraryDispatcher of starknet::Store::<Comp3TraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let Comp3TraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let Comp3TraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl Comp3TraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitSafeLibraryDispatcher> {
    type SubPointersType = Comp3TraitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitSafeLibraryDispatcher>) -> Comp3TraitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl Comp3TraitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Comp3TraitSafeLibraryDispatcher> {
    type SubPointersType = Comp3TraitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitSafeLibraryDispatcher>>) -> Comp3TraitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeDispatcherCopy of core::traits::Copy::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherDrop of core::traits::Drop::<Comp3TraitSafeDispatcher>;
impl Comp3TraitSafeDispatcherSerde of core::serde::Serde::<Comp3TraitSafeDispatcher> {
    fn serialize(self: @Comp3TraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Comp3TraitSafeDispatcher> {
        core::option::Option::Some(Comp3TraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreComp3TraitSafeDispatcher of starknet::Store::<Comp3TraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let Comp3TraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Comp3TraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            Comp3TraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Comp3TraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let Comp3TraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl Comp3TraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Comp3TraitSafeDispatcher> {
    type SubPointersType = Comp3TraitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Comp3TraitSafeDispatcher>) -> Comp3TraitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct Comp3TraitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl Comp3TraitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Comp3TraitSafeDispatcher> {
    type SubPointersType = Comp3TraitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Comp3TraitSafeDispatcher>>) -> Comp3TraitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Comp3TraitSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitDispatcherSubPointers>;
impl Comp3TraitDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitDispatcherSubPointersMutDrop of core::traits::Drop::<Comp3TraitDispatcherSubPointersMut>;
impl Comp3TraitDispatcherSubPointersMutCopy of core::traits::Copy::<Comp3TraitDispatcherSubPointersMut>;


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitLibraryDispatcherSubPointers>;
impl Comp3TraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitLibraryDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Comp3TraitLibraryDispatcherSubPointersMut>;
impl Comp3TraitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Comp3TraitLibraryDispatcherSubPointersMut>;


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcherSubPointers>;
impl Comp3TraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Comp3TraitSafeLibraryDispatcherSubPointersMut>;
impl Comp3TraitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Comp3TraitSafeLibraryDispatcherSubPointersMut>;


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeDispatcherSubPointersDrop of core::traits::Drop::<Comp3TraitSafeDispatcherSubPointers>;
impl Comp3TraitSafeDispatcherSubPointersCopy of core::traits::Copy::<Comp3TraitSafeDispatcherSubPointers>;


lib.cairo:27:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl Comp3TraitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Comp3TraitSafeDispatcherSubPointersMut>;
impl Comp3TraitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Comp3TraitSafeDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::Deref<@ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



lib.cairo:6:5-11:5
      #[generate_trait]
 _____^
| ...
|     }
|_____^
generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>,
    > {
        fn foo1(self: @ComponentState<TContractState>);
    }


lib.cairo:1:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;


lib.cairo:14:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::Deref<@ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



lib.cairo:19:5-24:5
      #[generate_trait]
 _____^
| ...
|     }
|_____^
generate_trait:

    trait Comp1HelperTrait<
        TContractState, impl X: HasComponent<TContractState>,
    > {
        fn foo2(self: @ComponentState<TContractState>);
    }


lib.cairo:14:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:14:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:16:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:16:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;


lib.cairo:32:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::Deref<@ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
pub impl Comp3<
            TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>,

> of super::Comp3Trait<TContractState> {
    
    fn foo3(ref self: TContractState) {
        let mut component = HasComponent::get_component_mut(ref self);
        Comp3Impl::foo3(ref component)
    }
}

lib.cairo:32:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:32:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:35:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:35:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;


lib.cairo:38:5
    #[embeddable_as(Comp3)]
    ^^^^^^^^^^^^^^^^^^^^^^^
embeddable:

pub trait UnsafeNewContractStateTraitForComp3<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__Comp3__foo3<TContractState,
        impl Comp1: super::component1::HasComponent<TContractState>,
        impl Comp2: super::component2::HasComponent<TContractState>,
        +HasComponent<TContractState>,
        +Drop<TContractState>,impl UnsafeNewContractState: UnsafeNewContractStateTraitForComp3<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    Comp3::<TContractState, Comp1, Comp2, _, _>::foo3(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



pub mod __external_Comp3 {
    pub use super::__wrapper__Comp3__foo3 as foo3;
}

pub mod __l1_handler_Comp3 {
}

pub mod __constructor_Comp3 {
}

//! > ==========================================================================

//! > Test write on a non ref contract state.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState);
}

#[starknet::contract]
mod contract {
    use super::ContractTrait;
    #[storage]
    struct Storage {
        a_member: felt252,
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) {
            // Should raise diagnostics
            self.a_member.write(0);
        }
    }
}

//! > expected_diagnostics
error[E0002]: Method `write` could not be called on type `core::starknet::storage::storage_base::StorageBase::<core::felt252>`.
Candidate `core::starknet::storage::map::StorageMapWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::map::StorageMapWriteAccess::<core::starknet::storage::storage_base::StorageBase::<core::felt252>>.
Candidate `core::starknet::storage::StoragePointerWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StoragePointerWriteAccess::<core::starknet::storage::storage_base::StorageBase::<core::felt252>>.
Candidate `core::starknet::storage::map::StorageMapWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::map::StorageMapWriteAccess::<core::starknet::storage::StoragePath::<core::felt252>>.
Candidate `core::starknet::storage::StoragePointerWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StoragePointerWriteAccess::<core::starknet::storage::StoragePath::<core::felt252>>.
Candidate `core::starknet::storage::map::StorageMapWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::map::StorageMapWriteAccess::<core::starknet::storage::StoragePointer0Offset::<core::felt252>>.
Candidate `core::starknet::storage::StoragePointerWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StoragePointerWriteAccess::<core::starknet::storage::StoragePointer0Offset::<core::felt252>>.
Candidate `core::starknet::storage::map::StorageMapWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::map::StorageMapWriteAccess::<core::starknet::storage::StoragePointer::<core::felt252>>.
Candidate `core::starknet::storage::StoragePointerWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StoragePointerWriteAccess::<core::starknet::storage::StoragePointer::<core::felt252>>.
 --> lib.cairo:18:27
            self.a_member.write(0);
                          ^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState);
}

#[starknet::contract]
mod contract {
    use super::ContractTrait;
    #[storage]
    struct Storage {
        a_member: felt252,
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) {
            // Should raise diagnostics
            self.a_member.write(0);
        }
    }
}

lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
ContractTraitDispatcherTrait:

trait ContractTraitDispatcherTrait<T> {
    fn foo(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitDispatcher> {
    fn foo(self: ContractTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitLibraryDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitLibraryDispatcher> {
    fn foo(self: ContractTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait ContractTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitSafeLibraryDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeLibraryDispatcher> {
    fn foo(self: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitSafeDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeDispatcher> {
    fn foo(self: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitDispatcherCopy of core::traits::Copy::<ContractTraitDispatcher>;
impl ContractTraitDispatcherDrop of core::traits::Drop::<ContractTraitDispatcher>;
impl ContractTraitDispatcherSerde of core::serde::Serde::<ContractTraitDispatcher> {
    fn serialize(self: @ContractTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitDispatcher> {
        core::option::Option::Some(ContractTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitDispatcher of starknet::Store::<ContractTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl ContractTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitDispatcher> {
    type SubPointersType = ContractTraitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitDispatcher>) -> ContractTraitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl ContractTraitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitDispatcher> {
    type SubPointersType = ContractTraitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitDispatcher>>) -> ContractTraitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitLibraryDispatcherCopy of core::traits::Copy::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherDrop of core::traits::Drop::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherSerde of core::serde::Serde::<ContractTraitLibraryDispatcher> {
    fn serialize(self: @ContractTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitLibraryDispatcher> {
        core::option::Option::Some(ContractTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitLibraryDispatcher of starknet::Store::<ContractTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl ContractTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitLibraryDispatcher> {
    type SubPointersType = ContractTraitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitLibraryDispatcher>) -> ContractTraitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl ContractTraitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitLibraryDispatcher> {
    type SubPointersType = ContractTraitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitLibraryDispatcher>>) -> ContractTraitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeLibraryDispatcherCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherSerde of core::serde::Serde::<ContractTraitSafeLibraryDispatcher> {
    fn serialize(self: @ContractTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeLibraryDispatcher> {
        core::option::Option::Some(ContractTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitSafeLibraryDispatcher of starknet::Store::<ContractTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl ContractTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeLibraryDispatcher> {
    type SubPointersType = ContractTraitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeLibraryDispatcher>) -> ContractTraitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl ContractTraitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitSafeLibraryDispatcher> {
    type SubPointersType = ContractTraitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeLibraryDispatcher>>) -> ContractTraitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeDispatcherCopy of core::traits::Copy::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherDrop of core::traits::Drop::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherSerde of core::serde::Serde::<ContractTraitSafeDispatcher> {
    fn serialize(self: @ContractTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeDispatcher> {
        core::option::Option::Some(ContractTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitSafeDispatcher of starknet::Store::<ContractTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl ContractTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeDispatcher> {
    type SubPointersType = ContractTraitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeDispatcher>) -> ContractTraitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl ContractTraitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitSafeDispatcher> {
    type SubPointersType = ContractTraitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeDispatcher>>) -> ContractTraitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitDispatcherSubPointers>;
impl ContractTraitDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitDispatcherSubPointersMut>;
impl ContractTraitDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitLibraryDispatcherSubPointers>;
impl ContractTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitLibraryDispatcherSubPointersMut>;
impl ContractTraitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcherSubPointers>;
impl ContractTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcherSubPointersMut>;
impl ContractTraitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeDispatcherSubPointers>;
impl ContractTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitSafeDispatcherSubPointersMut>;
impl ContractTraitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitSafeDispatcherSubPointersMut>;


lib.cairo:6:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
        pub a_member: felt252,
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
    pub a_member: starknet::storage::StorageBase<felt252>,
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let __a_member_value__ = starknet::storage::StorageBase {__base_address__: selector!("a_member")};
        StorageStorageBase {
           a_member: __a_member_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
    pub a_member: starknet::storage::StorageBase<starknet::storage::Mutable::<felt252>>,
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let __a_member_value__ = starknet::storage::StorageBase {__base_address__: selector!("a_member")};
        StorageStorageBaseMut {
           a_member: __a_member_value__,
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x3232c860888b3e1c54dda19284c63d6667fbbdebe403a54921a6dfbbe3134c9.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractInterfaceImpl__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ContractInterfaceImpl::foo(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractInterfaceImpl__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:6:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:6:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:9:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:9:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > ==========================================================================

//! > Test write on a non ref component state.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::component]
mod test_component {
    #[storage]
    struct Storage {
        data: u32,
    }
}

#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState);
}

#[starknet::contract]
mod contract {
    component!(path: super::test_component, storage: component_member, event: CompEvent);
    use super::ContractTrait;
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_member: super::test_component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::test_component::Event,
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) {
            // Should raise diagnostics
            self.component_member.data.write();
        }
    }
}

//! > expected_diagnostics
error[E0002]: Method `write` could not be called on type `core::starknet::storage::storage_base::StorageBase::<core::integer::u32>`.
Candidate `core::starknet::storage::map::StorageMapWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::map::StorageMapWriteAccess::<core::starknet::storage::storage_base::StorageBase::<core::integer::u32>>.
Candidate `core::starknet::storage::StoragePointerWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StoragePointerWriteAccess::<core::starknet::storage::storage_base::StorageBase::<core::integer::u32>>.
Candidate `core::starknet::storage::map::StorageMapWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::map::StorageMapWriteAccess::<core::starknet::storage::StoragePath::<core::integer::u32>>.
Candidate `core::starknet::storage::StoragePointerWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StoragePointerWriteAccess::<core::starknet::storage::StoragePath::<core::integer::u32>>.
Candidate `core::starknet::storage::map::StorageMapWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::map::StorageMapWriteAccess::<core::starknet::storage::StoragePointer0Offset::<core::integer::u32>>.
Candidate `core::starknet::storage::StoragePointerWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StoragePointerWriteAccess::<core::starknet::storage::StoragePointer0Offset::<core::integer::u32>>.
Candidate `core::starknet::storage::map::StorageMapWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::map::StorageMapWriteAccess::<core::starknet::storage::StoragePointer::<core::integer::u32>>.
Candidate `core::starknet::storage::StoragePointerWriteAccess::write` inference failed with: Trait has no implementation in context: core::starknet::storage::StoragePointerWriteAccess::<core::starknet::storage::StoragePointer::<core::integer::u32>>.
 --> lib.cairo:34:40
            self.component_member.data.write();
                                       ^^^^^

//! > generated_cairo_code
lib.cairo:

#[starknet::component]
mod test_component {
    #[storage]
    struct Storage {
        data: u32,
    }
}

#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState);
}

#[starknet::contract]
mod contract {
    component!(path: super::test_component, storage: component_member, event: CompEvent);
    use super::ContractTrait;
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_member: super::test_component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::test_component::Event,
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) {
            // Should raise diagnostics
            self.component_member.data.write();
        }
    }
}

lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
ContractTraitDispatcherTrait:

trait ContractTraitDispatcherTrait<T> {
    fn foo(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitDispatcher> {
    fn foo(self: ContractTraitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitLibraryDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitLibraryDispatcher> {
    fn foo(self: ContractTraitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait ContractTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitSafeLibraryDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeLibraryDispatcher> {
    fn foo(self: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitSafeDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeDispatcher> {
    fn foo(self: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitDispatcherCopy of core::traits::Copy::<ContractTraitDispatcher>;
impl ContractTraitDispatcherDrop of core::traits::Drop::<ContractTraitDispatcher>;
impl ContractTraitDispatcherSerde of core::serde::Serde::<ContractTraitDispatcher> {
    fn serialize(self: @ContractTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitDispatcher> {
        core::option::Option::Some(ContractTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitDispatcher of starknet::Store::<ContractTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl ContractTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitDispatcher> {
    type SubPointersType = ContractTraitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitDispatcher>) -> ContractTraitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl ContractTraitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitDispatcher> {
    type SubPointersType = ContractTraitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitDispatcher>>) -> ContractTraitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitLibraryDispatcherCopy of core::traits::Copy::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherDrop of core::traits::Drop::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherSerde of core::serde::Serde::<ContractTraitLibraryDispatcher> {
    fn serialize(self: @ContractTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitLibraryDispatcher> {
        core::option::Option::Some(ContractTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitLibraryDispatcher of starknet::Store::<ContractTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl ContractTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitLibraryDispatcher> {
    type SubPointersType = ContractTraitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitLibraryDispatcher>) -> ContractTraitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl ContractTraitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitLibraryDispatcher> {
    type SubPointersType = ContractTraitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitLibraryDispatcher>>) -> ContractTraitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeLibraryDispatcherCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherSerde of core::serde::Serde::<ContractTraitSafeLibraryDispatcher> {
    fn serialize(self: @ContractTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeLibraryDispatcher> {
        core::option::Option::Some(ContractTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitSafeLibraryDispatcher of starknet::Store::<ContractTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl ContractTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeLibraryDispatcher> {
    type SubPointersType = ContractTraitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeLibraryDispatcher>) -> ContractTraitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl ContractTraitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitSafeLibraryDispatcher> {
    type SubPointersType = ContractTraitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeLibraryDispatcher>>) -> ContractTraitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeDispatcherCopy of core::traits::Copy::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherDrop of core::traits::Drop::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherSerde of core::serde::Serde::<ContractTraitSafeDispatcher> {
    fn serialize(self: @ContractTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeDispatcher> {
        core::option::Option::Some(ContractTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitSafeDispatcher of starknet::Store::<ContractTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl ContractTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeDispatcher> {
    type SubPointersType = ContractTraitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeDispatcher>) -> ContractTraitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl ContractTraitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitSafeDispatcher> {
    type SubPointersType = ContractTraitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeDispatcher>>) -> ContractTraitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitDispatcherSubPointers>;
impl ContractTraitDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitDispatcherSubPointersMut>;
impl ContractTraitDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitDispatcherSubPointersMut>;


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitLibraryDispatcherSubPointers>;
impl ContractTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitLibraryDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitLibraryDispatcherSubPointersMut>;
impl ContractTraitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitLibraryDispatcherSubPointersMut>;


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcherSubPointers>;
impl ContractTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcherSubPointersMut>;
impl ContractTraitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcherSubPointersMut>;


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeDispatcherSubPointers>;
impl ContractTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeDispatcherSubPointers>;


lib.cairo:9:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitSafeDispatcherSubPointersMut>;
impl ContractTraitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitSafeDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
        pub data: u32,
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
    pub data: starknet::storage::StorageBase<u32>,
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let __data_value__ = starknet::storage::StorageBase {__base_address__: selector!("data")};
        StorageStorageBase {
           data: __data_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
    pub data: starknet::storage::StorageBase<starknet::storage::Mutable::<u32>>,
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let __data_value__ = starknet::storage::StorageBase {__base_address__: selector!("data")};
        StorageStorageBaseMut {
           data: __data_value__,
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::Deref<@ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}



lib.cairo:1:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:3:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;


lib.cairo:14:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:



#[phantom]
pub struct Storage {
        #[substorage(v0)]
        pub component_member: super::test_component::Storage,
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
        #[substorage(v0)]
    pub component_member: starknet::storage::FlattenedStorage<super::test_component::Storage>,
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let __component_member_value__ = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           component_member: __component_member_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
        #[substorage(v0)]
    pub component_member: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<super::test_component::Storage>>,
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let __component_member_value__ = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           component_member: __component_member_value__,
        }
    }
}

pub struct ContractState {
        #[substorage(v0)]
        pub component_member: super::test_component::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
            component_member: super::test_component::unsafe_new_component_state::<ContractState>(),
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x29df08f1d7a448905745936c947da165c96a5e2fdbd90ffd2bdabbc7a7e0b1d.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractInterfaceImpl__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ContractInterfaceImpl::foo(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractInterfaceImpl__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_test_component of super::test_component::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @super::test_component::ComponentState<ContractState> {
                 @super::test_component::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> super::test_component::ComponentState<ContractState> {
        super::test_component::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @super::test_component::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: super::test_component::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, super::test_component::Event>>(ref self: super::test_component::ComponentState<ContractState>, event: S) {
        let event: super::test_component::Event = core::traits::Into::into(event);
        let mut contract = super::test_component::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::CompEvent(event));
    }
}


lib.cairo:25:14
    #[derive(Drop, starknet::Event)]
             ^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:25:20
    #[derive(Drop, starknet::Event)]
                   ^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::CompEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("CompEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("CompEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::CompEvent(val));
        }
        Option::None
    }
}
impl EventCompEventIntoEvent of Into<super::test_component::Event, Event> {
    fn into(self: super::test_component::Event) -> Event {
        Event::CompEvent(self)
    }
}



lib.cairo:18:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:18:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > ==========================================================================

//! > Test sub pointers of a non `DeriveStorage` type.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
struct u256Pair {
    a: u256,
    b: u256,
}

impl u256PairStore of starknet::Store<u256Pair> {
    fn read(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress,
    ) -> starknet::SyscallResult<u256Pair> {
        let a = starknet::Store::<u256>::read(address_domain, base)?;
        let b = starknet::Store::<u256>::read_at_offset(address_domain, base, 2)?;
        starknet::SyscallResult::Ok(u256Pair { a, b })
    }
    fn write(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: u256Pair,
    ) -> starknet::SyscallResult<()> {
        starknet::Store::<u256>::write(address_domain, base, value.a)?;
        starknet::Store::<u256>::write_at_offset(address_domain, base, 2, value.b)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8,
    ) -> starknet::SyscallResult<u256Pair> {
        let a = starknet::Store::<u256>::read_at_offset(address_domain, base, offset)?;
        let b = starknet::Store::<u256>::read_at_offset(address_domain, base, offset + 2)?;
        starknet::SyscallResult::Ok(u256Pair { a, b })
    }
    fn write_at_offset(
        address_domain: u32,
        base: starknet::storage_access::StorageBaseAddress,
        offset: u8,
        value: u256Pair,
    ) -> starknet::SyscallResult<()> {
        starknet::Store::<u256>::write_at_offset(address_domain, base, offset, value.a)?;
        starknet::Store::<u256>::write_at_offset(address_domain, base, offset + 2, value.b)?;
        starknet::SyscallResult::Ok(())
    }
    fn size() -> u8 {
        4
    }
}

#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState) -> u256;
}

#[starknet::contract]
mod contract {
    use super::ContractTrait;
    #[storage]
    struct Storage {
        u256_pair: super::u256Pair,
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) -> u256 {
            self.u256_pair.a.read()
        }
    }
}

//! > expected_diagnostics
error: Type "core::starknet::storage::storage_base::StorageBase::<test::u256Pair>" has no member "a"
 --> lib.cairo:59:28
            self.u256_pair.a.read()
                           ^

error: Ambiguous method call. More than one applicable trait function with a suitable self type was found: core::starknet::storage::map::StorageMapReadAccess::read and core::starknet::storage::StoragePointerReadAccess::read. Consider adding type annotations or explicitly refer to the impl function.
 --> lib.cairo:59:30
            self.u256_pair.a.read()
                             ^^^^

//! > generated_cairo_code
lib.cairo:

struct u256Pair {
    a: u256,
    b: u256,
}

impl u256PairStore of starknet::Store<u256Pair> {
    fn read(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress,
    ) -> starknet::SyscallResult<u256Pair> {
        let a = starknet::Store::<u256>::read(address_domain, base)?;
        let b = starknet::Store::<u256>::read_at_offset(address_domain, base, 2)?;
        starknet::SyscallResult::Ok(u256Pair { a, b })
    }
    fn write(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: u256Pair,
    ) -> starknet::SyscallResult<()> {
        starknet::Store::<u256>::write(address_domain, base, value.a)?;
        starknet::Store::<u256>::write_at_offset(address_domain, base, 2, value.b)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(
        address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8,
    ) -> starknet::SyscallResult<u256Pair> {
        let a = starknet::Store::<u256>::read_at_offset(address_domain, base, offset)?;
        let b = starknet::Store::<u256>::read_at_offset(address_domain, base, offset + 2)?;
        starknet::SyscallResult::Ok(u256Pair { a, b })
    }
    fn write_at_offset(
        address_domain: u32,
        base: starknet::storage_access::StorageBaseAddress,
        offset: u8,
        value: u256Pair,
    ) -> starknet::SyscallResult<()> {
        starknet::Store::<u256>::write_at_offset(address_domain, base, offset, value.a)?;
        starknet::Store::<u256>::write_at_offset(address_domain, base, offset + 2, value.b)?;
        starknet::SyscallResult::Ok(())
    }
    fn size() -> u8 {
        4
    }
}

#[starknet::interface]
trait ContractTrait<TContractState> {
    fn foo(self: @TContractState) -> u256;
}

#[starknet::contract]
mod contract {
    use super::ContractTrait;
    #[storage]
    struct Storage {
        u256_pair: super::u256Pair,
    }

    #[abi(embed_v0)]
    impl ContractInterfaceImpl of ContractTrait<ContractState> {
        fn foo(self: @ContractState) -> u256 {
            self.u256_pair.a.read()
        }
    }
}

lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
ContractTraitDispatcherTrait:

trait ContractTraitDispatcherTrait<T> {
    fn foo(self: T) -> u256;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitDispatcher> {
    fn foo(self: ContractTraitDispatcher) -> u256 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<u256>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitLibraryDispatcherImpl of ContractTraitDispatcherTrait<ContractTraitLibraryDispatcher> {
    fn foo(self: ContractTraitLibraryDispatcher) -> u256 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<u256>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

trait ContractTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn foo(self: T) -> starknet::SyscallResult<u256>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl ContractTraitSafeLibraryDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeLibraryDispatcher> {
    fn foo(self: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<u256> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<u256>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct ContractTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl ContractTraitSafeDispatcherImpl of ContractTraitSafeDispatcherTrait<ContractTraitSafeDispatcher> {
    fn foo(self: ContractTraitSafeDispatcher) -> starknet::SyscallResult<u256> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("foo"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<u256>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitDispatcherCopy of core::traits::Copy::<ContractTraitDispatcher>;
impl ContractTraitDispatcherDrop of core::traits::Drop::<ContractTraitDispatcher>;
impl ContractTraitDispatcherSerde of core::serde::Serde::<ContractTraitDispatcher> {
    fn serialize(self: @ContractTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitDispatcher> {
        core::option::Option::Some(ContractTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitDispatcher of starknet::Store::<ContractTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl ContractTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitDispatcher> {
    type SubPointersType = ContractTraitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitDispatcher>) -> ContractTraitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl ContractTraitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitDispatcher> {
    type SubPointersType = ContractTraitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitDispatcher>>) -> ContractTraitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitLibraryDispatcherCopy of core::traits::Copy::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherDrop of core::traits::Drop::<ContractTraitLibraryDispatcher>;
impl ContractTraitLibraryDispatcherSerde of core::serde::Serde::<ContractTraitLibraryDispatcher> {
    fn serialize(self: @ContractTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitLibraryDispatcher> {
        core::option::Option::Some(ContractTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitLibraryDispatcher of starknet::Store::<ContractTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl ContractTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitLibraryDispatcher> {
    type SubPointersType = ContractTraitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitLibraryDispatcher>) -> ContractTraitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl ContractTraitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitLibraryDispatcher> {
    type SubPointersType = ContractTraitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitLibraryDispatcher>>) -> ContractTraitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeLibraryDispatcherCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcher>;
impl ContractTraitSafeLibraryDispatcherSerde of core::serde::Serde::<ContractTraitSafeLibraryDispatcher> {
    fn serialize(self: @ContractTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeLibraryDispatcher> {
        core::option::Option::Some(ContractTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitSafeLibraryDispatcher of starknet::Store::<ContractTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl ContractTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeLibraryDispatcher> {
    type SubPointersType = ContractTraitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeLibraryDispatcher>) -> ContractTraitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl ContractTraitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitSafeLibraryDispatcher> {
    type SubPointersType = ContractTraitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeLibraryDispatcher>>) -> ContractTraitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeDispatcherCopy of core::traits::Copy::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherDrop of core::traits::Drop::<ContractTraitSafeDispatcher>;
impl ContractTraitSafeDispatcherSerde of core::serde::Serde::<ContractTraitSafeDispatcher> {
    fn serialize(self: @ContractTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ContractTraitSafeDispatcher> {
        core::option::Option::Some(ContractTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreContractTraitSafeDispatcher of starknet::Store::<ContractTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let ContractTraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<ContractTraitSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            ContractTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: ContractTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let ContractTraitSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl ContractTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<ContractTraitSafeDispatcher> {
    type SubPointersType = ContractTraitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<ContractTraitSafeDispatcher>) -> ContractTraitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct ContractTraitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl ContractTraitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<ContractTraitSafeDispatcher> {
    type SubPointersType = ContractTraitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<ContractTraitSafeDispatcher>>) -> ContractTraitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                ContractTraitSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitDispatcherSubPointers>;
impl ContractTraitDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitDispatcherSubPointersMut>;
impl ContractTraitDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitDispatcherSubPointersMut>;


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitLibraryDispatcherSubPointers>;
impl ContractTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitLibraryDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitLibraryDispatcherSubPointersMut>;
impl ContractTraitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitLibraryDispatcherSubPointersMut>;


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcherSubPointers>;
impl ContractTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitSafeLibraryDispatcherSubPointersMut>;
impl ContractTraitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitSafeLibraryDispatcherSubPointersMut>;


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<ContractTraitSafeDispatcherSubPointers>;
impl ContractTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<ContractTraitSafeDispatcherSubPointers>;


lib.cairo:43:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl ContractTraitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<ContractTraitSafeDispatcherSubPointersMut>;
impl ContractTraitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<ContractTraitSafeDispatcherSubPointersMut>;


lib.cairo:48:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
        pub u256_pair: super::u256Pair,
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
    pub u256_pair: starknet::storage::StorageBase<super::u256Pair>,
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let __u256_pair_value__ = starknet::storage::StorageBase {__base_address__: selector!("u256_pair")};
        StorageStorageBase {
           u256_pair: __u256_pair_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
    pub u256_pair: starknet::storage::StorageBase<starknet::storage::Mutable::<super::u256Pair>>,
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let __u256_pair_value__ = starknet::storage::StorageBase {__base_address__: selector!("u256_pair")};
        StorageStorageBaseMut {
           u256_pair: __u256_pair_value__,
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0xc5af418eb5eed4ff51ca2888dc884ade488de0dea59772fe757c6cfc2d73f3.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractInterfaceImpl__foo(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractInterfaceImpl::foo(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u256>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractInterfaceImpl__foo as foo;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:48:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:48:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:51:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:51:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > ==========================================================================

//! > Test `#[abi(embed_v0)]` with bad trait.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::interface]
trait Interface<TContractState> {
    fn func(self: @TContractState);
}

#[starknet::component]
mod component {
    #[storage]
    struct Storage {}

    #[embeddable_as(MyEmbeddableImpl)]
    impl MyImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of super::Interface<ComponentState<TContractState>> {
        fn func(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::contract]
mod contract {
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_storage: super::component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::component::Event,
    }

    component!(path: super::component, storage: component_storage, event: CompEvent);

    #[abi(embed_v0)]
    impl MyEmbeddedImpl = super::component::MyImpl<ContractState>;
}

//! > expected_diagnostics
error[E0006]: Trait not found.
 --> lib.cairo:35:5-36:66
      #[abi(embed_v0)]
 _____^
|     impl MyEmbeddedImpl = super::component::MyImpl<ContractState>;
|__________________________________________________________________^

//! > generated_cairo_code
lib.cairo:

#[starknet::interface]
trait Interface<TContractState> {
    fn func(self: @TContractState);
}

#[starknet::component]
mod component {
    #[storage]
    struct Storage {}

    #[embeddable_as(MyEmbeddableImpl)]
    impl MyImpl<
        TContractState, impl X: HasComponent<TContractState>,
    > of super::Interface<ComponentState<TContractState>> {
        fn func(self: @ComponentState<TContractState>) {}
    }
}

#[starknet::contract]
mod contract {
    #[storage]
    struct Storage {
        #[substorage(v0)]
        component_storage: super::component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CompEvent: super::component::Event,
    }

    component!(path: super::component, storage: component_storage, event: CompEvent);

    #[abi(embed_v0)]
    impl MyEmbeddedImpl = super::component::MyImpl<ContractState>;
}

lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
InterfaceDispatcherTrait:

trait InterfaceDispatcherTrait<T> {
    fn func(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceDispatcherImpl of InterfaceDispatcherTrait<InterfaceDispatcher> {
    fn func(self: InterfaceDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("func"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceLibraryDispatcherImpl of InterfaceDispatcherTrait<InterfaceLibraryDispatcher> {
    fn func(self: InterfaceLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("func"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait InterfaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn func(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl InterfaceSafeLibraryDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeLibraryDispatcher> {
    fn func(self: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("func"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct InterfaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl InterfaceSafeDispatcherImpl of InterfaceSafeDispatcherTrait<InterfaceSafeDispatcher> {
    fn func(self: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("func"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceDispatcherCopy of core::traits::Copy::<InterfaceDispatcher>;
impl InterfaceDispatcherDrop of core::traits::Drop::<InterfaceDispatcher>;
impl InterfaceDispatcherSerde of core::serde::Serde::<InterfaceDispatcher> {
    fn serialize(self: @InterfaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceDispatcher> {
        core::option::Option::Some(InterfaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceDispatcher of starknet::Store::<InterfaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl InterfaceDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceDispatcher> {
    type SubPointersType = InterfaceDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceDispatcher>) -> InterfaceDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl InterfaceDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceDispatcher> {
    type SubPointersType = InterfaceDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceDispatcher>>) -> InterfaceDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceLibraryDispatcherCopy of core::traits::Copy::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherDrop of core::traits::Drop::<InterfaceLibraryDispatcher>;
impl InterfaceLibraryDispatcherSerde of core::serde::Serde::<InterfaceLibraryDispatcher> {
    fn serialize(self: @InterfaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceLibraryDispatcher> {
        core::option::Option::Some(InterfaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceLibraryDispatcher of starknet::Store::<InterfaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl InterfaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceLibraryDispatcher> {
    type SubPointersType = InterfaceLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceLibraryDispatcher>) -> InterfaceLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl InterfaceLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceLibraryDispatcher> {
    type SubPointersType = InterfaceLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceLibraryDispatcher>>) -> InterfaceLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeLibraryDispatcherCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcher>;
impl InterfaceSafeLibraryDispatcherSerde of core::serde::Serde::<InterfaceSafeLibraryDispatcher> {
    fn serialize(self: @InterfaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeLibraryDispatcher> {
        core::option::Option::Some(InterfaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceSafeLibraryDispatcher of starknet::Store::<InterfaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let class_hash = starknet::Store::<starknet::ClassHash>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write(__store_derive_address_domain__, __store_derive_base__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeLibraryDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceSafeLibraryDispatcher {
            class_hash,
        } = value;
        starknet::Store::<starknet::ClassHash>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
#[doc(hidden)]
impl InterfaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceSafeLibraryDispatcher> {
    type SubPointersType = InterfaceSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceSafeLibraryDispatcher>) -> InterfaceSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
#[doc(hidden)]
impl InterfaceSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceSafeLibraryDispatcher> {
    type SubPointersType = InterfaceSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceSafeLibraryDispatcher>>) -> InterfaceSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeDispatcherCopy of core::traits::Copy::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherDrop of core::traits::Drop::<InterfaceSafeDispatcher>;
impl InterfaceSafeDispatcherSerde of core::serde::Serde::<InterfaceSafeDispatcher> {
    fn serialize(self: @InterfaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<InterfaceSafeDispatcher> {
        core::option::Option::Some(InterfaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInterfaceSafeDispatcher of starknet::Store::<InterfaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InterfaceSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write(__store_derive_address_domain__, __store_derive_base__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InterfaceSafeDispatcher> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InterfaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InterfaceSafeDispatcher) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InterfaceSafeDispatcher {
            contract_address,
        } = value;
        starknet::Store::<starknet::ContractAddress>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
#[doc(hidden)]
impl InterfaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<InterfaceSafeDispatcher> {
    type SubPointersType = InterfaceSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InterfaceSafeDispatcher>) -> InterfaceSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InterfaceSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
#[doc(hidden)]
impl InterfaceSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<InterfaceSafeDispatcher> {
    type SubPointersType = InterfaceSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InterfaceSafeDispatcher>>) -> InterfaceSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InterfaceSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceDispatcherSubPointersDrop of core::traits::Drop::<InterfaceDispatcherSubPointers>;
impl InterfaceDispatcherSubPointersCopy of core::traits::Copy::<InterfaceDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceDispatcherSubPointersMut>;
impl InterfaceDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceLibraryDispatcherSubPointers>;
impl InterfaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceLibraryDispatcherSubPointersMut>;
impl InterfaceLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcherSubPointers>;
impl InterfaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceSafeLibraryDispatcherSubPointersMut>;
impl InterfaceSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceSafeLibraryDispatcherSubPointersMut>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeDispatcherSubPointersDrop of core::traits::Drop::<InterfaceSafeDispatcherSubPointers>;
impl InterfaceSafeDispatcherSubPointersCopy of core::traits::Copy::<InterfaceSafeDispatcherSubPointers>;


lib.cairo:1:1
#[starknet::interface]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl InterfaceSafeDispatcherSubPointersMutDrop of core::traits::Drop::<InterfaceSafeDispatcherSubPointersMut>;
impl InterfaceSafeDispatcherSubPointersMutCopy of core::traits::Copy::<InterfaceSafeDispatcherSubPointersMut>;


lib.cairo:6:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
component:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::Deref<@ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn component_state_for_testing<TContractState>() -> ComponentState<TContractState> {
    unsafe_new_component_state::<TContractState>()
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}

#[starknet::embeddable]
pub impl MyEmbeddableImpl<
            TContractState, impl X: HasComponent<TContractState>,
impl TContractStateDrop: Drop<TContractState>
> of super::Interface<TContractState> {
    
    fn func(self: @TContractState) {
        let component = HasComponent::get_component(self);
        MyImpl::func(component)
    }
}

lib.cairo:6:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:6:1
#[starknet::component]
^^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:8:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:8:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;


lib.cairo:11:5
    #[embeddable_as(MyEmbeddableImpl)]
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
embeddable:

pub trait UnsafeNewContractStateTraitForMyEmbeddableImpl<
    TContractState
> {
    fn unsafe_new_contract_state() -> TContractState;
}

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__MyEmbeddableImpl__func<TContractState, impl X: HasComponent<TContractState>,
impl TContractStateDrop: Drop<TContractState>, impl UnsafeNewContractState: UnsafeNewContractStateTraitForMyEmbeddableImpl<TContractState>>(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = UnsafeNewContractState::unsafe_new_contract_state();
    MyEmbeddableImpl::<TContractState, X, TContractStateDrop>::func(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}



pub mod __external_MyEmbeddableImpl {
    pub use super::__wrapper__MyEmbeddableImpl__func as func;
}

pub mod __l1_handler_MyEmbeddableImpl {
}

pub mod __constructor_MyEmbeddableImpl {
}


lib.cairo:19:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:



#[phantom]
pub struct Storage {
        #[substorage(v0)]
        pub component_storage: super::component::Storage,
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
        #[substorage(v0)]
    pub component_storage: starknet::storage::FlattenedStorage<super::component::Storage>,
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let __component_storage_value__ = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           component_storage: __component_storage_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
        #[substorage(v0)]
    pub component_storage: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<super::component::Storage>>,
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let __component_storage_value__ = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           component_storage: __component_storage_value__,
        }
    }
}

pub struct ContractState {
        #[substorage(v0)]
        pub component_storage: super::component::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
            component_storage: super::component::unsafe_new_component_state::<ContractState>(),
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x3168f720317a98a00e5727dec4873607cd97bfa1e65fef0524f5661f2b767ed.try_into().unwrap();

impl ContractStateMyImpl of
    super::component::UnsafeNewContractStateTraitForMyImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}

pub mod __external {
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_component of super::component::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @super::component::ComponentState<ContractState> {
                 @super::component::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> super::component::ComponentState<ContractState> {
        super::component::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @super::component::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: super::component::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, super::component::Event>>(ref self: super::component::ComponentState<ContractState>, event: S) {
        let event: super::component::Event = core::traits::Into::into(event);
        let mut contract = super::component::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::CompEvent(event));
    }
}


lib.cairo:28:14
    #[derive(Drop, starknet::Event)]
             ^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:28:20
    #[derive(Drop, starknet::Event)]
                   ^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::CompEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("CompEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("CompEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::CompEvent(val));
        }
        Option::None
    }
}
impl EventCompEventIntoEvent of Into<super::component::Event, Event> {
    fn into(self: super::component::Event) -> Event {
        Event::CompEvent(self)
    }
}



lib.cairo:21:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:21:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;

//! > ==========================================================================

//! > Test Store type with missing `Drop`.

//! > test_runner_name
ExpandContractTestRunner(expect_diagnostics: true)

//! > cairo_code
#[starknet::contract]
mod test_contract {
    #[derive(Copy, starknet::Store)]
    struct InvalidStorageStruct {
        inner: u8,
    }

    #[storage]
    struct Storage {
        field: InvalidStorageStruct,
    }

    #[external(v0)]
    fn foo_v0(ref self: ContractState) {
        let _ = self.field.read();
    }
}

//! > expected_diagnostics
error: Variable not dropped.
 --> lib.cairo:15:13
        let _ = self.field.read();
            ^
note: Trait has no implementation in context: core::traits::Drop::<test::test_contract::InvalidStorageStruct>.
note: Trait has no implementation in context: core::traits::Destruct::<test::test_contract::InvalidStorageStruct>.

//! > diagnostics

//! > generated_cairo_code
lib.cairo:

#[starknet::contract]
mod test_contract {
    #[derive(Copy, starknet::Store)]
    struct InvalidStorageStruct {
        inner: u8,
    }

    #[storage]
    struct Storage {
        field: InvalidStorageStruct,
    }

    #[external(v0)]
    fn foo_v0(ref self: ContractState) {
        let _ = self.field.read();
    }
}

lib.cairo:3:14
    #[derive(Copy, starknet::Store)]
             ^^^^
impls:

impl InvalidStorageStructCopy of core::traits::Copy::<InvalidStorageStruct>;


lib.cairo:3:20
    #[derive(Copy, starknet::Store)]
                   ^^^^^^^^^^^^^^^
starknet_derive:

impl StoreInvalidStorageStruct of starknet::Store::<InvalidStorageStruct> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<InvalidStorageStruct> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let inner = starknet::Store::<u8>::read(__store_derive_address_domain__, __store_derive_base__)?;
        starknet::SyscallResult::Ok(
            InvalidStorageStruct {
                inner,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: InvalidStorageStruct) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let InvalidStorageStruct {
            inner,
        } = value;
        starknet::Store::<u8>::write(__store_derive_address_domain__, __store_derive_base__, inner)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<InvalidStorageStruct> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let inner = starknet::Store::<u8>::read_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__)?;
        starknet::SyscallResult::Ok(
            InvalidStorageStruct {
                inner,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: InvalidStorageStruct) -> starknet::SyscallResult<()> {
        let __store_derive_address_domain__ = address_domain;
        let __store_derive_base__ = base;
        let __store_derive_offset__ = offset;
        let InvalidStorageStruct {
            inner,
        } = value;
        starknet::Store::<u8>::write_at_offset(__store_derive_address_domain__, __store_derive_base__, __store_derive_offset__, inner)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<u8>::size()
    }
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InvalidStorageStructSubPointers {
    pub inner: starknet::storage::StoragePointer<u8>,
}
#[doc(hidden)]
impl InvalidStorageStructSubPointersImpl of starknet::storage::SubPointers<InvalidStorageStruct> {
    type SubPointersType = InvalidStorageStructSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<InvalidStorageStruct>) -> InvalidStorageStructSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __inner_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InvalidStorageStructSubPointers {
           inner: __inner_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct InvalidStorageStructSubPointersMut {
    pub inner: starknet::storage::StoragePointer<starknet::storage::Mutable::<u8>>,
}
#[doc(hidden)]
impl InvalidStorageStructSubPointersMutImpl of starknet::storage::SubPointersMut<InvalidStorageStruct> {
    type SubPointersType = InvalidStorageStructSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<InvalidStorageStruct>>) -> InvalidStorageStructSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __inner_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                InvalidStorageStructSubPointersMut {
           inner: __inner_value__,
        }
    }
}


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
contract:

#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
        pub field: InvalidStorageStruct,
}

#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBase {
    pub field: starknet::storage::StorageBase<InvalidStorageStruct>,
}
#[doc(hidden)]
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let __field_value__ = starknet::storage::StorageBase {__base_address__: selector!("field")};
        StorageStorageBase {
           field: __field_value__,
        }
    }
}
#[derive(Drop, Copy)]
#[doc(hidden)]
pub struct StorageStorageBaseMut {
    pub field: starknet::storage::StorageBase<starknet::storage::Mutable::<InvalidStorageStruct>>,
}
#[doc(hidden)]
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let __field_value__ = starknet::storage::StorageBase {__base_address__: selector!("field")};
        StorageStorageBaseMut {
           field: __field_value__,
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::Deref<@ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}
#[cfg(target: 'test')]
#[inline(always)]
pub fn contract_state_for_testing() -> ContractState {
    unsafe_new_contract_state()
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;
#[cfg(target: 'test')]
pub const TEST_CLASS_HASH: starknet::ClassHash = 0x3140ea2161c9eba12d890be5ea892f4f2b985bb300febf93c7b28573ece4148.try_into().unwrap();

#[doc(hidden)]
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__foo_v0(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    foo_v0(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__foo_v0 as foo_v0;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }



lib.cairo:3:20
    #[derive(Copy, starknet::Store)]
                   ^^^^^^^^^^^^^^^
impls:

impl InvalidStorageStructSubPointersDrop of core::traits::Drop::<InvalidStorageStructSubPointers>;
impl InvalidStorageStructSubPointersCopy of core::traits::Copy::<InvalidStorageStructSubPointers>;


lib.cairo:3:20
    #[derive(Copy, starknet::Store)]
                   ^^^^^^^^^^^^^^^
impls:

impl InvalidStorageStructSubPointersMutDrop of core::traits::Drop::<InvalidStorageStructSubPointersMut>;
impl InvalidStorageStructSubPointersMutCopy of core::traits::Copy::<InvalidStorageStructSubPointersMut>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
impls:

impl EventDrop of core::traits::Drop::<Event>;


lib.cairo:1:1
#[starknet::contract]
^^^^^^^^^^^^^^^^^^^^^
starknet_derive:

impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}



lib.cairo:8:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;


lib.cairo:8:5
    #[storage]
    ^^^^^^^^^^
impls:

impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
