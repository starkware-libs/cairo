// Simple parser for sierra.
// Currently only used for testing.

use crate::program::*;

grammar;

pub Program: Program = {
    <type_declarations:TypeDeclaration*>
    <extension_declarations:ExtensionDeclaration*>
    <statements:Statement*>
    <funcs:Function*>
    => Program{type_declarations, extension_declarations, statements, funcs},
}

TypeDeclaration: TypeDeclaration = {
    "type" <id:ConcreteTypeId> "=" <generic_id:GenericTypeId> "<" <args:GenericArgs> ">" ";"
    => TypeDeclaration{id, generic_id, args},
    "type" <id:ConcreteTypeId> "=" <generic_id:GenericTypeId> ";"
    => TypeDeclaration{id, generic_id, args: vec![]},
}

ExtensionDeclaration: ExtensionDeclaration = {
    "ext" <id:ConcreteExtensionId> "=" <generic_id:GenericExtensionId>
    "<" <args:GenericArgs> ">" ";" => ExtensionDeclaration{id, generic_id, args},
    "ext" <id:ConcreteExtensionId> "=" <generic_id:GenericExtensionId> ";"
    => ExtensionDeclaration{id, generic_id, args: vec![]},
}

Function: Function = {
    <id:FunctionId> "@" <entry:StatementId>
    "(" <params: Params> ")" "->" "(" <ret_types: ConcreteTypeIds> ")" ";"
    => Function{id, params, ret_types, entry},
}

Param: Param = {
    <id:VarId> ":" <ty:ConcreteTypeId> => Param{id, ty},
}
Params = Comma<Param>;

GenericExtensionId: GenericExtensionId = {
    <id:Label> => GenericExtensionId::from_string(id),
    "[" <id:UnsignedInt> "]" => GenericExtensionId::new(id),
}

ConcreteExtensionId: ConcreteExtensionId = {
    <id:Label> => ConcreteExtensionId::from_string(id),
    "[" <id:UnsignedInt> "]" => ConcreteExtensionId::new(id),
}

FunctionId: FunctionId = {
    <id:Label> => FunctionId::from_string(id),
    "[" <id:UnsignedInt> "]" => FunctionId::new(id),
}

VarId: VarId = {
    <id:Label> => VarId::from_string(id),
    "[" <id:UnsignedInt> "]" => VarId::new(id),
}
VarIds = Comma<VarId>;

GenericTypeId: GenericTypeId = {
    <id:Label> => GenericTypeId::from_string(id),
    "[" <id:UnsignedInt> "]" => GenericTypeId::new(id),
}

ConcreteTypeId: ConcreteTypeId = {
    <id:Label> => ConcreteTypeId::from_string(id),
    "[" <id:UnsignedInt> "]" => ConcreteTypeId::new(id),
}
ConcreteTypeIds = Comma<ConcreteTypeId>;

StatementId: StatementId = {
     <id:UnsignedInt> => StatementId(id as usize),
}

GenericArg: GenericArg = {
    <v:SignedInt> => GenericArg::Value(v),
    ConcreteTypeId => GenericArg::Type(<>),
    "&" <id:FunctionId> => GenericArg::Func(id),
}
GenericArgs = Comma<GenericArg>;

Statement: Statement = {
    <invocation:Invocation> => Statement::Invocation(invocation),
    "return" "(" <args:VarIds> ")" ";" => Statement::Return(args),
}

Invocation: Invocation = {
    <extension_id:ConcreteExtensionId> "(" <args:VarIds> ")" "->" "(" <results:VarIds> ")" ";" =>
        Invocation{
            extension_id,
            args,
            branches: vec![BranchInfo{ target: BranchTarget::Fallthrough , results }]
        },
    <extension_id:ConcreteExtensionId> "(" <args:VarIds> ")" "{" <branches:BranchInfo*> "}" ";" =>
        Invocation{extension_id, args, branches},
}

// Generates a vector of Ts with or without a trailing comma.
Comma<T>: Vec<T> = {
    // If we have an additional element we add it to the vector, otherwise
    // returning the current vector.
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

BranchInfo: BranchInfo = {
    <target: BranchTarget> "(" <results:VarIds> ")" =>
        BranchInfo{ target, results },
}

BranchTarget: BranchTarget = {
     "fallthrough" => BranchTarget::Fallthrough,
     <id:StatementId> => BranchTarget::Statement(id),
}

Label: String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string(),
}

UnsignedInt: u64 = {
    r"[1-9][0-9]*|0" => <>.parse().unwrap(),
}

SignedInt: i64 = {
    UnsignedInt => <> as i64,
    "-" <unsigned:UnsignedInt> => -(unsigned as i64),
}

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]" => {},
    _,
}
