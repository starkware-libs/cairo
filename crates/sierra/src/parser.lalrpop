// Simple parser for sierra.
// Currently only used for testing.

use crate::ids::*;
use crate::program::*;

grammar;

pub Program: Program = {
    <type_declarations:TypeDeclaration*>
    <libfunc_declarations:LibFuncDeclaration*>
    <statements:Statement*>
    <funcs:Function*>
    => Program{type_declarations, libfunc_declarations, statements, funcs},
}

TypeDeclaration: TypeDeclaration = {
    "type" <id:ConcreteTypeId> "=" <generic_id:GenericTypeId> "<" <args:GenericArgs> ">" ";"
    => TypeDeclaration{id, long_id: ConcreteTypeLongId{generic_id, args}},
    "type" <id:ConcreteTypeId> "=" <generic_id:GenericTypeId> ";"
    => TypeDeclaration{id, long_id: ConcreteTypeLongId{generic_id, args: vec![]}},
}

LibFuncDeclaration: LibFuncDeclaration = {
    "libfunc" <id:ConcreteLibFuncId> "=" <generic_id:GenericLibFuncId>
    "<" <args:GenericArgs> ">" ";"
    => LibFuncDeclaration{id, long_id: ConcreteLibFuncLongId{generic_id, args}},
    "libfunc" <id:ConcreteLibFuncId> "=" <generic_id:GenericLibFuncId> ";"
    => LibFuncDeclaration{id, long_id: ConcreteLibFuncLongId{generic_id, args: vec![]}},
}

Function: Function = {
    <id:FunctionId> "@" <entry:StatementIdx>
    "(" <params: Params> ")" "->" "(" <ret_types: ConcreteTypeIds> ")" ";"
    => Function{id, params, ret_types, entry},
}

Param: Param = {
    <id:VarId> ":" <ty:ConcreteTypeId> => Param{id, ty},
}
Params = Comma<Param>;

GenericLibFuncId: GenericLibFuncId = {
    <id:Label> => GenericLibFuncId::from_string(id),
    "[" <id:UnsignedInt> "]" => GenericLibFuncId::new(id),
}

ConcreteLibFuncId: ConcreteLibFuncId = {
    <id:Label> => ConcreteLibFuncId::from_string(id),
    "[" <id:UnsignedInt> "]" => ConcreteLibFuncId::new(id),
}

FunctionId: FunctionId = {
    <id:Label> => FunctionId::from_string(id),
    "[" <id:UnsignedInt> "]" => FunctionId::new(id),
}

VarId: VarId = {
    <id:Label> => VarId::from_string(id),
    "[" <id:UnsignedInt> "]" => VarId::new(id),
}
VarIds = Comma<VarId>;

GenericTypeId: GenericTypeId = {
    <id:Label> => GenericTypeId::from_string(id),
    "[" <id:UnsignedInt> "]" => GenericTypeId::new(id),
}

ConcreteTypeId: ConcreteTypeId = {
    <id:Label> => ConcreteTypeId::from_string(id),
    "[" <id:UnsignedInt> "]" => ConcreteTypeId::new(id),
}
ConcreteTypeIds = Comma<ConcreteTypeId>;

StatementIdx: StatementIdx = {
     <id:UnsignedInt> => StatementIdx(id as usize),
}

GenericArg: GenericArg = {
    ConcreteTypeId => GenericArg::Type(<>),
    <v:SignedInt> => GenericArg::Value(v),
    "user@" <id:FunctionId> => GenericArg::UserFunc(id),
    "lib@" <id:ConcreteLibFuncId> => GenericArg::LibFunc(id),
}
GenericArgs = Comma<GenericArg>;

Statement: Statement = {
    <invocation:Invocation> => Statement::Invocation(invocation),
    "return" "(" <args:VarIds> ")" ";" => Statement::Return(args),
}

Invocation: Invocation = {
    <libfunc_id:ConcreteLibFuncId> "(" <args:VarIds> ")" "->" "(" <results:VarIds> ")" ";" =>
        Invocation{
            libfunc_id,
            args,
            branches: vec![BranchInfo{ target: BranchTarget::Fallthrough , results }]
        },
    <libfunc_id:ConcreteLibFuncId> "(" <args:VarIds> ")" "{" <branches:BranchInfo*> "}" ";" =>
        Invocation{libfunc_id, args, branches},
}

// Generates a vector of Ts with or without a trailing comma.
Comma<T>: Vec<T> = {
    // If we have an additional element we add it to the vector, otherwise
    // returning the current vector.
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

BranchInfo: BranchInfo = {
    <target: BranchTarget> "(" <results:VarIds> ")" =>
        BranchInfo{ target, results },
}

BranchTarget: BranchTarget = {
     "fallthrough" => BranchTarget::Fallthrough,
     <id:StatementIdx> => BranchTarget::Statement(id),
}

Label: String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string(),
}

UnsignedInt: u64 = {
    r"[1-9][0-9]*|0" => <>.parse().unwrap(),
}

SignedInt: i64 = {
    UnsignedInt => <> as i64,
    "-" <unsigned:UnsignedInt> => -(unsigned as i64),
}

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]" => {},
    _,
}
