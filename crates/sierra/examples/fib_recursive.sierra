type uint128 = uint128;
type GasBuiltin = GasBuiltin;
type RangeCheck = RangeCheck;
type NonZeroInt = NonZero<uint128>;
type UninitializedInt = Uninitialized<uint128>;


libfunc store_temp_uint128 = store_temp<uint128>;
libfunc alloc_local_uint128 = alloc_local<uint128>;
libfunc store_local_uint128 = store_local<uint128>;
libfunc store_temp_gb = store_temp<GasBuiltin>;
libfunc store_temp_rc = store_temp<RangeCheck>;
libfunc uint128_const_1 = uint128_const<1>;
libfunc uint128_const_minus_1 = uint128_const<-1>;
libfunc uint128_add = uint128_wrapping_add;
libfunc uint128_sub_1 = uint128_wrapping_sub<1>;
libfunc uint128_dup = dup<uint128>;
libfunc uint128_drop = drop<uint128>;
libfunc uint128_jump_nz = uint128_jump_nz;
libfunc uint128_unwrap_nz = unwrap_nz<uint128>;
libfunc get_gas = get_gas;
libfunc refund_gas = refund_gas;
libfunc finalize_locals = finalize_locals;
libfunc call_fib = function_call<user@Fibonacci>;

// Statement #  0 - tests if n == 0 and initiates 1 for the early return values.
uint128_const_1() -> (one);
store_temp_uint128(one) -> (one);
uint128_jump_nz(n) { fallthrough() 8(n) };
// Statement #  3 - n == 0, so we return updated gb and 1.
refund_gas(gb) -> (gb);
store_temp_rc(rc) -> (rc);
store_temp_gb(gb) -> (gb);
store_temp_uint128(one) -> (one);
return(rc, gb, one);
// Statement #  8 - calculating n - 1, and testing if n - 1 == 0.
uint128_unwrap_nz(n) -> (n);
uint128_sub_1(n) -> (n_1);
store_temp_uint128(n_1) -> (n_1);
uint128_jump_nz(n_1) { fallthrough() 17(n_1) };
// Statement # 12 - n == 1, so we return updated gb and 1.
refund_gas(gb) -> (gb);
store_temp_rc(rc) -> (rc);
store_temp_gb(gb) -> (gb);
store_temp_uint128(one) -> (one);
return(rc, gb, one);
// Statement # 17 - Get gas for the recursive calls.
uint128_unwrap_nz(n_1) -> (n_1);
uint128_drop(one) -> ();
get_gas(rc, gb) { 27(rc, gb) fallthrough(rc, gb) }; // Statement 20.
// Statement # 21 - Ran out of gas - returning update gb and error value.
store_temp_rc(rc) -> (rc);
refund_gas(gb) -> (gb);
store_temp_gb(gb) -> (gb);
uint128_drop(n_1) -> ();
uint128_const_minus_1() -> (minus);
store_temp_uint128(minus) -> (minus);
return(rc, gb, minus);
// Statement # 27 - Performing both recursive calculations and returning their sum.
alloc_local_uint128() -> (l_n_2);
alloc_local_uint128() -> (l_r1);
finalize_locals() -> ();
store_temp_rc(rc) -> (rc);
store_temp_gb(gb) -> (gb);
uint128_dup(n_1) -> (n_1, n_2);
uint128_sub_1(n_2) -> (n_2);
store_local_uint128(l_n_2, n_2) -> (n_2);
store_temp_uint128(n_1) -> (n_1);
call_fib(rc, gb, n_1) -> (rc, gb, r1);
store_local_uint128(l_r1, r1) -> (r1);
store_temp_rc(rc) -> (rc);
store_temp_gb(gb) -> (gb);
store_temp_uint128(n_2) -> (n_2);
call_fib(rc, gb, n_2) -> (rc, gb, r2);
refund_gas(gb) -> (gb); // Statement 41.
store_temp_rc(rc) -> (rc);
store_temp_gb(gb) -> (gb);
uint128_add(r1, r2) -> (r);
store_temp_uint128(r) -> (r);
return(rc, gb, r);

Fibonacci@0(rc: RangeCheck, gb: GasBuiltin, n: uint128) -> (RangeCheck, GasBuiltin, uint128);
