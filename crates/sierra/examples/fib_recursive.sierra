type int = int;
type GasBuiltin = GasBuiltin;
type NonZeroInt = NonZero<int>;
type UninitializedInt = uninitialized<int>;


libfunc store_temp_int = store_temp<int>;
libfunc alloc_local_int = alloc_local<int>;
libfunc store_local_int = store_local<int>;
libfunc store_temp_gb = store_temp<GasBuiltin>;
libfunc int_const_1 = int_const<1>;
libfunc int_const_minus_10000 = int_const<-10000>;
libfunc int_add = int_add;
libfunc int_sub_1 = int_sub<1>;
libfunc int_dup = int_dup;
libfunc int_drop = int_drop;
libfunc int_jump_nz = int_jump_nz;
libfunc int_unwrap_nz = unwrap_nz<int>;
libfunc get_gas = get_gas;
libfunc refund_gas = refund_gas;
libfunc finalize_locals = finalize_locals;
libfunc call_fib = function_call<user@Fibonacci>;

// Statement #  0 - tests if n == 0 and initiates 1 for the early return values.
int_const_1() -> (one);
store_temp_int(one) -> (one);
int_jump_nz(n) { 7(n) fallthrough() };
// Statement #  3 - n == 0, so we return updated gb and 1.
refund_gas(gb) -> (gb);
store_temp_gb(gb) -> (gb);
store_temp_int(one) -> (one);
return(gb, one);
// Statement #  7 - calculating n - 1, and testing if n - 1 == 0.
int_unwrap_nz(n) -> (n);
int_sub_1(n) -> (n_1);
store_temp_int(n_1) -> (n_1);
int_jump_nz(n_1) { 15(n_1) fallthrough() };
// Statement # 11 - n == 1, so we return updated gb and 1.
refund_gas(gb) -> (gb);
store_temp_gb(gb) -> (gb);
store_temp_int(one) -> (one);
return(gb, one);
// Statement # 15 - Get gas for the recursive calls.
int_unwrap_nz(n_1) -> (n_1);
int_drop(one) -> ();
get_gas(gb) { 24(gb) fallthrough(gb) }; // Statement 18.
// Statement # 18 - Ran out of gas - returning update gb and error value.
refund_gas(gb) -> (gb);
store_temp_gb(gb) -> (gb);
int_drop(n_1) -> ();
int_const_minus_10000() -> (minus);
store_temp_int(minus) -> (minus);
return(gb, minus);
// Statement # 24 - Performing both recursive calculations and returning their sum.
alloc_local_int() -> (l_n_2);
alloc_local_int() -> (l_r1);
finalize_locals() -> ();
store_temp_gb(gb) -> (gb);
int_dup(n_1) -> (n_1, n_2);
int_sub_1(n_2) -> (n_2);
store_local_int(l_n_2, n_2) -> (n_2);
store_temp_int(n_1) -> (n_1);
call_fib(gb, n_1) -> (gb, r1);
store_local_int(l_r1, r1) -> (r1);
store_temp_gb(gb) -> (gb);
store_temp_int(n_2) -> (n_2);
call_fib(gb, n_2) -> (gb, r2);
refund_gas(gb) -> (gb); // Statement 37.
store_temp_gb(gb) -> (gb);
int_add(r1, r2) -> (r);
store_temp_int(r) -> (r);
return(gb, r);

Fibonacci@0(gb: GasBuiltin, n: int) -> (GasBuiltin, int);
