//! > Basic borrow checking valid.

//! > test_runner_name
test_function_lowering

//! > function
fn foo(x: ACopy, y: ADrop) {
  if true {
    use_a_copy(x);
    use_a_drop(y);
  } else {
    use_a_drop(y);
  }
  use_a_copy(x);
}

//! > function_name
foo

//! > module_code
extern type ACopy;
impl ACopyCopy of Copy::<ACopy>;
extern type ADrop;
impl ADropDrop of Drop::<ADrop>;

extern fn use_a_copy(x: ACopy) nopanic;
extern fn use_a_drop(x: ADrop) nopanic;

//! > semantic_diagnostics

//! > lowering_diagnostics

//! > lowering_structured
blk0 (root):
Inputs: v0: test::ACopy, v1: test::ADrop
Initial implicits:
Statements:
  (v2: ()) <- struct_construct()
  (v3: core::bool) <- bool::True(v2)
End:
  Match(match_enum(v3) {
    bool::False => blk2,
    bool::True => blk1,
  })

blk1:
Inputs: v4: ()
Initial implicits:
Statements:
  () <- test::use_a_copy(v0)
  () <- test::use_a_drop(v1)
End:
  Goto(3, {})

blk2:
Inputs: v5: ()
Initial implicits:
Statements:
  () <- test::use_a_drop(v1)
End:
  Goto(3, {})

blk3:
Inputs:
Initial implicits:
Statements:
  () <- test::use_a_copy(v0)
  (v6: ()) <- struct_construct()
End:
  Return(v6)

//! > lowering_flat
blk0 (root):
Inputs: v0: test::ACopy, v1: test::ADrop
Statements:
  (v2: ()) <- struct_construct()
  (v3: core::bool) <- bool::True(v2)
End:
  Match(match_enum(v3) {
    bool::False => blk1,
    bool::True => blk2,
  })

blk1:
Inputs: v5: ()
Statements:
  () <- test::use_a_drop(v1)
End:
  Goto(blk3, {})

blk2:
Inputs: v4: ()
Statements:
  () <- test::use_a_copy(v0)
  () <- test::use_a_drop(v1)
End:
  Goto(blk3, {})

blk3:
Inputs:
Statements:
  () <- test::use_a_copy(v0)
  (v6: ()) <- struct_construct()
End:
  Return(v6)

//! > ==========================================================================

//! > Basic borrow checking failures.

//! > test_runner_name
test_function_lowering

//! > function
fn foo(x: ACopy, y: ADrop) {
  if true {
    use_a_copy(x);
    use_a_drop(y);
  } else {
  }
  use_a_drop(y);
}

//! > function_name
foo

//! > module_code
extern type ACopy;
impl ACopyCopy of Copy::<ACopy>;
extern type ADrop;
impl ADropDrop of Drop::<ADrop>;

extern fn use_a_copy(x: ACopy) nopanic;
extern fn use_a_drop(x: ADrop) nopanic;

//! > semantic_diagnostics

//! > lowering_diagnostics
error: Variable was previously moved.
 --> lib.cairo:8:18
fn foo(x: ACopy, y: ADrop) {
                 ^

//! > lowering_structured
blk0 (root):
Inputs: v0: test::ACopy, v1: test::ADrop
Initial implicits:
Statements:
  (v2: ()) <- struct_construct()
  (v3: core::bool) <- bool::True(v2)
End:
  Match(match_enum(v3) {
    bool::False => blk2,
    bool::True => blk1,
  })

blk1:
Inputs: v4: ()
Initial implicits:
Statements:
  () <- test::use_a_copy(v0)
  () <- test::use_a_drop(v1)
End:
  Goto(3, {})

blk2:
Inputs: v5: ()
Initial implicits:
Statements:
End:
  Goto(3, {})

blk3:
Inputs:
Initial implicits:
Statements:
  () <- test::use_a_drop(v1)
  (v6: ()) <- struct_construct()
End:
  Return(v6)

//! > lowering_flat

//! > ==========================================================================

//! > Borrow checking with panic

//! > test_runner_name
test_function_lowering

//! > function
fn foo(ref x: ADrop, y: ADrop) {
  use_a_drop(x);
  bar();
  x = y;
}

fn bar(){
  let mut data = array_new::<felt>();
  array_append::<felt>(ref data, 1);
  panic(data);
}

//! > function_name
foo

//! > module_code
extern type ACopy;
impl ACopyCopy of Copy::<ACopy>;
extern type ADrop;
impl ADropDrop of Drop::<ADrop>;

extern fn use_a_copy(x: ACopy) nopanic;
extern fn use_a_drop(x: ADrop) nopanic;

//! > semantic_diagnostics

//! > lowering_diagnostics

//! > lowering_structured
blk0 (root):
Inputs: v0: test::ADrop, v1: test::ADrop
Initial implicits:
Statements:
  () <- test::use_a_drop(v0)
  (v2: ()) <- test::bar()
  (v3: ()) <- struct_construct()
End:
  Return(v1, v3)

//! > lowering_flat
blk0 (root):
Inputs: v0: test::ADrop, v1: test::ADrop
Statements:
  () <- test::use_a_drop(v0)
  (v4: core::PanicResult::<((),)>) <- test::bar()
End:
  Match(match_enum(v4) {
    PanicResult::Ok => blk1,
    PanicResult::Err => blk3,
  })

blk1:
Inputs: v5: ((),)
Statements:
  (v6: ()) <- struct_destructure(v5)
End:
  Goto(blk2, {})

blk2:
Inputs:
Statements:
  (v3: ()) <- struct_construct()
  (v8: (test::ADrop, ())) <- struct_construct(v1, v3)
  (v9: core::PanicResult::<(test::ADrop, ())>) <- PanicResult::Ok(v8)
End:
  Return(v9)

blk3:
Inputs: v7: core::array::Array::<core::felt>
Statements:
  (v10: core::PanicResult::<(test::ADrop, ())>) <- PanicResult::Err(v7)
End:
  Return(v10)

//! > ==========================================================================

//! > Borrow checking array

//! > test_runner_name
test_function_lowering

//! > function
fn foo(ref self: Query::<felt>, value: felt) {
  let mut data = self.data;
  array_append(ref data, value)
}

//! > function_name
foo

//! > module_code
struct Query<T> {
  data: Array::<T>, 
}

//! > semantic_diagnostics

//! > lowering_diagnostics
error: Variable was previously moved.
 --> lib.cairo:4:12
fn foo(ref self: Query::<felt>, value: felt) {
           ^**^

//! > lowering_structured
blk0 (root):
Inputs: v0: test::Query::<core::felt>, v1: core::felt
Initial implicits:
Statements:
  (v2: core::array::Array::<core::felt>) <- struct_destructure(v0)
  (v3: core::array::Array::<core::felt>) <- core::array::array_append::<core::felt>(v2, v1)
  (v4: ()) <- struct_construct()
End:
  Return(v0, v4)

//! > lowering_flat
