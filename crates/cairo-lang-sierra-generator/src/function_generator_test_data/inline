//! > test inlined function.

//! > test_runner_name
test_function_generator

//! > function
fn foo(a: felt) -> felt {
  if a == 2 {
    bar(a)
  } else {
    a
  }
}

//! > function_name
foo

//! > module_code
#[inline(always)]
fn bar(a: felt) -> felt {
  if a == 0 {
    return 1;
  }
  0
}

//! > semantic_diagnostics

//! > lowering_diagnostics

//! > sierra_gen_diagnostics

//! > sierra_code
label0:
felt_const<2>() -> ([1])
dup<felt>([0]) -> ([0], [3])
felt_sub([3], [1]) -> ([2])
store_temp<felt>([2]) -> ([2])
felt_is_zero([2]) { fallthrough() label1([4]) }
branch_align() -> ()
felt_is_zero([0]) { fallthrough() label3([5]) }
branch_align() -> ()
felt_const<1>() -> ([6])
dup<felt>([6]) -> ([6], [7])
store_temp<felt>([7]) -> ([7])
jump() { label5() }
label3:
branch_align() -> ()
drop<NonZero<felt>>([5]) -> ()
jump() { label6() }
label4:
label6:
felt_const<0>() -> ([8])
dup<felt>([8]) -> ([8], [7])
store_temp<felt>([7]) -> ([7])
label5:
dup<felt>([7]) -> ([7], [9])
jump() { label7() }
label1:
branch_align() -> ()
drop<NonZero<felt>>([4]) -> ()
dup<felt>([0]) -> ([0], [9])
store_temp<felt>([9]) -> ([9])
jump() { label7() }
label2:
label7:
store_temp<felt>([9]) -> ([10])
return([10])

//! > ==========================================================================

//! > test goto + fallthrough convergence.

//! > test_runner_name
test_function_generator

//! > function
fn foo(a: @Array::<felt>) -> @felt {
    let t: Option::<@felt> = a.get(0_u32);
    inlined_expect(t)
}

//! > function_name
foo

//! > module_code
use array::ArrayTrait;

#[inline(always)]
fn inlined_expect(option: Option::<@felt>) -> @felt {
    match option {
        Option::Some(x) => x,
        Option::None(()) => @0,
    }
}

//! > semantic_diagnostics

//! > lowering_diagnostics

//! > sierra_gen_diagnostics

//! > sierra_code
label0:
u32_const<0>() -> ([2])
store_temp<u32>([2]) -> ([2])
array_get<felt>([0], [1], [2]) { fallthrough([3], [4]) label1([5]) }
branch_align() -> ()
enum_init<core::option::Option::<@core::felt>, 0>([4]) -> ([6])
store_temp<RangeCheck>([3]) -> ([7])
dup<RangeCheck>([7]) -> ([7], [3])
store_temp<core::option::Option::<@core::felt>>([6]) -> ([8])
dup<core::option::Option::<@core::felt>>([8]) -> ([8], [6])
jump() { label3() }
label1:
branch_align() -> ()
struct_construct<Unit>() -> ([9])
enum_init<core::option::Option::<@core::felt>, 1>([9]) -> ([10])
store_temp<RangeCheck>([5]) -> ([7])
dup<RangeCheck>([7]) -> ([7], [5])
store_temp<core::option::Option::<@core::felt>>([10]) -> ([8])
dup<core::option::Option::<@core::felt>>([8]) -> ([8], [10])
jump() { label3() }
label2:
label3:
enum_match<core::option::Option::<@core::felt>>([8]) { fallthrough([11]) label4([12]) }
branch_align() -> ()
dup<felt>([11]) -> ([11], [13])
store_temp<felt>([13]) -> ([13])
jump() { label6() }
label4:
branch_align() -> ()
struct_deconstruct<Unit>([12]) -> ()
felt_const<0>() -> ([14])
snapshot_take<felt>([14]) -> ([15], [16])
drop<felt>([15]) -> ()
dup<felt>([16]) -> ([16], [13])
store_temp<felt>([13]) -> ([13])
jump() { label6() }
label5:
label6:
store_temp<RangeCheck>([7]) -> ([17])
store_temp<felt>([13]) -> ([18])
return([17], [18])
