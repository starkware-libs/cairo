//! > Unused coupon

//! > test_runner_name
test_program_generator

//! > cairo
extern fn coupon_buy<T>() -> T nopanic;
extern fn coupon_refund<T>(c: T) nopanic;
extern fn drop<T>(c: T) nopanic;

struct MyStruct {
    c: bar::<u8>::Coupon,
    box: Box::<bar::<u8>::Coupon>,
}

fn foo(my_struct: MyStruct, coupon: bar::<u8>::Coupon) -> MyStruct {
    coupon_refund(my_struct.c);
    coupon_refund(my_struct.box.unbox());
    drop(coupon);
    MyStruct{ c: coupon_buy(), box: BoxTrait::new(coupon_buy()) }
}

fn return_coupon() -> bar::<u8>::Coupon {
    coupon_buy()
}

fn bar<T>() -> felt252 {
    10
}

//! > sierra_code
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type Box<Unit> = Box<Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type test::MyStruct = Struct<ut@test::MyStruct, Unit, Box<Unit>> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc struct_deconstruct<test::MyStruct> = struct_deconstruct<test::MyStruct>;
libfunc drop<Unit> = drop<Unit>;
libfunc unbox<Unit> = unbox<Unit>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc into_box<Unit> = into_box<Unit>;
libfunc struct_construct<test::MyStruct> = struct_construct<test::MyStruct>;

struct_deconstruct<test::MyStruct>([0]) -> ([2], [3]); // 0
drop<Unit>([2]) -> (); // 1
unbox<Unit>([3]) -> ([4]); // 2
drop<Unit>([4]) -> (); // 3
drop<Unit>([1]) -> (); // 4
struct_construct<Unit>() -> ([5]); // 5
struct_construct<Unit>() -> ([6]); // 6
into_box<Unit>([6]) -> ([7]); // 7
struct_construct<test::MyStruct>([5], [7]) -> ([8]); // 8
return([8]); // 9
struct_construct<Unit>() -> ([0]); // 10
return([0]); // 11

test::foo@0([0]: test::MyStruct, [1]: Unit) -> (test::MyStruct);
test::return_coupon@10() -> (Unit);
