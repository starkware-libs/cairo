//! > Test trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
struct A {}
trait MyTrait<T> {
    fn param_test(ref a: u128) -> bad_type nopanic;

    fn no_ret_ty(a: u128) -> felt252;
}
impl MyImpl of MyTrait::<A>;
impl MyImpl2<T> of MyTrait::<T> {
    mod a;
    use b;
    extern fn extern_func() nopanic;
    extern type DummyType;

    trait DummyTrait;
    impl DummyImpl1 = MyImpl;
    impl DummyImpl2 of MyTrait::<T>;

    struct DummyStruct {}

    enum DummyEnum {}

    fn my_bar() {

    }

    fn param_test(a: felt252, b: felt252, c: felt252) -> u128 {

    }

    fn no_ret_ty(ref a: u128) {

    }
}

impl abc of abc;

//! > expected_diagnostics
error: Missing token TerminalEq.
 --> lib.cairo:16:20
    impl DummyImpl2 of MyTrait::<T>;
                   ^

error: Missing token TerminalSemicolon.
 --> lib.cairo:16:23
    impl DummyImpl2 of MyTrait::<T>;
                      ^

error: 'of' is a reserved identifier.
 --> lib.cairo:16:21
    impl DummyImpl2 of MyTrait::<T>;
                    ^^

error: Skipped tokens. Expected: Const/Function/Impl/Type or an attribute.
 --> lib.cairo:16:24
    impl DummyImpl2 of MyTrait::<T>;
                       ^***********^

error: Type not found.
 --> lib.cairo:3:35
    fn param_test(ref a: u128) -> bad_type nopanic;
                                  ^******^

error: Not all trait items are implemented. Missing: 'param_test', 'no_ret_ty'.
 --> lib.cairo:7:6
impl MyImpl of MyTrait::<A>;
     ^****^

error: `mod` is not allowed inside impl.
 --> lib.cairo:9:5
    mod a;
    ^*^

error: `use` is not allowed inside impl.
 --> lib.cairo:10:5
    use b;
    ^*^

error: `extern` is not allowed inside impl.
 --> lib.cairo:11:5
    extern fn extern_func() nopanic;
    ^****^

error: `extern` is not allowed inside impl.
 --> lib.cairo:12:5
    extern type DummyType;
    ^****^

error: `trait` is not allowed inside impl.
 --> lib.cairo:14:5
    trait DummyTrait;
    ^***^

error: `struct` is not allowed inside impl.
 --> lib.cairo:18:5
    struct DummyStruct {}
    ^****^

error: `enum` is not allowed inside impl.
 --> lib.cairo:20:5
    enum DummyEnum {}
    ^**^

error: Impl item function `MyImpl2::my_bar` is not a member of trait `MyTrait`.
 --> lib.cairo:22:5
\   fn my_bar() {
|       
|   }
|___^

error: The number of parameters in the impl function `MyImpl2::param_test` is incompatible with `MyTrait::param_test`. Expected: 1, actual: 3.
 --> lib.cairo:26:19
    fn param_test(a: felt252, b: felt252, c: felt252) -> u128 {
                  ^********************************^

error: Parameter type of impl function `MyImpl2::param_test` is incompatible with `MyTrait::param_test`. Expected: `core::integer::u128`, actual: `core::felt252`.
 --> lib.cairo:26:22
    fn param_test(a: felt252, b: felt252, c: felt252) -> u128 {
                     ^*****^

error: Parameter of impl function MyImpl2::param_test is incompatible with MyTrait::param_test. It should be a reference.
 --> lib.cairo:26:19
    fn param_test(a: felt252, b: felt252, c: felt252) -> u128 {
                  ^

error: The signature of function `param_test` is incompatible with trait `MyTrait`. The trait function is declared as nopanic.
 --> lib.cairo:26:18
    fn param_test(a: felt252, b: felt252, c: felt252) -> u128 {
                 ^******************************************^

error: Return type of impl function `MyImpl2::param_test` is incompatible with `MyTrait::param_test`. Expected: `<missing>`, actual: `core::integer::u128`.
 --> lib.cairo:26:58
    fn param_test(a: felt252, b: felt252, c: felt252) -> u128 {
                                                         ^**^

error: Unexpected return type. Expected: "core::integer::u128", found: "()".
 --> lib.cairo:26:63
\   {
|       
|   }
|___^

error: Parameter of impl function MyImpl2::no_ret_ty is incompatible with MyTrait::no_ret_ty. It should not be a reference.
 --> lib.cairo:30:18
    fn no_ret_ty(ref a: u128) {
                 ^*^

error: Return type of impl function `MyImpl2::no_ret_ty` is incompatible with `MyTrait::no_ret_ty`. Expected: `core::felt252`, actual: `()`.
 --> lib.cairo:30:31
    fn no_ret_ty(ref a: u128) {
                              ^

error: Impl item impl `MyImpl2::DummyImpl1` is not a member of trait `MyTrait`.
 --> lib.cairo:15:5
    impl DummyImpl1 = MyImpl;
    ^***********************^

error: Impl item impl `MyImpl2::DummyImpl2` is not a member of trait `MyTrait`.
 --> lib.cairo:16:5
    impl DummyImpl2 of MyTrait::<T>;
    ^*************^

error: Impl not found.
 --> lib.cairo:16:21
    impl DummyImpl2 of MyTrait::<T>;
                    ^

error: Not a trait.
 --> lib.cairo:35:13
impl abc of abc;
            ^*^

//! > ==========================================================================

//! > Test impls of nonexisting traits.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
struct A {}
trait MyTrait<T>;
impl MyImpl3 of NonExistingTrait;
impl MyImpl4 of foo;

//! > expected_diagnostics
error: Trait not found.
 --> lib.cairo:3:17
impl MyImpl3 of NonExistingTrait;
                ^**************^

error: Not a trait.
 --> lib.cairo:4:17
impl MyImpl4 of foo;
                ^*^

//! > ==========================================================================

//! > Test copy and dup impls.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
struct NonCopy {}

struct A {}
enum B {}
struct C {
    x: felt252,
    y: NonCopy
}
enum D {
    X: felt252,
    Y: NonCopy
}
extern type E;

impl ACopy of Copy<A>;
impl ADrop of Drop<A>;
impl BCopy of Copy<B>;
impl BDrop of Drop<B>;
impl CCopy of Copy<C>;
impl CDrop of Drop<C>;
impl DCopy of Copy<D>;
impl DDrop of Drop<D>;
impl ECopy of Copy<E>;
impl EDrop of Drop<E>;
impl TCopy of Copy<()>;
impl TDrop of Drop<()>;
impl T2Copy of Copy<(felt252, NonCopy)>;
impl T2Drop of Drop<(felt252, NonCopy)>;

//! > expected_diagnostics
error: Invalid copy trait implementation, Trait has no implementation in context: core::traits::Copy::<test::NonCopy>.
 --> lib.cairo:19:1
impl CCopy of Copy<C>;
^********************^

error: Invalid drop trait implementation, Trait has no implementation in context: core::traits::Drop::<test::NonCopy>.
 --> lib.cairo:20:1
impl CDrop of Drop<C>;
^********************^

error: Invalid copy trait implementation, Trait has no implementation in context: core::traits::Copy::<test::NonCopy>.
 --> lib.cairo:21:1
impl DCopy of Copy<D>;
^********************^

error: Invalid drop trait implementation, Trait has no implementation in context: core::traits::Drop::<test::NonCopy>.
 --> lib.cairo:22:1
impl DDrop of Drop<D>;
^********************^

error: Invalid copy trait implementation, Trait has no implementation in context: core::traits::Copy::<test::NonCopy>.
 --> lib.cairo:27:1
impl T2Copy of Copy<(felt252, NonCopy)>;
^**************************************^

error: Invalid drop trait implementation, Trait has no implementation in context: core::traits::Drop::<test::NonCopy>.
 --> lib.cairo:28:1
impl T2Drop of Drop<(felt252, NonCopy)>;
^**************************************^

//! > ==========================================================================

//! > Mutable param is not allowed in trait functions.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    fn f(mut a: felt252);
}

//! > expected_diagnostics
error: Parameter of trait function `MyTrait::f` can't be defined as mutable.
 --> lib.cairo:2:10
    fn f(mut a: felt252);
         ^*^

//! > ==========================================================================

//! > Impl function param can be mutable or immutable.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    fn f(a: felt252);
}
impl MyImpl<T> of MyTrait<T> {
    fn f(a: felt252) {}
}
impl MyImpl2<T> of MyTrait<T> {
    fn f(mut a: felt252) {}
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Test trait function with body.

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    fn foo() {}
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Test no impls of trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {
    MyTrait::foo()
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    fn foo();
}

//! > expected_diagnostics
error: Trait has no implementation in context: test::MyTrait.
 --> lib.cairo:5:14
    MyTrait::foo()
             ^*^

//! > ==========================================================================

//! > Test multiple impls of trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {
    MyTrait::foo()
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    fn foo();
}
impl MyImpl1 of MyTrait {
    fn foo() {}
}
impl MyImpl2 of MyTrait {
    fn foo() {}
}

//! > expected_diagnostics
error: Trait `test::MyTrait` has multiple implementations, in: `test::MyImpl1`, `test::MyImpl2`
 --> lib.cairo:11:14
    MyTrait::foo()
             ^*^

//! > ==========================================================================

//! > Test missing functions in empty impl.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    fn foo1();
    fn foo2();
}
impl MyImpl of MyTrait;

//! > expected_diagnostics
error: Not all trait items are implemented. Missing: 'foo1', 'foo2'.
 --> lib.cairo:5:6
impl MyImpl of MyTrait;
     ^****^

//! > ==========================================================================

//! > Test missing items in empty impl.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait OtherTrait {}
trait MyTrait {
    fn foo1();
    fn foo2();
    type X;
    const C: u32;
    impl Z: OtherTrait;
}
impl MyImpl of MyTrait;
// TODO(TomerStarkware): improve diagnostics for missing impls.

//! > expected_diagnostics
error: Not all trait items are implemented. Missing: 'foo1', 'foo2', 'X', 'C'.
 --> lib.cairo:9:6
impl MyImpl of MyTrait;
     ^****^

error: Cannot infer implicit impl `Z.`
Could not find implementation of trait `test::OtherTrait`
 --> lib.cairo:9:1
impl MyImpl of MyTrait;
^*********************^

error: Trait has no implementation in context: test::OtherTrait.
 --> lib.cairo:9:1
impl MyImpl of MyTrait;
^*********************^

//! > ==========================================================================

//! > Test missing items in nonempty impl.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait OtherTrait {}
mod inner {
    impl I of super::OtherTrait {}
}
trait MyTrait {
    fn foo1();
    fn foo2();
    fn foo3();
    type X;
    type Y;
    const C: u32;
    const D: u32;
    impl E: OtherTrait;
    impl F: OtherTrait;
}
impl MyImpl of MyTrait {
    type X = u32;
    const C: u32 = 3;
    impl E = inner::I;
    fn foo2() {}
}

//! > expected_diagnostics
error: Not all trait items are implemented. Missing: 'foo1', 'foo3', 'Y', 'D'.
 --> lib.cairo:16:6
impl MyImpl of MyTrait {
     ^****^

error: Cannot infer implicit impl `F.`
Could not find implementation of trait `test::OtherTrait`
 --> lib.cairo:16:1
\   impl MyImpl of MyTrait {
|       type X = u32;
|       const C: u32 = 3;
|       impl E = inner::I;
|       fn foo2() {}
|   }
|___^

error: Trait has no implementation in context: test::OtherTrait.
 --> lib.cairo:16:1
\   impl MyImpl of MyTrait {
|       type X = u32;
|       const C: u32 = 3;
|       impl E = inner::I;
|       fn foo2() {}
|   }
|___^

//! > ==========================================================================

//! > Test impl items that don't exist in the trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {}
impl MyImpl of MyTrait {
    type X = u32;
    const C: u32 = 3;
    impl E = Self;
    fn bar() {}
}

//! > expected_diagnostics
error: Impl item function `MyImpl::bar` is not a member of trait `MyTrait`.
 --> lib.cairo:6:5
    fn bar() {}
    ^*********^

error: Impl item type `MyImpl::X` is not a member of trait `MyTrait`.
 --> lib.cairo:3:5
    type X = u32;
    ^***********^

error: Impl item const `MyImpl::C` is not a member of trait `MyTrait`.
 --> lib.cairo:4:5
    const C: u32 = 3;
    ^***************^

error: Impl item impl `MyImpl::E` is not a member of trait `MyTrait`.
 --> lib.cairo:5:5
    impl E = Self;
    ^************^

//! > ==========================================================================

//! > Verify that the relevant diagnostic is issued when a concrete parameter type is inconsistent

//! > with the assignment of the generic args of the trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bla() {}

//! > function_name
bla

//! > module_code
trait Identity<T> {
    fn foo(a: T);
}

impl Felt252Identity of Identity<felt252> {
    fn foo(a: u128) {}
}

//! > expected_diagnostics
error: Parameter type of impl function `Felt252Identity::foo` is incompatible with `Identity::foo`. Expected: `core::felt252`, actual: `core::integer::u128`.
 --> lib.cairo:6:15
    fn foo(a: u128) {}
              ^**^

//! > ==========================================================================

//! > Verify that the relevant diagnostic is issued when a concrete return type is inconsistent with

//! > the assignment of the generic args of the trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bla() {}

//! > function_name
bla

//! > module_code
trait Identity<T> {
    fn foo() -> T;
}

impl Felt252Identity of Identity<felt252> {
    fn foo() -> u128 {
        3_u128
    }
}

//! > expected_diagnostics
error: Return type of impl function `Felt252Identity::foo` is incompatible with `Identity::foo`. Expected: `core::felt252`, actual: `core::integer::u128`.
 --> lib.cairo:6:17
    fn foo() -> u128 {
                ^**^

//! > ==========================================================================

//! > Repeating generic params in trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn bla() {}

//! > function_name
bla

//! > module_code
trait Identity<T, T> {
    fn foo(a: T);
}

impl Felt252Identity of Identity<felt252, felt252> {
    fn foo(a: felt252) {}
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Repeating generic params in trait and function.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bla() {}

//! > function_name
bla

//! > module_code
trait Identity<T> {
    fn foo<T>(a: T);
}

impl Felt252Identity of Identity<felt252> {
    fn foo<T>(a: felt252) {}
}

//! > expected_diagnostics
error: Parameter type of impl function `Felt252Identity::foo` is incompatible with `Identity::foo`. Expected: `T`, actual: `core::felt252`.
 --> lib.cairo:6:18
    fn foo<T>(a: felt252) {}
                 ^*****^

//! > ==========================================================================

//! > Matching generic arguments of functions in trait/impl.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn bla() {}

//! > function_name
bla

//! > module_code
trait Identity<T> {
    fn foo<S>(a: T, b: S);
}

impl Felt252Identity of Identity<felt252> {
    fn foo<S>(a: felt252, b: S) {}
}

//! > expected_diagnostics

//! > ==========================================================================

//! > trait/impl type declared twice.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bla() {}

//! > function_name
bla

//! > module_code
trait MyTrait<T> {
    type X;
    type X;
}

impl MyImpl of MyTrait<felt252> {
    type X = u32;
    type X = u64;
}

//! > expected_diagnostics
error: The name `X` is defined multiple times.
 --> lib.cairo:3:10
    type X;
         ^

error: The name `X` is defined multiple times.
 --> lib.cairo:8:10
    type X = u64;
         ^

//! > ==========================================================================

//! > trait/impl const declared twice.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bla() {}

//! > function_name
bla

//! > module_code
trait MyTrait<T> {
    const X: i32;
    const X: i32;
}
///TODO(TomerStarkware): add multiple impls of the same const when it is supported.

//! > expected_diagnostics
error: The name `X` is defined multiple times.
 --> lib.cairo:3:11
    const X: i32;
          ^

//! > ==========================================================================

//! > trait/impl impl declared twice.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bla() {}

//! > function_name
bla

//! > module_code
trait MyTrait<T> {
    impl X: MyTrait<u32>;
    impl X: MyTrait<i32>;
}
impl MyImpl<T> of MyTrait<T> {
    impl X = MyImpl<u32>;
    impl X = MyImpl<i32>;
}

//! > expected_diagnostics
error: The name `X` is defined multiple times.
 --> lib.cairo:3:10
    impl X: MyTrait<i32>;
         ^

error: The name `X` is defined multiple times.
 --> lib.cairo:7:10
    impl X = MyImpl<i32>;
         ^

error: Expected an impl of `test::MyTrait::<core::integer::i32>`. Got an impl of `test::MyTrait::<core::integer::u32>`.
 --> lib.cairo:6:5
    impl X = MyImpl<u32>;
    ^*******************^

//! > ==========================================================================

//! > trait/impl function declared twice.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bla() {}

//! > function_name
bla

//! > module_code
trait MyTrait<T> {
    fn foo<S>(a: T, b: S, c: felt252);
    fn foo<S>(a: T, b: S);
}

impl MyImpl of MyTrait<felt252> {
    fn foo<S>(a: felt252, b: S, c: felt252) {}
    fn foo<S>(a: felt252, b: S) {}
}

//! > expected_diagnostics
error: The name `foo` is defined multiple times.
 --> lib.cairo:3:8
    fn foo<S>(a: T, b: S);
       ^*^

error: The name `foo` is defined multiple times.
 --> lib.cairo:8:8
    fn foo<S>(a: felt252, b: S) {}
       ^*^

error: The number of parameters in the impl function `MyImpl::foo` is incompatible with `MyTrait::foo`. Expected: 2, actual: 3.
 --> lib.cairo:7:15
    fn foo<S>(a: felt252, b: S, c: felt252) {}
              ^**************************^

//! > ==========================================================================

//! > Test impl of an impl instead of trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bla() {}

//! > function_name
bla

//! > module_code
trait t1 {}
impl imp1 of t1 {}
impl imp2 of imp1 {}
impl imp3 of imp3 {}
mod inner {
    trait t_inner {}
    impl imp of t_inner {}
}
use inner::imp as inner_imp;
impl imp4 of inner_imp {}

//! > expected_diagnostics
error: Not a trait.
 --> lib.cairo:3:14
impl imp2 of imp1 {}
             ^**^

error: Not a trait.
 --> lib.cairo:4:14
impl imp3 of imp3 {}
             ^**^

error: Not a trait.
 --> lib.cairo:10:14
impl imp4 of inner_imp {}
             ^*******^

//! > ==========================================================================

//! > Test type items in trait/impl.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type X;
}
impl MyImpl of MyTrait {
    type X = u32;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Test const items in trait/impl.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    const X: u32;
    fn foo() -> u32;
}

impl MyImpl of MyTrait {
    const X: u32 = 3;
    fn foo() -> u32 {
        Self::X
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Test `Self` in impls.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    fn foo1() -> u32;
    fn foo2() -> u32;
}
impl MyImpl of MyTrait {
    fn foo1() -> u32 {
        Self::foo2()
    }
    fn foo2() -> u32 {
        3
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Type mismatch with `Self` in impls.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    fn foo1() -> u32;
    fn foo2() -> u16;
}
impl MyImpl of MyTrait {
    fn foo1() -> u32 {
        Self::foo2()
    }
    fn foo2() -> u16 {
        3
    }
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:6:22
\   {
|       Self::foo2()
|   }
|___^

//! > ==========================================================================

//! > `Self` can't be non-first segment.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
mod inner {
    trait MyTrait {
        fn foo1();
        fn foo2();
    }
    impl MyImpl of MyTrait {
        fn foo1() {
            super::inner::Self::foo2(); // This is not ok.
        }
        fn foo2() {}
    }
}

//! > expected_diagnostics
error: `Self` can only be the first segment of a path.
 --> lib.cairo:8:27
            super::inner::Self::foo2(); // This is not ok.
                          ^**^

//! > ==========================================================================

//! > Type mismatch of trait and impl functions.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    fn foo(x: u16, y: u16) -> u16;
}
impl MyImpl of MyTrait {
    fn foo(x: u32, y: u32) -> u32 {
        x
    }
}

//! > expected_diagnostics
error: Parameter type of impl function `MyImpl::foo` is incompatible with `MyTrait::foo`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:5:15
    fn foo(x: u32, y: u32) -> u32 {
              ^*^

error: Parameter type of impl function `MyImpl::foo` is incompatible with `MyTrait::foo`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:5:23
    fn foo(x: u32, y: u32) -> u32 {
                      ^*^

error: Return type of impl function `MyImpl::foo` is incompatible with `MyTrait::foo`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:5:31
    fn foo(x: u32, y: u32) -> u32 {
                              ^*^

//! > ==========================================================================

//! > Type in IntoIterator Trait implementation do not Have implementation for Iterator Trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
#[derive(Drop)]
pub struct Foo {}
pub struct FooIter {}

#[feature("collections-into-iter")]
impl FooIntoIterator of core::iter::IntoIterator<Foo> {
    type IntoIter = FooIter;

    fn into_iter(self: Foo) -> FooIter {
        FooIter {}
    }
}

//! > expected_diagnostics
error: Cannot infer implicit impl `Iterator.`
Could not find implementation of trait `core::iter::traits::iterator::Iterator::<test::FooIter>`
 --> lib.cairo:5:1
\   #[feature("collections-into-iter")]
|   impl FooIntoIterator of core::iter::IntoIterator<Foo> {
|       type IntoIter = FooIter;
|       
|       fn into_iter(self: Foo) -> FooIter {
|           FooIter {}
|       }
|   }
|___^

error: Trait has no implementation in context: core::iter::traits::iterator::Iterator::<test::FooIter>.
 --> lib.cairo:5:1
\   #[feature("collections-into-iter")]
|   impl FooIntoIterator of core::iter::IntoIterator<Foo> {
|       type IntoIter = FooIter;
|       
|       fn into_iter(self: Foo) -> FooIter {
|           FooIter {}
|       }
|   }
|___^

//! > ==========================================================================

//! > Deref trait cycle of two impls.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
struct A {}
struct B {}

impl ADeref of core::ops::Deref<A> {
    type Target = B;
    fn deref(self: A) -> B {
        B {}
    }
}

impl BDeref of core::ops::Deref<B> {
    type Target = A;
    fn deref(self: B) -> A {
        A {}
    }
}

//! > expected_diagnostics
error: Deref impls cycle detected:
core::ops::deref::Deref::<test::B> -> core::ops::deref::Deref::<test::A>
 --> lib.cairo:11:1
\   impl BDeref of core::ops::Deref<B> {
|       type Target = A;
|       fn deref(self: B) -> A {
|           A {}
|       }
|   }
|___^

error: Deref impls cycle detected:
core::ops::deref::Deref::<test::A> -> core::ops::deref::Deref::<test::B>
 --> lib.cairo:4:1
\   impl ADeref of core::ops::Deref<A> {
|       type Target = B;
|       fn deref(self: A) -> B {
|           B {}
|       }
|   }
|___^

//! > ==========================================================================

//! > Deref trait cycle of three impls.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
struct A {}
struct B {}
struct C {}

impl ADeref of core::ops::Deref<A> {
    type Target = B;
    fn deref(self: A) -> B {
        B {}
    }
}

impl BDeref of core::ops::Deref<B> {
    type Target = C;
    fn deref(self: B) -> C {
        C {}
    }
}

impl CDeref of core::ops::Deref<C> {
    type Target = A;
    fn deref(self: C) -> A {
        A {}
    }
}

//! > expected_diagnostics
error: Deref impls cycle detected:
core::ops::deref::Deref::<test::B> -> core::ops::deref::Deref::<test::C> -> core::ops::deref::Deref::<test::A>
 --> lib.cairo:12:1
\   impl BDeref of core::ops::Deref<B> {
|       type Target = C;
|       fn deref(self: B) -> C {
|           C {}
|       }
|   }
|___^

error: Deref impls cycle detected:
core::ops::deref::Deref::<test::C> -> core::ops::deref::Deref::<test::A> -> core::ops::deref::Deref::<test::B>
 --> lib.cairo:19:1
\   impl CDeref of core::ops::Deref<C> {
|       type Target = A;
|       fn deref(self: C) -> A {
|           A {}
|       }
|   }
|___^

error: Deref impls cycle detected:
core::ops::deref::Deref::<test::A> -> core::ops::deref::Deref::<test::B> -> core::ops::deref::Deref::<test::C>
 --> lib.cairo:5:1
\   impl ADeref of core::ops::Deref<A> {
|       type Target = B;
|       fn deref(self: A) -> B {
|           B {}
|       }
|   }
|___^

//! > ==========================================================================

//! > Inferring impl var from struct generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: *)

//! > function
fn foo1() -> felt252 {
    2
}

//! > function_name
foo1

//! > module_code
pub trait Tr {}
impl I0 of Tr {}

struct A<impl I: Tr> {}

fn foo<impl I: Tr>(x: A<I>) -> A<I> {
    x
}
fn bar<impl I: Tr>(x: A<I>) -> A<I> {
    foo(x)
}

//! > expected_diagnostics

//! > ==========================================================================

//! > trait cycle of generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: *)

//! > function
fn foo() -> felt252 {
    2
}

//! > function_name
foo

//! > module_code
pub trait Tr<+Tr> {}

//! > expected_diagnostics
error: Cycle detected while resolving generic param. Try specifying the generic impl parameter explicitly to break the cycle.
 --> lib.cairo:1:14
pub trait Tr<+Tr> {}
             ^*^

//! > ==========================================================================

//! > cycle with anonymous impl with impl alias instead of trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: *)

//! > function
fn foo() -> felt252 {
    2
}

//! > function_name
foo

//! > module_code
trait Tr {}
impl I0<T, +Ifelt252> of Tr {}
impl Ifelt = I0<Ifelt>;

//! > expected_diagnostics
error: Trait not found.
 --> lib.cairo:2:13
impl I0<T, +Ifelt252> of Tr {}
            ^******^

error: Cycle detected while resolving 'impls alias' items.
 --> lib.cairo:3:6
impl Ifelt = I0<Ifelt>;
     ^***^
