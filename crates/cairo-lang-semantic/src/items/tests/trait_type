//! > Test type items in trait/impl.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    MyImpl::foo1(3_u32);
    MyImpl::foo2(3_u32);
    MyImpl::foo3(3_u32);
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType) -> Self::OutputType;
    fn foo2(x: Self::InputType) -> Self::OutputType;
    fn foo3(x: u32) -> u32;
}
impl MyImpl of MyTrait {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: Self::InputType) -> Self::OutputType {
        x
    }
    fn foo2(x: u32) -> u32 {
        x
    }
    fn foo3(x: Self::InputType) -> Self::OutputType {
        x
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Trait type with generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType, t: T) -> Self::OutputType;
}
impl MyImpl<T> of MyTrait<T> {
    type InputType = T;
    type OutputType = T;
    fn foo(x: Self::InputType, t: T) -> Self::OutputType {
        x
    }
}
impl MyImplU32 of MyTrait<u32> {
    type InputType = u32;
    type OutputType = u32;
    fn foo(x: Self::InputType, t: u32) -> Self::OutputType {
        x
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Trait type with no impl in context, no generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType) -> Self::OutputType;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Trait type with no impl in context, with generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType, t: T) -> Self::OutputType;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Test type items in trait/impl with generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    MyImpl::<u32>::foo1(3_u32);
    MyImpl::<u32>::foo2(3_u32);
    MyImpl::<u32>::foo3(3_u32);
}

//! > function_name
foo

//! > module_code
trait MyTrait<T, S> {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType) -> Self::OutputType;
    fn foo2(x: Self::InputType) -> Self::OutputType;
    fn foo3(x: u32) -> u32;
}
impl MyImpl<T> of MyTrait<T, u32> {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: Self::InputType) -> Self::OutputType {
        x
    }
    fn foo2(x: u32) -> u32 {
        x
    }
    fn foo3(x: Self::InputType) -> Self::OutputType {
        x
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > A trait, without generics, shouldn't be used in a path in its own body.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: MyTrait::InputType) -> MyTrait::OutputType;
}

//! > expected_diagnostics
warning: In a trait, paths of the same trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:4:15
    fn foo(x: MyTrait::InputType) -> MyTrait::OutputType;
              ^^^^^^^

warning: In a trait, paths of the same trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:4:38
    fn foo(x: MyTrait::InputType) -> MyTrait::OutputType;
                                     ^^^^^^^

//! > ==========================================================================

//! > A trait shouldn't be used in a path in its own body, with the same generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo(x: MyTrait::<T>::InputType) -> MyTrait::<T>::OutputType;
}

//! > expected_diagnostics
warning: In a trait, paths of the same trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:4:15
    fn foo(x: MyTrait::<T>::InputType) -> MyTrait::<T>::OutputType;
              ^^^^^^^^^^^^

warning: In a trait, paths of the same trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:4:43
    fn foo(x: MyTrait::<T>::InputType) -> MyTrait::<T>::OutputType;
                                          ^^^^^^^^^^^^

//! > ==========================================================================

//! > A trait can be used in a path in its own body, if the generics are different.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo(x: MyTrait::<u32>::InputType) -> MyTrait::<u32>::OutputType;
}
impl MyImpl of MyTrait<u32> {
    type InputType = u32;
    type OutputType = u32;
    fn foo(x: Self::InputType) -> Self::OutputType {
        x
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > A trait in a path in its own body should be fully explicit.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait SomeTrait {}
trait MyTrait<T, +SomeTrait> {
    type InputType;
    fn foo(x: MyTrait::<T>::InputType);
}

//! > expected_diagnostics
warning: In a trait, paths of the same trait must be fully explicit. Either use `Self` if this is the intention, or explicitly specify all the generic arguments.
 --> lib.cairo:4:15
    fn foo(x: MyTrait::<T>::InputType);
              ^^^^^^^^^^^^

//! > ==========================================================================

//! > An impl, without generics, shouldn't be used in a path in its own body.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType) -> Self::OutputType;
    fn foo2();
}
impl MyImpl of MyTrait {
    type InputType = u32;
    type OutputType = u32;
    fn foo(x: MyImpl::InputType) -> MyImpl::OutputType {
        x
    }
    fn foo2() {
        let _: MyImpl::InputType = 3_u32;
    }
}

//! > expected_diagnostics
warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:15
    fn foo(x: MyImpl::InputType) -> MyImpl::OutputType {
              ^^^^^^

warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:37
    fn foo(x: MyImpl::InputType) -> MyImpl::OutputType {
                                    ^^^^^^

warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:14:16
        let _: MyImpl::InputType = 3_u32;
               ^^^^^^

//! > ==========================================================================

//! > An impl shouldn't be used in a path in its own body, with the same generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType) -> Self::OutputType;
}
impl MyImpl<T> of MyTrait {
    type InputType = T;
    type OutputType = T;
    fn foo(x: MyImpl::<T>::InputType) -> MyImpl::<T>::OutputType {
        let y: MyImpl::<T>::InputType = x;
        y
    }
}

//! > expected_diagnostics
warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:9:15
    fn foo(x: MyImpl::<T>::InputType) -> MyImpl::<T>::OutputType {
              ^^^^^^^^^^^

warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:9:42
    fn foo(x: MyImpl::<T>::InputType) -> MyImpl::<T>::OutputType {
                                         ^^^^^^^^^^^

warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:16
        let y: MyImpl::<T>::InputType = x;
               ^^^^^^^^^^^

//! > ==========================================================================

//! > An impl can be used in a path in its own body, if the generics are different.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType, y: Self::InputType) -> Self::OutputType;
}
impl MyImpl<T> of MyTrait<T> {
    type InputType = T;
    type OutputType = T;
    fn foo(x: MyImpl::<u32>::InputType, y: Self::InputType) -> MyImpl::<u32>::OutputType {
        let z: MyImpl::<u32>::InputType = x;
        z
    }
}

//! > expected_diagnostics
error: Parameter type of impl function `MyImpl::foo` is incompatible with `MyTrait::foo`. Expected: `T`, actual: `core::integer::u32`.
 --> lib.cairo:9:15
    fn foo(x: MyImpl::<u32>::InputType, y: Self::InputType) -> MyImpl::<u32>::OutputType {
              ^^^^^^^^^^^^^^^^^^^^^^^^

error: Return type of impl function `MyImpl::foo` is incompatible with `MyTrait::foo`. Expected: `T`, actual: `core::integer::u32`.
 --> lib.cairo:9:64
    fn foo(x: MyImpl::<u32>::InputType, y: Self::InputType) -> MyImpl::<u32>::OutputType {
                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > An impl in a path in its own body should be fully explicit.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait SomeTrait {}
trait MyTrait {
    type InputType;
    fn foo();
}
impl MyImpl<T, +SomeTrait> of MyTrait {
    type InputType = u32;
    fn foo() {
        let _: MyImpl::<T>::InputType = 3;
    }
}

//! > expected_diagnostics
warning: In an impl, paths of the same impl must be fully explicit. Either use `Self` if this is the intention, or explicitly specify all the generic arguments.
 --> lib.cairo:9:16
        let _: MyImpl::<T>::InputType = 3;
               ^^^^^^^^^^^

//! > ==========================================================================

//! > A trait, without generics, shouldn't be used in a path in the body of its own impl.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType) -> Self::OutputType;
    fn foo2();
}
impl MyImpl of MyTrait {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: MyTrait::InputType) -> MyTrait::OutputType {
        x
    }
    fn foo2() {
        let _: MyTrait::InputType = 3_u32;
    }
}

//! > expected_diagnostics
warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:16
    fn foo1(x: MyTrait::InputType) -> MyTrait::OutputType {
               ^^^^^^^

warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:39
    fn foo1(x: MyTrait::InputType) -> MyTrait::OutputType {
                                      ^^^^^^^

warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:14:16
        let _: MyTrait::InputType = 3_u32;
               ^^^^^^^

//! > ==========================================================================

//! > A trait shouldn't be used in a path in the body of its own impl, with the same generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType) -> Self::OutputType;
    fn foo2();
}
impl MyImpl of MyTrait<u32> {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: MyTrait::<u32>::InputType) -> MyTrait::<u32>::OutputType {
        x
    }
    fn foo2() {
        let _: MyTrait::<u32>::InputType = 3_u32;
    }
}

//! > expected_diagnostics
warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:16
    fn foo1(x: MyTrait::<u32>::InputType) -> MyTrait::<u32>::OutputType {
               ^^^^^^^^^^^^^^

warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:46
    fn foo1(x: MyTrait::<u32>::InputType) -> MyTrait::<u32>::OutputType {
                                             ^^^^^^^^^^^^^^

warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:14:16
        let _: MyTrait::<u32>::InputType = 3_u32;
               ^^^^^^^^^^^^^^

//! > ==========================================================================

//! > A trait can be used in a path in the body of an impl of it, if the generics are different.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType) -> Self::OutputType;
}
impl MyImpl_u16 of MyTrait<u16> {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: MyTrait::<u32>::InputType) -> MyTrait::<u32>::OutputType {
        let y: MyTrait::<u32>::InputType = 3_u32;
        y
    }
}
impl MyImpl_u32 of MyTrait<u32> {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: Self::InputType) -> Self::OutputType {
        let y: Self::InputType = 3_u32;
        y
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Incompatible signatures with trait/impl type items.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType);
    fn foo2() -> Self::OutputType;
    fn foo3(x: u16);
    fn foo4() -> u16;
}
impl MyImpl of MyTrait {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: u16) {} // param type doesn't match.
    fn foo2() -> u16 {
        1_u16
    } // return type doesn't match.
    fn foo3(x: Self::InputType) {} // param type doesn't match.
    fn foo4() -> Self::OutputType {
        1_u32
    } // return type doesn't match.
}

//! > expected_diagnostics
error: Parameter type of impl function `MyImpl::foo1` is incompatible with `MyTrait::foo1`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:12:16
    fn foo1(x: u16) {} // param type doesn't match.
               ^^^

error: Return type of impl function `MyImpl::foo2` is incompatible with `MyTrait::foo2`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:13:18
    fn foo2() -> u16 {
                 ^^^

error: Parameter type of impl function `MyImpl::foo3` is incompatible with `MyTrait::foo3`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:16:16
    fn foo3(x: Self::InputType) {} // param type doesn't match.
               ^^^^^^^^^^^^^^^

error: Return type of impl function `MyImpl::foo4` is incompatible with `MyTrait::foo4`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:17:18
    fn foo4() -> Self::OutputType {
                 ^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > Member access of impl type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    let x = MyStruct { value: 3_u32 };
    let _: MyStruct<u32> = MyImpl::foo(x);
}

//! > function_name
foo

//! > module_code
struct MyStruct<T> {
    value: T,
}
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType) -> Self::OutputType;
}
impl MyImpl of MyTrait {
    type InputType = MyStruct<u32>;
    type OutputType = MyStruct<u32>;
    fn foo(x: Self::InputType) -> Self::OutputType {
        MyStruct { value: x.value }
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Method call on impl type that has this method.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    MyImpl::foo(Some(3));
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = Option<usize>;
    fn foo(x: Self::InputType) {
        x.unwrap();
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Method call on impl type that doesn't have this method.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = usize;
    fn foo(x: Self::InputType) {
        x.unwrap();
    }
}

//! > expected_diagnostics
error[E0002]: Method `unwrap` could not be called on type `core::integer::u32`.
Candidate `core::option::OptionTrait::unwrap` inference failed with: Type mismatch: `core::integer::u32` and `core::option::Option::<?0>`.
Candidate `core::result::ResultTrait::unwrap` inference failed with: Type mismatch: `core::integer::u32` and `core::result::Result::<?0, ?1>`.
 --> lib.cairo:8:11
        x.unwrap();
          ^^^^^^

//! > ==========================================================================

//! > Unary operator on impl type that implements it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    MyImpl::foo(3);
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = i32;
    fn foo(x: Self::InputType) {
        -x;
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Unary operator on impl type that doesn't implement it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = u32;
    fn foo(x: Self::InputType) {
        -x; // u32 doesn't implement `Neg`.
    }
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::traits::Neg::<core::integer::u32>.
 --> lib.cairo:8:9
        -x; // u32 doesn't implement `Neg`.
        ^^

//! > ==========================================================================

//! > Binary operator on impl types that implement it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    let _: usize = MyImpl::foo(3, 4);
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType1;
    type InputType2;
    type OutputType;
    fn foo(x: Self::InputType1, y: Self::InputType2) -> Self::OutputType;
}
impl MyImpl of MyTrait {
    type InputType1 = usize;
    type InputType2 = usize;
    type OutputType = usize;
    fn foo(x: Self::InputType1, y: Self::InputType2) -> Self::OutputType {
        x + y
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Binary operator on impl type that doesn't implement it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = Option<usize>;
    fn foo(x: Self::InputType) {
        let _ = x + x; // Option<usize> doesn't implement `Add`.
    }
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::traits::Add::<core::option::Option::<core::integer::u32>>.
 --> lib.cairo:8:17
        let _ = x + x; // Option<usize> doesn't implement `Add`.
                ^^^^^

//! > ==========================================================================

//! > Indexing an impl type that implements `Index`.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    MyImpl::foo(array![0]);
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType) -> Self::OutputType;
}
impl MyImpl of MyTrait {
    type InputType = Array<usize>;
    type OutputType = usize;
    fn foo(x: Self::InputType) -> Self::OutputType {
        *x[0_u32]
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Indexing an impl type that doesn't implement `Index`.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = usize;
    fn foo(x: Self::InputType) {
        x[0];
    }
}

//! > expected_diagnostics
error: Type `core::integer::u32` could not be indexed.
Candidate `core::ops::index::Index::index` inference failed with: Trait has no implementation in context: core::ops::index::Index::<core::integer::u32, ?2>.
Candidate `core::ops::index::IndexView::index` inference failed with: Trait has no implementation in context: core::ops::index::IndexView::<core::integer::u32, ?2>.
 --> lib.cairo:8:9
        x[0];
        ^^^^

//! > ==========================================================================

//! > Using traits' items is allowed in other traits, if well resolved.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl of AnotherTrait {
    type AnotherType = u32;
}
trait MyTrait {
    fn bar1(x: AnotherTrait::AnotherType);
    fn bar2() -> AnotherTrait::AnotherType;
}
impl MyImpl of MyTrait {
    fn bar1(x: u32) {}
    fn bar2() -> u32 {
        3_u32
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Using traits' items in other traits, well resolved, but with type mismatch.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl of AnotherTrait {
    type AnotherType = u16;
}
trait MyTrait {
    fn bar1(x: AnotherTrait::AnotherType);
    fn bar2() -> AnotherTrait::AnotherType;
}
impl MyImpl of MyTrait {
    fn bar1(x: u32) {}
    fn bar2() -> u32 {
        3_u32
    }
}

//! > expected_diagnostics
error: Parameter type of impl function `MyImpl::bar1` is incompatible with `MyTrait::bar1`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:12:16
    fn bar1(x: u32) {}
               ^^^

error: Return type of impl function `MyImpl::bar2` is incompatible with `MyTrait::bar2`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:13:18
    fn bar2() -> u32 {
                 ^^^

//! > ==========================================================================

//! > Using traits' items in other traits, but they can't be resolved.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
// A trait with 0 impls in the context.
trait AnotherTrait0 {
    type AnotherType;
}
// A trait with 2 impls in the context.
trait AnotherTrait2 {
    type AnotherType;
}
impl AnotherImpl20 of AnotherTrait2 {
    type AnotherType = u32;
}
impl AnotherImpl21 of AnotherTrait2 {
    type AnotherType = u32;
}
trait MyTrait {
    type MyType;
    fn bar1(x: AnotherTrait0::AnotherType);
    fn bar2() -> AnotherTrait0::AnotherType;
    fn bar3(x: AnotherTrait2::AnotherType);
    fn bar4() -> AnotherTrait2::AnotherType;
}

//! > expected_diagnostics
error: Trait has no implementation in context: test::AnotherTrait0.
 --> lib.cairo:17:31
    fn bar1(x: AnotherTrait0::AnotherType);
                              ^^^^^^^^^^^

error: Trait has no implementation in context: test::AnotherTrait0.
 --> lib.cairo:18:33
    fn bar2() -> AnotherTrait0::AnotherType;
                                ^^^^^^^^^^^

error: Trait `test::AnotherTrait2` has multiple implementations, in: `test::AnotherImpl20`, `test::AnotherImpl21`
 --> lib.cairo:19:31
    fn bar3(x: AnotherTrait2::AnotherType);
                              ^^^^^^^^^^^

error: Trait `test::AnotherTrait2` has multiple implementations, in: `test::AnotherImpl20`, `test::AnotherImpl21`
 --> lib.cairo:20:33
    fn bar4() -> AnotherTrait2::AnotherType;
                                ^^^^^^^^^^^

//! > ==========================================================================

//! > traits' items are resolved when there is a single impl in context.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl of AnotherTrait {
    type AnotherType = u32;
}
trait MyTrait {
    type MyType;
    fn foo1() -> u32;
    fn foo2(x: u32);
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn foo1() -> AnotherTrait::AnotherType {
        3_u32
    }
    fn foo2(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> MyTrait::MyType {
    3_u32
}
fn bar2(x: MyTrait::MyType) {
    let _: u32 = x;
}
fn bar3() {
    let _: MyTrait::MyType = 3_u32;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Mismatch of resolved traits' items when there is a single impl in context.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl of AnotherTrait {
    type AnotherType = u16;
}
trait MyTrait {
    type MyType;
    fn foo1() -> u32;
    fn foo2(x: u32);
}
impl MyImpl of MyTrait {
    type MyType = u16;
    fn foo1() -> AnotherTrait::AnotherType {
        3
    }
    fn foo2(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> MyTrait::MyType {
    3_u32
}
fn bar2(x: MyTrait::MyType) {
    let _: u32 = x;
}
fn bar3() {
    let _: MyTrait::MyType = 3_u32;
}

//! > expected_diagnostics
error: Return type of impl function `MyImpl::foo1` is incompatible with `MyTrait::foo1`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:14:18
    fn foo1() -> AnotherTrait::AnotherType {
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

error: Parameter type of impl function `MyImpl::foo2` is incompatible with `MyTrait::foo2`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:17:16
    fn foo2(x: AnotherTrait::AnotherType) {}
               ^^^^^^^^^^^^^^^^^^^^^^^^^

error: Unexpected return type. Expected: "core::integer::u16", found: "core::integer::u32".
 --> lib.cairo:19:14
fn bar1() -> MyTrait::MyType {
             ^^^^^^^^^^^^^^^

error: Unexpected argument type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:23:18
    let _: u32 = x;
                 ^

error: `test::MyImpl::MyType` type mismatch: `core::integer::u32` and `core::integer::u16`.
 --> lib.cairo:26:21
    let _: MyTrait::MyType = 3_u32;
                    ^^^^^^

//! > ==========================================================================

//! > traits' items can't be resolved if there is no impl in context.

//! > TODO(yuval): try to eliminate redundant/duplicate diagnostics. Here and in other tests.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
trait MyTrait {
    fn foo1() -> u32;
    fn foo2(x: u32);
}
impl MyImpl of MyTrait {
    fn foo1() -> AnotherTrait::AnotherType {
        3_u32
    }
    fn foo2(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> AnotherTrait::AnotherType {
    3_u32
}
fn bar2(x: AnotherTrait::AnotherType) {}
fn bar3() {
    let _: AnotherTrait::AnotherType = 3_u32;
}

//! > expected_diagnostics
error: Trait has no implementation in context: test::AnotherTrait.
 --> lib.cairo:9:32
    fn foo1() -> AnotherTrait::AnotherType {
                               ^^^^^^^^^^^

error: Trait has no implementation in context: test::AnotherTrait.
 --> lib.cairo:12:30
    fn foo2(x: AnotherTrait::AnotherType) {}
                             ^^^^^^^^^^^

error: Trait has no implementation in context: test::AnotherTrait.
 --> lib.cairo:14:28
fn bar1() -> AnotherTrait::AnotherType {
                           ^^^^^^^^^^^

error: Trait has no implementation in context: test::AnotherTrait.
 --> lib.cairo:17:26
fn bar2(x: AnotherTrait::AnotherType) {}
                         ^^^^^^^^^^^

error: Trait has no implementation in context: test::AnotherTrait.
 --> lib.cairo:19:26
    let _: AnotherTrait::AnotherType = 3_u32;
                         ^^^^^^^^^^^

//! > ==========================================================================

//! > traits' items can't be resolved if there are multiple impls in context.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl1 of AnotherTrait {
    type AnotherType = u32;
}
impl AnotherImpl2 of AnotherTrait {
    type AnotherType = u32;
}
trait MyTrait {
    fn foo1() -> u32;
    fn foo2(x: u32);
}
impl MyImpl of MyTrait {
    fn foo1() -> AnotherTrait::AnotherType {
        3_u32
    }
    fn foo2(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> AnotherTrait::AnotherType {
    3_u32
}
fn bar2(x: AnotherTrait::AnotherType) {}
fn bar3() {
    let _: AnotherTrait::AnotherType = 3_u32;
}

//! > expected_diagnostics
error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:15:32
    fn foo1() -> AnotherTrait::AnotherType {
                               ^^^^^^^^^^^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:18:30
    fn foo2(x: AnotherTrait::AnotherType) {}
                             ^^^^^^^^^^^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:20:28
fn bar1() -> AnotherTrait::AnotherType {
                           ^^^^^^^^^^^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:23:26
fn bar2(x: AnotherTrait::AnotherType) {}
                         ^^^^^^^^^^^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:25:26
    let _: AnotherTrait::AnotherType = 3_u32;
                         ^^^^^^^^^^^

//! > ==========================================================================

//! > impl items are allowed, even in a trait body.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl1 of AnotherTrait {
    type AnotherType = u32;
}
impl AnotherImpl2 of AnotherTrait {
    type AnotherType = u16;
}
trait MyTrait {
    fn foo1() -> AnotherImpl1::AnotherType;
    fn foo2(x: AnotherImpl1::AnotherType);
}
impl MyImpl of MyTrait {
    fn foo1() -> AnotherImpl1::AnotherType {
        3_u32
    }
    fn foo2(x: AnotherImpl1::AnotherType) {}
}
fn bar1() -> AnotherImpl1::AnotherType {
    3_u32
}
fn bar2(x: AnotherImpl1::AnotherType) {}
fn bar3() {
    let _: AnotherImpl1::AnotherType = 3_u32;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > impl items are allowed in its own trait body.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType;
    fn foo1() -> MyImpl::MyType;
    fn foo2(x: MyImpl::MyType);
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn foo1() -> Self::MyType {
        3_u32
    }
    fn foo2(x: Self::MyType) {}
}

//! > expected_diagnostics

//! > ==========================================================================

//! > impl items in its own trait body, with type mismatch.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType;
    fn foo1() -> MyImpl::MyType;
    fn foo2(x: MyImpl::MyType);
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn foo1() -> Self::MyType {
        3_u16
    }
    fn foo2(x: Self::MyType) {}
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:8:18
    fn foo1() -> Self::MyType {
                 ^^^^^^^^^^^^

//! > ==========================================================================

//! > traits' items resolved in all kind of statements.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
}
impl MyImpl of MyTrait {
    type MyType1 = u32;
    type MyType2 = u32;
}
fn ret_statement(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    return x;
}
fn ret_expr(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    x
}
fn let_statement(x: MyTrait::MyType2) {
    let _: MyTrait::MyType1 = x;
}
fn break_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    loop {
        if cond {
            break x;
        } else {
            break y;
        }
    };
}
enum MyEnum {
    VariantA,
    VariantB,
}
fn match_statement(e: MyEnum, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    let _ = match e {
        MyEnum::VariantA => { x },
        MyEnum::VariantB => { y },
    };
}
fn if_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    if cond {
        x
    } else {
        y
    };
}
fn error_propagation(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Some(x?)
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Diagnostics on mismatches with traits' items that are resolved in all kind of statements.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
}
impl MyImpl of MyTrait {
    type MyType1 = u16;
    type MyType2 = u32;
}
fn ret_statement(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    return x;
}
fn ret_expr(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    x
}
fn let_statement(x: MyTrait::MyType2) {
    let _: MyTrait::MyType1 = x;
}
fn break_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    loop {
        if cond {
            break x;
        } else {
            break y;
        }
    };
}
enum MyEnum {
    VariantA,
    VariantB,
}
fn match_statement(e: MyEnum, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    let _ = match e {
        MyEnum::VariantA => { x },
        MyEnum::VariantB => { y },
    };
}
fn if_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    if cond {
        x
    } else {
        y
    };
}
fn error_propagation(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Some(x?)
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:10:12
    return x;
           ^

error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:12:37
fn ret_expr(x: MyTrait::MyType1) -> MyTrait::MyType2 {
                                    ^^^^^^^^^^^^^^^^

error: `test::MyImpl::MyType1` type mismatch: `core::integer::u32` and `core::integer::u16`.
 --> lib.cairo:16:21
    let _: MyTrait::MyType1 = x;
                    ^^^^^^^

error: Loop has incompatible return types: "core::integer::u16" and "core::integer::u32"
 --> lib.cairo:23:19
            break y;
                  ^

error: Match arms have incompatible types: "core::integer::u16" and "core::integer::u32"
 --> lib.cairo:34:29
        MyEnum::VariantB => { y },
                            ^^^^^

error: If blocks have incompatible types: "core::integer::u16" and "core::integer::u32"
 --> lib.cairo:38:5-42:5
      if cond {
 _____^
| ...
|     };
|_____^

error: Unexpected return type. Expected: "core::option::Option::<core::integer::u32>", found: "core::option::Option::<core::integer::u16>".
 --> lib.cairo:44:54
fn error_propagation(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
                                                     ^^^^^^^^^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > Recursive resolution.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    type MyType3;
    type MyType4;
}
impl MyImpl of MyTrait {
    type MyType1 = u32;
    type MyType2 = u32;
    type MyType3 = u32;
    type MyType4 = u32;
}
fn generic_args(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Some(x?)
}
fn tuple(x: MyTrait::MyType1, y: MyTrait::MyType2) -> (MyTrait::MyType2, MyTrait::MyType1) {
    (x, y)
}
fn fix_sized_array(x: [MyTrait::MyType1; 3]) -> [MyTrait::MyType2; 3] {
    x
}
fn snapshot(x: @@MyTrait::MyType1) -> @@MyTrait::MyType2 {
    x
}
fn snapshot2(x: @MyTrait::MyType1) -> @@MyTrait::MyType2 {
    @x
}
fn complex1(
    x: @(
        MyTrait::MyType1,
        Option<@Result<[Option<MyTrait::MyType2>; 3], (@MyTrait::MyType3, MyTrait::MyType4)>>,
    ),
) -> @(u32, Option<@Result<[Option<u32>; 3], (@u32, u32)>>) {
    x
}
fn complex2(
    x: @(u32, Option<@Result<[Option<u32>; 3], (@u32, u32)>>),
) -> @(
    MyTrait::MyType1,
    Option<@Result<[Option<MyTrait::MyType2>; 3], (@MyTrait::MyType3, MyTrait::MyType4)>>,
) {
    x
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Diagnostics on mismatches with recursive resolution.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    type MyType3;
    type MyType4;
}
impl MyImpl of MyTrait {
    type MyType1 = u16;
    type MyType2 = u32;
    type MyType3 = u32;
    type MyType4 = u32;
}
fn generic_args(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Some(x?)
}
fn tuple(x: MyTrait::MyType1, y: MyTrait::MyType2) -> (MyTrait::MyType2, MyTrait::MyType1) {
    (x, y)
}
fn fix_sized_array(x: [MyTrait::MyType1; 3]) -> [MyTrait::MyType2; 3] {
    x
}
fn snapshot(x: @@MyTrait::MyType1) -> @@MyTrait::MyType2 {
    x
}
fn snapshot2(x: @MyTrait::MyType1) -> @@MyTrait::MyType2 {
    @x
}
fn complex1(
    x: @(
        MyTrait::MyType1,
        Option<@Result<[Option<MyTrait::MyType2>; 3], (@MyTrait::MyType3, MyTrait::MyType4)>>,
    ),
) -> @(u32, Option<@Result<[Option<u32>; 3], (@u32, u32)>>) {
    x
}
fn complex2(
    x: @(u32, Option<@Result<[Option<u32>; 3], (@u32, u32)>>),
) -> @(
    MyTrait::MyType1,
    Option<@Result<[Option<MyTrait::MyType2>; 3], (@MyTrait::MyType3, MyTrait::MyType4)>>,
) {
    x
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::option::Option::<core::integer::u32>", found: "core::option::Option::<core::integer::u16>".
 --> lib.cairo:13:49
fn generic_args(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
                                                ^^^^^^^^^^^^^^^^^^^^^^^^

error: Unexpected return type. Expected: "(core::integer::u32, core::integer::u16)", found: "(core::integer::u16, core::integer::u32)".
 --> lib.cairo:16:55
fn tuple(x: MyTrait::MyType1, y: MyTrait::MyType2) -> (MyTrait::MyType2, MyTrait::MyType1) {
                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Unexpected return type. Expected: "[core::integer::u32; 3]", found: "[core::integer::u16; 3]".
 --> lib.cairo:19:49
fn fix_sized_array(x: [MyTrait::MyType1; 3]) -> [MyTrait::MyType2; 3] {
                                                ^^^^^^^^^^^^^^^^^^^^^

error: Unexpected return type. Expected: "@@core::integer::u32", found: "@@core::integer::u16".
 --> lib.cairo:22:39
fn snapshot(x: @@MyTrait::MyType1) -> @@MyTrait::MyType2 {
                                      ^^^^^^^^^^^^^^^^^^

error: Unexpected return type. Expected: "@@core::integer::u32", found: "@@core::integer::u16".
 --> lib.cairo:25:39
fn snapshot2(x: @MyTrait::MyType1) -> @@MyTrait::MyType2 {
                                      ^^^^^^^^^^^^^^^^^^

error: Unexpected return type. Expected: "@(core::integer::u32, core::option::Option::<@core::result::Result::<[core::option::Option::<core::integer::u32>; 3], (@core::integer::u32, core::integer::u32)>>)", found: "@(core::integer::u16, core::option::Option::<@core::result::Result::<[core::option::Option::<core::integer::u32>; 3], (@core::integer::u32, core::integer::u32)>>)".
 --> lib.cairo:33:6
) -> @(u32, Option<@Result<[Option<u32>; 3], (@u32, u32)>>) {
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Unexpected return type. Expected: "@(core::integer::u16, core::option::Option::<@core::result::Result::<[core::option::Option::<core::integer::u32>; 3], (@core::integer::u32, core::integer::u32)>>)", found: "@(core::integer::u32, core::option::Option::<@core::result::Result::<[core::option::Option::<core::integer::u32>; 3], (@core::integer::u32, core::integer::u32)>>)".
 --> lib.cairo:38:6-41:1
  ) -> @(
 ______^
| ...
| ) {
|_^

//! > ==========================================================================

//! > Diagnostics on using trait function as a type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo(x: MyImpl::my_function) {
    let _: MyImpl::my_function = 3;
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType;
    fn my_function() -> u16;
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn my_function() -> u16 {
        2_u16
    }
}

//! > expected_diagnostics
error: Not a type.
 --> lib.cairo:11:11
fn foo(x: MyImpl::my_function) {
          ^^^^^^^^^^^^^^^^^^^

error: Not a type.
 --> lib.cairo:12:12
    let _: MyImpl::my_function = 3;
           ^^^^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > Impl type chain resolution.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    fn bar(x: Self::MyType1) -> u32;
}
impl MyImpl of MyTrait {
    type MyType1 = Self::MyType2;
    type MyType2 = u32;
    fn bar(x: Self::MyType1) -> u32 {
        x
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Impl type chain resolution, with mismatch types.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    fn bar(x: Self::MyType1) -> u32;
}
impl MyImpl of MyTrait {
    type MyType1 = Self::MyType2;
    type MyType2 = u16;
    fn bar(x: Self::MyType1) -> u32 {
        x
    }
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:9:33
    fn bar(x: Self::MyType1) -> u32 {
                                ^^^

//! > ==========================================================================

//! > Impl types cycle of length 1.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
}
impl MyImpl of MyTrait {
    type MyType1 = Self::MyType1;
}

//! > expected_diagnostics
error: Cycle detected while resolving type-alias/impl-type items.
 --> lib.cairo:5:10
    type MyType1 = Self::MyType1;
         ^^^^^^^

//! > ==========================================================================

//! > Impl types cycle of length 2.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
}
impl MyImpl of MyTrait {
    type MyType1 = Self::MyType2;
    type MyType2 = Self::MyType1;
}

//! > expected_diagnostics
error: Cycle detected while resolving type-alias/impl-type items.
 --> lib.cairo:6:10
    type MyType1 = Self::MyType2;
         ^^^^^^^

error: Cycle detected while resolving type-alias/impl-type items.
 --> lib.cairo:7:10
    type MyType2 = Self::MyType1;
         ^^^^^^^

//! > ==========================================================================

//! > Error propagation of `Self::` type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    fn bar(x: Self::MyType1) -> Self::MyType2;
}
impl MyImpl of MyTrait {
    type MyType1 = Option<()>;
    type MyType2 = Option<()>;
    fn bar(x: Self::MyType1) -> Self::MyType2 {
        Some(x?)
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > `Self::` segment in unsupported context.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
fn free_func(x: Self::MyType1) -> Self::MyType2 {
    let _: Self::MyType3 = 3;
}

//! > expected_diagnostics
error: `Self` is not supported in this context.
 --> lib.cairo:1:17
fn free_func(x: Self::MyType1) -> Self::MyType2 {
                ^^^^

error: `Self` is not supported in this context.
 --> lib.cairo:1:35
fn free_func(x: Self::MyType1) -> Self::MyType2 {
                                  ^^^^

error: `Self` is not supported in this context.
 --> lib.cairo:2:12
    let _: Self::MyType3 = 3;
           ^^^^

//! > ==========================================================================

//! > `Self` segment for a result type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > TODO(orizi): Make this not generate diagnostics.

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyInto<T, S> {
    fn my_into(self: T) -> S;
}
mod inner {
    struct MyType {}
    impl MyU16IntoMyType of super::MyInto<u16, MyType> {
        fn my_into(self: u16) -> MyType {
            MyType {}
        }
    }
}
use inner::MyType;
trait MyTrait {
    type MyTraitType;
    fn bar() -> Self::MyTraitType;
}
impl MyImpl of MyTrait {
    type MyTraitType = (MyType, MyType);
    fn bar() -> Self::MyTraitType {
        let _: Self::MyTraitType = (3_u16.my_into(), 3_u16.my_into());
        (3_u16.my_into(), 3_u16.my_into())
    }
}

//! > expected_diagnostics
error[E0002]: Method `my_into` could not be called on type `core::integer::u16`.
Candidate `test::MyInto::my_into` inference failed with: Trait has no implementation in context: test::MyInto::<core::integer::u16, ?1>.
 --> lib.cairo:20:43
        let _: Self::MyTraitType = (3_u16.my_into(), 3_u16.my_into());
                                          ^^^^^^^

error[E0002]: Method `my_into` could not be called on type `core::integer::u16`.
Candidate `test::MyInto::my_into` inference failed with: Trait has no implementation in context: test::MyInto::<core::integer::u16, ?1>.
 --> lib.cairo:20:60
        let _: Self::MyTraitType = (3_u16.my_into(), 3_u16.my_into());
                                                           ^^^^^^^

error[E0002]: Method `my_into` could not be called on type `core::integer::u16`.
Candidate `test::MyInto::my_into` inference failed with: Trait has no implementation in context: test::MyInto::<core::integer::u16, ?1>.
 --> lib.cairo:21:16
        (3_u16.my_into(), 3_u16.my_into())
               ^^^^^^^

error[E0002]: Method `my_into` could not be called on type `core::integer::u16`.
Candidate `test::MyInto::my_into` inference failed with: Trait has no implementation in context: test::MyInto::<core::integer::u16, ?1>.
 --> lib.cairo:21:33
        (3_u16.my_into(), 3_u16.my_into())
                                ^^^^^^^

//! > ==========================================================================

//! > using an impl's associated type in a concrete impl with generic args.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() -> u32 {
    let x: MyImpl::<u32>::ty = 4;
    x
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

impl MyImpl<K> of MyTrait {
    type ty = K;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > trait's associated type is not inferred from a concrete impl with generic args.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() -> u32 {
    let x: MyTrait::ty = 4_u32;
    x
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

impl MyImpl<K> of MyTrait {
    type ty = K;
}
///TODO(TomerStarkware): infer impl types from trait types.

//! > expected_diagnostics
error: Candidate impl test::MyImpl::<?0> has an unused generic parameter.
 --> lib.cairo:10:21
    let x: MyTrait::ty = 4_u32;
                    ^^

//! > ==========================================================================

//! > trait's generic arg is inferred from concrete impl with associated type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() -> u32 {
    MyTrait::<u32>::foo()
}

//! > function_name
foo

//! > module_code
trait MyTrait<T, K> {
    type ty;
    fn foo() -> Self::ty;
}

impl MyImpl<K, +Default<K>> of MyTrait<u32, K> {
    type ty = K;
    fn foo() -> Self::ty {
        Default::default()
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > using an impl's associated type in a function signature of a concrete impl with generic args.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo(x: felt252, y: felt252, z: felt252, w: felt252) -> felt252 {
    DepAdd::<felt252>::other_add(x, y)
}

//! > function_name
foo

//! > module_code
trait OtherAdd<Lhs, Rhs> {
    type Output;
    fn other_add(lhs: Lhs, rhs: Rhs) -> Self::Output;
}
impl DepAdd<T> of OtherAdd<T, T> {
    type Output = T;
    fn other_add(lhs: T, rhs: T) -> T {
        lhs
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > using a trait's associated type in a function signature of a concrete impl with generic args.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo(x: felt252, y: felt252, z: felt252, w: felt252) -> felt252 {
    OtherAdd::<felt252>::other_add(x, y)
}

//! > function_name
foo

//! > module_code
trait OtherAdd<Lhs, Rhs> {
    type Output;
    fn other_add(lhs: Lhs, rhs: Rhs) -> Self::Output;
}
impl DepAdd<T> of OtherAdd<T, T> {
    type Output = T;
    fn other_add(lhs: T, rhs: T) -> T {
        lhs
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > using a generic impl with generic args.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() -> felt252 {
    bar::<_, DepAdd>(3_felt252, 4)
}
pub fn bar<T, +OtherAdd<T, T>>(x: T, y: T) -> OtherAdd::<T, T>::Output {
    OtherAdd::other_add(x, y)
}

//! > function_name
foo

//! > module_code
trait OtherAdd<Lhs, Rhs> {
    type Output;
    fn other_add(lhs: Lhs, rhs: Rhs) -> Self::Output;
}
impl DepAdd<T, +Drop<T>> of OtherAdd<T, T> {
    type Output = T;
    fn other_add(lhs: T, rhs: T) -> T {
        lhs
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Accessing a member of a type that is a trait's associated type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() -> felt252 {
    let x = Trt::foo();
    x.t
}

//! > function_name
foo

//! > module_code
trait Trt {
    type T;
    fn foo() -> Self::T;
}

//! > expected_diagnostics
error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:7:7
    x.t
      ^

error: Trait has no implementation in context: test::Trt.
 --> lib.cairo:6:18
    let x = Trt::foo();
                 ^^^

//! > ==========================================================================

//! > Using self calls.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait Trt<T> {
    type Assoc;
    fn func(self: T) -> Self::Assoc;
}

fn bar<T, impl TrtImp: Trt<T>>(x: T) -> TrtImp::Assoc {
    x.func()
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Trait associated types reading.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() -> u32 {
    array![12, 13, 14].first()
}

//! > function_name
foo

//! > module_code
trait FirstTrait<T> {
    type Element;
    fn first(self: T) -> Self::Element;
}

impl ArrayFirst<T> of FirstTrait<Array<T>> {
    type Element = T;
    fn first(mut self: Array<T>) -> T {
        self.pop_front().unwrap()
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Use of missing Impl type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {
    let _: MyImpl::ty = 5;
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}
impl MyImpl of MyTrait {}

//! > expected_diagnostics
error[E0004]: Not all trait items are implemented. Missing: 'ty'.
 --> lib.cairo:4:6
impl MyImpl of MyTrait {}
     ^^^^^^

error: Trait has no implementation in context: test::MyTrait.
 --> lib.cairo:5:10-7:1
  fn foo() {
 __________^
|     let _: MyImpl::ty = 5;
| }
|_^

//! > ==========================================================================

//! > Associated type bounds with TypeEqual.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn bar<+MyTrait, +core::metaprogramming::TypeEqual<MyTrait::ty, felt252>>(
    _y: MyTrait::ty,
) -> felt252 {
    _y + 3
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Associated type bounds with TypeEqual transitive.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<
    impl I1: MyTrait,
    impl I2: MyTrait,
    +core::metaprogramming::TypeEqual<I1::ty, I2::ty>,
    +core::metaprogramming::TypeEqual<felt252, I1::ty>,
>() -> I2::ty {
    3_u32
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::felt252", found: "core::integer::u32".
 --> lib.cairo:9:8
>() -> I2::ty {
       ^^^^^^

//! > ==========================================================================

//! > Associated type bounds with TypeEqual conflicts.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<
    +MyTrait,
    +core::metaprogramming::TypeEqual<MyTrait::ty, felt252>,
    +core::metaprogramming::TypeEqual<MyTrait::ty, u32>,
>(
    _y: MyTrait::ty,
) -> MyTrait::ty {
    _y
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

//! > expected_diagnostics
error: Type mismatch: `core::felt252` and `core::integer::u32`.
 --> lib.cairo:10:18-12:1
  ) -> MyTrait::ty {
 __________________^
|     _y
| }
|_^

//! > ==========================================================================

//! > Associated type bounds with TypeEqual inference based on bounds.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
///TODO(TomerStarkware): remove diagnostic and make it compile without errors.
fn bar<
    +MyTrait,
    +core::metaprogramming::TypeEqual<MyTrait::ty, felt252>,
    +TraitWithInferredParams<MyTrait::ty>,
>(
    _y: MyTrait::ty,
) -> MyTrait::ty {
    _y + TraitWithInferredParams::<MyTrait::ty>::foo()
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}
trait OtherTrait<T> {
    fn foo() -> T;
}
impl OtherImpl of OtherTrait<felt252> {
    fn foo() -> felt252 {
        3
    }
}
trait TraitWithInferredParams<T, +OtherTrait<T>> {
    fn foo() -> T;
}

//! > expected_diagnostics
error: Trait has no implementation in context: test::OtherTrait::<_::ty>.
 --> lib.cairo:19:6
    +TraitWithInferredParams<MyTrait::ty>,
     ^^^^^^^^^^^^^^^^^^^^^^^

error: Trait has no implementation in context: test::TraitWithInferredParams::<core::felt252, test::OtherImpl>.
 --> lib.cairo:23:50
    _y + TraitWithInferredParams::<MyTrait::ty>::foo()
                                                 ^^^

//! > ==========================================================================

//! > Associated type bounds with TypeEqual, only bound associated types to another associated type. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn bar<
    impl I1: MyTrait, impl I2: MyTrait, +core::metaprogramming::TypeEqual<I1::ty, I2::ty>,
>() -> I1::ty {
    I2::foo()
}
fn foo() {
    bar::<MyImplu32, MyImplu32>();
    bar::<MyImplfelt252, MyImplfelt252>();
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}
impl MyImplu32 of MyTrait {
    type ty = u32;
    fn foo() -> Self::ty {
        3
    }
}
impl MyImplfelt252 of MyTrait {
    type ty = felt252;
    fn foo() -> Self::ty {
        3
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Associated type bounds with TypeEqual, only bound associated types to another associated type wrong type. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<
    impl I1: MyTrait, impl I2: MyTrait, +core::metaprogramming::TypeEqual<I1::ty, I2::ty>,
>() -> I1::ty {
    I2::foo()
}
fn foo() {
    bar::<MyImplu32, MyImplfelt252>();
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}
impl MyImplu32 of MyTrait {
    type ty = u32;
    fn foo() -> Self::ty {
        3
    }
}
impl MyImplfelt252 of MyTrait {
    type ty = felt252;
    fn foo() -> Self::ty {
        3
    }
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::metaprogramming::TypeEqual::<core::integer::u32, core::felt252>.
 --> lib.cairo:23:5
    bar::<MyImplu32, MyImplfelt252>();
    ^^^

//! > ==========================================================================

//! > Associated type bounds with TypeEqual, only bound associated types to another associated inferring type. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<
    impl I1: MyTrait, impl I2: MyTrait, +core::metaprogramming::TypeEqual<I1::ty, I2::ty>,
>() -> I2::ty {
    I1::foo()
}
fn bar2<impl I1: MyTrait, impl I2: MyTrait>() -> I2::ty {
    bar::<I1, I2>()
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::metaprogramming::TypeEqual::<I1::ty, I2::ty>.
 --> lib.cairo:11:5
    bar::<I1, I2>()
    ^^^

//! > ==========================================================================

//! > Reimplementing TypeEqual trait. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
impl I of core::metaprogramming::TypeEqual<u32, felt252>;

//! > expected_diagnostics
error: Trait `core::metaprogramming::TypeEqual` should not be implemented outside of the corelib.
 --> lib.cairo:1:11
impl I of core::metaprogramming::TypeEqual<u32, felt252>;
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > TypeEqual with 3 generic parameters. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
fn bar<T, impl I: core::metaprogramming::TypeEqual<T, T, T>>() {}

//! > expected_diagnostics
error: Expected 2 generic arguments, found 3.
 --> lib.cairo:1:58
fn bar<T, impl I: core::metaprogramming::TypeEqual<T, T, T>>() {}
                                                         ^

//! > ==========================================================================

//! > TypeEqual with non type parameter.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
fn bar<T, const C: u32, impl I: core::metaprogramming::TypeEqual<T, C>>() {}

//! > expected_diagnostics
error: Not a type.
 --> lib.cairo:1:69
fn bar<T, const C: u32, impl I: core::metaprogramming::TypeEqual<T, C>>() {}
                                                                    ^

//! > ==========================================================================

//! > Mismatch between inferred trait type and expected type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
///TODO(TomerStarkware): change diagnostics to mismatch types instead of missing impl.
fn foo() {
    let _: felt252 = MyTrait::my_function();
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType;
    fn my_function() -> Self::MyType;
}
impl MyImpl of MyTrait {
    type MyType = u16;
    fn my_function() -> u16 {
        2_u16
    }
}

//! > expected_diagnostics
error: `test::MyImpl::MyType` type mismatch: `core::felt252` and `core::integer::u16`.
 --> lib.cairo:13:31
    let _: felt252 = MyTrait::my_function();
                              ^^^^^^^^^^^

//! > ==========================================================================

//! > Associated type bounds.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn bar<+MyTrait[ty: felt252]>(y: MyTrait::ty) -> felt252 {
    y + 3
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Associated type bounds transitive.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<impl I1: MyTrait[ty: u32], impl I2: MyTrait[ty: I1::ty]>() -> I2::ty {
    3_u8
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u8".
 --> lib.cairo:4:70
fn bar<impl I1: MyTrait[ty: u32], impl I2: MyTrait[ty: I1::ty]>() -> I2::ty {
                                                                     ^^^^^^

//! > ==========================================================================

//! > Associated type bounds conflicts.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<+MyTrait[ty: felt252], +core::metaprogramming::TypeEqual<MyTrait::ty, u32>>(
    _y: MyTrait::ty,
) -> MyTrait::ty {
    _y
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

//! > expected_diagnostics
error: Type mismatch: `core::felt252` and `core::integer::u32`.
 --> lib.cairo:6:18-8:1
  ) -> MyTrait::ty {
 __________________^
|     _y
| }
|_^

//! > ==========================================================================

//! > Associated type bounds, only bound associated types to another associated type. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn bar<impl I1: MyTrait, impl I2: MyTrait[ty: I1::ty]>() -> I1::ty {
    I2::foo()
}
fn foo() {
    bar::<MyImplu32, MyImplu32>();
    bar::<MyImplfelt252, MyImplfelt252>();
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}
impl MyImplu32 of MyTrait {
    type ty = u32;
    fn foo() -> Self::ty {
        3
    }
}
impl MyImplfelt252 of MyTrait {
    type ty = felt252;
    fn foo() -> Self::ty {
        3
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Associated type bounds, bound associated types together and pass wrong type. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<impl I1: MyTrait[ty: I2::ty], impl I2: MyTrait>() -> I1::ty {
    I2::foo()
}
fn foo() {
    bar::<MyImplu32, MyImplfelt252>();
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}
impl MyImplu32 of MyTrait {
    type ty = u32;
    fn foo() -> Self::ty {
        3
    }
}
impl MyImplfelt252 of MyTrait {
    type ty = felt252;
    fn foo() -> Self::ty {
        3
    }
}

//! > expected_diagnostics
error: Type mismatch: `core::integer::u32` and `I2::ty`.
 --> lib.cairo:21:5
    bar::<MyImplu32, MyImplfelt252>();
    ^^^

//! > ==========================================================================

//! > Associated type bounds, passing unconstrained type into constrained one.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<impl I1: MyTrait[ty: felt252]>() -> I1::ty {
    I1::foo()
}
fn bar2<impl J1: MyTrait>() -> J1::ty {
    bar()
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "J1::ty", found: "core::felt252".
 --> lib.cairo:8:32
fn bar2<impl J1: MyTrait>() -> J1::ty {
                               ^^^^^^

//! > ==========================================================================

//! > Associated type bounds, passing constrained type into the same constrained type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn bar<impl I1: MyTrait[ty: u32]>() -> I1::ty {
    I1::foo()
}

fn bar2<impl J1: MyTrait[ty: u32]>() -> J1::ty {
    bar()
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Associated type bounds, passing wrong constrained type into another constrained type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<impl I1: MyTrait[ty: u32]>() -> I1::ty {
    I1::foo()
}
fn bar2<impl I1: MyTrait[ty: u8]>() -> I1::ty {
    bar()
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::integer::u8", found: "core::integer::u32".
 --> lib.cairo:8:40
fn bar2<impl I1: MyTrait[ty: u8]>() -> I1::ty {
                                       ^^^^^^

//! > ==========================================================================

//! > Associated type bounds, multiple implementations.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<impl I1: MyTrait[ty: u32]>() -> I1::ty {
    I1::foo()
}
fn foo() {
    bar();
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}

impl I1 of MyTrait {
    type ty = u32;
    fn foo() -> u32 {
        3
    }
}

impl I2 of MyTrait {
    type ty = u8;
    fn foo() -> u8 {
        3
    }
}

//! > expected_diagnostics
error: Trait `test::MyTrait` has multiple implementations, in: `test::I1`, `test::I2`
 --> lib.cairo:23:5
    bar();
    ^^^

//! > ==========================================================================

//! > Associated type bounds, non type bound.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<impl I1: MyTrait[ty: u32]>() -> u32 {
    I1::foo()
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    const ty: u32;

    fn foo() -> u32;
}

//! > expected_diagnostics
error: associated type `ty` not found for `test::MyTrait`
 --> lib.cairo:6:25
fn bar<impl I1: MyTrait[ty: u32]>() -> u32 {
                        ^^^^^^^

//! > ==========================================================================

//! > Associated type bounds, repeated type bound.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<impl I1: MyTrait[ty: u32, ty: felt252]>() -> u32 {
    I1::foo()
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}

//! > expected_diagnostics
error: the value of the associated type `ty` in trait `test::MyTrait` is already specified
 --> lib.cairo:5:17
fn bar<impl I1: MyTrait[ty: u32, ty: felt252]>() -> u32 {
                ^^^^^^^

//! > ==========================================================================

//! > Associated type bounds, passing an impl with the wrong trait  type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<impl I1: MyTrait[ty: u32]>() {
    I1::foo();
}
fn foo() {
    bar::<MyImpl>();
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}
impl MyImpl of MyTrait {
    type ty = u8;
    fn foo() -> u8 {
        3
    }
}

//! > expected_diagnostics
error: Type mismatch: `core::integer::u8` and `core::integer::u32`.
 --> lib.cairo:15:5
    bar::<MyImpl>();
    ^^^

//! > ==========================================================================

//! > Associated type bounds, passing an impl with the wrong trait.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<impl I1: MyTrait[ty: u32]>() {
    I1::foo();
}
fn foo() {
    bar::<MyImpl>();
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}
trait OtherTrait {
    type ty;
    fn foo() -> Self::ty;
}
impl MyImpl of OtherTrait {
    type ty = u8;
    fn foo() -> u8 {
        3
    }
}

//! > expected_diagnostics
error: Expected an impl of `test::MyTrait`. Got an impl of `test::OtherTrait`.
 --> lib.cairo:19:11
    bar::<MyImpl>();
          ^^^^^^

//! > ==========================================================================

//! > Using an impl with generic args which is a constrained trait type

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn bar<impl I1: MyTrait[ty: u32], +OtherTrait<I1::ty>>() {
    OtherTrait::foo(5_u32);
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}
trait OtherTrait<T> {
    fn foo(a: T) -> T;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Multiple implementations of a trait by having an impl on both side of a type constraint.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<impl I1: MyTrait[ty: u32], +OtherTrait<I1::ty>, +OtherTrait<u32>>() {
    OtherTrait::foo(5_u32);
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}
trait OtherTrait<T> {
    fn foo(a: T) -> T;
}

//! > expected_diagnostics
error: Trait `test::OtherTrait::<core::integer::u32>` has multiple implementations, in: `+OtherTrait<I1::ty>`, `+OtherTrait<u32>`
 --> lib.cairo:9:17
    OtherTrait::foo(5_u32);
                ^^^

//! > ==========================================================================

//! > impl function with wrong generic associated item constraint.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}
trait Tr {
    fn foo<+MyTrait[ty: i32]>();
}

impl I of Tr {
    fn foo<impl I1: MyTrait[ty: u64]>() {}
}

//! > expected_diagnostics
error: Generic parameter trait of impl function `I::foo` is incompatible with `Tr::foo`. Expected: `test::MyTrait`, actual: `test::MyTrait`.
 --> lib.cairo:9:12
    fn foo<impl I1: MyTrait[ty: u64]>() {}
           ^^^^^^^^^^^^^^^^^^^^^^^^^

//! > ==========================================================================

//! > Mismatch in associated type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() -> S<M> {
    S { x: 3_felt252 }
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
}

impl M of MyTrait {
    type InputType = u32;
}

struct S<impl M: MyTrait> {
    x: M::InputType,
}

//! > expected_diagnostics
error: `test::M::InputType` type mismatch: `core::felt252` and `core::integer::u32`.
 --> lib.cairo:12:13
fn foo() -> S<M> {
            ^^^^
