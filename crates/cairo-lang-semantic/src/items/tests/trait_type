//! > Test type items in trait/impl.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    MyImpl::foo1(3_u32);
    MyImpl::foo2(3_u32);
    MyImpl::foo3(3_u32);
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType) -> Self::OutputType;
    fn foo2(x: Self::InputType) -> Self::OutputType;
    fn foo3(x: u32) -> u32;
}
impl MyImpl of MyTrait {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: Self::InputType) -> Self::OutputType {
        x
    }
    fn foo2(x: u32) -> u32 {
        x
    }
    fn foo3(x: Self::InputType) -> Self::OutputType {
        x
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Trait type with generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType, t: T) -> Self::OutputType;
}
impl MyImpl<T> of MyTrait<T> {
    type InputType = T;
    type OutputType = T;
    fn foo(x: Self::InputType, t: T) -> Self::OutputType {
        x
    }
}
impl MyImplU32 of MyTrait<u32> {
    type InputType = u32;
    type OutputType = u32;
    fn foo(x: Self::InputType, t: u32) -> Self::OutputType {
        x
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Trait type with no impl in context, no generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType) -> Self::OutputType;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Trait type with no impl in context, with generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType, t: T) -> Self::OutputType;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Test type items in trait/impl with generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    MyImpl::<u32>::foo1(3_u32);
    MyImpl::<u32>::foo2(3_u32);
    MyImpl::<u32>::foo3(3_u32);
}

//! > function_name
foo

//! > module_code
trait MyTrait<T, S> {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType) -> Self::OutputType;
    fn foo2(x: Self::InputType) -> Self::OutputType;
    fn foo3(x: u32) -> u32;
}
impl MyImpl<T> of MyTrait<T, u32> {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: Self::InputType) -> Self::OutputType {
        x
    }
    fn foo2(x: u32) -> u32 {
        x
    }
    fn foo3(x: Self::InputType) -> Self::OutputType {
        x
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > A trait, without generics, shouldn't be used in a path in its own body.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: MyTrait::InputType) -> MyTrait::OutputType;
}

//! > expected_diagnostics
warning: In a trait, paths of the same trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:4:15
    fn foo(x: MyTrait::InputType) -> MyTrait::OutputType;
              ^*****^

warning: In a trait, paths of the same trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:4:38
    fn foo(x: MyTrait::InputType) -> MyTrait::OutputType;
                                     ^*****^

//! > ==========================================================================

//! > A trait shouldn't be used in a path in its own body, with the same generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo(x: MyTrait::<T>::InputType) -> MyTrait::<T>::OutputType;
}

//! > expected_diagnostics
warning: In a trait, paths of the same trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:4:15
    fn foo(x: MyTrait::<T>::InputType) -> MyTrait::<T>::OutputType;
              ^**********^

warning: In a trait, paths of the same trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:4:43
    fn foo(x: MyTrait::<T>::InputType) -> MyTrait::<T>::OutputType;
                                          ^**********^

//! > ==========================================================================

//! > A trait can be used in a path in its own body, if the generics are different.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo(x: MyTrait::<u32>::InputType) -> MyTrait::<u32>::OutputType;
}
impl MyImpl of MyTrait<u32> {
    type InputType = u32;
    type OutputType = u32;
    fn foo(x: Self::InputType) -> Self::OutputType {
        x
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > A trait in a path in its own body should be fully explicit.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait SomeTrait {}
trait MyTrait<T, +SomeTrait> {
    type InputType;
    fn foo(x: MyTrait::<T>::InputType);
}

//! > expected_diagnostics
warning: In a trait, paths of the same trait must be fully explicit. Either use `Self` if this is the intention, or explicitly specify all the generic arguments.
 --> lib.cairo:4:15
    fn foo(x: MyTrait::<T>::InputType);
              ^**********^

//! > ==========================================================================

//! > An impl, without generics, shouldn't be used in a path in its own body.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType) -> Self::OutputType;
    fn foo2();
}
impl MyImpl of MyTrait {
    type InputType = u32;
    type OutputType = u32;
    fn foo(x: MyImpl::InputType) -> MyImpl::OutputType {
        x
    }
    fn foo2() {
        let _: MyImpl::InputType = 3_u32;
    }
}

//! > expected_diagnostics
warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:15
    fn foo(x: MyImpl::InputType) -> MyImpl::OutputType {
              ^****^

warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:37
    fn foo(x: MyImpl::InputType) -> MyImpl::OutputType {
                                    ^****^

warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:14:16
        let _: MyImpl::InputType = 3_u32;
               ^****^

//! > ==========================================================================

//! > An impl shouldn't be used in a path in its own body, with the same generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType) -> Self::OutputType;
}
impl MyImpl<T> of MyTrait {
    type InputType = T;
    type OutputType = T;
    fn foo(x: MyImpl::<T>::InputType) -> MyImpl::<T>::OutputType {
        let y: MyImpl::<T>::InputType = x;
        y
    }
}

//! > expected_diagnostics
warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:9:15
    fn foo(x: MyImpl::<T>::InputType) -> MyImpl::<T>::OutputType {
              ^*********^

warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:9:42
    fn foo(x: MyImpl::<T>::InputType) -> MyImpl::<T>::OutputType {
                                         ^*********^

warning: In an impl, paths of the same impl are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:16
        let y: MyImpl::<T>::InputType = x;
               ^*********^

//! > ==========================================================================

//! > An impl can be used in a path in its own body, if the generics are different.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType, y: Self::InputType) -> Self::OutputType;
}
impl MyImpl<T> of MyTrait<T> {
    type InputType = T;
    type OutputType = T;
    fn foo(x: MyImpl::<u32>::InputType, y: Self::InputType) -> MyImpl::<u32>::OutputType {
        let z: MyImpl::<u32>::InputType = x;
        z
    }
}

//! > expected_diagnostics
error: Parameter type of impl function `MyImpl::foo` is incompatible with `MyTrait::foo`. Expected: `T`, actual: `core::integer::u32`.
 --> lib.cairo:9:15
    fn foo(x: MyImpl::<u32>::InputType, y: Self::InputType) -> MyImpl::<u32>::OutputType {
              ^**********************^

error: Return type of impl function `MyImpl::foo` is incompatible with `MyTrait::foo`. Expected: `T`, actual: `core::integer::u32`.
 --> lib.cairo:9:64
    fn foo(x: MyImpl::<u32>::InputType, y: Self::InputType) -> MyImpl::<u32>::OutputType {
                                                               ^***********************^

//! > ==========================================================================

//! > An impl in a path in its own body should be fully explicit.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait SomeTrait {}
trait MyTrait {
    type InputType;
    fn foo();
}
impl MyImpl<T, +SomeTrait> of MyTrait {
    type InputType = u32;
    fn foo() {
        let _: MyImpl::<T>::InputType = 3;
    }
}

//! > expected_diagnostics
warning: In an impl, paths of the same impl must be fully explicit. Either use `Self` if this is the intention, or explicitly specify all the generic arguments.
 --> lib.cairo:9:16
        let _: MyImpl::<T>::InputType = 3;
               ^*********^

//! > ==========================================================================

//! > A trait, without generics, shouldn't be used in a path in the body of its own impl.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType) -> Self::OutputType;
    fn foo2();
}
impl MyImpl of MyTrait {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: MyTrait::InputType) -> MyTrait::OutputType {
        x
    }
    fn foo2() {
        let _: MyTrait::InputType = 3_u32;
    }
}

//! > expected_diagnostics
warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:16
    fn foo1(x: MyTrait::InputType) -> MyTrait::OutputType {
               ^*****^

warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:39
    fn foo1(x: MyTrait::InputType) -> MyTrait::OutputType {
                                      ^*****^

warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:14:16
        let _: MyTrait::InputType = 3_u32;
               ^*****^

//! > ==========================================================================

//! > A trait shouldn't be used in a path in the body of its own impl, with the same generics.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: warnings_only)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType) -> Self::OutputType;
    fn foo2();
}
impl MyImpl of MyTrait<u32> {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: MyTrait::<u32>::InputType) -> MyTrait::<u32>::OutputType {
        x
    }
    fn foo2() {
        let _: MyTrait::<u32>::InputType = 3_u32;
    }
}

//! > expected_diagnostics
warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:16
    fn foo1(x: MyTrait::<u32>::InputType) -> MyTrait::<u32>::OutputType {
               ^************^

warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:10:46
    fn foo1(x: MyTrait::<u32>::InputType) -> MyTrait::<u32>::OutputType {
                                             ^************^

warning: In an impl, paths of the impl's trait are not allowed. Did you mean to use `Self::`?
 --> lib.cairo:14:16
        let _: MyTrait::<u32>::InputType = 3_u32;
               ^************^

//! > ==========================================================================

//! > A trait can be used in a path in the body of an impl of it, if the generics are different.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType) -> Self::OutputType;
}
impl MyImpl_u16 of MyTrait<u16> {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: MyTrait::<u32>::InputType) -> MyTrait::<u32>::OutputType {
        let y: MyTrait::<u32>::InputType = 3_u32;
        y
    }
}
impl MyImpl_u32 of MyTrait<u32> {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: Self::InputType) -> Self::OutputType {
        let y: Self::InputType = 3_u32;
        y
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Incompatible signatures with trait/impl type items.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo1(x: Self::InputType);
    fn foo2() -> Self::OutputType;
    fn foo3(x: u16);
    fn foo4() -> u16;
}
impl MyImpl of MyTrait {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: u16) {} // param type doesn't match.
    fn foo2() -> u16 {
        1_u16
    } // return type doesn't match.
    fn foo3(x: Self::InputType) {} // param type doesn't match.
    fn foo4() -> Self::OutputType {
        1_u32
    } // return type doesn't match.
}

//! > expected_diagnostics
error: Parameter type of impl function `MyImpl::foo1` is incompatible with `MyTrait::foo1`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:12:16
    fn foo1(x: u16) {} // param type doesn't match.
               ^*^

error: Return type of impl function `MyImpl::foo2` is incompatible with `MyTrait::foo2`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:13:18
    fn foo2() -> u16 {
                 ^*^

error: Parameter type of impl function `MyImpl::foo3` is incompatible with `MyTrait::foo3`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:16:16
    fn foo3(x: Self::InputType) {} // param type doesn't match.
               ^*************^

error: Return type of impl function `MyImpl::foo4` is incompatible with `MyTrait::foo4`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:17:18
    fn foo4() -> Self::OutputType {
                 ^**************^

//! > ==========================================================================

//! > Member access of impl type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    let x = MyStruct { value: 3_u32 };
    let _: MyStruct<u32> = MyImpl::foo(x);
}

//! > function_name
foo

//! > module_code
struct MyStruct<T> {
    value: T,
}
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType) -> Self::OutputType;
}
impl MyImpl of MyTrait {
    type InputType = MyStruct<u32>;
    type OutputType = MyStruct<u32>;
    fn foo(x: Self::InputType) -> Self::OutputType {
        MyStruct { value: x.value }
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Method call on impl type that has this method.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    MyImpl::foo(Option::Some(3));
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = Option<usize>;
    fn foo(x: Self::InputType) {
        x.unwrap();
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Method call on impl type that doesn't have this method.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = usize;
    fn foo(x: Self::InputType) {
        x.unwrap();
    }
}

//! > expected_diagnostics
error[E0002]: Method `unwrap` could not be called on type `core::integer::u32`.
Candidate `OptionTrait::unwrap` inference failed with: Type mismatch: `core::integer::u32` and `core::option::Option::<?0>`.
Candidate `ResultTrait::unwrap` inference failed with: Type mismatch: `core::integer::u32` and `core::result::Result::<?0, ?1>`.
 --> lib.cairo:8:11
        x.unwrap();
          ^****^

//! > ==========================================================================

//! > Unary operator on impl type that implements it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    MyImpl::foo(3);
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = i32;
    fn foo(x: Self::InputType) {
        -x;
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Unary operator on impl type that doesn't implement it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = u32;
    fn foo(x: Self::InputType) {
        -x; // u32 doesn't implement `Neg`.
    }
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::traits::Neg::<core::integer::u32>.
 --> lib.cairo:8:9
        -x; // u32 doesn't implement `Neg`.
        ^^

//! > ==========================================================================

//! > Binary operator on impl types that implement it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    let _: usize = MyImpl::foo(3, 4);
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType1;
    type InputType2;
    type OutputType;
    fn foo(x: Self::InputType1, y: Self::InputType2) -> Self::OutputType;
}
impl MyImpl of MyTrait {
    type InputType1 = usize;
    type InputType2 = usize;
    type OutputType = usize;
    fn foo(x: Self::InputType1, y: Self::InputType2) -> Self::OutputType {
        x + y
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Binary operator on impl type that doesn't implement it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = Option<usize>;
    fn foo(x: Self::InputType) {
        let _ = x + x; // Option<usize> doesn't implement `Add`.
    }
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::traits::Add::<core::option::Option::<core::integer::u32>>.
 --> lib.cairo:8:17
        let _ = x + x; // Option<usize> doesn't implement `Add`.
                ^***^

//! > ==========================================================================

//! > Indexing an impl type that implements `Index`.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {
    MyImpl::foo(array![0]);
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: Self::InputType) -> Self::OutputType;
}
impl MyImpl of MyTrait {
    type InputType = Array<usize>;
    type OutputType = usize;
    fn foo(x: Self::InputType) -> Self::OutputType {
        *x[0_u32]
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Indexing an impl type that doesn't implement `Index`.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: Self::InputType);
}
impl MyImpl of MyTrait {
    type InputType = usize;
    fn foo(x: Self::InputType) {
        x[0];
    }
}

//! > expected_diagnostics
error: Type `core::integer::u32` could not be indexed.
Candidate `Index::index` inference failed with: Trait has no implementation in context: core::ops::index::Index::<core::integer::u32, ?1>.
Candidate `IndexView::index` inference failed with: Trait has no implementation in context: core::ops::index::IndexView::<core::integer::u32, ?1>.
 --> lib.cairo:8:9
        x[0];
        ^**^

//! > ==========================================================================

//! > Using traits' items is allowed in other traits, if well resolved.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl of AnotherTrait {
    type AnotherType = u32;
}
trait MyTrait {
    fn bar1(x: AnotherTrait::AnotherType);
    fn bar2() -> AnotherTrait::AnotherType;
}
impl MyImpl of MyTrait {
    fn bar1(x: u32) {}
    fn bar2() -> u32 {
        3_u32
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Using traits' items in other traits, well resolved, but with type mismatch.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl of AnotherTrait {
    type AnotherType = u16;
}
trait MyTrait {
    fn bar1(x: AnotherTrait::AnotherType);
    fn bar2() -> AnotherTrait::AnotherType;
}
impl MyImpl of MyTrait {
    fn bar1(x: u32) {}
    fn bar2() -> u32 {
        3_u32
    }
}

//! > expected_diagnostics
error: Parameter type of impl function `MyImpl::bar1` is incompatible with `MyTrait::bar1`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:12:16
    fn bar1(x: u32) {}
               ^*^

error: Return type of impl function `MyImpl::bar2` is incompatible with `MyTrait::bar2`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:13:18
    fn bar2() -> u32 {
                 ^*^

//! > ==========================================================================

//! > Using traits' items in other traits, but they can't be resolved.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
// A trait with 0 impls in the context.
trait AnotherTrait0 {
    type AnotherType;
}
// A trait with 2 impls in the context.
trait AnotherTrait2 {
    type AnotherType;
}
impl AnotherImpl20 of AnotherTrait2 {
    type AnotherType = u32;
}
impl AnotherImpl21 of AnotherTrait2 {
    type AnotherType = u32;
}
trait MyTrait {
    type MyType;
    fn bar1(x: AnotherTrait0::AnotherType);
    fn bar2() -> AnotherTrait0::AnotherType;
    fn bar3(x: AnotherTrait2::AnotherType);
    fn bar4() -> AnotherTrait2::AnotherType;
}

//! > expected_diagnostics
error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:17:31
    fn bar1(x: AnotherTrait0::AnotherType);
                              ^*********^

error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:18:33
    fn bar2() -> AnotherTrait0::AnotherType;
                                ^*********^

error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:19:31
    fn bar3(x: AnotherTrait2::AnotherType);
                              ^*********^

error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:20:33
    fn bar4() -> AnotherTrait2::AnotherType;
                                ^*********^

//! > ==========================================================================

//! > traits' items are resolved when there is a single impl in context.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl of AnotherTrait {
    type AnotherType = u32;
}
trait MyTrait {
    type MyType;
    fn foo1() -> u32;
    fn foo2(x: u32);
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn foo1() -> AnotherTrait::AnotherType {
        3_u32
    }
    fn foo2(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> MyTrait::MyType {
    3_u32
}
fn bar2(x: MyTrait::MyType) {
    let _: u32 = x;
}
fn bar3() {
    let _: MyTrait::MyType = 3_u32;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Mismatch of resolved traits' items when there is a single impl in context.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl of AnotherTrait {
    type AnotherType = u16;
}
trait MyTrait {
    type MyType;
    fn foo1() -> u32;
    fn foo2(x: u32);
}
impl MyImpl of MyTrait {
    type MyType = u16;
    fn foo1() -> AnotherTrait::AnotherType {
        3
    }
    fn foo2(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> MyTrait::MyType {
    3_u32
}
fn bar2(x: MyTrait::MyType) {
    let _: u32 = x;
}
fn bar3() {
    let _: MyTrait::MyType = 3_u32;
}

//! > expected_diagnostics
error: Return type of impl function `MyImpl::foo1` is incompatible with `MyTrait::foo1`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:14:18
    fn foo1() -> AnotherTrait::AnotherType {
                 ^***********************^

error: Parameter type of impl function `MyImpl::foo2` is incompatible with `MyTrait::foo2`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:17:16
    fn foo2(x: AnotherTrait::AnotherType) {}
               ^***********************^

error: Unexpected return type. Expected: "core::integer::u16", found: "core::integer::u32".
 --> lib.cairo:19:30
\   fn bar1() -> MyTrait::MyType {
|       3_u32
|   }
|___^

error: Unexpected argument type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:23:18
    let _: u32 = x;
                 ^

error: Type mismatch: `core::integer::u32` and `core::integer::u16`.
 --> lib.cairo:25:11
\   fn bar3() {
|       let _: MyTrait::MyType = 3_u32;
|   }
|___^

//! > ==========================================================================

//! > traits' items can't be resolved if there is no impl in context.

//! > TODO(yuval): try to eliminate redundant/duplicate diagnostics. Here and in other tests.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
trait MyTrait {
    fn foo1() -> u32;
    fn foo2(x: u32);
}
impl MyImpl of MyTrait {
    fn foo1() -> AnotherTrait::AnotherType {
        3_u32
    }
    fn foo2(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> AnotherTrait::AnotherType {
    3_u32
}
fn bar2(x: AnotherTrait::AnotherType) {}
fn bar3() {
    let _: AnotherTrait::AnotherType = 3_u32;
}

//! > expected_diagnostics
error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:9:32
    fn foo1() -> AnotherTrait::AnotherType {
                               ^*********^

error: Return type of impl function `MyImpl::foo1` is incompatible with `MyTrait::foo1`. Expected: `core::integer::u32`, actual: `<missing>`.
 --> lib.cairo:9:18
    fn foo1() -> AnotherTrait::AnotherType {
                 ^***********************^

error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:12:30
    fn foo2(x: AnotherTrait::AnotherType) {}
                             ^*********^

error: Parameter type of impl function `MyImpl::foo2` is incompatible with `MyTrait::foo2`. Expected: `core::integer::u32`, actual: `<missing>`.
 --> lib.cairo:12:16
    fn foo2(x: AnotherTrait::AnotherType) {}
               ^***********************^

error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:14:28
fn bar1() -> AnotherTrait::AnotherType {
                           ^*********^

error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:17:26
fn bar2(x: AnotherTrait::AnotherType) {}
                         ^*********^

error: Trait has no implementation in context: test::AnotherTrait.
 --> lib.cairo:19:26
    let _: AnotherTrait::AnotherType = 3_u32;
                         ^*********^

//! > ==========================================================================

//! > traits' items can't be resolved if there are multiple impls in context.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl1 of AnotherTrait {
    type AnotherType = u32;
}
impl AnotherImpl2 of AnotherTrait {
    type AnotherType = u32;
}
trait MyTrait {
    fn foo1() -> u32;
    fn foo2(x: u32);
}
impl MyImpl of MyTrait {
    fn foo1() -> AnotherTrait::AnotherType {
        3_u32
    }
    fn foo2(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> AnotherTrait::AnotherType {
    3_u32
}
fn bar2(x: AnotherTrait::AnotherType) {}
fn bar3() {
    let _: AnotherTrait::AnotherType = 3_u32;
}

//! > expected_diagnostics
error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:15:32
    fn foo1() -> AnotherTrait::AnotherType {
                               ^*********^

error: Return type of impl function `MyImpl::foo1` is incompatible with `MyTrait::foo1`. Expected: `core::integer::u32`, actual: `<missing>`.
 --> lib.cairo:15:18
    fn foo1() -> AnotherTrait::AnotherType {
                 ^***********************^

error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:18:30
    fn foo2(x: AnotherTrait::AnotherType) {}
                             ^*********^

error: Parameter type of impl function `MyImpl::foo2` is incompatible with `MyTrait::foo2`. Expected: `core::integer::u32`, actual: `<missing>`.
 --> lib.cairo:18:16
    fn foo2(x: AnotherTrait::AnotherType) {}
               ^***********************^

error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:20:28
fn bar1() -> AnotherTrait::AnotherType {
                           ^*********^

error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:23:26
fn bar2(x: AnotherTrait::AnotherType) {}
                         ^*********^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:25:26
    let _: AnotherTrait::AnotherType = 3_u32;
                         ^*********^

//! > ==========================================================================

//! > impl items are allowed, even in a trait body.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl1 of AnotherTrait {
    type AnotherType = u32;
}
impl AnotherImpl2 of AnotherTrait {
    type AnotherType = u16;
}
trait MyTrait {
    fn foo1() -> AnotherImpl1::AnotherType;
    fn foo2(x: AnotherImpl1::AnotherType);
}
impl MyImpl of MyTrait {
    fn foo1() -> AnotherImpl1::AnotherType {
        3_u32
    }
    fn foo2(x: AnotherImpl1::AnotherType) {}
}
fn bar1() -> AnotherImpl1::AnotherType {
    3_u32
}
fn bar2(x: AnotherImpl1::AnotherType) {}
fn bar3() {
    let _: AnotherImpl1::AnotherType = 3_u32;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > impl items are allowed in its own trait body.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType;
    fn foo1() -> MyImpl::MyType;
    fn foo2(x: MyImpl::MyType);
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn foo1() -> Self::MyType {
        3_u32
    }
    fn foo2(x: Self::MyType) {}
}

//! > expected_diagnostics

//! > ==========================================================================

//! > impl items in its own trait body, with type mismatch.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType;
    fn foo1() -> MyImpl::MyType;
    fn foo2(x: MyImpl::MyType);
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn foo1() -> Self::MyType {
        3_u16
    }
    fn foo2(x: Self::MyType) {}
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:8:31
\   fn foo1() -> Self::MyType {
|       3_u16
|   }
|___^

//! > ==========================================================================

//! > traits' items resolved in all kind of statements.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
}
impl MyImpl of MyTrait {
    type MyType1 = u32;
    type MyType2 = u32;
}
fn ret_statement(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    return x;
}
fn ret_expr(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    x
}
fn let_statement(x: MyTrait::MyType2) {
    let _: MyTrait::MyType1 = x;
}
fn break_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    loop {
        if cond {
            break x;
        } else {
            break y;
        }
    };
}
enum MyEnum {
    VariantA,
    VariantB,
}
fn match_statement(e: MyEnum, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    let _ = match e {
        MyEnum::VariantA => { x },
        MyEnum::VariantB => { y },
    };
}
fn if_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    if cond {
        x
    } else {
        y
    };
}
fn error_propagation(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Option::Some(x?)
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Diagnostics on mismatches with traits' items that are resolved in all kind of statements.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
}
impl MyImpl of MyTrait {
    type MyType1 = u16;
    type MyType2 = u32;
}
fn ret_statement(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    return x;
}
fn ret_expr(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    x
}
fn let_statement(x: MyTrait::MyType2) {
    let _: MyTrait::MyType1 = x;
}
fn break_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    loop {
        if cond {
            break x;
        } else {
            break y;
        }
    };
}
enum MyEnum {
    VariantA,
    VariantB,
}
fn match_statement(e: MyEnum, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    let _ = match e {
        MyEnum::VariantA => { x },
        MyEnum::VariantB => { y },
    };
}
fn if_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    if cond {
        x
    } else {
        y
    };
}
fn error_propagation(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Option::Some(x?)
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:10:12
    return x;
           ^

error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:12:54
\   fn ret_expr(x: MyTrait::MyType1) -> MyTrait::MyType2 {
|       x
|   }
|___^

error: Type mismatch: `core::integer::u32` and `core::integer::u16`.
 --> lib.cairo:15:39
\   fn let_statement(x: MyTrait::MyType2) {
|       let _: MyTrait::MyType1 = x;
|   }
|___^

error: Loop has incompatible return types: "core::integer::u16" and "core::integer::u32"
 --> lib.cairo:23:19
            break y;
                  ^

error: Match arms have incompatible types: "core::integer::u16" and "core::integer::u32"
 --> lib.cairo:34:29
        MyEnum::VariantB => { y },
                            ^***^

error: If blocks have incompatible types: "core::integer::u16" and "core::integer::u32"
 --> lib.cairo:38:5
\   if cond {
|       x
|   } else {
|       y
|   }
|___^

error: Unexpected return type. Expected: "core::option::Option::<core::integer::u32>", found: "core::option::Option::<core::integer::u16>".
 --> lib.cairo:44:79
\   fn error_propagation(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
|       Option::Some(x?)
|   }
|___^

//! > ==========================================================================

//! > Recursive resolution.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    type MyType3;
    type MyType4;
}
impl MyImpl of MyTrait {
    type MyType1 = u32;
    type MyType2 = u32;
    type MyType3 = u32;
    type MyType4 = u32;
}
fn generic_args(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Option::Some(x?)
}
fn tuple(x: MyTrait::MyType1, y: MyTrait::MyType2) -> (MyTrait::MyType2, MyTrait::MyType1) {
    (x, y)
}
fn fix_sized_array(x: [MyTrait::MyType1; 3]) -> [MyTrait::MyType2; 3] {
    x
}
fn snapshot(x: @@MyTrait::MyType1) -> @@MyTrait::MyType2 {
    x
}
fn snapshot2(x: @MyTrait::MyType1) -> @@MyTrait::MyType2 {
    @x
}
fn complex1(
    x: @(
        MyTrait::MyType1,
        Option<@Result<[Option<MyTrait::MyType2>; 3], (@MyTrait::MyType3, MyTrait::MyType4)>>
    )
) -> @(u32, Option<@Result<[Option<u32>; 3], (@u32, u32)>>) {
    x
}
fn complex2(
    x: @(u32, Option<@Result<[Option<u32>; 3], (@u32, u32)>>)
) -> @(
    MyTrait::MyType1,
    Option<@Result<[Option<MyTrait::MyType2>; 3], (@MyTrait::MyType3, MyTrait::MyType4)>>
) {
    x
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Diagnostics on mismatches with recursive resolution.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    type MyType3;
    type MyType4;
}
impl MyImpl of MyTrait {
    type MyType1 = u16;
    type MyType2 = u32;
    type MyType3 = u32;
    type MyType4 = u32;
}
fn generic_args(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Option::Some(x?)
}
fn tuple(x: MyTrait::MyType1, y: MyTrait::MyType2) -> (MyTrait::MyType2, MyTrait::MyType1) {
    (x, y)
}
fn fix_sized_array(x: [MyTrait::MyType1; 3]) -> [MyTrait::MyType2; 3] {
    x
}
fn snapshot(x: @@MyTrait::MyType1) -> @@MyTrait::MyType2 {
    x
}
fn snapshot2(x: @MyTrait::MyType1) -> @@MyTrait::MyType2 {
    @x
}
fn complex1(
    x: @(
        MyTrait::MyType1,
        Option<@Result<[Option<MyTrait::MyType2>; 3], (@MyTrait::MyType3, MyTrait::MyType4)>>
    )
) -> @(u32, Option<@Result<[Option<u32>; 3], (@u32, u32)>>) {
    x
}
fn complex2(
    x: @(u32, Option<@Result<[Option<u32>; 3], (@u32, u32)>>)
) -> @(
    MyTrait::MyType1,
    Option<@Result<[Option<MyTrait::MyType2>; 3], (@MyTrait::MyType3, MyTrait::MyType4)>>
) {
    x
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::option::Option::<core::integer::u32>", found: "core::option::Option::<core::integer::u16>".
 --> lib.cairo:13:74
\   fn generic_args(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
|       Option::Some(x?)
|   }
|___^

error: Unexpected return type. Expected: "(core::integer::u32, core::integer::u16)", found: "(core::integer::u16, core::integer::u32)".
 --> lib.cairo:16:92
\   fn tuple(x: MyTrait::MyType1, y: MyTrait::MyType2) -> (MyTrait::MyType2, MyTrait::MyType1) {
|       (x, y)
|   }
|___^

error: Unexpected return type. Expected: "[core::integer::u32; 3]", found: "[core::integer::u16; 3]".
 --> lib.cairo:19:71
\   fn fix_sized_array(x: [MyTrait::MyType1; 3]) -> [MyTrait::MyType2; 3] {
|       x
|   }
|___^

error: Unexpected return type. Expected: "@@core::integer::u32", found: "@@core::integer::u16".
 --> lib.cairo:22:58
\   fn snapshot(x: @@MyTrait::MyType1) -> @@MyTrait::MyType2 {
|       x
|   }
|___^

error: Unexpected return type. Expected: "@@core::integer::u32", found: "@@core::integer::u16".
 --> lib.cairo:25:58
\   fn snapshot2(x: @MyTrait::MyType1) -> @@MyTrait::MyType2 {
|       @x
|   }
|___^

error: Unexpected return type. Expected: "@(core::integer::u32, core::option::Option::<@core::result::Result::<[core::option::Option::<core::integer::u32>; 3], (@core::integer::u32, core::integer::u32)>>)", found: "@(core::integer::u16, core::option::Option::<@core::result::Result::<[core::option::Option::<core::integer::u32>; 3], (@core::integer::u32, core::integer::u32)>>)".
 --> lib.cairo:33:61
\   ) -> @(u32, Option<@Result<[Option<u32>; 3], (@u32, u32)>>) {
|       x
|   }
|___^

error: Unexpected return type. Expected: "@(core::integer::u16, core::option::Option::<@core::result::Result::<[core::option::Option::<core::integer::u32>; 3], (@core::integer::u32, core::integer::u32)>>)", found: "@(core::integer::u32, core::option::Option::<@core::result::Result::<[core::option::Option::<core::integer::u32>; 3], (@core::integer::u32, core::integer::u32)>>)".
 --> lib.cairo:41:3
\   ) {
|       x
|   }
|___^

//! > ==========================================================================

//! > Diagnostics on using trait function as a type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo(x: MyImpl::my_function) {
    let _: MyImpl::my_function = 3;
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType;
    fn my_function() -> u16;
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn my_function() -> u16 {
        2_u16
    }
}

//! > expected_diagnostics
error: Not a type.
 --> lib.cairo:11:11
fn foo(x: MyImpl::my_function) {
          ^*****************^

error: Not a type.
 --> lib.cairo:12:12
    let _: MyImpl::my_function = 3;
           ^*****************^

//! > ==========================================================================

//! > Impl type chain resolution.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    fn bar(x: Self::MyType1) -> u32;
}
impl MyImpl of MyTrait {
    type MyType1 = Self::MyType2;
    type MyType2 = u32;
    fn bar(x: Self::MyType1) -> u32 {
        x
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Impl type chain resolution, with mismatch types.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    fn bar(x: Self::MyType1) -> u32;
}
impl MyImpl of MyTrait {
    type MyType1 = Self::MyType2;
    type MyType2 = u16;
    fn bar(x: Self::MyType1) -> u32 {
        x
    }
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:9:37
\   fn bar(x: Self::MyType1) -> u32 {
|       x
|   }
|___^

//! > ==========================================================================

//! > Impl types cycle of length 1.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
}
impl MyImpl of MyTrait {
    type MyType1 = Self::MyType1;
}

//! > expected_diagnostics
error: Cycle detected while resolving type-alias/impl-type items.
 --> lib.cairo:5:10
    type MyType1 = Self::MyType1;
         ^*****^

//! > ==========================================================================

//! > Impl types cycle of length 2.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
}
impl MyImpl of MyTrait {
    type MyType1 = Self::MyType2;
    type MyType2 = Self::MyType1;
}

//! > expected_diagnostics
error: Cycle detected while resolving type-alias/impl-type items.
 --> lib.cairo:6:10
    type MyType1 = Self::MyType2;
         ^*****^

error: Cycle detected while resolving type-alias/impl-type items.
 --> lib.cairo:7:10
    type MyType2 = Self::MyType1;
         ^*****^

//! > ==========================================================================

//! > Error propagation of `Self::` type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    fn bar(x: Self::MyType1) -> Self::MyType2;
}
impl MyImpl of MyTrait {
    type MyType1 = Option<()>;
    type MyType2 = Option<()>;
    fn bar(x: Self::MyType1) -> Self::MyType2 {
        Option::Some(x?)
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > `Self::` segment in unsupported context.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
fn free_func(x: Self::MyType1) -> Self::MyType2 {
    let _: Self::MyType3 = 3;
}

//! > expected_diagnostics
error: `Self` is not supported in this context.
 --> lib.cairo:1:17
fn free_func(x: Self::MyType1) -> Self::MyType2 {
                ^**^

error: `Self` is not supported in this context.
 --> lib.cairo:1:35
fn free_func(x: Self::MyType1) -> Self::MyType2 {
                                  ^**^

error: `Self` is not supported in this context.
 --> lib.cairo:2:12
    let _: Self::MyType3 = 3;
           ^**^

//! > ==========================================================================

//! > `Self` segment for a result type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > TODO(orizi): Make this not generate diagnostics.

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyInto<T, S> {
    fn my_into(self: T) -> S;
}
mod inner {
    struct MyType {}
    impl MyU16IntoMyType of super::MyInto<u16, MyType> {
        fn my_into(self: u16) -> MyType {
            MyType {}
        }
    }
}
use inner::MyType;
trait MyTrait {
    type MyTraitType;
    fn bar() -> Self::MyTraitType;
}
impl MyImpl of MyTrait {
    type MyTraitType = (MyType, MyType);
    fn bar() -> Self::MyTraitType {
        let _: Self::MyTraitType = (3_u16.my_into(), 3_u16.my_into());
        (3_u16.my_into(), 3_u16.my_into())
    }
}

//! > expected_diagnostics
error[E0002]: Method `my_into` could not be called on type `core::integer::u16`.
Candidate `MyInto::my_into` inference failed with: Trait has no implementation in context: test::MyInto::<core::integer::u16, ?1>.
 --> lib.cairo:20:43
        let _: Self::MyTraitType = (3_u16.my_into(), 3_u16.my_into());
                                          ^*****^

error[E0002]: Method `my_into` could not be called on type `core::integer::u16`.
Candidate `MyInto::my_into` inference failed with: Trait has no implementation in context: test::MyInto::<core::integer::u16, ?1>.
 --> lib.cairo:20:60
        let _: Self::MyTraitType = (3_u16.my_into(), 3_u16.my_into());
                                                           ^*****^

error[E0002]: Method `my_into` could not be called on type `core::integer::u16`.
Candidate `MyInto::my_into` inference failed with: Trait has no implementation in context: test::MyInto::<core::integer::u16, ?1>.
 --> lib.cairo:21:16
        (3_u16.my_into(), 3_u16.my_into())
               ^*****^

error[E0002]: Method `my_into` could not be called on type `core::integer::u16`.
Candidate `MyInto::my_into` inference failed with: Trait has no implementation in context: test::MyInto::<core::integer::u16, ?1>.
 --> lib.cairo:21:33
        (3_u16.my_into(), 3_u16.my_into())
                                ^*****^

//! > ==========================================================================

//! > using an impl's associated type in a concrete impl with generic args.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() -> u32 {
    let x: MyImpl::<u32>::ty = 4;
    x
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

impl MyImpl<K> of MyTrait {
    type ty = K;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > trait's associated type is not inferred from a concrete impl with generic args.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() -> u32 {
    let x: MyTrait::ty = 4_u32;
    x
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

impl MyImpl<K> of MyTrait {
    type ty = K;
}
///TODO(TomerStarkware): infer impl types from trait types.

//! > expected_diagnostics
error: Candidate impl test::MyImpl::<?0> has an unused generic parameter.
 --> lib.cairo:10:21
    let x: MyTrait::ty = 4_u32;
                    ^^

//! > ==========================================================================

//! > using an impl's associated type in a function signature of a concrete impl with generic args.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo(x: felt252, y: felt252, z: felt252, w: felt252) -> felt252 {
    DepAdd::<felt252>::other_add(x, y)
}

//! > function_name
foo

//! > module_code
trait OtherAdd<Lhs, Rhs> {
    type Output;
    fn other_add(lhs: Lhs, rhs: Rhs) -> Self::Output;
}
impl DepAdd<T> of OtherAdd<T, T> {
    type Output = T;
    fn other_add(lhs: T, rhs: T) -> T {
        lhs
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > using a trait's associated type in a function signature of a concrete impl with generic args.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo(x: felt252, y: felt252, z: felt252, w: felt252) -> felt252 {
    OtherAdd::<felt252>::other_add(x, y)
}

//! > function_name
foo

//! > module_code
trait OtherAdd<Lhs, Rhs> {
    type Output;
    fn other_add(lhs: Lhs, rhs: Rhs) -> Self::Output;
}
impl DepAdd<T> of OtherAdd<T, T> {
    type Output = T;
    fn other_add(lhs: T, rhs: T) -> T {
        lhs
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > using a generic impl with generic args.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() -> felt252 {
    bar::<_, DepAdd>(3_felt252, 4)
}
pub fn bar<T, +OtherAdd<T, T>>(x: T, y: T) -> OtherAdd::<T, T>::Output {
    OtherAdd::other_add(x, y)
}

//! > function_name
foo

//! > module_code
trait OtherAdd<Lhs, Rhs> {
    type Output;
    fn other_add(lhs: Lhs, rhs: Rhs) -> Self::Output;
}
impl DepAdd<T, +Drop<T>> of OtherAdd<T, T> {
    type Output = T;
    fn other_add(lhs: T, rhs: T) -> T {
        lhs
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Accessing a member of a type that is a trait's associated type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() -> felt252 {
    let x = Trt::foo();
    x.t
}

//! > function_name
foo

//! > module_code
trait Trt {
    type T;
    fn foo() -> Self::T;
}

//! > expected_diagnostics
error: Type annotations needed. Failed to infer ?0.
 --> lib.cairo:7:7
    x.t
      ^

//! > ==========================================================================

//! > Using self calls.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait Trt<T> {
    type Assoc;
    fn func(self: T) -> Self::Assoc;
}

fn bar<T, impl TrtImp: Trt<T>>(x: T) -> TrtImp::Assoc {
    x.func()
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Trait associated types reading.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() -> u32 {
    array![12, 13, 14].first()
}

//! > function_name
foo

//! > module_code
trait FirstTrait<T> {
    type Element;
    fn first(self: T) -> Self::Element;
}

impl ArrayFirst<T> of FirstTrait<Array<T>> {
    type Element = T;
    fn first(mut self: Array<T>) -> T {
        self.pop_front().unwrap()
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Use of missing Impl type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {
    let _: MyImpl::ty = 5;
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}
impl MyImpl of MyTrait {}

//! > expected_diagnostics
error: Not all trait items are implemented. Missing: 'ty'.
 --> lib.cairo:4:6
impl MyImpl of MyTrait {}
     ^****^

error: Trait has no implementation in context: test::MyTrait.
 --> lib.cairo:5:10
\   fn foo() {
|       let _: MyImpl::ty = 5;
|   }
|___^

//! > ==========================================================================

//! > Associated type bounds.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn bar<+MyTrait, +core::metaprogramming::TypeEqual<MyTrait::ty, felt252>>(
    _y: MyTrait::ty
) -> felt252 {
    _y + 3
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Associated type bounds transitive.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<
    impl I1: MyTrait,
    impl I2: MyTrait,
    +core::metaprogramming::TypeEqual<I1::ty, I2::ty>,
    +core::metaprogramming::TypeEqual<felt252, I1::ty>
>() -> I2::ty {
    3_u32
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::felt252", found: "core::integer::u32".
 --> lib.cairo:9:15
\   >() -> I2::ty {
|       3_u32
|   }
|___^

//! > ==========================================================================

//! > Associated type bounds conflicts.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<
    +MyTrait,
    +core::metaprogramming::TypeEqual<MyTrait::ty, felt252>,
    +core::metaprogramming::TypeEqual<MyTrait::ty, u32>
>(
    _y: MyTrait::ty
) -> MyTrait::ty {
    _y
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}

//! > expected_diagnostics
error: Type mismatch: `core::felt252` and `core::integer::u32`.
 --> lib.cairo:10:18
\   ) -> MyTrait::ty {
|       _y
|   }
|___^

//! > ==========================================================================

//! > Associated type bounds inference based on bounds.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
///TODO(TomerStarkware): remove diagnostic and make it compile without errors.
fn bar<
    +MyTrait,
    +core::metaprogramming::TypeEqual<MyTrait::ty, felt252>,
    +TraitWithInferredParams<MyTrait::ty>,
>(
    _y: MyTrait::ty
) -> MyTrait::ty {
    _y + TraitWithInferredParams::<MyTrait::ty>::foo()
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
}
trait OtherTrait<T> {
    fn foo() -> T;
}
impl OtherImpl of OtherTrait<felt252> {
    fn foo() -> felt252 {
        3
    }
}
trait TraitWithInferredParams<T, +OtherTrait<T>> {
    fn foo() -> T;
}

//! > expected_diagnostics
error: Trait has no implementation in context: test::OtherTrait::<_::ty>.
 --> lib.cairo:19:6
    +TraitWithInferredParams<MyTrait::ty>,
     ^*********************^

error: Trait has no implementation in context: test::TraitWithInferredParams::<core::felt252, test::OtherImpl>.
 --> lib.cairo:23:50
    _y + TraitWithInferredParams::<MyTrait::ty>::foo()
                                                 ^*^

//! > ==========================================================================

//! > Associated type bounds, only bound associated types to another associated type. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn bar<
    impl I1: MyTrait, impl I2: MyTrait, +core::metaprogramming::TypeEqual<I1::ty, I2::ty>
>() -> I1::ty {
    I2::foo()
}
fn foo() {
    bar::<MyImplu32, MyImplu32>();
    bar::<MyImplfelt252, MyImplfelt252>();
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}
impl MyImplu32 of MyTrait {
    type ty = u32;
    fn foo() -> Self::ty {
        3
    }
}
impl MyImplfelt252 of MyTrait {
    type ty = felt252;
    fn foo() -> Self::ty {
        3
    }
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Associated type bounds, only bound associated types to another associated type wrong type. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<
    impl I1: MyTrait, impl I2: MyTrait, +core::metaprogramming::TypeEqual<I1::ty, I2::ty>
>() -> I1::ty {
    I2::foo()
}
fn foo() {
    bar::<MyImplu32, MyImplfelt252>();
}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}
impl MyImplu32 of MyTrait {
    type ty = u32;
    fn foo() -> Self::ty {
        3
    }
}
impl MyImplfelt252 of MyTrait {
    type ty = felt252;
    fn foo() -> Self::ty {
        3
    }
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::metaprogramming::TypeEqual::<core::integer::u32, core::felt252>.
 --> lib.cairo:23:5
    bar::<MyImplu32, MyImplfelt252>();
    ^*^

//! > ==========================================================================

//! > Associated type bounds, only bound associated types to another associated inferring type. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn bar<
    impl I1: MyTrait, impl I2: MyTrait, +core::metaprogramming::TypeEqual<I1::ty, I2::ty>
>() -> I2::ty {
    I1::foo()
}
fn bar2<impl I1: MyTrait, impl I2: MyTrait>() -> I2::ty {
    bar::<I1, I2>()
}
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type ty;
    fn foo() -> Self::ty;
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::metaprogramming::TypeEqual::<I1::ty, I2::ty>.
 --> lib.cairo:11:5
    bar::<I1, I2>()
    ^*^

//! > ==========================================================================

//! > Reimplementing TypeEqual trait. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
impl I of core::metaprogramming::TypeEqual<u32, felt252>;

//! > expected_diagnostics
error: Type equals trait should not be re-implemented.
 --> lib.cairo:1:11
impl I of core::metaprogramming::TypeEqual<u32, felt252>;
          ^********************************************^

//! > ==========================================================================

//! > TypeEqual with 3 generic parameters. 

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
fn bar<T, impl I: core::metaprogramming::TypeEqual<T, T, T>>() {}

//! > expected_diagnostics
error: Expected 2 generic arguments, found 3.
 --> lib.cairo:1:58
fn bar<T, impl I: core::metaprogramming::TypeEqual<T, T, T>>() {}
                                                         ^

//! > ==========================================================================

//! > TypeEqual with non type parameter.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
fn bar<T, const C: u32, impl I: core::metaprogramming::TypeEqual<T, C>>() {}

//! > expected_diagnostics
error: Not a type.
 --> lib.cairo:1:69
fn bar<T, const C: u32, impl I: core::metaprogramming::TypeEqual<T, C>>() {}
                                                                    ^
