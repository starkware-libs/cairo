//! > Test type items in trait/impl.

//! > TODO(yg):
* Later: 1. "Self::", 2. generics.
* Cycles/chains: 1. type Type2 = Self::Type1. 2. cycle: type Type2 = Self::Type1; type Type1 = Self::Type2;
* more tests: method call on a trait type according to the type it's assigned.
* make sure it works with type aliases. Add a test for it.
* Consider and add test: should using impls' types in traits be allowed? If any - make sure cycles are avoided. And if not allowed - consider whether impls' types should be allowed to be used in other impls.
* Add tests for trait MyTrait { fn foo() -> AnotherImpl::AnotherType; } - should it be supported? Beware cycles.
* Add tests for impl::MyType, for impl in {generic impls, ImplVars}.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo1(x: MyTrait::InputType) -> MyTrait::OutputType;
    fn foo2(x: MyTrait::InputType) -> MyTrait::OutputType;
    fn foo3(x: MyTrait::InputType) -> MyTrait::OutputType;
    fn foo4(x: u32) -> u32;
    fn foo5(x: u32) -> u32;
}
impl MyImpl of MyTrait {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: MyTrait::InputType) -> MyTrait::OutputType { x }
    fn foo2(x: MyImpl::InputType) -> MyImpl::OutputType { x }
    fn foo3(x: u32) -> u32 { x }
    fn foo4(x: MyTrait::InputType) -> MyTrait::OutputType { x }
    fn foo5(x: MyImpl::InputType) -> MyImpl::OutputType { x }
}
fn main() {
   MyImpl::foo1(3_u32);
   MyImpl::foo2(3_u32);
   MyImpl::foo3(3_u32);
   MyImpl::foo4(3_u32);
   MyImpl::foo5(3_u32);
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Incompatible signatures with trait/impl type items.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo1(x: MyTrait::InputType);
    fn foo2() -> MyTrait::OutputType;
    fn foo3(x: u16);
    fn foo4() -> u16;
}
impl MyImpl of MyTrait {
    type InputType = u32;
    type OutputType = u32;
    fn foo1(x: u16) {} // param type doesn't match.
    fn foo2() -> u16 { 1_u16 } // return type doesn't match.
    fn foo3(x: MyImpl::InputType) {} // param type doesn't match.
    fn foo4() -> MyImpl::OutputType { 1_u32 } // return type doesn't match.
}

//! > expected_diagnostics
error: Parameter type of impl function `MyImpl::foo1` is incompatible with `MyTrait::foo1`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:12:16
    fn foo1(x: u16) {} // param type doesn't match.
               ^*^

error: Return type of impl function `MyImpl::foo2` is incompatible with `MyTrait::foo2`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:13:18
    fn foo2() -> u16 { 1_u16 } // return type doesn't match.
                 ^*^

error: Parameter type of impl function `MyImpl::foo3` is incompatible with `MyTrait::foo3`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:14:16
    fn foo3(x: MyImpl::InputType) {} // param type doesn't match.
               ^***************^

error: Return type of impl function `MyImpl::foo4` is incompatible with `MyTrait::foo4`. Expected: `core::integer::u16`, actual: `core::integer::u32`.
 --> lib.cairo:15:18
    fn foo4() -> MyImpl::OutputType { 1_u32 } // return type doesn't match.
                 ^****************^

//! > ==========================================================================

//! > Member access of impl type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
struct MyStruct<T> {
   value: T,
}
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: MyTrait::InputType) -> MyTrait::OutputType;
}
impl MyImpl of MyTrait {
    type InputType = MyStruct<u32>;
    type OutputType = MyStruct<u32>;
    fn foo(x: MyImpl::InputType) -> MyImpl::OutputType {
        MyStruct { value: x.value }
    }
}
fn main() {
   let x = MyStruct { value: 3_u32 };
   let _: MyStruct<u32> = MyImpl::foo(x);
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Method call on impl type that has this method.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: MyTrait::InputType);
}
impl MyImpl of MyTrait {
    type InputType = Option<usize>;
    fn foo(x: MyImpl::InputType) {
        x.unwrap();
    }
}
fn main() {
   MyImpl::foo(Option::Some(3));
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Method call on impl type that doesn't have this method.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: MyTrait::InputType);
}
impl MyImpl of MyTrait {
    type InputType = usize;
    fn foo(x: MyImpl::InputType) {
        x.unwrap();
    }
}

//! > expected_diagnostics
error: Method `unwrap` could not be called on type `core::integer::u32`.
Candidate `OptionTrait::unwrap` inference failed with: Type mismatch: `core::integer::u32` and `core::option::Option::<?0>`
Candidate `ResultTrait::unwrap` inference failed with: Type mismatch: `core::integer::u32` and `core::result::Result::<?0, ?1>`
 --> lib.cairo:8:11
        x.unwrap();
          ^****^

//! > ==========================================================================

//! > Unary operator on impl type that implements it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: MyTrait::InputType);
}
impl MyImpl of MyTrait {
    type InputType = i32;
    fn foo(x: MyImpl::InputType) {
        -x;
    }
}
fn main() {
   MyImpl::foo(3);
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Unary operator on impl type that doesn't implement it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: MyTrait::InputType);
}
impl MyImpl of MyTrait {
    type InputType = u32;
    fn foo(x: MyImpl::InputType) {
        -x; // u32 doesn't implement `Neg`.
    }
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::traits::Neg::<core::integer::u32>
 --> lib.cairo:8:9
        -x; // u32 doesn't implement `Neg`.
        ^^

//! > ==========================================================================

//! > Binary operator on impl types that implement it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType1;
    type InputType2;
    type OutputType;
    fn foo(x: MyTrait::InputType1, y: MyTrait::InputType2) -> MyTrait::OutputType;
}
impl MyImpl of MyTrait {
    type InputType1 = usize;
    type InputType2 = usize;
    type OutputType = usize;
    fn foo(x: MyImpl::InputType1, y: MyImpl::InputType2) -> MyImpl::OutputType {
        x + y
    }
}
fn main() {
   let _: usize = MyImpl::foo(3, 4);
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Binary operator on impl type that doesn't implement it.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: MyTrait::InputType);
}
impl MyImpl of MyTrait {
    type InputType = Option<usize>;
    fn foo(x: MyImpl::InputType) {
        x + x; // Option<usize> doesn't implement `Add`.
    }
}

//! > expected_diagnostics
error: Trait has no implementation in context: core::traits::Add::<core::option::Option::<core::integer::u32>>
 --> lib.cairo:8:9
        x + x; // Option<usize> doesn't implement `Add`.
        ^***^

//! > ==========================================================================

//! > Indexing an impl type that implements `Index`.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    type OutputType;
    fn foo(x: MyTrait::InputType)  -> MyTrait::OutputType;
}
impl MyImpl of MyTrait {
    type InputType = Array<usize>;
    type OutputType = usize;
    fn foo(x: MyImpl::InputType) -> MyImpl::OutputType {
        *x[0_u32]
    }
}
fn main() {
   MyImpl::foo(array![0]);
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Indexing an impl type that doesn't implement `Index`.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type InputType;
    fn foo(x: MyTrait::InputType);
}
impl MyImpl of MyTrait {
    type InputType = usize;
    fn foo(x: MyImpl::InputType) {
        x[0];
    }
}

//! > expected_diagnostics
error: Type `core::integer::u32` could not be indexed.
Candidate `Index::index` inference failed with: Trait has no implementation in context: core::traits::Index::<core::integer::u32, ?2, ?3>
Candidate `IndexView::index` inference failed with: Trait has no implementation in context: core::traits::IndexView::<core::integer::u32, ?2, ?3>
 --> lib.cairo:8:9
        x[0];
        ^**^

//! > ==========================================================================

//! > Using traits' items is prohibited in traits.

//! > TODO(yg): disallow `MyTrait::` in `MyTrait`.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
trait MyTrait {
    type MyType;
    fn bar1(x: MyTrait::MyType);
    fn bar2() -> MyTrait::MyType;
    fn bar3(x: AnotherTrait::AnotherType);
    fn bar4() -> AnotherTrait::AnotherType;
}

//! > expected_diagnostics
error: Trait types are not supported inside traits. Did you mean to use `Self::`?
 --> lib.cairo:8:16
    fn bar3(x: AnotherTrait::AnotherType);
               ^***********************^

error: Trait types are not supported inside traits. Did you mean to use `Self::`?
 --> lib.cairo:9:18
    fn bar4() -> AnotherTrait::AnotherType;
                 ^***********************^

//! > ==========================================================================

//! > Using traits' items is prohibited in traits + impl diagnostics.

//! > TODO(yg): disallow `MyTrait::` in `MyTrait`.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
trait MyTrait {
    type MyType;
    fn bar1(x: MyTrait::MyType);
    fn bar2() -> MyTrait::MyType;
    fn bar3(x: AnotherTrait::AnotherType);
    fn bar4() -> AnotherTrait::AnotherType;
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn bar1(x: u32) {}
    fn bar2() -> u32 { 3_u32 }
    fn bar3(x: u32) {}
    fn bar4() -> u32 { 3_u32 }
}

//! > expected_diagnostics
error: Trait types are not supported inside traits. Did you mean to use `Self::`?
 --> lib.cairo:8:16
    fn bar3(x: AnotherTrait::AnotherType);
               ^***********************^

error: Trait types are not supported inside traits. Did you mean to use `Self::`?
 --> lib.cairo:9:18
    fn bar4() -> AnotherTrait::AnotherType;
                 ^***********************^

error: Parameter type of impl function `MyImpl::bar3` is incompatible with `MyTrait::bar3`. Expected: `<missing>`, actual: `core::integer::u32`.
 --> lib.cairo:15:16
    fn bar3(x: u32) {}
               ^*^

error: Return type of impl function `MyImpl::bar4` is incompatible with `MyTrait::bar4`. Expected: `<missing>`, actual: `core::integer::u32`.
 --> lib.cairo:16:18
    fn bar4() -> u32 { 3_u32 }
                 ^*^

//! > ==========================================================================

//! > traits' items are resolved when there is a single impl in context.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl of AnotherTrait {
    type AnotherType = u32;
}
trait MyTrait {
    type MyType;
    fn foo1() -> u32;
    fn foo2(x: u32);
    fn foo3() -> u32;
    fn foo4(x: u32);
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn foo1() -> MyTrait::MyType { 3_u32 }
    fn foo2(x: MyTrait::MyType) {}
    fn foo3() -> AnotherTrait::AnotherType { 3_u32 }
    fn foo4(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> MyTrait::MyType { 3_u32 }
fn bar2(x: MyTrait::MyType) {
    let _: u32 = x;
}
fn bar3() {
    let _: MyTrait::MyType = 3_u32;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Mismatch of resolved traits' items when there is a single impl in context.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl of AnotherTrait {
    type AnotherType = u16;
}
trait MyTrait {
    type MyType;
    fn foo1() -> u32;
    fn foo2(x: u32);
    fn foo3() -> u32;
    fn foo4(x: u32);
}
impl MyImpl of MyTrait {
    type MyType = u16;
    fn foo1() -> MyTrait::MyType { 3_u32 }
    fn foo2(x: MyTrait::MyType) {}
    fn foo3() -> AnotherTrait::AnotherType { 3_u32 }
    fn foo4(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> MyTrait::MyType { 3_u32 }
fn bar2(x: MyTrait::MyType) {
    let _: u32 = x;
}
fn bar3() {
    let _: MyTrait::MyType = 3_u32;
}

//! > expected_diagnostics
error: Return type of impl function `MyImpl::foo1` is incompatible with `MyTrait::foo1`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:16:18
    fn foo1() -> MyTrait::MyType { 3_u32 }
                 ^*************^

error: Unexpected return type. Expected: "core::integer::u16", found: "core::integer::u32".
 --> lib.cairo:16:34
    fn foo1() -> MyTrait::MyType { 3_u32 }
                                 ^*******^

error: Parameter type of impl function `MyImpl::foo2` is incompatible with `MyTrait::foo2`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:17:16
    fn foo2(x: MyTrait::MyType) {}
               ^*************^

error: Return type of impl function `MyImpl::foo3` is incompatible with `MyTrait::foo3`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:18:18
    fn foo3() -> AnotherTrait::AnotherType { 3_u32 }
                 ^***********************^

error: Unexpected return type. Expected: "core::integer::u16", found: "core::integer::u32".
 --> lib.cairo:18:44
    fn foo3() -> AnotherTrait::AnotherType { 3_u32 }
                                           ^*******^

error: Parameter type of impl function `MyImpl::foo4` is incompatible with `MyTrait::foo4`. Expected: `core::integer::u32`, actual: `core::integer::u16`.
 --> lib.cairo:19:16
    fn foo4(x: AnotherTrait::AnotherType) {}
               ^***********************^

error: Unexpected return type. Expected: "core::integer::u16", found: "core::integer::u32".
 --> lib.cairo:21:30
fn bar1() -> MyTrait::MyType { 3_u32 }
                             ^*******^

error: Unexpected argument type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:23:18
    let _: u32 = x;
                 ^

error: Unexpected argument type. Expected: "core::integer::u16", found: "core::integer::u32".
 --> lib.cairo:26:30
    let _: MyTrait::MyType = 3_u32;
                             ^***^

//! > ==========================================================================

//! > traits' items can't be resolved if there is no impl in context.

//! > TODO(yuval): try to eliminate redundant diagnostics.

//! > TODO(yuval): try to change "ImplVarId(#)::..." in diagnostics to "<missing>".

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
trait MyTrait {
    fn foo1() -> u32;
    fn foo2(x: u32);
}
impl MyImpl of MyTrait {
    fn foo1() -> AnotherTrait::AnotherType { 3_u32 }
    fn foo2(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> AnotherTrait::AnotherType { 3_u32 }
fn bar2(x: AnotherTrait::AnotherType) {}
fn bar3() {
    let _: AnotherTrait::AnotherType = 3_u32;
}

//! > expected_diagnostics
error: Return type of impl function `MyImpl::foo1` is incompatible with `MyTrait::foo1`. Expected: `core::integer::u32`, actual: `ImplVarId(7)::AnotherType`.
 --> lib.cairo:9:18
    fn foo1() -> AnotherTrait::AnotherType { 3_u32 }
                 ^***********************^

error: Trait has no implementation in context: test::AnotherTrait
 --> lib.cairo:9:32
    fn foo1() -> AnotherTrait::AnotherType { 3_u32 }
                               ^*********^

error: Unexpected return type. Expected: "ImplVarId(7)::AnotherType", found: "core::integer::u32".
 --> lib.cairo:9:44
    fn foo1() -> AnotherTrait::AnotherType { 3_u32 }
                                           ^*******^

error: Trait has no implementation in context: test::AnotherTrait
 --> lib.cairo:9:32
    fn foo1() -> AnotherTrait::AnotherType { 3_u32 }
                               ^*********^

error: Parameter type of impl function `MyImpl::foo2` is incompatible with `MyTrait::foo2`. Expected: `core::integer::u32`, actual: `ImplVarId(16)::AnotherType`.
 --> lib.cairo:10:16
    fn foo2(x: AnotherTrait::AnotherType) {}
               ^***********************^

error: Trait has no implementation in context: test::AnotherTrait
 --> lib.cairo:10:30
    fn foo2(x: AnotherTrait::AnotherType) {}
                             ^*********^

error: Trait has no implementation in context: test::AnotherTrait
 --> lib.cairo:10:30
    fn foo2(x: AnotherTrait::AnotherType) {}
                             ^*********^

error: Trait has no implementation in context: test::AnotherTrait
 --> lib.cairo:12:28
fn bar1() -> AnotherTrait::AnotherType { 3_u32 }
                           ^*********^

error: Unexpected return type. Expected: "ImplVarId(18)::AnotherType", found: "core::integer::u32".
 --> lib.cairo:12:40
fn bar1() -> AnotherTrait::AnotherType { 3_u32 }
                                       ^*******^

error: Trait has no implementation in context: test::AnotherTrait
 --> lib.cairo:12:28
fn bar1() -> AnotherTrait::AnotherType { 3_u32 }
                           ^*********^

error: Trait has no implementation in context: test::AnotherTrait
 --> lib.cairo:13:26
fn bar2(x: AnotherTrait::AnotherType) {}
                         ^*********^

error: Trait has no implementation in context: test::AnotherTrait
 --> lib.cairo:13:26
fn bar2(x: AnotherTrait::AnotherType) {}
                         ^*********^

error: Unexpected argument type. Expected: "ImplVarId(25)::AnotherType", found: "core::integer::u32".
 --> lib.cairo:15:40
    let _: AnotherTrait::AnotherType = 3_u32;
                                       ^***^

error: Trait has no implementation in context: test::AnotherTrait
 --> lib.cairo:15:26
    let _: AnotherTrait::AnotherType = 3_u32;
                         ^*********^

//! > ==========================================================================

//! > traits' items can't be resolved if there are multiple impls in context.

//! > TODO(yuval): try to eliminate redundant diagnostics.

//! > TODO(yuval): try to change "ImplVarId(#)::..." in diagnostics to "<missing>".

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl1 of AnotherTrait {
    type AnotherType = u32;
}
impl AnotherImpl2 of AnotherTrait {
    type AnotherType = u32;
}
trait MyTrait {
    fn foo1() -> u32;
    fn foo2(x: u32);
}
impl MyImpl of MyTrait {
    fn foo1() -> AnotherTrait::AnotherType { 3_u32 }
    fn foo2(x: AnotherTrait::AnotherType) {}
}
fn bar1() -> AnotherTrait::AnotherType { 3_u32 }
fn bar2(x: AnotherTrait::AnotherType) {}
fn bar3() {
    let _: AnotherTrait::AnotherType = 3_u32;
}

//! > expected_diagnostics
error: Return type of impl function `MyImpl::foo1` is incompatible with `MyTrait::foo1`. Expected: `core::integer::u32`, actual: `ImplVarId(91)::AnotherType`.
 --> lib.cairo:15:18
    fn foo1() -> AnotherTrait::AnotherType { 3_u32 }
                 ^***********************^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:15:32
    fn foo1() -> AnotherTrait::AnotherType { 3_u32 }
                               ^*********^

error: Unexpected return type. Expected: "ImplVarId(91)::AnotherType", found: "core::integer::u32".
 --> lib.cairo:15:44
    fn foo1() -> AnotherTrait::AnotherType { 3_u32 }
                                           ^*******^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:15:32
    fn foo1() -> AnotherTrait::AnotherType { 3_u32 }
                               ^*********^

error: Parameter type of impl function `MyImpl::foo2` is incompatible with `MyTrait::foo2`. Expected: `core::integer::u32`, actual: `ImplVarId(93)::AnotherType`.
 --> lib.cairo:16:16
    fn foo2(x: AnotherTrait::AnotherType) {}
               ^***********************^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:16:30
    fn foo2(x: AnotherTrait::AnotherType) {}
                             ^*********^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:16:30
    fn foo2(x: AnotherTrait::AnotherType) {}
                             ^*********^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:18:28
fn bar1() -> AnotherTrait::AnotherType { 3_u32 }
                           ^*********^

error: Unexpected return type. Expected: "ImplVarId(94)::AnotherType", found: "core::integer::u32".
 --> lib.cairo:18:40
fn bar1() -> AnotherTrait::AnotherType { 3_u32 }
                                       ^*******^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:18:28
fn bar1() -> AnotherTrait::AnotherType { 3_u32 }
                           ^*********^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:19:26
fn bar2(x: AnotherTrait::AnotherType) {}
                         ^*********^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:19:26
fn bar2(x: AnotherTrait::AnotherType) {}
                         ^*********^

error: Unexpected argument type. Expected: "ImplVarId(98)::AnotherType", found: "core::integer::u32".
 --> lib.cairo:21:40
    let _: AnotherTrait::AnotherType = 3_u32;
                                       ^***^

error: Trait `test::AnotherTrait` has multiple implementations, in: `test::AnotherImpl1`, `test::AnotherImpl2`
 --> lib.cairo:21:26
    let _: AnotherTrait::AnotherType = 3_u32;
                         ^*********^

//! > ==========================================================================

//! > impls' items are allowed.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait AnotherTrait {
    type AnotherType;
}
impl AnotherImpl1 of AnotherTrait {
    type AnotherType = u32;
}
impl AnotherImpl2 of AnotherTrait {
    type AnotherType = u16;
}
trait MyTrait {
    fn foo1() -> AnotherImpl1::AnotherType;
    fn foo2(x: AnotherImpl1::AnotherType);
}
impl MyImpl of MyTrait {
    fn foo1() -> AnotherImpl1::AnotherType { 3_u32 }
    fn foo2(x: AnotherImpl1::AnotherType) {}
}
fn bar1() -> AnotherImpl1::AnotherType { 3_u32 }
fn bar2(x: AnotherImpl1::AnotherType) {}
fn bar3() {
    let _: AnotherImpl1::AnotherType = 3_u32;
}

//! > expected_diagnostics

//! > ==========================================================================

//! > traits' items resolved in all kind of statements.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
}
impl MyImpl of MyTrait {
    type MyType1 = u32;
    type MyType2 = u32;
}
fn ret_statement(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    return x;
}
fn ret_expr(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    x
}
fn let_statement(x: MyTrait::MyType2) {
    let _: MyTrait::MyType1 = x;
}
fn break_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    loop {
        if cond {
            break x;
        } else {
            break y;
        }
    };
}
enum MyEnum {
    VariantA,
    VariantB,
}
fn match_statement(e: MyEnum, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    let _ = match e {
        MyEnum::VariantA => {
            x
        },
        MyEnum::VariantB => {
            y
        },
    };
}
fn if_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    if cond { x } else { y };
}
fn error_propagation(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Option::Some(x?)
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Diagnostics on mismatches with traits' items that are resolved in all kind of statements.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
}
impl MyImpl of MyTrait {
    type MyType1 = u16;
    type MyType2 = u32;
}
fn ret_statement(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    return x;
}
fn ret_expr(x: MyTrait::MyType1) -> MyTrait::MyType2 {
    x
}
fn let_statement(x: MyTrait::MyType2) {
    let _: MyTrait::MyType1 = x;
}
fn break_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    loop {
        if cond {
            break x;
        } else {
            break y;
        }
    };
}
enum MyEnum {
    VariantA,
    VariantB,
}
fn match_statement(e: MyEnum, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    let _ = match e {
        MyEnum::VariantA => {
            x
        },
        MyEnum::VariantB => {
            y
        },
    };
}
fn if_statement(cond: bool, x: MyTrait::MyType1, y: MyTrait::MyType2) {
    if cond { x } else { y };
}
fn error_propagation(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Option::Some(x?)
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:10:12
    return x;
           ^

error: Unexpected return type. Expected: "core::integer::u32", found: "core::integer::u16".
 --> lib.cairo:12:54
fn ret_expr(x: MyTrait::MyType1) -> MyTrait::MyType2 {
                                                     ^

error: Unexpected argument type. Expected: "core::integer::u16", found: "core::integer::u32".
 --> lib.cairo:16:31
    let _: MyTrait::MyType1 = x;
                              ^

error: Loop has incompatible return types: "core::integer::u16" and "core::integer::u32"
 --> lib.cairo:23:19
            break y;
                  ^

error: Match arms have incompatible types: "core::integer::u16" and "core::integer::u32"
 --> lib.cairo:36:29
        MyEnum::VariantB => {
                            ^

error: If blocks have incompatible types: "core::integer::u16" and "core::integer::u32"
 --> lib.cairo:42:5
    if cond { x } else { y };
    ^**********************^

error: Unexpected return type. Expected: "core::option::Option::<core::integer::u32>", found: "core::option::Option::<core::integer::u16>".
 --> lib.cairo:44:79
fn error_propagation(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
                                                                              ^

//! > ==========================================================================

//! > Recursive resolution.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: false)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    type MyType3;
    type MyType4;
}
impl MyImpl of MyTrait {
    type MyType1 = u32;
    type MyType2 = u32;
    type MyType3 = u32;
    type MyType4 = u32;
}
fn generic_args(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Option::Some(x?)
}
fn tuple(x: MyTrait::MyType1, y: MyTrait::MyType2) -> (MyTrait::MyType2, MyTrait::MyType1) {
    (x, y)
}
fn snapshot(x: @@MyTrait::MyType1) -> @@MyTrait::MyType2 {
    x
}
fn complex1(x: @(MyTrait::MyType1, Option<@Result<MyTrait::MyType2, (@MyTrait::MyType3, MyTrait::MyType4)>>)) -> @(u32, Option<@Result<u32, (@u32, u32)>>) {
    x
}
fn complex2(x: @(u32, Option<@Result<u32, (@u32, u32)>>)) -> @(MyTrait::MyType1, Option<@Result<MyTrait::MyType2, (@MyTrait::MyType3, MyTrait::MyType4)>>) {
    x
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Diagnostics on mismatches with recursive resolution.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType1;
    type MyType2;
    type MyType3;
    type MyType4;
}
impl MyImpl of MyTrait {
    type MyType1 = u16;
    type MyType2 = u32;
    type MyType3 = u32;
    type MyType4 = u32;
}
fn generic_args(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
    Option::Some(x?)
}
fn tuple(x: MyTrait::MyType1, y: MyTrait::MyType2) -> (MyTrait::MyType2, MyTrait::MyType1) {
    (x, y)
}
fn snapshot(x: @@MyTrait::MyType1) -> @@MyTrait::MyType2 {
    x
}
fn complex1(x: @(MyTrait::MyType1, Option<@Result<MyTrait::MyType2, (@MyTrait::MyType3, MyTrait::MyType4)>>)) -> @(u32, Option<@Result<u32, (@u32, u32)>>) {
    x
}
fn complex2(x: @(u32, Option<@Result<u32, (@u32, u32)>>)) -> @(MyTrait::MyType1, Option<@Result<MyTrait::MyType2, (@MyTrait::MyType3, MyTrait::MyType4)>>) {
    x
}

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::option::Option::<core::integer::u32>", found: "core::option::Option::<core::integer::u16>".
 --> lib.cairo:13:74
fn generic_args(x: Option<MyTrait::MyType1>) -> Option<MyTrait::MyType2> {
                                                                         ^

error: Unexpected return type. Expected: "(core::integer::u32, core::integer::u16)", found: "(core::integer::u16, core::integer::u32)".
 --> lib.cairo:16:92
fn tuple(x: MyTrait::MyType1, y: MyTrait::MyType2) -> (MyTrait::MyType2, MyTrait::MyType1) {
                                                                                           ^

error: Unexpected return type. Expected: "@@core::integer::u32", found: "@@core::integer::u16".
 --> lib.cairo:19:58
fn snapshot(x: @@MyTrait::MyType1) -> @@MyTrait::MyType2 {
                                                         ^

error: Unexpected return type. Expected: "@(core::integer::u32, core::option::Option::<@core::result::Result::<core::integer::u32, (@core::integer::u32, core::integer::u32)>>)", found: "@(core::integer::u16, core::option::Option::<@core::result::Result::<core::integer::u32, (@core::integer::u32, core::integer::u32)>>)".
 --> lib.cairo:22:156
fn complex1(x: @(MyTrait::MyType1, Option<@Result<MyTrait::MyType2, (@MyTrait::MyType3, MyTrait::MyType4)>>)) -> @(u32, Option<@Result<u32, (@u32, u32)>>) {
                                                                                                                                                           ^

error: Unexpected return type. Expected: "@(core::integer::u16, core::option::Option::<@core::result::Result::<core::integer::u32, (@core::integer::u32, core::integer::u32)>>)", found: "@(core::integer::u32, core::option::Option::<@core::result::Result::<core::integer::u32, (@core::integer::u32, core::integer::u32)>>)".
 --> lib.cairo:25:156
fn complex2(x: @(u32, Option<@Result<u32, (@u32, u32)>>)) -> @(MyTrait::MyType1, Option<@Result<MyTrait::MyType2, (@MyTrait::MyType3, MyTrait::MyType4)>>) {
                                                                                                                                                           ^

//! > ==========================================================================

//! > Diagnostics on using trait function as a type.

//! > test_runner_name
test_function_diagnostics(expect_diagnostics: true)

//! > function
fn foo() {}

//! > function_name
foo

//! > module_code
trait MyTrait {
    type MyType;
    fn my_function() -> u16;
}
impl MyImpl of MyTrait {
    type MyType = u32;
    fn my_function() -> u16 { 2_u16 }
}
fn main(x: MyImpl::my_function) {
    let _: MyImpl::my_function = 3;
}

//! > expected_diagnostics
error: Not a type.
 --> lib.cairo:9:12
fn main(x: MyImpl::my_function) {
           ^*****************^

error: Not a type.
 --> lib.cairo:10:12
    let _: MyImpl::my_function = 3;
           ^*****************^
