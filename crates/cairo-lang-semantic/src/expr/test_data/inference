//! > Test return type inference

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() -> Option::<felt> {
    Option::Some(5)
}

//! > function_name
foo

//! > module_code

//! > expected_diagnostics

//! > ==========================================================================

//! > Test array inference

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
    let mut arr = array_new();
    array_append(ref arr, 1)
}

//! > function_name
foo

//! > module_code

//! > expected_diagnostics

//! > ==========================================================================

//! > Test cycles

//! > test_runner_name
test_function_diagnostics

//! > comments
// TODO(spapini): Make better diagnostics.

//! > function
fn foo() {
    let mut arr = array_new();
    array_append(arr, arr)
}

//! > function_name
foo

//! > module_code

//! > expected_diagnostics
error: ref argument must be passed with a preceding 'ref'.
 --> lib.cairo:3:18
    array_append(arr, arr)
                 ^*^

error: Unexpected argument type. Expected: "?0", found: "core::array::Array::<?0>".
 --> lib.cairo:3:23
    array_append(arr, arr)
                      ^*^

error: Type annotations needed. Failed to infer ?0
 --> lib.cairo:2:19
    let mut arr = array_new();
                  ^*******^

//! > ==========================================================================

//! > Test undetermined system

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
    let mut arr = array_new();
}

//! > function_name
foo

//! > module_code

//! > expected_diagnostics
error: Type annotations needed. Failed to infer ?0
 --> lib.cairo:2:19
    let mut arr = array_new();
                  ^*******^

//! > ==========================================================================

//! > Test type mismatch

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
    let mut arr: felt = array_new::<felt>();
}

//! > function_name
foo

//! > module_code

//! > expected_diagnostics
error: Unexpected argument type. Expected: "core::felt", found: "core::array::Array::<core::felt>".
 --> lib.cairo:2:25
    let mut arr: felt = array_new::<felt>();
                        ^*****************^

//! > ==========================================================================

//! > Test never type

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() -> felt {
    panic(array_new())
}

//! > function_name
foo

//! > module_code

//! > expected_diagnostics

//! > ==========================================================================

//! > Test anti never type

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() -> never {
    5
}

//! > function_name
foo

//! > module_code

//! > expected_diagnostics
error: Unexpected return type. Expected: "core::never", found: "core::felt".
 --> lib.cairo:1:19
fn foo() -> never {
                  ^

//! > ==========================================================================

//! > Test trait inference.

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
   MyTrait::foo(5);
   MyTrait::foo(true);
   MyTrait::foo(Option::None(()));
}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
   fn foo(x: T);
}
impl MyImpl1 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl2 of MyTrait::<bool> {
   fn foo(x: bool) {}
}
impl MyImpl3 of MyTrait::<Option::<felt>> {
    fn foo(x: Option::<felt>) {}
 }

//! > expected_diagnostics

//! > ==========================================================================

//! > Test trait inference no impl failure.

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
   MyTrait::foo(true);
}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
   fn foo(x: T);
}
impl MyImpl1 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl2 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl3 of MyTrait::<Option::<felt>> {
    fn foo(x: Option::<felt>) {}
}
impl MyImpl4 of MyTrait::<Option::<bool>> {
    fn foo(x: Option::<bool>) {}
}

//! > expected_diagnostics
error: Trait has no implementation in context: test::MyTrait::<core::bool>
 --> lib.cairo:17:4
   MyTrait::foo(true);
   ^****************^

//! > ==========================================================================

//! > Test trait inference multiple impl failure.

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
   MyTrait::foo(5);
   MyTrait::foo(Option::<felt>::None(()));
}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
   fn foo(x: T);
}
impl MyImpl1 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl2 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl3 of MyTrait::<Option::<felt>> {
    fn foo(x: Option::<felt>) {}
}
impl MyImpl4 of MyTrait::<Option::<bool>> {
    fn foo(x: Option::<bool>) {}
}

//! > expected_diagnostics
error: Trait `test::MyTrait::<core::felt>` has multiple implementations, in: "test::MyImpl1", "test::MyImpl2"
 --> lib.cairo:17:13
   MyTrait::foo(5);
            ^*^

//! > ==========================================================================

//! > Test trait inference unresolved type for impl.

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
   MyTrait::foo(Option::None(()));
}

//! > function_name
foo

//! > module_code
trait MyTrait<T> {
   fn foo(x: T);
}
impl MyImpl1 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl2 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl3 of MyTrait::<Option::<felt>> {
    fn foo(x: Option::<felt>) {}
}
impl MyImpl4 of MyTrait::<Option::<bool>> {
    fn foo(x: Option::<bool>) {}
}

//! > expected_diagnostics
error: Type annotations needed. Failed to infer ?1
 --> lib.cairo:17:17
   MyTrait::foo(Option::None(()));
                ^****^

//! > ==========================================================================

//! > Test dot_expr inference.

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo(my_box: Box::<MyStruct>) -> felt {
   box::unbox(my_box).a
}

//! > function_name
foo

//! > module_code
struct MyStruct {
   a: felt
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Infer impl

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
   bar(true);
}

//! > function_name
foo

//! > module_code
fn bar<impl Tr: MyTrait::<bool>>(x: bool){
}

trait MyTrait<T> {
   fn foo(x: T);
}
impl MyImpl1 of MyTrait::<bool> {
   fn foo(x: bool) {}
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Infer impl after inferring type

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
   bar(Option::Some(5));
}

//! > function_name
foo

//! > module_code
fn bar<S, impl Tr: MyTrait::<S>>(x: S){
}

trait MyTrait<T> {
   fn foo(x: T);
}
impl MyImpl1 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl2 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl3 of MyTrait::<Option::<felt>> {
    fn foo(x: Option::<felt>) {}
}
impl MyImpl4 of MyTrait::<Option::<bool>> {
    fn foo(x: Option::<bool>) {}
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Infer impl failure

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
   bar(true);
}

//! > function_name
foo

//! > module_code
fn bar<S, impl Tr: MyTrait::<S>>(x: S){
}

trait MyTrait<T> {
   fn foo(x: T);
}
impl MyImpl1 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl2 of MyTrait::<felt> {
   fn foo(x: felt) {}
}
impl MyImpl3 of MyTrait::<Option::<felt>> {
    fn foo(x: Option::<felt>) {}
}
impl MyImpl4 of MyTrait::<Option::<bool>> {
    fn foo(x: Option::<bool>) {}
}

//! > expected_diagnostics
error: Trait has no implementation in context: test::MyTrait::<core::bool>
 --> lib.cairo:20:4
   bar(true);
   ^*******^

//! > ==========================================================================

//! > Infer impl generic param from generic param.

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
   A::<felt>{}.foo();
}

//! > function_name
foo

//! > module_code
impl FeltDrop of Drop::<felt>;
struct A<T> { }
trait MyTrait<T> {
   fn foo<impl TDrop: Drop::<T>>(self:A<T>);
   fn bar<impl TDrop: Drop::<T>>(self:A<T>);
}
impl MyImpl<T> of MyTrait::<T> {
   fn foo<impl TDrop: Drop::<T>>(self:A<T>){self.bar()}
   fn bar<impl TDrop: Drop::<T>>(self:A<T>){}
}

//! > expected_diagnostics

//! > ==========================================================================

//! > Complex clone inference.

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
   (@5).clone();
   5.clone();
}

//! > comments
// TODO(spapini): Fix this.

//! > function_name
foo

//! > module_code
impl FeltCopy of Copy::<felt>;

trait Clone<T> {
    fn clone(self: @T) -> T;
}

impl CloneImpl<T, impl TCopy: Copy::<T>> of Clone::<T> {
    fn clone(self: @T) -> T {
        *self
    }
}

//! > expected_diagnostics
error: Method `clone` not found on type "core::felt". Did you import the correct trait and impl?
 --> lib.cairo:14:6
   5.clone();
     ^***^

//! > ==========================================================================

//! > infer generic impl in a function.

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
   clone_loop(5)
}

//! > function_name
foo

//! > module_code
impl FeltCopy of Copy::<felt>;
fn clone_loop<T, impl TClone: Clone::<T>>(x: T) {
   clone_loop::<T>(x)
}

//! > expected_diagnostics

//! > ==========================================================================

//! > infer drop impl.

//! > test_runner_name
test_function_diagnostics

//! > function
fn foo() {
}

//! > function_name
foo

//! > module_code
struct A {}
struct B{
   a: A,
}
impl I<impl TI: Drop::<A>> of Drop::<B>;

//! > expected_diagnostics
