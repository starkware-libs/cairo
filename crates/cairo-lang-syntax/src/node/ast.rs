// Autogenerated file. To regenerate, please run `cargo run --bin generate-syntax`.
#![allow(clippy::match_single_binding)]
#![allow(clippy::too_many_arguments)]
#![allow(dead_code)]
#![allow(unused_variables)]
use std::ops::Deref;
use std::sync::Arc;

use cairo_lang_filesystem::span::TextWidth;
use cairo_lang_utils::{Intern, LookupIntern, extract_matches};
use smol_str::SmolStr;

use super::element_list::ElementList;
use super::green::GreenNodeDetails;
use super::kind::SyntaxKind;
use super::{
    GreenId, GreenNode, SyntaxGroup, SyntaxNode, SyntaxStablePtr, SyntaxStablePtrId, Terminal,
    Token, TypedStablePtr, TypedSyntaxNode,
};
#[path = "ast_ext.rs"]
mod ast_ext;
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct Trivia<'db>(ElementList<'db, Trivium<'db>, 1>);
impl<'db> Deref for Trivia<'db> {
    type Target = ElementList<'db, Trivium<'db>, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> Trivia<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<TriviumGreen<'db>>,
    ) -> TriviaGreen<'db> {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        TriviaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Trivia,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TriviaPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TriviaPtr<'db> {
    type SyntaxNode = Trivia<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TriviaPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TriviaPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TriviaGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Trivia<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Trivia);
    type StablePtr = TriviaPtr<'db>;
    type Green = TriviaGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TriviaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Trivia,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::Trivia { Some(Self(ElementList::new(node))) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TriviaPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum Trivium<'db> {
    SingleLineComment(TokenSingleLineComment<'db>),
    SingleLineDocComment(TokenSingleLineDocComment<'db>),
    SingleLineInnerComment(TokenSingleLineInnerComment<'db>),
    Whitespace(TokenWhitespace<'db>),
    Newline(TokenNewline<'db>),
    Skipped(TokenSkipped<'db>),
    SkippedNode(TriviumSkippedNode<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TriviumPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TriviumPtr<'db> {
    type SyntaxNode = Trivium<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        Trivium::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TriviumPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TriviumPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TokenSingleLineCommentPtr<'db>> for TriviumPtr<'db> {
    fn from(value: TokenSingleLineCommentPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenSingleLineDocCommentPtr<'db>> for TriviumPtr<'db> {
    fn from(value: TokenSingleLineDocCommentPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenSingleLineInnerCommentPtr<'db>> for TriviumPtr<'db> {
    fn from(value: TokenSingleLineInnerCommentPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenWhitespacePtr<'db>> for TriviumPtr<'db> {
    fn from(value: TokenWhitespacePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenNewlinePtr<'db>> for TriviumPtr<'db> {
    fn from(value: TokenNewlinePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenSkippedPtr<'db>> for TriviumPtr<'db> {
    fn from(value: TokenSkippedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TriviumSkippedNodePtr<'db>> for TriviumPtr<'db> {
    fn from(value: TriviumSkippedNodePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenSingleLineCommentGreen<'db>> for TriviumGreen<'db> {
    fn from(value: TokenSingleLineCommentGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenSingleLineDocCommentGreen<'db>> for TriviumGreen<'db> {
    fn from(value: TokenSingleLineDocCommentGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenSingleLineInnerCommentGreen<'db>> for TriviumGreen<'db> {
    fn from(value: TokenSingleLineInnerCommentGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenWhitespaceGreen<'db>> for TriviumGreen<'db> {
    fn from(value: TokenWhitespaceGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenNewlineGreen<'db>> for TriviumGreen<'db> {
    fn from(value: TokenNewlineGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenSkippedGreen<'db>> for TriviumGreen<'db> {
    fn from(value: TokenSkippedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TriviumSkippedNodeGreen<'db>> for TriviumGreen<'db> {
    fn from(value: TriviumSkippedNodeGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TriviumGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Trivium<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = TriviumPtr<'db>;
    type Green = TriviumGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TokenSingleLineComment => {
                Trivium::SingleLineComment(TokenSingleLineComment::from_syntax_node(db, node))
            }
            SyntaxKind::TokenSingleLineDocComment => {
                Trivium::SingleLineDocComment(TokenSingleLineDocComment::from_syntax_node(db, node))
            }
            SyntaxKind::TokenSingleLineInnerComment => Trivium::SingleLineInnerComment(
                TokenSingleLineInnerComment::from_syntax_node(db, node),
            ),
            SyntaxKind::TokenWhitespace => {
                Trivium::Whitespace(TokenWhitespace::from_syntax_node(db, node))
            }
            SyntaxKind::TokenNewline => Trivium::Newline(TokenNewline::from_syntax_node(db, node)),
            SyntaxKind::TokenSkipped => Trivium::Skipped(TokenSkipped::from_syntax_node(db, node)),
            SyntaxKind::TriviumSkippedNode => {
                Trivium::SkippedNode(TriviumSkippedNode::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Trivium"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TokenSingleLineComment => {
                Some(Trivium::SingleLineComment(TokenSingleLineComment::from_syntax_node(db, node)))
            }
            SyntaxKind::TokenSingleLineDocComment => Some(Trivium::SingleLineDocComment(
                TokenSingleLineDocComment::from_syntax_node(db, node),
            )),
            SyntaxKind::TokenSingleLineInnerComment => Some(Trivium::SingleLineInnerComment(
                TokenSingleLineInnerComment::from_syntax_node(db, node),
            )),
            SyntaxKind::TokenWhitespace => {
                Some(Trivium::Whitespace(TokenWhitespace::from_syntax_node(db, node)))
            }
            SyntaxKind::TokenNewline => {
                Some(Trivium::Newline(TokenNewline::from_syntax_node(db, node)))
            }
            SyntaxKind::TokenSkipped => {
                Some(Trivium::Skipped(TokenSkipped::from_syntax_node(db, node)))
            }
            SyntaxKind::TriviumSkippedNode => {
                Some(Trivium::SkippedNode(TriviumSkippedNode::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            Trivium::SingleLineComment(x) => x.as_syntax_node(),
            Trivium::SingleLineDocComment(x) => x.as_syntax_node(),
            Trivium::SingleLineInnerComment(x) => x.as_syntax_node(),
            Trivium::Whitespace(x) => x.as_syntax_node(),
            Trivium::Newline(x) => x.as_syntax_node(),
            Trivium::Skipped(x) => x.as_syntax_node(),
            Trivium::SkippedNode(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TriviumPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> Trivium<'db> {
    /// Checks if a kind of a variant of [Trivium].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TokenSingleLineComment
                | SyntaxKind::TokenSingleLineDocComment
                | SyntaxKind::TokenSingleLineInnerComment
                | SyntaxKind::TokenWhitespace
                | SyntaxKind::TokenNewline
                | SyntaxKind::TokenSkipped
                | SyntaxKind::TriviumSkippedNode
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum Expr<'db> {
    Path(ExprPath<'db>),
    Literal(TerminalLiteralNumber<'db>),
    ShortString(TerminalShortString<'db>),
    String(TerminalString<'db>),
    False(TerminalFalse<'db>),
    True(TerminalTrue<'db>),
    Parenthesized(ExprParenthesized<'db>),
    Unary(ExprUnary<'db>),
    Binary(ExprBinary<'db>),
    Tuple(ExprListParenthesized<'db>),
    FunctionCall(ExprFunctionCall<'db>),
    StructCtorCall(ExprStructCtorCall<'db>),
    Block(ExprBlock<'db>),
    Match(ExprMatch<'db>),
    If(ExprIf<'db>),
    Loop(ExprLoop<'db>),
    While(ExprWhile<'db>),
    For(ExprFor<'db>),
    Closure(ExprClosure<'db>),
    ErrorPropagate(ExprErrorPropagate<'db>),
    FieldInitShorthand(ExprFieldInitShorthand<'db>),
    Indexed(ExprIndexed<'db>),
    InlineMacro(ExprInlineMacro<'db>),
    FixedSizeArray(ExprFixedSizeArray<'db>),
    Placeholder(ExprPlaceholder<'db>),
    Missing(ExprMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ExprPtr<'db> {
    type SyntaxNode = Expr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        Expr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ExprPathPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprPathPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLiteralNumberPtr<'db>> for ExprPtr<'db> {
    fn from(value: TerminalLiteralNumberPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalShortStringPtr<'db>> for ExprPtr<'db> {
    fn from(value: TerminalShortStringPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalStringPtr<'db>> for ExprPtr<'db> {
    fn from(value: TerminalStringPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalFalsePtr<'db>> for ExprPtr<'db> {
    fn from(value: TerminalFalsePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalTruePtr<'db>> for ExprPtr<'db> {
    fn from(value: TerminalTruePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprParenthesizedPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprParenthesizedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprUnaryPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprUnaryPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprBinaryPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprBinaryPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprListParenthesizedPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprListParenthesizedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprFunctionCallPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprFunctionCallPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprStructCtorCallPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprStructCtorCallPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprBlockPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprBlockPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprMatchPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprMatchPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprIfPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprIfPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprLoopPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprLoopPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprWhilePtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprWhilePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprForPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprForPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprClosurePtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprClosurePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprErrorPropagatePtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprErrorPropagatePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprFieldInitShorthandPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprFieldInitShorthandPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprIndexedPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprIndexedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprInlineMacroPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprInlineMacroPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprFixedSizeArrayPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprFixedSizeArrayPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprPlaceholderPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprPlaceholderPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprMissingPtr<'db>> for ExprPtr<'db> {
    fn from(value: ExprMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprPathGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprPathGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLiteralNumberGreen<'db>> for ExprGreen<'db> {
    fn from(value: TerminalLiteralNumberGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalShortStringGreen<'db>> for ExprGreen<'db> {
    fn from(value: TerminalShortStringGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalStringGreen<'db>> for ExprGreen<'db> {
    fn from(value: TerminalStringGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalFalseGreen<'db>> for ExprGreen<'db> {
    fn from(value: TerminalFalseGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalTrueGreen<'db>> for ExprGreen<'db> {
    fn from(value: TerminalTrueGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprParenthesizedGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprParenthesizedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprUnaryGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprUnaryGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprBinaryGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprBinaryGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprListParenthesizedGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprListParenthesizedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprFunctionCallGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprFunctionCallGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprStructCtorCallGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprStructCtorCallGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprBlockGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprBlockGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprMatchGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprMatchGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprIfGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprIfGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprLoopGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprLoopGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprWhileGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprWhileGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprForGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprForGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprClosureGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprClosureGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprErrorPropagateGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprErrorPropagateGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprFieldInitShorthandGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprFieldInitShorthandGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprIndexedGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprIndexedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprInlineMacroGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprInlineMacroGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprFixedSizeArrayGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprFixedSizeArrayGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprPlaceholderGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprPlaceholderGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprMissingGreen<'db>> for ExprGreen<'db> {
    fn from(value: ExprMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Expr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ExprPtr<'db>;
    type Green = ExprGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprGreen(ExprMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprPath => Expr::Path(ExprPath::from_syntax_node(db, node)),
            SyntaxKind::TerminalLiteralNumber => {
                Expr::Literal(TerminalLiteralNumber::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalShortString => {
                Expr::ShortString(TerminalShortString::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalString => Expr::String(TerminalString::from_syntax_node(db, node)),
            SyntaxKind::TerminalFalse => Expr::False(TerminalFalse::from_syntax_node(db, node)),
            SyntaxKind::TerminalTrue => Expr::True(TerminalTrue::from_syntax_node(db, node)),
            SyntaxKind::ExprParenthesized => {
                Expr::Parenthesized(ExprParenthesized::from_syntax_node(db, node))
            }
            SyntaxKind::ExprUnary => Expr::Unary(ExprUnary::from_syntax_node(db, node)),
            SyntaxKind::ExprBinary => Expr::Binary(ExprBinary::from_syntax_node(db, node)),
            SyntaxKind::ExprListParenthesized => {
                Expr::Tuple(ExprListParenthesized::from_syntax_node(db, node))
            }
            SyntaxKind::ExprFunctionCall => {
                Expr::FunctionCall(ExprFunctionCall::from_syntax_node(db, node))
            }
            SyntaxKind::ExprStructCtorCall => {
                Expr::StructCtorCall(ExprStructCtorCall::from_syntax_node(db, node))
            }
            SyntaxKind::ExprBlock => Expr::Block(ExprBlock::from_syntax_node(db, node)),
            SyntaxKind::ExprMatch => Expr::Match(ExprMatch::from_syntax_node(db, node)),
            SyntaxKind::ExprIf => Expr::If(ExprIf::from_syntax_node(db, node)),
            SyntaxKind::ExprLoop => Expr::Loop(ExprLoop::from_syntax_node(db, node)),
            SyntaxKind::ExprWhile => Expr::While(ExprWhile::from_syntax_node(db, node)),
            SyntaxKind::ExprFor => Expr::For(ExprFor::from_syntax_node(db, node)),
            SyntaxKind::ExprClosure => Expr::Closure(ExprClosure::from_syntax_node(db, node)),
            SyntaxKind::ExprErrorPropagate => {
                Expr::ErrorPropagate(ExprErrorPropagate::from_syntax_node(db, node))
            }
            SyntaxKind::ExprFieldInitShorthand => {
                Expr::FieldInitShorthand(ExprFieldInitShorthand::from_syntax_node(db, node))
            }
            SyntaxKind::ExprIndexed => Expr::Indexed(ExprIndexed::from_syntax_node(db, node)),
            SyntaxKind::ExprInlineMacro => {
                Expr::InlineMacro(ExprInlineMacro::from_syntax_node(db, node))
            }
            SyntaxKind::ExprFixedSizeArray => {
                Expr::FixedSizeArray(ExprFixedSizeArray::from_syntax_node(db, node))
            }
            SyntaxKind::ExprPlaceholder => {
                Expr::Placeholder(ExprPlaceholder::from_syntax_node(db, node))
            }
            SyntaxKind::ExprMissing => Expr::Missing(ExprMissing::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Expr"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprPath => Some(Expr::Path(ExprPath::from_syntax_node(db, node))),
            SyntaxKind::TerminalLiteralNumber => {
                Some(Expr::Literal(TerminalLiteralNumber::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalShortString => {
                Some(Expr::ShortString(TerminalShortString::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalString => {
                Some(Expr::String(TerminalString::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalFalse => {
                Some(Expr::False(TerminalFalse::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalTrue => Some(Expr::True(TerminalTrue::from_syntax_node(db, node))),
            SyntaxKind::ExprParenthesized => {
                Some(Expr::Parenthesized(ExprParenthesized::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprUnary => Some(Expr::Unary(ExprUnary::from_syntax_node(db, node))),
            SyntaxKind::ExprBinary => Some(Expr::Binary(ExprBinary::from_syntax_node(db, node))),
            SyntaxKind::ExprListParenthesized => {
                Some(Expr::Tuple(ExprListParenthesized::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprFunctionCall => {
                Some(Expr::FunctionCall(ExprFunctionCall::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprStructCtorCall => {
                Some(Expr::StructCtorCall(ExprStructCtorCall::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprBlock => Some(Expr::Block(ExprBlock::from_syntax_node(db, node))),
            SyntaxKind::ExprMatch => Some(Expr::Match(ExprMatch::from_syntax_node(db, node))),
            SyntaxKind::ExprIf => Some(Expr::If(ExprIf::from_syntax_node(db, node))),
            SyntaxKind::ExprLoop => Some(Expr::Loop(ExprLoop::from_syntax_node(db, node))),
            SyntaxKind::ExprWhile => Some(Expr::While(ExprWhile::from_syntax_node(db, node))),
            SyntaxKind::ExprFor => Some(Expr::For(ExprFor::from_syntax_node(db, node))),
            SyntaxKind::ExprClosure => Some(Expr::Closure(ExprClosure::from_syntax_node(db, node))),
            SyntaxKind::ExprErrorPropagate => {
                Some(Expr::ErrorPropagate(ExprErrorPropagate::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprFieldInitShorthand => {
                Some(Expr::FieldInitShorthand(ExprFieldInitShorthand::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprIndexed => Some(Expr::Indexed(ExprIndexed::from_syntax_node(db, node))),
            SyntaxKind::ExprInlineMacro => {
                Some(Expr::InlineMacro(ExprInlineMacro::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprFixedSizeArray => {
                Some(Expr::FixedSizeArray(ExprFixedSizeArray::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprPlaceholder => {
                Some(Expr::Placeholder(ExprPlaceholder::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprMissing => Some(Expr::Missing(ExprMissing::from_syntax_node(db, node))),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            Expr::Path(x) => x.as_syntax_node(),
            Expr::Literal(x) => x.as_syntax_node(),
            Expr::ShortString(x) => x.as_syntax_node(),
            Expr::String(x) => x.as_syntax_node(),
            Expr::False(x) => x.as_syntax_node(),
            Expr::True(x) => x.as_syntax_node(),
            Expr::Parenthesized(x) => x.as_syntax_node(),
            Expr::Unary(x) => x.as_syntax_node(),
            Expr::Binary(x) => x.as_syntax_node(),
            Expr::Tuple(x) => x.as_syntax_node(),
            Expr::FunctionCall(x) => x.as_syntax_node(),
            Expr::StructCtorCall(x) => x.as_syntax_node(),
            Expr::Block(x) => x.as_syntax_node(),
            Expr::Match(x) => x.as_syntax_node(),
            Expr::If(x) => x.as_syntax_node(),
            Expr::Loop(x) => x.as_syntax_node(),
            Expr::While(x) => x.as_syntax_node(),
            Expr::For(x) => x.as_syntax_node(),
            Expr::Closure(x) => x.as_syntax_node(),
            Expr::ErrorPropagate(x) => x.as_syntax_node(),
            Expr::FieldInitShorthand(x) => x.as_syntax_node(),
            Expr::Indexed(x) => x.as_syntax_node(),
            Expr::InlineMacro(x) => x.as_syntax_node(),
            Expr::FixedSizeArray(x) => x.as_syntax_node(),
            Expr::Placeholder(x) => x.as_syntax_node(),
            Expr::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> Expr<'db> {
    /// Checks if a kind of a variant of [Expr].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ExprPath
                | SyntaxKind::TerminalLiteralNumber
                | SyntaxKind::TerminalShortString
                | SyntaxKind::TerminalString
                | SyntaxKind::TerminalFalse
                | SyntaxKind::TerminalTrue
                | SyntaxKind::ExprParenthesized
                | SyntaxKind::ExprUnary
                | SyntaxKind::ExprBinary
                | SyntaxKind::ExprListParenthesized
                | SyntaxKind::ExprFunctionCall
                | SyntaxKind::ExprStructCtorCall
                | SyntaxKind::ExprBlock
                | SyntaxKind::ExprMatch
                | SyntaxKind::ExprIf
                | SyntaxKind::ExprLoop
                | SyntaxKind::ExprWhile
                | SyntaxKind::ExprFor
                | SyntaxKind::ExprClosure
                | SyntaxKind::ExprErrorPropagate
                | SyntaxKind::ExprFieldInitShorthand
                | SyntaxKind::ExprIndexed
                | SyntaxKind::ExprInlineMacro
                | SyntaxKind::ExprFixedSizeArray
                | SyntaxKind::ExprPlaceholder
                | SyntaxKind::ExprMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprList<'db>(ElementList<'db, Expr<'db>, 2>);
impl<'db> Deref for ExprList<'db> {
    type Target = ElementList<'db, Expr<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> ExprList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<ExprListElementOrSeparatorGreen<'db>>,
    ) -> ExprListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        ExprListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ExprListPtr<'db> {
    type SyntaxNode = ExprList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprList<'db> {
        ExprList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum ExprListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(ExprGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for ExprListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        ExprListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<ExprGreen<'db>> for ExprListElementOrSeparatorGreen<'db> {
    fn from(value: ExprGreen<'db>) -> Self {
        ExprListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> ExprListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            ExprListElementOrSeparatorGreen::Separator(green) => green.0,
            ExprListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprList);
    type StablePtr = ExprListPtr<'db>;
    type Green = ExprListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ExprList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct Arg<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Arg<'db> {
    pub const INDEX_MODIFIERS: usize = 0;
    pub const INDEX_ARG_CLAUSE: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        modifiers: ModifierListGreen<'db>,
        arg_clause: ArgClauseGreen<'db>,
    ) -> ArgGreen<'db> {
        let children: Vec<GreenId> = vec![modifiers.0, arg_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Arg,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> Arg<'db> {
    pub fn modifiers(&self, db: &'db dyn SyntaxGroup) -> ModifierList<'db> {
        ModifierList::from_syntax_node(db, self.children[0])
    }
    pub fn arg_clause(&self, db: &'db dyn SyntaxGroup) -> ArgClause<'db> {
        ArgClause::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ArgPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ArgPtr<'db> {
    type SyntaxNode = Arg<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Arg<'db> {
        Arg::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ArgPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ArgPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Arg<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Arg);
    type StablePtr = ArgPtr<'db>;
    type Green = ArgGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ArgGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Arg,
                details: GreenNodeDetails::Node {
                    children: vec![ModifierList::missing(db).0, ArgClause::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Arg,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Arg
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::Arg { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ArgPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum ArgClause<'db> {
    Unnamed(ArgClauseUnnamed<'db>),
    Named(ArgClauseNamed<'db>),
    FieldInitShorthand(ArgClauseFieldInitShorthand<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ArgClausePtr<'db> {
    type SyntaxNode = ArgClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        ArgClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ArgClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ArgClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ArgClauseUnnamedPtr<'db>> for ArgClausePtr<'db> {
    fn from(value: ArgClauseUnnamedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgClauseNamedPtr<'db>> for ArgClausePtr<'db> {
    fn from(value: ArgClauseNamedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgClauseFieldInitShorthandPtr<'db>> for ArgClausePtr<'db> {
    fn from(value: ArgClauseFieldInitShorthandPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgClauseUnnamedGreen<'db>> for ArgClauseGreen<'db> {
    fn from(value: ArgClauseUnnamedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgClauseNamedGreen<'db>> for ArgClauseGreen<'db> {
    fn from(value: ArgClauseNamedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgClauseFieldInitShorthandGreen<'db>> for ArgClauseGreen<'db> {
    fn from(value: ArgClauseFieldInitShorthandGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ArgClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ArgClausePtr<'db>;
    type Green = ArgClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ArgClauseUnnamed => {
                ArgClause::Unnamed(ArgClauseUnnamed::from_syntax_node(db, node))
            }
            SyntaxKind::ArgClauseNamed => {
                ArgClause::Named(ArgClauseNamed::from_syntax_node(db, node))
            }
            SyntaxKind::ArgClauseFieldInitShorthand => ArgClause::FieldInitShorthand(
                ArgClauseFieldInitShorthand::from_syntax_node(db, node),
            ),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "ArgClause"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ArgClauseUnnamed => {
                Some(ArgClause::Unnamed(ArgClauseUnnamed::from_syntax_node(db, node)))
            }
            SyntaxKind::ArgClauseNamed => {
                Some(ArgClause::Named(ArgClauseNamed::from_syntax_node(db, node)))
            }
            SyntaxKind::ArgClauseFieldInitShorthand => Some(ArgClause::FieldInitShorthand(
                ArgClauseFieldInitShorthand::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            ArgClause::Unnamed(x) => x.as_syntax_node(),
            ArgClause::Named(x) => x.as_syntax_node(),
            ArgClause::FieldInitShorthand(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ArgClausePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> ArgClause<'db> {
    /// Checks if a kind of a variant of [ArgClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ArgClauseUnnamed
                | SyntaxKind::ArgClauseNamed
                | SyntaxKind::ArgClauseFieldInitShorthand
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ArgClauseNamed<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ArgClauseNamed<'db> {
    pub const INDEX_NAME: usize = 0;
    pub const INDEX_COLON: usize = 1;
    pub const INDEX_VALUE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        name: TerminalIdentifierGreen<'db>,
        colon: TerminalColonGreen<'db>,
        value: ExprGreen<'db>,
    ) -> ArgClauseNamedGreen<'db> {
        let children: Vec<GreenId> = vec![name.0, colon.0, value.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgClauseNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseNamed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ArgClauseNamed<'db> {
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[1])
    }
    pub fn value(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgClauseNamedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ArgClauseNamedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ArgClauseNamedPtr<'db> {
    type SyntaxNode = ArgClauseNamed<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ArgClauseNamed<'db> {
        ArgClauseNamed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ArgClauseNamedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ArgClauseNamedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgClauseNamedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ArgClauseNamed<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgClauseNamed);
    type StablePtr = ArgClauseNamedPtr<'db>;
    type Green = ArgClauseNamedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ArgClauseNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseNamed,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgClauseNamed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgClauseNamed
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgClauseNamed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ArgClauseNamedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ArgClauseUnnamed<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ArgClauseUnnamed<'db> {
    pub const INDEX_VALUE: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        value: ExprGreen<'db>,
    ) -> ArgClauseUnnamedGreen<'db> {
        let children: Vec<GreenId> = vec![value.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgClauseUnnamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseUnnamed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ArgClauseUnnamed<'db> {
    pub fn value(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgClauseUnnamedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ArgClauseUnnamedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ArgClauseUnnamedPtr<'db> {
    type SyntaxNode = ArgClauseUnnamed<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ArgClauseUnnamed<'db> {
        ArgClauseUnnamed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ArgClauseUnnamedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ArgClauseUnnamedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgClauseUnnamedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ArgClauseUnnamed<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgClauseUnnamed);
    type StablePtr = ArgClauseUnnamedPtr<'db>;
    type Green = ArgClauseUnnamedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ArgClauseUnnamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseUnnamed,
                details: GreenNodeDetails::Node {
                    children: vec![Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgClauseUnnamed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgClauseUnnamed
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgClauseUnnamed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ArgClauseUnnamedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ArgClauseFieldInitShorthand<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ArgClauseFieldInitShorthand<'db> {
    pub const INDEX_COLON: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        colon: TerminalColonGreen<'db>,
        name: ExprFieldInitShorthandGreen<'db>,
    ) -> ArgClauseFieldInitShorthandGreen<'db> {
        let children: Vec<GreenId> = vec![colon.0, name.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgClauseFieldInitShorthandGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseFieldInitShorthand,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ArgClauseFieldInitShorthand<'db> {
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> ExprFieldInitShorthand<'db> {
        ExprFieldInitShorthand::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgClauseFieldInitShorthandPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ArgClauseFieldInitShorthandPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ArgClauseFieldInitShorthandPtr<'db> {
    type SyntaxNode = ArgClauseFieldInitShorthand<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ArgClauseFieldInitShorthand<'db> {
        ArgClauseFieldInitShorthand::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ArgClauseFieldInitShorthandPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ArgClauseFieldInitShorthandPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgClauseFieldInitShorthandGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ArgClauseFieldInitShorthand<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgClauseFieldInitShorthand);
    type StablePtr = ArgClauseFieldInitShorthandPtr<'db>;
    type Green = ArgClauseFieldInitShorthandGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ArgClauseFieldInitShorthandGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseFieldInitShorthand,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalColon::missing(db).0,
                        ExprFieldInitShorthand::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgClauseFieldInitShorthand,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgClauseFieldInitShorthand
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgClauseFieldInitShorthand {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ArgClauseFieldInitShorthandPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprFieldInitShorthand<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprFieldInitShorthand<'db> {
    pub const INDEX_NAME: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        name: TerminalIdentifierGreen<'db>,
    ) -> ExprFieldInitShorthandGreen<'db> {
        let children: Vec<GreenId> = vec![name.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprFieldInitShorthandGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFieldInitShorthand,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprFieldInitShorthand<'db> {
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprFieldInitShorthandPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprFieldInitShorthandPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprFieldInitShorthandPtr<'db> {
    type SyntaxNode = ExprFieldInitShorthand<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprFieldInitShorthand<'db> {
        ExprFieldInitShorthand::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprFieldInitShorthandPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprFieldInitShorthandPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprFieldInitShorthandGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprFieldInitShorthand<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprFieldInitShorthand);
    type StablePtr = ExprFieldInitShorthandPtr<'db>;
    type Green = ExprFieldInitShorthandGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprFieldInitShorthandGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFieldInitShorthand,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprFieldInitShorthand,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprFieldInitShorthand
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprFieldInitShorthand {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprFieldInitShorthandPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ArgList<'db>(ElementList<'db, Arg<'db>, 2>);
impl<'db> Deref for ArgList<'db> {
    type Target = ElementList<'db, Arg<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> ArgList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<ArgListElementOrSeparatorGreen<'db>>,
    ) -> ArgListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        ArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ArgListPtr<'db> {
    type SyntaxNode = ArgList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ArgList<'db> {
        ArgList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ArgListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ArgListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum ArgListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(ArgGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for ArgListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        ArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<ArgGreen<'db>> for ArgListElementOrSeparatorGreen<'db> {
    fn from(value: ArgGreen<'db>) -> Self {
        ArgListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> ArgListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            ArgListElementOrSeparatorGreen::Separator(green) => green.0,
            ArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ArgList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgList);
    type StablePtr = ArgListPtr<'db>;
    type Green = ArgListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ArgList { Some(Self(ElementList::new(node))) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ArgListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprMissing<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> ExprMissingGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprMissing<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprMissingPtr<'db> {
    type SyntaxNode = ExprMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprMissing<'db> {
        ExprMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprMissing);
    type StablePtr = ExprMissingPtr<'db>;
    type Green = ExprMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprMissing { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum PathSegment<'db> {
    Simple(PathSegmentSimple<'db>),
    WithGenericArgs(PathSegmentWithGenericArgs<'db>),
    Missing(PathSegmentMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PathSegmentPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for PathSegmentPtr<'db> {
    type SyntaxNode = PathSegment<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        PathSegment::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PathSegmentPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PathSegmentPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<PathSegmentSimplePtr<'db>> for PathSegmentPtr<'db> {
    fn from(value: PathSegmentSimplePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PathSegmentWithGenericArgsPtr<'db>> for PathSegmentPtr<'db> {
    fn from(value: PathSegmentWithGenericArgsPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PathSegmentMissingPtr<'db>> for PathSegmentPtr<'db> {
    fn from(value: PathSegmentMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PathSegmentSimpleGreen<'db>> for PathSegmentGreen<'db> {
    fn from(value: PathSegmentSimpleGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PathSegmentWithGenericArgsGreen<'db>> for PathSegmentGreen<'db> {
    fn from(value: PathSegmentWithGenericArgsGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PathSegmentMissingGreen<'db>> for PathSegmentGreen<'db> {
    fn from(value: PathSegmentMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PathSegmentGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PathSegment<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = PathSegmentPtr<'db>;
    type Green = PathSegmentGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PathSegmentGreen(PathSegmentMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::PathSegmentSimple => {
                PathSegment::Simple(PathSegmentSimple::from_syntax_node(db, node))
            }
            SyntaxKind::PathSegmentWithGenericArgs => {
                PathSegment::WithGenericArgs(PathSegmentWithGenericArgs::from_syntax_node(db, node))
            }
            SyntaxKind::PathSegmentMissing => {
                PathSegment::Missing(PathSegmentMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "PathSegment"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::PathSegmentSimple => {
                Some(PathSegment::Simple(PathSegmentSimple::from_syntax_node(db, node)))
            }
            SyntaxKind::PathSegmentWithGenericArgs => Some(PathSegment::WithGenericArgs(
                PathSegmentWithGenericArgs::from_syntax_node(db, node),
            )),
            SyntaxKind::PathSegmentMissing => {
                Some(PathSegment::Missing(PathSegmentMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            PathSegment::Simple(x) => x.as_syntax_node(),
            PathSegment::WithGenericArgs(x) => x.as_syntax_node(),
            PathSegment::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PathSegmentPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> PathSegment<'db> {
    /// Checks if a kind of a variant of [PathSegment].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::PathSegmentSimple
                | SyntaxKind::PathSegmentWithGenericArgs
                | SyntaxKind::PathSegmentMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PathSegmentSimple<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> PathSegmentSimple<'db> {
    pub const INDEX_IDENT: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        ident: TerminalIdentifierGreen<'db>,
    ) -> PathSegmentSimpleGreen<'db> {
        let children: Vec<GreenId> = vec![ident.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PathSegmentSimpleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PathSegmentSimple,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> PathSegmentSimple<'db> {
    pub fn ident(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PathSegmentSimplePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> PathSegmentSimplePtr<'db> {}
impl<'db> TypedStablePtr<'db> for PathSegmentSimplePtr<'db> {
    type SyntaxNode = PathSegmentSimple<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PathSegmentSimple<'db> {
        PathSegmentSimple::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PathSegmentSimplePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PathSegmentSimplePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PathSegmentSimpleGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PathSegmentSimple<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PathSegmentSimple);
    type StablePtr = PathSegmentSimplePtr<'db>;
    type Green = PathSegmentSimpleGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PathSegmentSimpleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PathSegmentSimple,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PathSegmentSimple,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PathSegmentSimple
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PathSegmentSimple {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PathSegmentSimplePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionTerminalColonColon<'db> {
    Empty(OptionTerminalColonColonEmpty<'db>),
    TerminalColonColon(TerminalColonColon<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalColonColonPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionTerminalColonColonPtr<'db> {
    type SyntaxNode = OptionTerminalColonColon<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionTerminalColonColon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalColonColonPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalColonColonPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionTerminalColonColonEmptyPtr<'db>> for OptionTerminalColonColonPtr<'db> {
    fn from(value: OptionTerminalColonColonEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalColonColonPtr<'db>> for OptionTerminalColonColonPtr<'db> {
    fn from(value: TerminalColonColonPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionTerminalColonColonEmptyGreen<'db>> for OptionTerminalColonColonGreen<'db> {
    fn from(value: OptionTerminalColonColonEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalColonColonGreen<'db>> for OptionTerminalColonColonGreen<'db> {
    fn from(value: TerminalColonColonGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalColonColonGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalColonColon<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalColonColonPtr<'db>;
    type Green = OptionTerminalColonColonGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalColonColonEmpty => OptionTerminalColonColon::Empty(
                OptionTerminalColonColonEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::TerminalColonColon => OptionTerminalColonColon::TerminalColonColon(
                TerminalColonColon::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalColonColon"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalColonColonEmpty => Some(OptionTerminalColonColon::Empty(
                OptionTerminalColonColonEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalColonColon => Some(OptionTerminalColonColon::TerminalColonColon(
                TerminalColonColon::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionTerminalColonColon::Empty(x) => x.as_syntax_node(),
            OptionTerminalColonColon::TerminalColonColon(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalColonColonPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionTerminalColonColon<'db> {
    /// Checks if a kind of a variant of [OptionTerminalColonColon].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTerminalColonColonEmpty | SyntaxKind::TerminalColonColon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionTerminalColonColonEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionTerminalColonColonEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionTerminalColonColonEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTerminalColonColonEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalColonColonEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionTerminalColonColonEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalColonColonEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionTerminalColonColonEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionTerminalColonColonEmptyPtr<'db> {
    type SyntaxNode = OptionTerminalColonColonEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionTerminalColonColonEmpty<'db> {
        OptionTerminalColonColonEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalColonColonEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalColonColonEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalColonColonEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalColonColonEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalColonColonEmpty);
    type StablePtr = OptionTerminalColonColonEmptyPtr<'db>;
    type Green = OptionTerminalColonColonEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionTerminalColonColonEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalColonColonEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalColonColonEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalColonColonEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTerminalColonColonEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalColonColonEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PathSegmentWithGenericArgs<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> PathSegmentWithGenericArgs<'db> {
    pub const INDEX_IDENT: usize = 0;
    pub const INDEX_SEPARATOR: usize = 1;
    pub const INDEX_GENERIC_ARGS: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        ident: TerminalIdentifierGreen<'db>,
        separator: OptionTerminalColonColonGreen<'db>,
        generic_args: GenericArgsGreen<'db>,
    ) -> PathSegmentWithGenericArgsGreen<'db> {
        let children: Vec<GreenId> = vec![ident.0, separator.0, generic_args.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PathSegmentWithGenericArgsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PathSegmentWithGenericArgs,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> PathSegmentWithGenericArgs<'db> {
    pub fn ident(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
    pub fn separator(&self, db: &'db dyn SyntaxGroup) -> OptionTerminalColonColon<'db> {
        OptionTerminalColonColon::from_syntax_node(db, self.children[1])
    }
    pub fn generic_args(&self, db: &'db dyn SyntaxGroup) -> GenericArgs<'db> {
        GenericArgs::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PathSegmentWithGenericArgsPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> PathSegmentWithGenericArgsPtr<'db> {}
impl<'db> TypedStablePtr<'db> for PathSegmentWithGenericArgsPtr<'db> {
    type SyntaxNode = PathSegmentWithGenericArgs<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PathSegmentWithGenericArgs<'db> {
        PathSegmentWithGenericArgs::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PathSegmentWithGenericArgsPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PathSegmentWithGenericArgsPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PathSegmentWithGenericArgsGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PathSegmentWithGenericArgs<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PathSegmentWithGenericArgs);
    type StablePtr = PathSegmentWithGenericArgsPtr<'db>;
    type Green = PathSegmentWithGenericArgsGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PathSegmentWithGenericArgsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PathSegmentWithGenericArgs,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIdentifier::missing(db).0,
                        OptionTerminalColonColon::missing(db).0,
                        GenericArgs::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PathSegmentWithGenericArgs,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PathSegmentWithGenericArgs
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PathSegmentWithGenericArgs {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PathSegmentWithGenericArgsPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprPath<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprPath<'db> {
    pub const INDEX_DOLLAR: usize = 0;
    pub const INDEX_SEGMENTS: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        dollar: OptionTerminalDollarGreen<'db>,
        segments: ExprPathInnerGreen<'db>,
    ) -> ExprPathGreen<'db> {
        let children: Vec<GreenId> = vec![dollar.0, segments.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprPathGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprPath,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprPath<'db> {
    pub fn dollar(&self, db: &'db dyn SyntaxGroup) -> OptionTerminalDollar<'db> {
        OptionTerminalDollar::from_syntax_node(db, self.children[0])
    }
    pub fn segments(&self, db: &'db dyn SyntaxGroup) -> ExprPathInner<'db> {
        ExprPathInner::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprPathPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprPathPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprPathPtr<'db> {
    type SyntaxNode = ExprPath<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprPathPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprPathPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprPathGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprPath<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprPath);
    type StablePtr = ExprPathPtr<'db>;
    type Green = ExprPathGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprPathGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprPath,
                details: GreenNodeDetails::Node {
                    children: vec![
                        OptionTerminalDollar::missing(db).0,
                        ExprPathInner::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprPath,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprPath
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprPath { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprPathPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionTerminalDollar<'db> {
    Empty(OptionTerminalDollarEmpty<'db>),
    TerminalDollar(TerminalDollar<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalDollarPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionTerminalDollarPtr<'db> {
    type SyntaxNode = OptionTerminalDollar<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionTerminalDollar::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalDollarPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalDollarPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionTerminalDollarEmptyPtr<'db>> for OptionTerminalDollarPtr<'db> {
    fn from(value: OptionTerminalDollarEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDollarPtr<'db>> for OptionTerminalDollarPtr<'db> {
    fn from(value: TerminalDollarPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionTerminalDollarEmptyGreen<'db>> for OptionTerminalDollarGreen<'db> {
    fn from(value: OptionTerminalDollarEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDollarGreen<'db>> for OptionTerminalDollarGreen<'db> {
    fn from(value: TerminalDollarGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalDollarGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalDollar<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalDollarPtr<'db>;
    type Green = OptionTerminalDollarGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalDollarEmpty => {
                OptionTerminalDollar::Empty(OptionTerminalDollarEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDollar => {
                OptionTerminalDollar::TerminalDollar(TerminalDollar::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalDollar"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalDollarEmpty => Some(OptionTerminalDollar::Empty(
                OptionTerminalDollarEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalDollar => Some(OptionTerminalDollar::TerminalDollar(
                TerminalDollar::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionTerminalDollar::Empty(x) => x.as_syntax_node(),
            OptionTerminalDollar::TerminalDollar(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalDollarPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionTerminalDollar<'db> {
    /// Checks if a kind of a variant of [OptionTerminalDollar].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTerminalDollarEmpty | SyntaxKind::TerminalDollar)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionTerminalDollarEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionTerminalDollarEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionTerminalDollarEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTerminalDollarEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalDollarEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionTerminalDollarEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalDollarEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionTerminalDollarEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionTerminalDollarEmptyPtr<'db> {
    type SyntaxNode = OptionTerminalDollarEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionTerminalDollarEmpty<'db> {
        OptionTerminalDollarEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalDollarEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalDollarEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalDollarEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalDollarEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalDollarEmpty);
    type StablePtr = OptionTerminalDollarEmptyPtr<'db>;
    type Green = OptionTerminalDollarEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionTerminalDollarEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalDollarEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalDollarEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalDollarEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTerminalDollarEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalDollarEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PathSegmentMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> PathSegmentMissing<'db> {
    pub const INDEX_IDENT: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        ident: TerminalIdentifierGreen<'db>,
    ) -> PathSegmentMissingGreen<'db> {
        let children: Vec<GreenId> = vec![ident.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PathSegmentMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PathSegmentMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> PathSegmentMissing<'db> {
    pub fn ident(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PathSegmentMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> PathSegmentMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for PathSegmentMissingPtr<'db> {
    type SyntaxNode = PathSegmentMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PathSegmentMissing<'db> {
        PathSegmentMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PathSegmentMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PathSegmentMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PathSegmentMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PathSegmentMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PathSegmentMissing);
    type StablePtr = PathSegmentMissingPtr<'db>;
    type Green = PathSegmentMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PathSegmentMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PathSegmentMissing,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PathSegmentMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PathSegmentMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PathSegmentMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PathSegmentMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprPathInner<'db>(ElementList<'db, PathSegment<'db>, 2>);
impl<'db> Deref for ExprPathInner<'db> {
    type Target = ElementList<'db, PathSegment<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> ExprPathInner<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<ExprPathInnerElementOrSeparatorGreen<'db>>,
    ) -> ExprPathInnerGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        ExprPathInnerGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprPathInner,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprPathInnerPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ExprPathInnerPtr<'db> {
    type SyntaxNode = ExprPathInner<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprPathInner<'db> {
        ExprPathInner::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprPathInnerPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprPathInnerPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum ExprPathInnerElementOrSeparatorGreen<'db> {
    Separator(TerminalColonColonGreen<'db>),
    Element(PathSegmentGreen<'db>),
}
impl<'db> From<TerminalColonColonGreen<'db>> for ExprPathInnerElementOrSeparatorGreen<'db> {
    fn from(value: TerminalColonColonGreen<'db>) -> Self {
        ExprPathInnerElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<PathSegmentGreen<'db>> for ExprPathInnerElementOrSeparatorGreen<'db> {
    fn from(value: PathSegmentGreen<'db>) -> Self {
        ExprPathInnerElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> ExprPathInnerElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            ExprPathInnerElementOrSeparatorGreen::Separator(green) => green.0,
            ExprPathInnerElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprPathInnerGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprPathInner<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprPathInner);
    type StablePtr = ExprPathInnerPtr<'db>;
    type Green = ExprPathInnerGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprPathInnerGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprPathInner,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ExprPathInner {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprPathInnerPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprParenthesized<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprParenthesized<'db> {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_EXPR: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lparen: TerminalLParenGreen<'db>,
        expr: ExprGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
    ) -> ExprParenthesizedGreen<'db> {
        let children: Vec<GreenId> = vec![lparen.0, expr.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprParenthesized,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprParenthesized<'db> {
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[0])
    }
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[1])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprParenthesizedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprParenthesizedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprParenthesizedPtr<'db> {
    type SyntaxNode = ExprParenthesized<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprParenthesized<'db> {
        ExprParenthesized::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprParenthesizedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprParenthesizedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprParenthesizedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprParenthesized<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprParenthesized);
    type StablePtr = ExprParenthesizedPtr<'db>;
    type Green = ExprParenthesizedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprParenthesized,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        Expr::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprParenthesized,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprParenthesized
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprParenthesized {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprParenthesizedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprUnary<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprUnary<'db> {
    pub const INDEX_OP: usize = 0;
    pub const INDEX_EXPR: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        op: UnaryOperatorGreen<'db>,
        expr: ExprGreen<'db>,
    ) -> ExprUnaryGreen<'db> {
        let children: Vec<GreenId> = vec![op.0, expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprUnaryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprUnary,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprUnary<'db> {
    pub fn op(&self, db: &'db dyn SyntaxGroup) -> UnaryOperator<'db> {
        UnaryOperator::from_syntax_node(db, self.children[0])
    }
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprUnaryPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprUnaryPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprUnaryPtr<'db> {
    type SyntaxNode = ExprUnary<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprUnary<'db> {
        ExprUnary::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprUnaryPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprUnaryPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprUnaryGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprUnary<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprUnary);
    type StablePtr = ExprUnaryPtr<'db>;
    type Green = ExprUnaryGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprUnaryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprUnary,
                details: GreenNodeDetails::Node {
                    children: vec![UnaryOperator::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprUnary,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprUnary
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprUnary { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprUnaryPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum UnaryOperator<'db> {
    Not(TerminalNot<'db>),
    BitNot(TerminalBitNot<'db>),
    Minus(TerminalMinus<'db>),
    At(TerminalAt<'db>),
    Desnap(TerminalMul<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UnaryOperatorPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for UnaryOperatorPtr<'db> {
    type SyntaxNode = UnaryOperator<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        UnaryOperator::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<UnaryOperatorPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: UnaryOperatorPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TerminalNotPtr<'db>> for UnaryOperatorPtr<'db> {
    fn from(value: TerminalNotPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalBitNotPtr<'db>> for UnaryOperatorPtr<'db> {
    fn from(value: TerminalBitNotPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMinusPtr<'db>> for UnaryOperatorPtr<'db> {
    fn from(value: TerminalMinusPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAtPtr<'db>> for UnaryOperatorPtr<'db> {
    fn from(value: TerminalAtPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulPtr<'db>> for UnaryOperatorPtr<'db> {
    fn from(value: TerminalMulPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNotGreen<'db>> for UnaryOperatorGreen<'db> {
    fn from(value: TerminalNotGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalBitNotGreen<'db>> for UnaryOperatorGreen<'db> {
    fn from(value: TerminalBitNotGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMinusGreen<'db>> for UnaryOperatorGreen<'db> {
    fn from(value: TerminalMinusGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAtGreen<'db>> for UnaryOperatorGreen<'db> {
    fn from(value: TerminalAtGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulGreen<'db>> for UnaryOperatorGreen<'db> {
    fn from(value: TerminalMulGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UnaryOperatorGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for UnaryOperator<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = UnaryOperatorPtr<'db>;
    type Green = UnaryOperatorGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalNot => UnaryOperator::Not(TerminalNot::from_syntax_node(db, node)),
            SyntaxKind::TerminalBitNot => {
                UnaryOperator::BitNot(TerminalBitNot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinus => {
                UnaryOperator::Minus(TerminalMinus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalAt => UnaryOperator::At(TerminalAt::from_syntax_node(db, node)),
            SyntaxKind::TerminalMul => {
                UnaryOperator::Desnap(TerminalMul::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "UnaryOperator"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalNot => {
                Some(UnaryOperator::Not(TerminalNot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalBitNot => {
                Some(UnaryOperator::BitNot(TerminalBitNot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMinus => {
                Some(UnaryOperator::Minus(TerminalMinus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAt => {
                Some(UnaryOperator::At(TerminalAt::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMul => {
                Some(UnaryOperator::Desnap(TerminalMul::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            UnaryOperator::Not(x) => x.as_syntax_node(),
            UnaryOperator::BitNot(x) => x.as_syntax_node(),
            UnaryOperator::Minus(x) => x.as_syntax_node(),
            UnaryOperator::At(x) => x.as_syntax_node(),
            UnaryOperator::Desnap(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        UnaryOperatorPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> UnaryOperator<'db> {
    /// Checks if a kind of a variant of [UnaryOperator].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TerminalNot
                | SyntaxKind::TerminalBitNot
                | SyntaxKind::TerminalMinus
                | SyntaxKind::TerminalAt
                | SyntaxKind::TerminalMul
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprBinary<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprBinary<'db> {
    pub const INDEX_LHS: usize = 0;
    pub const INDEX_OP: usize = 1;
    pub const INDEX_RHS: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lhs: ExprGreen<'db>,
        op: BinaryOperatorGreen<'db>,
        rhs: ExprGreen<'db>,
    ) -> ExprBinaryGreen<'db> {
        let children: Vec<GreenId> = vec![lhs.0, op.0, rhs.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprBinaryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprBinary,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprBinary<'db> {
    pub fn lhs(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[0])
    }
    pub fn op(&self, db: &'db dyn SyntaxGroup) -> BinaryOperator<'db> {
        BinaryOperator::from_syntax_node(db, self.children[1])
    }
    pub fn rhs(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprBinaryPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprBinaryPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprBinaryPtr<'db> {
    type SyntaxNode = ExprBinary<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprBinary<'db> {
        ExprBinary::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprBinaryPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprBinaryPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprBinaryGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprBinary<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprBinary);
    type StablePtr = ExprBinaryPtr<'db>;
    type Green = ExprBinaryGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprBinaryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprBinary,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Expr::missing(db).0,
                        BinaryOperator::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprBinary,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprBinary
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprBinary { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprBinaryPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum BinaryOperator<'db> {
    Dot(TerminalDot<'db>),
    Not(TerminalNot<'db>),
    Mul(TerminalMul<'db>),
    MulEq(TerminalMulEq<'db>),
    Div(TerminalDiv<'db>),
    DivEq(TerminalDivEq<'db>),
    Mod(TerminalMod<'db>),
    ModEq(TerminalModEq<'db>),
    Plus(TerminalPlus<'db>),
    PlusEq(TerminalPlusEq<'db>),
    Minus(TerminalMinus<'db>),
    MinusEq(TerminalMinusEq<'db>),
    EqEq(TerminalEqEq<'db>),
    Neq(TerminalNeq<'db>),
    Eq(TerminalEq<'db>),
    And(TerminalAnd<'db>),
    AndAnd(TerminalAndAnd<'db>),
    Or(TerminalOr<'db>),
    OrOr(TerminalOrOr<'db>),
    Xor(TerminalXor<'db>),
    LE(TerminalLE<'db>),
    GE(TerminalGE<'db>),
    LT(TerminalLT<'db>),
    GT(TerminalGT<'db>),
    DotDot(TerminalDotDot<'db>),
    DotDotEq(TerminalDotDotEq<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BinaryOperatorPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for BinaryOperatorPtr<'db> {
    type SyntaxNode = BinaryOperator<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        BinaryOperator::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<BinaryOperatorPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: BinaryOperatorPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TerminalDotPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalDotPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNotPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalNotPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalMulPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulEqPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalMulEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDivPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalDivPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDivEqPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalDivEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalModPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalModPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalModEqPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalModEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPlusPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalPlusPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPlusEqPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalPlusEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMinusPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalMinusPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMinusEqPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalMinusEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEqEqPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalEqEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNeqPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalNeqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEqPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAndPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalAndPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAndAndPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalAndAndPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOrPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalOrPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOrOrPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalOrOrPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalXorPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalXorPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLEPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalLEPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalGEPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalGEPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLTPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalLTPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalGTPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalGTPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotDotPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalDotDotPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotDotEqPtr<'db>> for BinaryOperatorPtr<'db> {
    fn from(value: TerminalDotDotEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalDotGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNotGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalNotGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalMulGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulEqGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalMulEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDivGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalDivGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDivEqGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalDivEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalModGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalModGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalModEqGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalModEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPlusGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalPlusGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPlusEqGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalPlusEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMinusGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalMinusGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMinusEqGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalMinusEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEqEqGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalEqEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNeqGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalNeqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEqGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAndGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalAndGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAndAndGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalAndAndGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOrGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalOrGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOrOrGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalOrOrGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalXorGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalXorGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLEGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalLEGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalGEGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalGEGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLTGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalLTGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalGTGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalGTGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotDotGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalDotDotGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotDotEqGreen<'db>> for BinaryOperatorGreen<'db> {
    fn from(value: TerminalDotDotEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BinaryOperatorGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for BinaryOperator<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = BinaryOperatorPtr<'db>;
    type Green = BinaryOperatorGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalDot => BinaryOperator::Dot(TerminalDot::from_syntax_node(db, node)),
            SyntaxKind::TerminalNot => BinaryOperator::Not(TerminalNot::from_syntax_node(db, node)),
            SyntaxKind::TerminalMul => BinaryOperator::Mul(TerminalMul::from_syntax_node(db, node)),
            SyntaxKind::TerminalMulEq => {
                BinaryOperator::MulEq(TerminalMulEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDiv => BinaryOperator::Div(TerminalDiv::from_syntax_node(db, node)),
            SyntaxKind::TerminalDivEq => {
                BinaryOperator::DivEq(TerminalDivEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMod => BinaryOperator::Mod(TerminalMod::from_syntax_node(db, node)),
            SyntaxKind::TerminalModEq => {
                BinaryOperator::ModEq(TerminalModEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPlus => {
                BinaryOperator::Plus(TerminalPlus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPlusEq => {
                BinaryOperator::PlusEq(TerminalPlusEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinus => {
                BinaryOperator::Minus(TerminalMinus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinusEq => {
                BinaryOperator::MinusEq(TerminalMinusEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEqEq => {
                BinaryOperator::EqEq(TerminalEqEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNeq => BinaryOperator::Neq(TerminalNeq::from_syntax_node(db, node)),
            SyntaxKind::TerminalEq => BinaryOperator::Eq(TerminalEq::from_syntax_node(db, node)),
            SyntaxKind::TerminalAnd => BinaryOperator::And(TerminalAnd::from_syntax_node(db, node)),
            SyntaxKind::TerminalAndAnd => {
                BinaryOperator::AndAnd(TerminalAndAnd::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalOr => BinaryOperator::Or(TerminalOr::from_syntax_node(db, node)),
            SyntaxKind::TerminalOrOr => {
                BinaryOperator::OrOr(TerminalOrOr::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalXor => BinaryOperator::Xor(TerminalXor::from_syntax_node(db, node)),
            SyntaxKind::TerminalLE => BinaryOperator::LE(TerminalLE::from_syntax_node(db, node)),
            SyntaxKind::TerminalGE => BinaryOperator::GE(TerminalGE::from_syntax_node(db, node)),
            SyntaxKind::TerminalLT => BinaryOperator::LT(TerminalLT::from_syntax_node(db, node)),
            SyntaxKind::TerminalGT => BinaryOperator::GT(TerminalGT::from_syntax_node(db, node)),
            SyntaxKind::TerminalDotDot => {
                BinaryOperator::DotDot(TerminalDotDot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDotDotEq => {
                BinaryOperator::DotDotEq(TerminalDotDotEq::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "BinaryOperator")
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalDot => {
                Some(BinaryOperator::Dot(TerminalDot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalNot => {
                Some(BinaryOperator::Not(TerminalNot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMul => {
                Some(BinaryOperator::Mul(TerminalMul::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMulEq => {
                Some(BinaryOperator::MulEq(TerminalMulEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDiv => {
                Some(BinaryOperator::Div(TerminalDiv::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDivEq => {
                Some(BinaryOperator::DivEq(TerminalDivEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMod => {
                Some(BinaryOperator::Mod(TerminalMod::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalModEq => {
                Some(BinaryOperator::ModEq(TerminalModEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalPlus => {
                Some(BinaryOperator::Plus(TerminalPlus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalPlusEq => {
                Some(BinaryOperator::PlusEq(TerminalPlusEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMinus => {
                Some(BinaryOperator::Minus(TerminalMinus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMinusEq => {
                Some(BinaryOperator::MinusEq(TerminalMinusEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEqEq => {
                Some(BinaryOperator::EqEq(TerminalEqEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalNeq => {
                Some(BinaryOperator::Neq(TerminalNeq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEq => {
                Some(BinaryOperator::Eq(TerminalEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAnd => {
                Some(BinaryOperator::And(TerminalAnd::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAndAnd => {
                Some(BinaryOperator::AndAnd(TerminalAndAnd::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalOr => {
                Some(BinaryOperator::Or(TerminalOr::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalOrOr => {
                Some(BinaryOperator::OrOr(TerminalOrOr::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalXor => {
                Some(BinaryOperator::Xor(TerminalXor::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLE => {
                Some(BinaryOperator::LE(TerminalLE::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalGE => {
                Some(BinaryOperator::GE(TerminalGE::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLT => {
                Some(BinaryOperator::LT(TerminalLT::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalGT => {
                Some(BinaryOperator::GT(TerminalGT::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDotDot => {
                Some(BinaryOperator::DotDot(TerminalDotDot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDotDotEq => {
                Some(BinaryOperator::DotDotEq(TerminalDotDotEq::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            BinaryOperator::Dot(x) => x.as_syntax_node(),
            BinaryOperator::Not(x) => x.as_syntax_node(),
            BinaryOperator::Mul(x) => x.as_syntax_node(),
            BinaryOperator::MulEq(x) => x.as_syntax_node(),
            BinaryOperator::Div(x) => x.as_syntax_node(),
            BinaryOperator::DivEq(x) => x.as_syntax_node(),
            BinaryOperator::Mod(x) => x.as_syntax_node(),
            BinaryOperator::ModEq(x) => x.as_syntax_node(),
            BinaryOperator::Plus(x) => x.as_syntax_node(),
            BinaryOperator::PlusEq(x) => x.as_syntax_node(),
            BinaryOperator::Minus(x) => x.as_syntax_node(),
            BinaryOperator::MinusEq(x) => x.as_syntax_node(),
            BinaryOperator::EqEq(x) => x.as_syntax_node(),
            BinaryOperator::Neq(x) => x.as_syntax_node(),
            BinaryOperator::Eq(x) => x.as_syntax_node(),
            BinaryOperator::And(x) => x.as_syntax_node(),
            BinaryOperator::AndAnd(x) => x.as_syntax_node(),
            BinaryOperator::Or(x) => x.as_syntax_node(),
            BinaryOperator::OrOr(x) => x.as_syntax_node(),
            BinaryOperator::Xor(x) => x.as_syntax_node(),
            BinaryOperator::LE(x) => x.as_syntax_node(),
            BinaryOperator::GE(x) => x.as_syntax_node(),
            BinaryOperator::LT(x) => x.as_syntax_node(),
            BinaryOperator::GT(x) => x.as_syntax_node(),
            BinaryOperator::DotDot(x) => x.as_syntax_node(),
            BinaryOperator::DotDotEq(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        BinaryOperatorPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> BinaryOperator<'db> {
    /// Checks if a kind of a variant of [BinaryOperator].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TerminalDot
                | SyntaxKind::TerminalNot
                | SyntaxKind::TerminalMul
                | SyntaxKind::TerminalMulEq
                | SyntaxKind::TerminalDiv
                | SyntaxKind::TerminalDivEq
                | SyntaxKind::TerminalMod
                | SyntaxKind::TerminalModEq
                | SyntaxKind::TerminalPlus
                | SyntaxKind::TerminalPlusEq
                | SyntaxKind::TerminalMinus
                | SyntaxKind::TerminalMinusEq
                | SyntaxKind::TerminalEqEq
                | SyntaxKind::TerminalNeq
                | SyntaxKind::TerminalEq
                | SyntaxKind::TerminalAnd
                | SyntaxKind::TerminalAndAnd
                | SyntaxKind::TerminalOr
                | SyntaxKind::TerminalOrOr
                | SyntaxKind::TerminalXor
                | SyntaxKind::TerminalLE
                | SyntaxKind::TerminalGE
                | SyntaxKind::TerminalLT
                | SyntaxKind::TerminalGT
                | SyntaxKind::TerminalDotDot
                | SyntaxKind::TerminalDotDotEq
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprListParenthesized<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprListParenthesized<'db> {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_EXPRESSIONS: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lparen: TerminalLParenGreen<'db>,
        expressions: ExprListGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
    ) -> ExprListParenthesizedGreen<'db> {
        let children: Vec<GreenId> = vec![lparen.0, expressions.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprListParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprListParenthesized,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprListParenthesized<'db> {
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[0])
    }
    pub fn expressions(&self, db: &'db dyn SyntaxGroup) -> ExprList<'db> {
        ExprList::from_syntax_node(db, self.children[1])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprListParenthesizedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprListParenthesizedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprListParenthesizedPtr<'db> {
    type SyntaxNode = ExprListParenthesized<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprListParenthesized<'db> {
        ExprListParenthesized::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprListParenthesizedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprListParenthesizedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprListParenthesizedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprListParenthesized<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprListParenthesized);
    type StablePtr = ExprListParenthesizedPtr<'db>;
    type Green = ExprListParenthesizedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprListParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprListParenthesized,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        ExprList::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprListParenthesized,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprListParenthesized
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprListParenthesized {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprListParenthesizedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprFunctionCall<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprFunctionCall<'db> {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        path: ExprPathGreen<'db>,
        arguments: ArgListParenthesizedGreen<'db>,
    ) -> ExprFunctionCallGreen<'db> {
        let children: Vec<GreenId> = vec![path.0, arguments.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprFunctionCallGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFunctionCall,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprFunctionCall<'db> {
    pub fn path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[0])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> ArgListParenthesized<'db> {
        ArgListParenthesized::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprFunctionCallPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprFunctionCallPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprFunctionCallPtr<'db> {
    type SyntaxNode = ExprFunctionCall<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprFunctionCall<'db> {
        ExprFunctionCall::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprFunctionCallPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprFunctionCallPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprFunctionCallGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprFunctionCall<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprFunctionCall);
    type StablePtr = ExprFunctionCallPtr<'db>;
    type Green = ExprFunctionCallGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprFunctionCallGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFunctionCall,
                details: GreenNodeDetails::Node {
                    children: vec![ExprPath::missing(db).0, ArgListParenthesized::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprFunctionCall,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprFunctionCall
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprFunctionCall {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprFunctionCallPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ArgListParenthesized<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ArgListParenthesized<'db> {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lparen: TerminalLParenGreen<'db>,
        arguments: ArgListGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
    ) -> ArgListParenthesizedGreen<'db> {
        let children: Vec<GreenId> = vec![lparen.0, arguments.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgListParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListParenthesized,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ArgListParenthesized<'db> {
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[0])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> ArgList<'db> {
        ArgList::from_syntax_node(db, self.children[1])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgListParenthesizedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ArgListParenthesizedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ArgListParenthesizedPtr<'db> {
    type SyntaxNode = ArgListParenthesized<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ArgListParenthesized<'db> {
        ArgListParenthesized::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ArgListParenthesizedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ArgListParenthesizedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgListParenthesizedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ArgListParenthesized<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgListParenthesized);
    type StablePtr = ArgListParenthesizedPtr<'db>;
    type Green = ArgListParenthesizedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ArgListParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListParenthesized,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        ArgList::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgListParenthesized,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgListParenthesized
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgListParenthesized {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ArgListParenthesizedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionArgListParenthesized<'db> {
    Empty(OptionArgListParenthesizedEmpty<'db>),
    ArgListParenthesized(ArgListParenthesized<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionArgListParenthesizedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionArgListParenthesizedPtr<'db> {
    type SyntaxNode = OptionArgListParenthesized<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionArgListParenthesized::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionArgListParenthesizedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionArgListParenthesizedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionArgListParenthesizedEmptyPtr<'db>> for OptionArgListParenthesizedPtr<'db> {
    fn from(value: OptionArgListParenthesizedEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgListParenthesizedPtr<'db>> for OptionArgListParenthesizedPtr<'db> {
    fn from(value: ArgListParenthesizedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionArgListParenthesizedEmptyGreen<'db>> for OptionArgListParenthesizedGreen<'db> {
    fn from(value: OptionArgListParenthesizedEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgListParenthesizedGreen<'db>> for OptionArgListParenthesizedGreen<'db> {
    fn from(value: ArgListParenthesizedGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionArgListParenthesizedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionArgListParenthesized<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionArgListParenthesizedPtr<'db>;
    type Green = OptionArgListParenthesizedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionArgListParenthesizedEmpty => OptionArgListParenthesized::Empty(
                OptionArgListParenthesizedEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::ArgListParenthesized => OptionArgListParenthesized::ArgListParenthesized(
                ArgListParenthesized::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionArgListParenthesized"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionArgListParenthesizedEmpty => Some(OptionArgListParenthesized::Empty(
                OptionArgListParenthesizedEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::ArgListParenthesized => {
                Some(OptionArgListParenthesized::ArgListParenthesized(
                    ArgListParenthesized::from_syntax_node(db, node),
                ))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionArgListParenthesized::Empty(x) => x.as_syntax_node(),
            OptionArgListParenthesized::ArgListParenthesized(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionArgListParenthesizedPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionArgListParenthesized<'db> {
    /// Checks if a kind of a variant of [OptionArgListParenthesized].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::OptionArgListParenthesizedEmpty | SyntaxKind::ArgListParenthesized
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionArgListParenthesizedEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionArgListParenthesizedEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionArgListParenthesizedEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionArgListParenthesizedEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionArgListParenthesizedEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionArgListParenthesizedEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionArgListParenthesizedEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionArgListParenthesizedEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionArgListParenthesizedEmptyPtr<'db> {
    type SyntaxNode = OptionArgListParenthesizedEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionArgListParenthesizedEmpty<'db> {
        OptionArgListParenthesizedEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionArgListParenthesizedEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionArgListParenthesizedEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionArgListParenthesizedEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionArgListParenthesizedEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionArgListParenthesizedEmpty);
    type StablePtr = OptionArgListParenthesizedEmptyPtr<'db>;
    type Green = OptionArgListParenthesizedEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionArgListParenthesizedEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionArgListParenthesizedEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionArgListParenthesizedEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionArgListParenthesizedEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionArgListParenthesizedEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionArgListParenthesizedEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprStructCtorCall<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprStructCtorCall<'db> {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        path: ExprPathGreen<'db>,
        arguments: StructArgListBracedGreen<'db>,
    ) -> ExprStructCtorCallGreen<'db> {
        let children: Vec<GreenId> = vec![path.0, arguments.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprStructCtorCallGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprStructCtorCall,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprStructCtorCall<'db> {
    pub fn path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[0])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> StructArgListBraced<'db> {
        StructArgListBraced::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprStructCtorCallPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprStructCtorCallPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprStructCtorCallPtr<'db> {
    type SyntaxNode = ExprStructCtorCall<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprStructCtorCall<'db> {
        ExprStructCtorCall::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprStructCtorCallPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprStructCtorCallPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprStructCtorCallGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprStructCtorCall<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprStructCtorCall);
    type StablePtr = ExprStructCtorCallPtr<'db>;
    type Green = ExprStructCtorCallGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprStructCtorCallGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprStructCtorCall,
                details: GreenNodeDetails::Node {
                    children: vec![ExprPath::missing(db).0, StructArgListBraced::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprStructCtorCall,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprStructCtorCall
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprStructCtorCall {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprStructCtorCallPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StructArgListBraced<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StructArgListBraced<'db> {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen<'db>,
        arguments: StructArgListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> StructArgListBracedGreen<'db> {
        let children: Vec<GreenId> = vec![lbrace.0, arguments.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StructArgListBracedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgListBraced,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StructArgListBraced<'db> {
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[0])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> StructArgList<'db> {
        StructArgList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgListBracedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StructArgListBracedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for StructArgListBracedPtr<'db> {
    type SyntaxNode = StructArgListBraced<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StructArgListBraced<'db> {
        StructArgListBraced::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StructArgListBracedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StructArgListBracedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgListBracedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StructArgListBraced<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgListBraced);
    type StablePtr = StructArgListBracedPtr<'db>;
    type Green = StructArgListBracedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StructArgListBracedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgListBraced,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        StructArgList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgListBraced,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgListBraced
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StructArgListBraced {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StructArgListBracedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprBlock<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprBlock<'db> {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_STATEMENTS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen<'db>,
        statements: StatementListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> ExprBlockGreen<'db> {
        let children: Vec<GreenId> = vec![lbrace.0, statements.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprBlockGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprBlock,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprBlock<'db> {
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[0])
    }
    pub fn statements(&self, db: &'db dyn SyntaxGroup) -> StatementList<'db> {
        StatementList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprBlockPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprBlockPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprBlockPtr<'db> {
    type SyntaxNode = ExprBlock<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprBlock<'db> {
        ExprBlock::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprBlockPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprBlockPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprBlockGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprBlock<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprBlock);
    type StablePtr = ExprBlockPtr<'db>;
    type Green = ExprBlockGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprBlockGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprBlock,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        StatementList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprBlock,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprBlock
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprBlock { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprBlockPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprMatch<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprMatch<'db> {
    pub const INDEX_MATCH_KW: usize = 0;
    pub const INDEX_EXPR: usize = 1;
    pub const INDEX_LBRACE: usize = 2;
    pub const INDEX_ARMS: usize = 3;
    pub const INDEX_RBRACE: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        match_kw: TerminalMatchGreen<'db>,
        expr: ExprGreen<'db>,
        lbrace: TerminalLBraceGreen<'db>,
        arms: MatchArmsGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> ExprMatchGreen<'db> {
        let children: Vec<GreenId> = vec![match_kw.0, expr.0, lbrace.0, arms.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprMatch,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprMatch<'db> {
    pub fn match_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalMatch<'db> {
        TerminalMatch::from_syntax_node(db, self.children[0])
    }
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[1])
    }
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[2])
    }
    pub fn arms(&self, db: &'db dyn SyntaxGroup) -> MatchArms<'db> {
        MatchArms::from_syntax_node(db, self.children[3])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprMatchPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprMatchPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprMatchPtr<'db> {
    type SyntaxNode = ExprMatch<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprMatch<'db> {
        ExprMatch::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprMatchPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprMatchPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprMatchGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprMatch<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprMatch);
    type StablePtr = ExprMatchPtr<'db>;
    type Green = ExprMatchGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprMatch,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalMatch::missing(db).0,
                        Expr::missing(db).0,
                        TerminalLBrace::missing(db).0,
                        MatchArms::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprMatch,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprMatch
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprMatch { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprMatchPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MatchArms<'db>(ElementList<'db, MatchArm<'db>, 2>);
impl<'db> Deref for MatchArms<'db> {
    type Target = ElementList<'db, MatchArm<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> MatchArms<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<MatchArmsElementOrSeparatorGreen<'db>>,
    ) -> MatchArmsGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        MatchArmsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MatchArms,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MatchArmsPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MatchArmsPtr<'db> {
    type SyntaxNode = MatchArms<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MatchArms<'db> {
        MatchArms::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MatchArmsPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MatchArmsPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum MatchArmsElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(MatchArmGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for MatchArmsElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        MatchArmsElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<MatchArmGreen<'db>> for MatchArmsElementOrSeparatorGreen<'db> {
    fn from(value: MatchArmGreen<'db>) -> Self {
        MatchArmsElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> MatchArmsElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            MatchArmsElementOrSeparatorGreen::Separator(green) => green.0,
            MatchArmsElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MatchArmsGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MatchArms<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MatchArms);
    type StablePtr = MatchArmsPtr<'db>;
    type Green = MatchArmsGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MatchArmsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MatchArms,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::MatchArms {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MatchArmsPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MatchArm<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> MatchArm<'db> {
    pub const INDEX_PATTERNS: usize = 0;
    pub const INDEX_ARROW: usize = 1;
    pub const INDEX_EXPRESSION: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        patterns: PatternListOrGreen<'db>,
        arrow: TerminalMatchArrowGreen<'db>,
        expression: ExprGreen<'db>,
    ) -> MatchArmGreen<'db> {
        let children: Vec<GreenId> = vec![patterns.0, arrow.0, expression.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        MatchArmGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MatchArm,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> MatchArm<'db> {
    pub fn patterns(&self, db: &'db dyn SyntaxGroup) -> PatternListOr<'db> {
        PatternListOr::from_syntax_node(db, self.children[0])
    }
    pub fn arrow(&self, db: &'db dyn SyntaxGroup) -> TerminalMatchArrow<'db> {
        TerminalMatchArrow::from_syntax_node(db, self.children[1])
    }
    pub fn expression(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MatchArmPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> MatchArmPtr<'db> {}
impl<'db> TypedStablePtr<'db> for MatchArmPtr<'db> {
    type SyntaxNode = MatchArm<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MatchArm<'db> {
        MatchArm::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MatchArmPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MatchArmPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MatchArmGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MatchArm<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MatchArm);
    type StablePtr = MatchArmPtr<'db>;
    type Green = MatchArmGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MatchArmGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MatchArm,
                details: GreenNodeDetails::Node {
                    children: vec![
                        PatternListOr::missing(db).0,
                        TerminalMatchArrow::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::MatchArm,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::MatchArm
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::MatchArm { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MatchArmPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprIf<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprIf<'db> {
    pub const INDEX_IF_KW: usize = 0;
    pub const INDEX_CONDITION: usize = 1;
    pub const INDEX_IF_BLOCK: usize = 2;
    pub const INDEX_ELSE_CLAUSE: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        if_kw: TerminalIfGreen<'db>,
        condition: ConditionGreen<'db>,
        if_block: ExprBlockGreen<'db>,
        else_clause: OptionElseClauseGreen<'db>,
    ) -> ExprIfGreen<'db> {
        let children: Vec<GreenId> = vec![if_kw.0, condition.0, if_block.0, else_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprIf,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprIf<'db> {
    pub fn if_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalIf<'db> {
        TerminalIf::from_syntax_node(db, self.children[0])
    }
    pub fn condition(&self, db: &'db dyn SyntaxGroup) -> Condition<'db> {
        Condition::from_syntax_node(db, self.children[1])
    }
    pub fn if_block(&self, db: &'db dyn SyntaxGroup) -> ExprBlock<'db> {
        ExprBlock::from_syntax_node(db, self.children[2])
    }
    pub fn else_clause(&self, db: &'db dyn SyntaxGroup) -> OptionElseClause<'db> {
        OptionElseClause::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprIfPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprIfPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprIfPtr<'db> {
    type SyntaxNode = ExprIf<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprIf<'db> {
        ExprIf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprIfPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprIfPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprIfGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprIf<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprIf);
    type StablePtr = ExprIfPtr<'db>;
    type Green = ExprIfGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprIf,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIf::missing(db).0,
                        Condition::missing(db).0,
                        ExprBlock::missing(db).0,
                        OptionElseClause::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprIf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprIf
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprIf { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprIfPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum Condition<'db> {
    Let(ConditionLet<'db>),
    Expr(ConditionExpr<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ConditionPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ConditionPtr<'db> {
    type SyntaxNode = Condition<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        Condition::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ConditionPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ConditionPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ConditionLetPtr<'db>> for ConditionPtr<'db> {
    fn from(value: ConditionLetPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ConditionExprPtr<'db>> for ConditionPtr<'db> {
    fn from(value: ConditionExprPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ConditionLetGreen<'db>> for ConditionGreen<'db> {
    fn from(value: ConditionLetGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ConditionExprGreen<'db>> for ConditionGreen<'db> {
    fn from(value: ConditionExprGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ConditionGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Condition<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ConditionPtr<'db>;
    type Green = ConditionGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ConditionLet => Condition::Let(ConditionLet::from_syntax_node(db, node)),
            SyntaxKind::ConditionExpr => Condition::Expr(ConditionExpr::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Condition"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ConditionLet => {
                Some(Condition::Let(ConditionLet::from_syntax_node(db, node)))
            }
            SyntaxKind::ConditionExpr => {
                Some(Condition::Expr(ConditionExpr::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            Condition::Let(x) => x.as_syntax_node(),
            Condition::Expr(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ConditionPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> Condition<'db> {
    /// Checks if a kind of a variant of [Condition].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::ConditionLet | SyntaxKind::ConditionExpr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ConditionLet<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ConditionLet<'db> {
    pub const INDEX_LET_KW: usize = 0;
    pub const INDEX_PATTERNS: usize = 1;
    pub const INDEX_EQ: usize = 2;
    pub const INDEX_EXPR: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        let_kw: TerminalLetGreen<'db>,
        patterns: PatternListOrGreen<'db>,
        eq: TerminalEqGreen<'db>,
        expr: ExprGreen<'db>,
    ) -> ConditionLetGreen<'db> {
        let children: Vec<GreenId> = vec![let_kw.0, patterns.0, eq.0, expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ConditionLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ConditionLet,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ConditionLet<'db> {
    pub fn let_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalLet<'db> {
        TerminalLet::from_syntax_node(db, self.children[0])
    }
    pub fn patterns(&self, db: &'db dyn SyntaxGroup) -> PatternListOr<'db> {
        PatternListOr::from_syntax_node(db, self.children[1])
    }
    pub fn eq(&self, db: &'db dyn SyntaxGroup) -> TerminalEq<'db> {
        TerminalEq::from_syntax_node(db, self.children[2])
    }
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ConditionLetPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ConditionLetPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ConditionLetPtr<'db> {
    type SyntaxNode = ConditionLet<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ConditionLet<'db> {
        ConditionLet::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ConditionLetPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ConditionLetPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ConditionLetGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ConditionLet<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ConditionLet);
    type StablePtr = ConditionLetPtr<'db>;
    type Green = ConditionLetGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ConditionLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ConditionLet,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLet::missing(db).0,
                        PatternListOr::missing(db).0,
                        TerminalEq::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ConditionLet,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ConditionLet
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ConditionLet { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ConditionLetPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ConditionExpr<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ConditionExpr<'db> {
    pub const INDEX_EXPR: usize = 0;
    pub fn new_green(db: &'db dyn SyntaxGroup, expr: ExprGreen<'db>) -> ConditionExprGreen<'db> {
        let children: Vec<GreenId> = vec![expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ConditionExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ConditionExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ConditionExpr<'db> {
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ConditionExprPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ConditionExprPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ConditionExprPtr<'db> {
    type SyntaxNode = ConditionExpr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ConditionExpr<'db> {
        ConditionExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ConditionExprPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ConditionExprPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ConditionExprGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ConditionExpr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ConditionExpr);
    type StablePtr = ConditionExprPtr<'db>;
    type Green = ConditionExprGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ConditionExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ConditionExpr,
                details: GreenNodeDetails::Node {
                    children: vec![Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ConditionExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ConditionExpr
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ConditionExpr {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ConditionExprPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum BlockOrIf<'db> {
    Block(ExprBlock<'db>),
    If(ExprIf<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BlockOrIfPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for BlockOrIfPtr<'db> {
    type SyntaxNode = BlockOrIf<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        BlockOrIf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<BlockOrIfPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: BlockOrIfPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ExprBlockPtr<'db>> for BlockOrIfPtr<'db> {
    fn from(value: ExprBlockPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprIfPtr<'db>> for BlockOrIfPtr<'db> {
    fn from(value: ExprIfPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprBlockGreen<'db>> for BlockOrIfGreen<'db> {
    fn from(value: ExprBlockGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprIfGreen<'db>> for BlockOrIfGreen<'db> {
    fn from(value: ExprIfGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BlockOrIfGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for BlockOrIf<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = BlockOrIfPtr<'db>;
    type Green = BlockOrIfGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprBlock => BlockOrIf::Block(ExprBlock::from_syntax_node(db, node)),
            SyntaxKind::ExprIf => BlockOrIf::If(ExprIf::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "BlockOrIf"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprBlock => Some(BlockOrIf::Block(ExprBlock::from_syntax_node(db, node))),
            SyntaxKind::ExprIf => Some(BlockOrIf::If(ExprIf::from_syntax_node(db, node))),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            BlockOrIf::Block(x) => x.as_syntax_node(),
            BlockOrIf::If(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        BlockOrIfPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> BlockOrIf<'db> {
    /// Checks if a kind of a variant of [BlockOrIf].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::ExprBlock | SyntaxKind::ExprIf)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprLoop<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprLoop<'db> {
    pub const INDEX_LOOP_KW: usize = 0;
    pub const INDEX_BODY: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        loop_kw: TerminalLoopGreen<'db>,
        body: ExprBlockGreen<'db>,
    ) -> ExprLoopGreen<'db> {
        let children: Vec<GreenId> = vec![loop_kw.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprLoop,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprLoop<'db> {
    pub fn loop_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalLoop<'db> {
        TerminalLoop::from_syntax_node(db, self.children[0])
    }
    pub fn body(&self, db: &'db dyn SyntaxGroup) -> ExprBlock<'db> {
        ExprBlock::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprLoopPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprLoopPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprLoopPtr<'db> {
    type SyntaxNode = ExprLoop<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprLoop<'db> {
        ExprLoop::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprLoopPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprLoopPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprLoopGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprLoop<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprLoop);
    type StablePtr = ExprLoopPtr<'db>;
    type Green = ExprLoopGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprLoop,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalLoop::missing(db).0, ExprBlock::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprLoop,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprLoop
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprLoop { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprLoopPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprWhile<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprWhile<'db> {
    pub const INDEX_WHILE_KW: usize = 0;
    pub const INDEX_CONDITION: usize = 1;
    pub const INDEX_BODY: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        while_kw: TerminalWhileGreen<'db>,
        condition: ConditionGreen<'db>,
        body: ExprBlockGreen<'db>,
    ) -> ExprWhileGreen<'db> {
        let children: Vec<GreenId> = vec![while_kw.0, condition.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprWhile,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprWhile<'db> {
    pub fn while_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalWhile<'db> {
        TerminalWhile::from_syntax_node(db, self.children[0])
    }
    pub fn condition(&self, db: &'db dyn SyntaxGroup) -> Condition<'db> {
        Condition::from_syntax_node(db, self.children[1])
    }
    pub fn body(&self, db: &'db dyn SyntaxGroup) -> ExprBlock<'db> {
        ExprBlock::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprWhilePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprWhilePtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprWhilePtr<'db> {
    type SyntaxNode = ExprWhile<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprWhile<'db> {
        ExprWhile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprWhilePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprWhilePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprWhileGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprWhile<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprWhile);
    type StablePtr = ExprWhilePtr<'db>;
    type Green = ExprWhileGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprWhile,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalWhile::missing(db).0,
                        Condition::missing(db).0,
                        ExprBlock::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprWhile,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprWhile
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprWhile { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprWhilePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprFor<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprFor<'db> {
    pub const INDEX_FOR_KW: usize = 0;
    pub const INDEX_PATTERN: usize = 1;
    pub const INDEX_IDENTIFIER: usize = 2;
    pub const INDEX_EXPR: usize = 3;
    pub const INDEX_BODY: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        for_kw: TerminalForGreen<'db>,
        pattern: PatternGreen<'db>,
        identifier: TerminalIdentifierGreen<'db>,
        expr: ExprGreen<'db>,
        body: ExprBlockGreen<'db>,
    ) -> ExprForGreen<'db> {
        let children: Vec<GreenId> = vec![for_kw.0, pattern.0, identifier.0, expr.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFor,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprFor<'db> {
    pub fn for_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalFor<'db> {
        TerminalFor::from_syntax_node(db, self.children[0])
    }
    pub fn pattern(&self, db: &'db dyn SyntaxGroup) -> Pattern<'db> {
        Pattern::from_syntax_node(db, self.children[1])
    }
    pub fn identifier(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[2])
    }
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[3])
    }
    pub fn body(&self, db: &'db dyn SyntaxGroup) -> ExprBlock<'db> {
        ExprBlock::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprForPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprForPtr<'db> {
    pub fn pattern_green(self, db: &'db dyn SyntaxGroup) -> PatternGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            PatternGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn identifier_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[1])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ExprForPtr<'db> {
    type SyntaxNode = ExprFor<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprFor<'db> {
        ExprFor::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprForPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprForPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprForGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprFor<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprFor);
    type StablePtr = ExprForPtr<'db>;
    type Green = ExprForGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFor,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalFor::missing(db).0,
                        Pattern::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        Expr::missing(db).0,
                        ExprBlock::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprFor,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprFor
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprFor { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprForPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ElseClause<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ElseClause<'db> {
    pub const INDEX_ELSE_KW: usize = 0;
    pub const INDEX_ELSE_BLOCK_OR_IF: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        else_kw: TerminalElseGreen<'db>,
        else_block_or_if: BlockOrIfGreen<'db>,
    ) -> ElseClauseGreen<'db> {
        let children: Vec<GreenId> = vec![else_kw.0, else_block_or_if.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ElseClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ElseClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ElseClause<'db> {
    pub fn else_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalElse<'db> {
        TerminalElse::from_syntax_node(db, self.children[0])
    }
    pub fn else_block_or_if(&self, db: &'db dyn SyntaxGroup) -> BlockOrIf<'db> {
        BlockOrIf::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ElseClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ElseClausePtr<'db> {}
impl<'db> TypedStablePtr<'db> for ElseClausePtr<'db> {
    type SyntaxNode = ElseClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ElseClause<'db> {
        ElseClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ElseClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ElseClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ElseClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ElseClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ElseClause);
    type StablePtr = ElseClausePtr<'db>;
    type Green = ElseClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ElseClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ElseClause,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalElse::missing(db).0, BlockOrIf::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ElseClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ElseClause
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ElseClause { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ElseClausePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionElseClause<'db> {
    Empty(OptionElseClauseEmpty<'db>),
    ElseClause(ElseClause<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionElseClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionElseClausePtr<'db> {
    type SyntaxNode = OptionElseClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionElseClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionElseClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionElseClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionElseClauseEmptyPtr<'db>> for OptionElseClausePtr<'db> {
    fn from(value: OptionElseClauseEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ElseClausePtr<'db>> for OptionElseClausePtr<'db> {
    fn from(value: ElseClausePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionElseClauseEmptyGreen<'db>> for OptionElseClauseGreen<'db> {
    fn from(value: OptionElseClauseEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ElseClauseGreen<'db>> for OptionElseClauseGreen<'db> {
    fn from(value: ElseClauseGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionElseClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionElseClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionElseClausePtr<'db>;
    type Green = OptionElseClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionElseClauseEmpty => {
                OptionElseClause::Empty(OptionElseClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::ElseClause => {
                OptionElseClause::ElseClause(ElseClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionElseClause"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionElseClauseEmpty => {
                Some(OptionElseClause::Empty(OptionElseClauseEmpty::from_syntax_node(db, node)))
            }
            SyntaxKind::ElseClause => {
                Some(OptionElseClause::ElseClause(ElseClause::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionElseClause::Empty(x) => x.as_syntax_node(),
            OptionElseClause::ElseClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionElseClausePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionElseClause<'db> {
    /// Checks if a kind of a variant of [OptionElseClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionElseClauseEmpty | SyntaxKind::ElseClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionElseClauseEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionElseClauseEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionElseClauseEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionElseClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionElseClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionElseClauseEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionElseClauseEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionElseClauseEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionElseClauseEmptyPtr<'db> {
    type SyntaxNode = OptionElseClauseEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionElseClauseEmpty<'db> {
        OptionElseClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionElseClauseEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionElseClauseEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionElseClauseEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionElseClauseEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionElseClauseEmpty);
    type StablePtr = OptionElseClauseEmptyPtr<'db>;
    type Green = OptionElseClauseEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionElseClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionElseClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionElseClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionElseClauseEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionElseClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionElseClauseEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprErrorPropagate<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprErrorPropagate<'db> {
    pub const INDEX_EXPR: usize = 0;
    pub const INDEX_OP: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        expr: ExprGreen<'db>,
        op: TerminalQuestionMarkGreen<'db>,
    ) -> ExprErrorPropagateGreen<'db> {
        let children: Vec<GreenId> = vec![expr.0, op.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprErrorPropagateGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprErrorPropagate,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprErrorPropagate<'db> {
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[0])
    }
    pub fn op(&self, db: &'db dyn SyntaxGroup) -> TerminalQuestionMark<'db> {
        TerminalQuestionMark::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprErrorPropagatePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprErrorPropagatePtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprErrorPropagatePtr<'db> {
    type SyntaxNode = ExprErrorPropagate<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprErrorPropagate<'db> {
        ExprErrorPropagate::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprErrorPropagatePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprErrorPropagatePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprErrorPropagateGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprErrorPropagate<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprErrorPropagate);
    type StablePtr = ExprErrorPropagatePtr<'db>;
    type Green = ExprErrorPropagateGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprErrorPropagateGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprErrorPropagate,
                details: GreenNodeDetails::Node {
                    children: vec![Expr::missing(db).0, TerminalQuestionMark::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprErrorPropagate,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprErrorPropagate
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprErrorPropagate {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprErrorPropagatePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprIndexed<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprIndexed<'db> {
    pub const INDEX_EXPR: usize = 0;
    pub const INDEX_LBRACK: usize = 1;
    pub const INDEX_INDEX_EXPR: usize = 2;
    pub const INDEX_RBRACK: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        expr: ExprGreen<'db>,
        lbrack: TerminalLBrackGreen<'db>,
        index_expr: ExprGreen<'db>,
        rbrack: TerminalRBrackGreen<'db>,
    ) -> ExprIndexedGreen<'db> {
        let children: Vec<GreenId> = vec![expr.0, lbrack.0, index_expr.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprIndexedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprIndexed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprIndexed<'db> {
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[0])
    }
    pub fn lbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrack<'db> {
        TerminalLBrack::from_syntax_node(db, self.children[1])
    }
    pub fn index_expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[2])
    }
    pub fn rbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrack<'db> {
        TerminalRBrack::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprIndexedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprIndexedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprIndexedPtr<'db> {
    type SyntaxNode = ExprIndexed<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprIndexed<'db> {
        ExprIndexed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprIndexedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprIndexedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprIndexedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprIndexed<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprIndexed);
    type StablePtr = ExprIndexedPtr<'db>;
    type Green = ExprIndexedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprIndexedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprIndexed,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Expr::missing(db).0,
                        TerminalLBrack::missing(db).0,
                        Expr::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprIndexed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprIndexed
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprIndexed { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprIndexedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprFixedSizeArray<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprFixedSizeArray<'db> {
    pub const INDEX_LBRACK: usize = 0;
    pub const INDEX_EXPRS: usize = 1;
    pub const INDEX_SIZE: usize = 2;
    pub const INDEX_RBRACK: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrack: TerminalLBrackGreen<'db>,
        exprs: ExprListGreen<'db>,
        size: OptionFixedSizeArraySizeGreen<'db>,
        rbrack: TerminalRBrackGreen<'db>,
    ) -> ExprFixedSizeArrayGreen<'db> {
        let children: Vec<GreenId> = vec![lbrack.0, exprs.0, size.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprFixedSizeArrayGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFixedSizeArray,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprFixedSizeArray<'db> {
    pub fn lbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrack<'db> {
        TerminalLBrack::from_syntax_node(db, self.children[0])
    }
    pub fn exprs(&self, db: &'db dyn SyntaxGroup) -> ExprList<'db> {
        ExprList::from_syntax_node(db, self.children[1])
    }
    pub fn size(&self, db: &'db dyn SyntaxGroup) -> OptionFixedSizeArraySize<'db> {
        OptionFixedSizeArraySize::from_syntax_node(db, self.children[2])
    }
    pub fn rbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrack<'db> {
        TerminalRBrack::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprFixedSizeArrayPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprFixedSizeArrayPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprFixedSizeArrayPtr<'db> {
    type SyntaxNode = ExprFixedSizeArray<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprFixedSizeArray<'db> {
        ExprFixedSizeArray::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprFixedSizeArrayPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprFixedSizeArrayPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprFixedSizeArrayGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprFixedSizeArray<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprFixedSizeArray);
    type StablePtr = ExprFixedSizeArrayPtr<'db>;
    type Green = ExprFixedSizeArrayGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprFixedSizeArrayGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFixedSizeArray,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrack::missing(db).0,
                        ExprList::missing(db).0,
                        OptionFixedSizeArraySize::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprFixedSizeArray,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprFixedSizeArray
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprFixedSizeArray {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprFixedSizeArrayPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct FixedSizeArraySize<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> FixedSizeArraySize<'db> {
    pub const INDEX_SEMICOLON: usize = 0;
    pub const INDEX_SIZE: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        semicolon: TerminalSemicolonGreen<'db>,
        size: ExprGreen<'db>,
    ) -> FixedSizeArraySizeGreen<'db> {
        let children: Vec<GreenId> = vec![semicolon.0, size.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        FixedSizeArraySizeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FixedSizeArraySize,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> FixedSizeArraySize<'db> {
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[0])
    }
    pub fn size(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct FixedSizeArraySizePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> FixedSizeArraySizePtr<'db> {}
impl<'db> TypedStablePtr<'db> for FixedSizeArraySizePtr<'db> {
    type SyntaxNode = FixedSizeArraySize<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> FixedSizeArraySize<'db> {
        FixedSizeArraySize::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<FixedSizeArraySizePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: FixedSizeArraySizePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct FixedSizeArraySizeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for FixedSizeArraySize<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::FixedSizeArraySize);
    type StablePtr = FixedSizeArraySizePtr<'db>;
    type Green = FixedSizeArraySizeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        FixedSizeArraySizeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FixedSizeArraySize,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalSemicolon::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::FixedSizeArraySize,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::FixedSizeArraySize
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::FixedSizeArraySize {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        FixedSizeArraySizePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionFixedSizeArraySize<'db> {
    Empty(OptionFixedSizeArraySizeEmpty<'db>),
    FixedSizeArraySize(FixedSizeArraySize<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionFixedSizeArraySizePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionFixedSizeArraySizePtr<'db> {
    type SyntaxNode = OptionFixedSizeArraySize<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionFixedSizeArraySize::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionFixedSizeArraySizePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionFixedSizeArraySizePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionFixedSizeArraySizeEmptyPtr<'db>> for OptionFixedSizeArraySizePtr<'db> {
    fn from(value: OptionFixedSizeArraySizeEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<FixedSizeArraySizePtr<'db>> for OptionFixedSizeArraySizePtr<'db> {
    fn from(value: FixedSizeArraySizePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionFixedSizeArraySizeEmptyGreen<'db>> for OptionFixedSizeArraySizeGreen<'db> {
    fn from(value: OptionFixedSizeArraySizeEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<FixedSizeArraySizeGreen<'db>> for OptionFixedSizeArraySizeGreen<'db> {
    fn from(value: FixedSizeArraySizeGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionFixedSizeArraySizeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionFixedSizeArraySize<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionFixedSizeArraySizePtr<'db>;
    type Green = OptionFixedSizeArraySizeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionFixedSizeArraySizeEmpty => OptionFixedSizeArraySize::Empty(
                OptionFixedSizeArraySizeEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::FixedSizeArraySize => OptionFixedSizeArraySize::FixedSizeArraySize(
                FixedSizeArraySize::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionFixedSizeArraySize"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionFixedSizeArraySizeEmpty => Some(OptionFixedSizeArraySize::Empty(
                OptionFixedSizeArraySizeEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::FixedSizeArraySize => Some(OptionFixedSizeArraySize::FixedSizeArraySize(
                FixedSizeArraySize::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionFixedSizeArraySize::Empty(x) => x.as_syntax_node(),
            OptionFixedSizeArraySize::FixedSizeArraySize(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionFixedSizeArraySizePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionFixedSizeArraySize<'db> {
    /// Checks if a kind of a variant of [OptionFixedSizeArraySize].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionFixedSizeArraySizeEmpty | SyntaxKind::FixedSizeArraySize)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionFixedSizeArraySizeEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionFixedSizeArraySizeEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionFixedSizeArraySizeEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionFixedSizeArraySizeEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionFixedSizeArraySizeEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionFixedSizeArraySizeEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionFixedSizeArraySizeEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionFixedSizeArraySizeEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionFixedSizeArraySizeEmptyPtr<'db> {
    type SyntaxNode = OptionFixedSizeArraySizeEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionFixedSizeArraySizeEmpty<'db> {
        OptionFixedSizeArraySizeEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionFixedSizeArraySizeEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionFixedSizeArraySizeEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionFixedSizeArraySizeEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionFixedSizeArraySizeEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionFixedSizeArraySizeEmpty);
    type StablePtr = OptionFixedSizeArraySizeEmptyPtr<'db>;
    type Green = OptionFixedSizeArraySizeEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionFixedSizeArraySizeEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionFixedSizeArraySizeEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionFixedSizeArraySizeEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionFixedSizeArraySizeEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionFixedSizeArraySizeEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionFixedSizeArraySizeEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprClosure<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprClosure<'db> {
    pub const INDEX_WRAPPER: usize = 0;
    pub const INDEX_RET_TY: usize = 1;
    pub const INDEX_OPTIONAL_NO_PANIC: usize = 2;
    pub const INDEX_EXPR: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        wrapper: ClosureParamWrapperGreen<'db>,
        ret_ty: OptionReturnTypeClauseGreen<'db>,
        optional_no_panic: OptionTerminalNoPanicGreen<'db>,
        expr: ExprGreen<'db>,
    ) -> ExprClosureGreen<'db> {
        let children: Vec<GreenId> = vec![wrapper.0, ret_ty.0, optional_no_panic.0, expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprClosureGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprClosure,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprClosure<'db> {
    pub fn wrapper(&self, db: &'db dyn SyntaxGroup) -> ClosureParamWrapper<'db> {
        ClosureParamWrapper::from_syntax_node(db, self.children[0])
    }
    pub fn ret_ty(&self, db: &'db dyn SyntaxGroup) -> OptionReturnTypeClause<'db> {
        OptionReturnTypeClause::from_syntax_node(db, self.children[1])
    }
    pub fn optional_no_panic(&self, db: &'db dyn SyntaxGroup) -> OptionTerminalNoPanic<'db> {
        OptionTerminalNoPanic::from_syntax_node(db, self.children[2])
    }
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprClosurePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprClosurePtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprClosurePtr<'db> {
    type SyntaxNode = ExprClosure<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprClosure<'db> {
        ExprClosure::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprClosurePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprClosurePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprClosureGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprClosure<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprClosure);
    type StablePtr = ExprClosurePtr<'db>;
    type Green = ExprClosureGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprClosureGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprClosure,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ClosureParamWrapper::missing(db).0,
                        OptionReturnTypeClause::missing(db).0,
                        OptionTerminalNoPanic::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprClosure,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprClosure
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprClosure { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprClosurePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum ClosureParamWrapper<'db> {
    Nullary(TerminalOrOr<'db>),
    NAry(ClosureParamWrapperNAry<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ClosureParamWrapperPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ClosureParamWrapperPtr<'db> {
    type SyntaxNode = ClosureParamWrapper<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        ClosureParamWrapper::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ClosureParamWrapperPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ClosureParamWrapperPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TerminalOrOrPtr<'db>> for ClosureParamWrapperPtr<'db> {
    fn from(value: TerminalOrOrPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ClosureParamWrapperNAryPtr<'db>> for ClosureParamWrapperPtr<'db> {
    fn from(value: ClosureParamWrapperNAryPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOrOrGreen<'db>> for ClosureParamWrapperGreen<'db> {
    fn from(value: TerminalOrOrGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ClosureParamWrapperNAryGreen<'db>> for ClosureParamWrapperGreen<'db> {
    fn from(value: ClosureParamWrapperNAryGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ClosureParamWrapperGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ClosureParamWrapper<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ClosureParamWrapperPtr<'db>;
    type Green = ClosureParamWrapperGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalOrOr => {
                ClosureParamWrapper::Nullary(TerminalOrOr::from_syntax_node(db, node))
            }
            SyntaxKind::ClosureParamWrapperNAry => {
                ClosureParamWrapper::NAry(ClosureParamWrapperNAry::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "ClosureParamWrapper"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalOrOr => {
                Some(ClosureParamWrapper::Nullary(TerminalOrOr::from_syntax_node(db, node)))
            }
            SyntaxKind::ClosureParamWrapperNAry => {
                Some(ClosureParamWrapper::NAry(ClosureParamWrapperNAry::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            ClosureParamWrapper::Nullary(x) => x.as_syntax_node(),
            ClosureParamWrapper::NAry(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ClosureParamWrapperPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> ClosureParamWrapper<'db> {
    /// Checks if a kind of a variant of [ClosureParamWrapper].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::TerminalOrOr | SyntaxKind::ClosureParamWrapperNAry)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ClosureParamWrapperNAry<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ClosureParamWrapperNAry<'db> {
    pub const INDEX_LEFTOR: usize = 0;
    pub const INDEX_PARAMS: usize = 1;
    pub const INDEX_RIGHTOR: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        leftor: TerminalOrGreen<'db>,
        params: ParamListGreen<'db>,
        rightor: TerminalOrGreen<'db>,
    ) -> ClosureParamWrapperNAryGreen<'db> {
        let children: Vec<GreenId> = vec![leftor.0, params.0, rightor.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ClosureParamWrapperNAryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ClosureParamWrapperNAry,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ClosureParamWrapperNAry<'db> {
    pub fn leftor(&self, db: &'db dyn SyntaxGroup) -> TerminalOr<'db> {
        TerminalOr::from_syntax_node(db, self.children[0])
    }
    pub fn params(&self, db: &'db dyn SyntaxGroup) -> ParamList<'db> {
        ParamList::from_syntax_node(db, self.children[1])
    }
    pub fn rightor(&self, db: &'db dyn SyntaxGroup) -> TerminalOr<'db> {
        TerminalOr::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ClosureParamWrapperNAryPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ClosureParamWrapperNAryPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ClosureParamWrapperNAryPtr<'db> {
    type SyntaxNode = ClosureParamWrapperNAry<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ClosureParamWrapperNAry<'db> {
        ClosureParamWrapperNAry::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ClosureParamWrapperNAryPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ClosureParamWrapperNAryPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ClosureParamWrapperNAryGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ClosureParamWrapperNAry<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ClosureParamWrapperNAry);
    type StablePtr = ClosureParamWrapperNAryPtr<'db>;
    type Green = ClosureParamWrapperNAryGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ClosureParamWrapperNAryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ClosureParamWrapperNAry,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalOr::missing(db).0,
                        ParamList::missing(db).0,
                        TerminalOr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ClosureParamWrapperNAry,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ClosureParamWrapperNAry
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ClosureParamWrapperNAry {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ClosureParamWrapperNAryPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprPlaceholder<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprPlaceholder<'db> {
    pub const INDEX_DOLLAR: usize = 0;
    pub const INDEX_PATH: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        dollar: TerminalDollarGreen<'db>,
        path: ExprPathGreen<'db>,
    ) -> ExprPlaceholderGreen<'db> {
        let children: Vec<GreenId> = vec![dollar.0, path.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprPlaceholderGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprPlaceholder,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprPlaceholder<'db> {
    pub fn dollar(&self, db: &'db dyn SyntaxGroup) -> TerminalDollar<'db> {
        TerminalDollar::from_syntax_node(db, self.children[0])
    }
    pub fn path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprPlaceholderPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprPlaceholderPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprPlaceholderPtr<'db> {
    type SyntaxNode = ExprPlaceholder<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprPlaceholder<'db> {
        ExprPlaceholder::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprPlaceholderPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprPlaceholderPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprPlaceholderGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprPlaceholder<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprPlaceholder);
    type StablePtr = ExprPlaceholderPtr<'db>;
    type Green = ExprPlaceholderGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprPlaceholderGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprPlaceholder,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalDollar::missing(db).0, ExprPath::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprPlaceholder,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprPlaceholder
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprPlaceholder {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprPlaceholderPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StructArgExpr<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StructArgExpr<'db> {
    pub const INDEX_COLON: usize = 0;
    pub const INDEX_EXPR: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        colon: TerminalColonGreen<'db>,
        expr: ExprGreen<'db>,
    ) -> StructArgExprGreen<'db> {
        let children: Vec<GreenId> = vec![colon.0, expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StructArgExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StructArgExpr<'db> {
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[0])
    }
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgExprPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StructArgExprPtr<'db> {}
impl<'db> TypedStablePtr<'db> for StructArgExprPtr<'db> {
    type SyntaxNode = StructArgExpr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StructArgExpr<'db> {
        StructArgExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StructArgExprPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StructArgExprPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgExprGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StructArgExpr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgExpr);
    type StablePtr = StructArgExprPtr<'db>;
    type Green = StructArgExprGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StructArgExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgExpr,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalColon::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgExpr
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StructArgExpr {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StructArgExprPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionStructArgExpr<'db> {
    Empty(OptionStructArgExprEmpty<'db>),
    StructArgExpr(StructArgExpr<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionStructArgExprPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionStructArgExprPtr<'db> {
    type SyntaxNode = OptionStructArgExpr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionStructArgExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionStructArgExprPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionStructArgExprPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionStructArgExprEmptyPtr<'db>> for OptionStructArgExprPtr<'db> {
    fn from(value: OptionStructArgExprEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StructArgExprPtr<'db>> for OptionStructArgExprPtr<'db> {
    fn from(value: StructArgExprPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionStructArgExprEmptyGreen<'db>> for OptionStructArgExprGreen<'db> {
    fn from(value: OptionStructArgExprEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StructArgExprGreen<'db>> for OptionStructArgExprGreen<'db> {
    fn from(value: StructArgExprGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionStructArgExprGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionStructArgExpr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionStructArgExprPtr<'db>;
    type Green = OptionStructArgExprGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionStructArgExprEmpty => {
                OptionStructArgExpr::Empty(OptionStructArgExprEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::StructArgExpr => {
                OptionStructArgExpr::StructArgExpr(StructArgExpr::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionStructArgExpr"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionStructArgExprEmpty => Some(OptionStructArgExpr::Empty(
                OptionStructArgExprEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::StructArgExpr => {
                Some(OptionStructArgExpr::StructArgExpr(StructArgExpr::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionStructArgExpr::Empty(x) => x.as_syntax_node(),
            OptionStructArgExpr::StructArgExpr(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionStructArgExprPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionStructArgExpr<'db> {
    /// Checks if a kind of a variant of [OptionStructArgExpr].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionStructArgExprEmpty | SyntaxKind::StructArgExpr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionStructArgExprEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionStructArgExprEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionStructArgExprEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionStructArgExprEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionStructArgExprEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionStructArgExprEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionStructArgExprEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionStructArgExprEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionStructArgExprEmptyPtr<'db> {
    type SyntaxNode = OptionStructArgExprEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionStructArgExprEmpty<'db> {
        OptionStructArgExprEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionStructArgExprEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionStructArgExprEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionStructArgExprEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionStructArgExprEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionStructArgExprEmpty);
    type StablePtr = OptionStructArgExprEmptyPtr<'db>;
    type Green = OptionStructArgExprEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionStructArgExprEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionStructArgExprEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionStructArgExprEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionStructArgExprEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionStructArgExprEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionStructArgExprEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StructArgSingle<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StructArgSingle<'db> {
    pub const INDEX_IDENTIFIER: usize = 0;
    pub const INDEX_ARG_EXPR: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        identifier: TerminalIdentifierGreen<'db>,
        arg_expr: OptionStructArgExprGreen<'db>,
    ) -> StructArgSingleGreen<'db> {
        let children: Vec<GreenId> = vec![identifier.0, arg_expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StructArgSingleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgSingle,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StructArgSingle<'db> {
    pub fn identifier(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
    pub fn arg_expr(&self, db: &'db dyn SyntaxGroup) -> OptionStructArgExpr<'db> {
        OptionStructArgExpr::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgSinglePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StructArgSinglePtr<'db> {
    pub fn identifier_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for StructArgSinglePtr<'db> {
    type SyntaxNode = StructArgSingle<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StructArgSingle<'db> {
        StructArgSingle::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StructArgSinglePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StructArgSinglePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgSingleGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StructArgSingle<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgSingle);
    type StablePtr = StructArgSinglePtr<'db>;
    type Green = StructArgSingleGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StructArgSingleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgSingle,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIdentifier::missing(db).0,
                        OptionStructArgExpr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgSingle,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgSingle
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StructArgSingle {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StructArgSinglePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StructArgTail<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StructArgTail<'db> {
    pub const INDEX_DOTDOT: usize = 0;
    pub const INDEX_EXPRESSION: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        dotdot: TerminalDotDotGreen<'db>,
        expression: ExprGreen<'db>,
    ) -> StructArgTailGreen<'db> {
        let children: Vec<GreenId> = vec![dotdot.0, expression.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StructArgTailGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgTail,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StructArgTail<'db> {
    pub fn dotdot(&self, db: &'db dyn SyntaxGroup) -> TerminalDotDot<'db> {
        TerminalDotDot::from_syntax_node(db, self.children[0])
    }
    pub fn expression(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgTailPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StructArgTailPtr<'db> {}
impl<'db> TypedStablePtr<'db> for StructArgTailPtr<'db> {
    type SyntaxNode = StructArgTail<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StructArgTail<'db> {
        StructArgTail::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StructArgTailPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StructArgTailPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgTailGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StructArgTail<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgTail);
    type StablePtr = StructArgTailPtr<'db>;
    type Green = StructArgTailGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StructArgTailGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgTail,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalDotDot::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgTail,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgTail
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StructArgTail {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StructArgTailPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum StructArg<'db> {
    StructArgSingle(StructArgSingle<'db>),
    StructArgTail(StructArgTail<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for StructArgPtr<'db> {
    type SyntaxNode = StructArg<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        StructArg::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StructArgPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StructArgPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<StructArgSinglePtr<'db>> for StructArgPtr<'db> {
    fn from(value: StructArgSinglePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StructArgTailPtr<'db>> for StructArgPtr<'db> {
    fn from(value: StructArgTailPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StructArgSingleGreen<'db>> for StructArgGreen<'db> {
    fn from(value: StructArgSingleGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StructArgTailGreen<'db>> for StructArgGreen<'db> {
    fn from(value: StructArgTailGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StructArg<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = StructArgPtr<'db>;
    type Green = StructArgGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::StructArgSingle => {
                StructArg::StructArgSingle(StructArgSingle::from_syntax_node(db, node))
            }
            SyntaxKind::StructArgTail => {
                StructArg::StructArgTail(StructArgTail::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "StructArg"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::StructArgSingle => {
                Some(StructArg::StructArgSingle(StructArgSingle::from_syntax_node(db, node)))
            }
            SyntaxKind::StructArgTail => {
                Some(StructArg::StructArgTail(StructArgTail::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            StructArg::StructArgSingle(x) => x.as_syntax_node(),
            StructArg::StructArgTail(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StructArgPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> StructArg<'db> {
    /// Checks if a kind of a variant of [StructArg].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::StructArgSingle | SyntaxKind::StructArgTail)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StructArgList<'db>(ElementList<'db, StructArg<'db>, 2>);
impl<'db> Deref for StructArgList<'db> {
    type Target = ElementList<'db, StructArg<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> StructArgList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<StructArgListElementOrSeparatorGreen<'db>>,
    ) -> StructArgListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        StructArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for StructArgListPtr<'db> {
    type SyntaxNode = StructArgList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StructArgList<'db> {
        StructArgList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StructArgListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StructArgListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum StructArgListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(StructArgGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for StructArgListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        StructArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<StructArgGreen<'db>> for StructArgListElementOrSeparatorGreen<'db> {
    fn from(value: StructArgGreen<'db>) -> Self {
        StructArgListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> StructArgListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            StructArgListElementOrSeparatorGreen::Separator(green) => green.0,
            StructArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StructArgListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StructArgList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgList);
    type StablePtr = StructArgListPtr<'db>;
    type Green = StructArgListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StructArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::StructArgList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StructArgListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ArgListBraced<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ArgListBraced<'db> {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen<'db>,
        arguments: ArgListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> ArgListBracedGreen<'db> {
        let children: Vec<GreenId> = vec![lbrace.0, arguments.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgListBracedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListBraced,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ArgListBraced<'db> {
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[0])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> ArgList<'db> {
        ArgList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgListBracedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ArgListBracedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ArgListBracedPtr<'db> {
    type SyntaxNode = ArgListBraced<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ArgListBraced<'db> {
        ArgListBraced::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ArgListBracedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ArgListBracedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgListBracedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ArgListBraced<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgListBraced);
    type StablePtr = ArgListBracedPtr<'db>;
    type Green = ArgListBracedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ArgListBracedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListBraced,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        ArgList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgListBraced,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgListBraced
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgListBraced {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ArgListBracedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ArgListBracketed<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ArgListBracketed<'db> {
    pub const INDEX_LBRACK: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub const INDEX_RBRACK: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrack: TerminalLBrackGreen<'db>,
        arguments: ArgListGreen<'db>,
        rbrack: TerminalRBrackGreen<'db>,
    ) -> ArgListBracketedGreen<'db> {
        let children: Vec<GreenId> = vec![lbrack.0, arguments.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgListBracketedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListBracketed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ArgListBracketed<'db> {
    pub fn lbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrack<'db> {
        TerminalLBrack::from_syntax_node(db, self.children[0])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> ArgList<'db> {
        ArgList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrack<'db> {
        TerminalRBrack::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgListBracketedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ArgListBracketedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ArgListBracketedPtr<'db> {
    type SyntaxNode = ArgListBracketed<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ArgListBracketed<'db> {
        ArgListBracketed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ArgListBracketedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ArgListBracketedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ArgListBracketedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ArgListBracketed<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgListBracketed);
    type StablePtr = ArgListBracketedPtr<'db>;
    type Green = ArgListBracketedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ArgListBracketedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListBracketed,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrack::missing(db).0,
                        ArgList::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgListBracketed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgListBracketed
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgListBracketed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ArgListBracketedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum WrappedArgList<'db> {
    BracketedArgList(ArgListBracketed<'db>),
    ParenthesizedArgList(ArgListParenthesized<'db>),
    BracedArgList(ArgListBraced<'db>),
    Missing(WrappedArgListMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedArgListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for WrappedArgListPtr<'db> {
    type SyntaxNode = WrappedArgList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        WrappedArgList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<WrappedArgListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: WrappedArgListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ArgListBracketedPtr<'db>> for WrappedArgListPtr<'db> {
    fn from(value: ArgListBracketedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgListParenthesizedPtr<'db>> for WrappedArgListPtr<'db> {
    fn from(value: ArgListParenthesizedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgListBracedPtr<'db>> for WrappedArgListPtr<'db> {
    fn from(value: ArgListBracedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<WrappedArgListMissingPtr<'db>> for WrappedArgListPtr<'db> {
    fn from(value: WrappedArgListMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgListBracketedGreen<'db>> for WrappedArgListGreen<'db> {
    fn from(value: ArgListBracketedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgListParenthesizedGreen<'db>> for WrappedArgListGreen<'db> {
    fn from(value: ArgListParenthesizedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ArgListBracedGreen<'db>> for WrappedArgListGreen<'db> {
    fn from(value: ArgListBracedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<WrappedArgListMissingGreen<'db>> for WrappedArgListGreen<'db> {
    fn from(value: WrappedArgListMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedArgListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for WrappedArgList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = WrappedArgListPtr<'db>;
    type Green = WrappedArgListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        WrappedArgListGreen(WrappedArgListMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ArgListBracketed => {
                WrappedArgList::BracketedArgList(ArgListBracketed::from_syntax_node(db, node))
            }
            SyntaxKind::ArgListParenthesized => WrappedArgList::ParenthesizedArgList(
                ArgListParenthesized::from_syntax_node(db, node),
            ),
            SyntaxKind::ArgListBraced => {
                WrappedArgList::BracedArgList(ArgListBraced::from_syntax_node(db, node))
            }
            SyntaxKind::WrappedArgListMissing => {
                WrappedArgList::Missing(WrappedArgListMissing::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "WrappedArgList")
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ArgListBracketed => {
                Some(WrappedArgList::BracketedArgList(ArgListBracketed::from_syntax_node(db, node)))
            }
            SyntaxKind::ArgListParenthesized => Some(WrappedArgList::ParenthesizedArgList(
                ArgListParenthesized::from_syntax_node(db, node),
            )),
            SyntaxKind::ArgListBraced => {
                Some(WrappedArgList::BracedArgList(ArgListBraced::from_syntax_node(db, node)))
            }
            SyntaxKind::WrappedArgListMissing => {
                Some(WrappedArgList::Missing(WrappedArgListMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            WrappedArgList::BracketedArgList(x) => x.as_syntax_node(),
            WrappedArgList::ParenthesizedArgList(x) => x.as_syntax_node(),
            WrappedArgList::BracedArgList(x) => x.as_syntax_node(),
            WrappedArgList::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        WrappedArgListPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> WrappedArgList<'db> {
    /// Checks if a kind of a variant of [WrappedArgList].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ArgListBracketed
                | SyntaxKind::ArgListParenthesized
                | SyntaxKind::ArgListBraced
                | SyntaxKind::WrappedArgListMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct WrappedArgListMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> WrappedArgListMissing<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> WrappedArgListMissingGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        WrappedArgListMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::WrappedArgListMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> WrappedArgListMissing<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedArgListMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> WrappedArgListMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for WrappedArgListMissingPtr<'db> {
    type SyntaxNode = WrappedArgListMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> WrappedArgListMissing<'db> {
        WrappedArgListMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<WrappedArgListMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: WrappedArgListMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedArgListMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for WrappedArgListMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::WrappedArgListMissing);
    type StablePtr = WrappedArgListMissingPtr<'db>;
    type Green = WrappedArgListMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        WrappedArgListMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::WrappedArgListMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::WrappedArgListMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::WrappedArgListMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::WrappedArgListMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        WrappedArgListMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum Pattern<'db> {
    Underscore(TerminalUnderscore<'db>),
    Literal(TerminalLiteralNumber<'db>),
    False(TerminalFalse<'db>),
    True(TerminalTrue<'db>),
    ShortString(TerminalShortString<'db>),
    String(TerminalString<'db>),
    Identifier(PatternIdentifier<'db>),
    Struct(PatternStruct<'db>),
    Tuple(PatternTuple<'db>),
    Enum(PatternEnum<'db>),
    FixedSizeArray(PatternFixedSizeArray<'db>),
    Path(ExprPath<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for PatternPtr<'db> {
    type SyntaxNode = Pattern<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        Pattern::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TerminalUnderscorePtr<'db>> for PatternPtr<'db> {
    fn from(value: TerminalUnderscorePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLiteralNumberPtr<'db>> for PatternPtr<'db> {
    fn from(value: TerminalLiteralNumberPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalFalsePtr<'db>> for PatternPtr<'db> {
    fn from(value: TerminalFalsePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalTruePtr<'db>> for PatternPtr<'db> {
    fn from(value: TerminalTruePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalShortStringPtr<'db>> for PatternPtr<'db> {
    fn from(value: TerminalShortStringPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalStringPtr<'db>> for PatternPtr<'db> {
    fn from(value: TerminalStringPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternIdentifierPtr<'db>> for PatternPtr<'db> {
    fn from(value: PatternIdentifierPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternStructPtr<'db>> for PatternPtr<'db> {
    fn from(value: PatternStructPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternTuplePtr<'db>> for PatternPtr<'db> {
    fn from(value: PatternTuplePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternEnumPtr<'db>> for PatternPtr<'db> {
    fn from(value: PatternEnumPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternFixedSizeArrayPtr<'db>> for PatternPtr<'db> {
    fn from(value: PatternFixedSizeArrayPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprPathPtr<'db>> for PatternPtr<'db> {
    fn from(value: ExprPathPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalUnderscoreGreen<'db>> for PatternGreen<'db> {
    fn from(value: TerminalUnderscoreGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLiteralNumberGreen<'db>> for PatternGreen<'db> {
    fn from(value: TerminalLiteralNumberGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalFalseGreen<'db>> for PatternGreen<'db> {
    fn from(value: TerminalFalseGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalTrueGreen<'db>> for PatternGreen<'db> {
    fn from(value: TerminalTrueGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalShortStringGreen<'db>> for PatternGreen<'db> {
    fn from(value: TerminalShortStringGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalStringGreen<'db>> for PatternGreen<'db> {
    fn from(value: TerminalStringGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternIdentifierGreen<'db>> for PatternGreen<'db> {
    fn from(value: PatternIdentifierGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternStructGreen<'db>> for PatternGreen<'db> {
    fn from(value: PatternStructGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternTupleGreen<'db>> for PatternGreen<'db> {
    fn from(value: PatternTupleGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternEnumGreen<'db>> for PatternGreen<'db> {
    fn from(value: PatternEnumGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternFixedSizeArrayGreen<'db>> for PatternGreen<'db> {
    fn from(value: PatternFixedSizeArrayGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprPathGreen<'db>> for PatternGreen<'db> {
    fn from(value: ExprPathGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Pattern<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = PatternPtr<'db>;
    type Green = PatternGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalUnderscore => {
                Pattern::Underscore(TerminalUnderscore::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLiteralNumber => {
                Pattern::Literal(TerminalLiteralNumber::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalFalse => Pattern::False(TerminalFalse::from_syntax_node(db, node)),
            SyntaxKind::TerminalTrue => Pattern::True(TerminalTrue::from_syntax_node(db, node)),
            SyntaxKind::TerminalShortString => {
                Pattern::ShortString(TerminalShortString::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalString => {
                Pattern::String(TerminalString::from_syntax_node(db, node))
            }
            SyntaxKind::PatternIdentifier => {
                Pattern::Identifier(PatternIdentifier::from_syntax_node(db, node))
            }
            SyntaxKind::PatternStruct => Pattern::Struct(PatternStruct::from_syntax_node(db, node)),
            SyntaxKind::PatternTuple => Pattern::Tuple(PatternTuple::from_syntax_node(db, node)),
            SyntaxKind::PatternEnum => Pattern::Enum(PatternEnum::from_syntax_node(db, node)),
            SyntaxKind::PatternFixedSizeArray => {
                Pattern::FixedSizeArray(PatternFixedSizeArray::from_syntax_node(db, node))
            }
            SyntaxKind::ExprPath => Pattern::Path(ExprPath::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Pattern"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalUnderscore => {
                Some(Pattern::Underscore(TerminalUnderscore::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLiteralNumber => {
                Some(Pattern::Literal(TerminalLiteralNumber::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalFalse => {
                Some(Pattern::False(TerminalFalse::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalTrue => {
                Some(Pattern::True(TerminalTrue::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalShortString => {
                Some(Pattern::ShortString(TerminalShortString::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalString => {
                Some(Pattern::String(TerminalString::from_syntax_node(db, node)))
            }
            SyntaxKind::PatternIdentifier => {
                Some(Pattern::Identifier(PatternIdentifier::from_syntax_node(db, node)))
            }
            SyntaxKind::PatternStruct => {
                Some(Pattern::Struct(PatternStruct::from_syntax_node(db, node)))
            }
            SyntaxKind::PatternTuple => {
                Some(Pattern::Tuple(PatternTuple::from_syntax_node(db, node)))
            }
            SyntaxKind::PatternEnum => Some(Pattern::Enum(PatternEnum::from_syntax_node(db, node))),
            SyntaxKind::PatternFixedSizeArray => {
                Some(Pattern::FixedSizeArray(PatternFixedSizeArray::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprPath => Some(Pattern::Path(ExprPath::from_syntax_node(db, node))),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            Pattern::Underscore(x) => x.as_syntax_node(),
            Pattern::Literal(x) => x.as_syntax_node(),
            Pattern::False(x) => x.as_syntax_node(),
            Pattern::True(x) => x.as_syntax_node(),
            Pattern::ShortString(x) => x.as_syntax_node(),
            Pattern::String(x) => x.as_syntax_node(),
            Pattern::Identifier(x) => x.as_syntax_node(),
            Pattern::Struct(x) => x.as_syntax_node(),
            Pattern::Tuple(x) => x.as_syntax_node(),
            Pattern::Enum(x) => x.as_syntax_node(),
            Pattern::FixedSizeArray(x) => x.as_syntax_node(),
            Pattern::Path(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> Pattern<'db> {
    /// Checks if a kind of a variant of [Pattern].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TerminalUnderscore
                | SyntaxKind::TerminalLiteralNumber
                | SyntaxKind::TerminalFalse
                | SyntaxKind::TerminalTrue
                | SyntaxKind::TerminalShortString
                | SyntaxKind::TerminalString
                | SyntaxKind::PatternIdentifier
                | SyntaxKind::PatternStruct
                | SyntaxKind::PatternTuple
                | SyntaxKind::PatternEnum
                | SyntaxKind::PatternFixedSizeArray
                | SyntaxKind::ExprPath
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PatternIdentifier<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> PatternIdentifier<'db> {
    pub const INDEX_MODIFIERS: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        modifiers: ModifierListGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
    ) -> PatternIdentifierGreen<'db> {
        let children: Vec<GreenId> = vec![modifiers.0, name.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternIdentifier,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> PatternIdentifier<'db> {
    pub fn modifiers(&self, db: &'db dyn SyntaxGroup) -> ModifierList<'db> {
        ModifierList::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternIdentifierPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> PatternIdentifierPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for PatternIdentifierPtr<'db> {
    type SyntaxNode = PatternIdentifier<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PatternIdentifier<'db> {
        PatternIdentifier::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternIdentifierPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternIdentifierPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternIdentifierGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternIdentifier<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternIdentifier);
    type StablePtr = PatternIdentifierPtr<'db>;
    type Green = PatternIdentifierGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PatternIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternIdentifier,
                details: GreenNodeDetails::Node {
                    children: vec![ModifierList::missing(db).0, TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternIdentifier,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternIdentifier
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternIdentifier {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternIdentifierPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PatternStruct<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> PatternStruct<'db> {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_LBRACE: usize = 1;
    pub const INDEX_PARAMS: usize = 2;
    pub const INDEX_RBRACE: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        path: ExprPathGreen<'db>,
        lbrace: TerminalLBraceGreen<'db>,
        params: PatternStructParamListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> PatternStructGreen<'db> {
        let children: Vec<GreenId> = vec![path.0, lbrace.0, params.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStruct,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> PatternStruct<'db> {
    pub fn path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[0])
    }
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[1])
    }
    pub fn params(&self, db: &'db dyn SyntaxGroup) -> PatternStructParamList<'db> {
        PatternStructParamList::from_syntax_node(db, self.children[2])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternStructPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> PatternStructPtr<'db> {}
impl<'db> TypedStablePtr<'db> for PatternStructPtr<'db> {
    type SyntaxNode = PatternStruct<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PatternStruct<'db> {
        PatternStruct::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternStructPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternStructPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternStructGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternStruct<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternStruct);
    type StablePtr = PatternStructPtr<'db>;
    type Green = PatternStructGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PatternStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStruct,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ExprPath::missing(db).0,
                        TerminalLBrace::missing(db).0,
                        PatternStructParamList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternStruct,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternStruct
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternStruct {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternStructPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PatternStructParamList<'db>(ElementList<'db, PatternStructParam<'db>, 2>);
impl<'db> Deref for PatternStructParamList<'db> {
    type Target = ElementList<'db, PatternStructParam<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> PatternStructParamList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<PatternStructParamListElementOrSeparatorGreen<'db>>,
    ) -> PatternStructParamListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        PatternStructParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStructParamList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternStructParamListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for PatternStructParamListPtr<'db> {
    type SyntaxNode = PatternStructParamList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PatternStructParamList<'db> {
        PatternStructParamList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternStructParamListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternStructParamListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum PatternStructParamListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(PatternStructParamGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for PatternStructParamListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        PatternStructParamListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<PatternStructParamGreen<'db>>
    for PatternStructParamListElementOrSeparatorGreen<'db>
{
    fn from(value: PatternStructParamGreen<'db>) -> Self {
        PatternStructParamListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> PatternStructParamListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            PatternStructParamListElementOrSeparatorGreen::Separator(green) => green.0,
            PatternStructParamListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternStructParamListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternStructParamList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternStructParamList);
    type StablePtr = PatternStructParamListPtr<'db>;
    type Green = PatternStructParamListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PatternStructParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStructParamList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::PatternStructParamList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternStructParamListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PatternTuple<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> PatternTuple<'db> {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_PATTERNS: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lparen: TerminalLParenGreen<'db>,
        patterns: PatternListGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
    ) -> PatternTupleGreen<'db> {
        let children: Vec<GreenId> = vec![lparen.0, patterns.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternTupleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternTuple,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> PatternTuple<'db> {
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[0])
    }
    pub fn patterns(&self, db: &'db dyn SyntaxGroup) -> PatternList<'db> {
        PatternList::from_syntax_node(db, self.children[1])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternTuplePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> PatternTuplePtr<'db> {}
impl<'db> TypedStablePtr<'db> for PatternTuplePtr<'db> {
    type SyntaxNode = PatternTuple<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PatternTuple<'db> {
        PatternTuple::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternTuplePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternTuplePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternTupleGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternTuple<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternTuple);
    type StablePtr = PatternTuplePtr<'db>;
    type Green = PatternTupleGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PatternTupleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternTuple,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        PatternList::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternTuple,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternTuple
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternTuple { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternTuplePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PatternFixedSizeArray<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> PatternFixedSizeArray<'db> {
    pub const INDEX_LBRACK: usize = 0;
    pub const INDEX_PATTERNS: usize = 1;
    pub const INDEX_RBRACK: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrack: TerminalLBrackGreen<'db>,
        patterns: PatternListGreen<'db>,
        rbrack: TerminalRBrackGreen<'db>,
    ) -> PatternFixedSizeArrayGreen<'db> {
        let children: Vec<GreenId> = vec![lbrack.0, patterns.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternFixedSizeArrayGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternFixedSizeArray,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> PatternFixedSizeArray<'db> {
    pub fn lbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrack<'db> {
        TerminalLBrack::from_syntax_node(db, self.children[0])
    }
    pub fn patterns(&self, db: &'db dyn SyntaxGroup) -> PatternList<'db> {
        PatternList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrack<'db> {
        TerminalRBrack::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternFixedSizeArrayPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> PatternFixedSizeArrayPtr<'db> {}
impl<'db> TypedStablePtr<'db> for PatternFixedSizeArrayPtr<'db> {
    type SyntaxNode = PatternFixedSizeArray<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PatternFixedSizeArray<'db> {
        PatternFixedSizeArray::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternFixedSizeArrayPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternFixedSizeArrayPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternFixedSizeArrayGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternFixedSizeArray<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternFixedSizeArray);
    type StablePtr = PatternFixedSizeArrayPtr<'db>;
    type Green = PatternFixedSizeArrayGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PatternFixedSizeArrayGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternFixedSizeArray,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrack::missing(db).0,
                        PatternList::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternFixedSizeArray,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternFixedSizeArray
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternFixedSizeArray {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternFixedSizeArrayPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PatternList<'db>(ElementList<'db, Pattern<'db>, 2>);
impl<'db> Deref for PatternList<'db> {
    type Target = ElementList<'db, Pattern<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> PatternList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<PatternListElementOrSeparatorGreen<'db>>,
    ) -> PatternListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        PatternListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for PatternListPtr<'db> {
    type SyntaxNode = PatternList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PatternList<'db> {
        PatternList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum PatternListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(PatternGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for PatternListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        PatternListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<PatternGreen<'db>> for PatternListElementOrSeparatorGreen<'db> {
    fn from(value: PatternGreen<'db>) -> Self {
        PatternListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> PatternListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            PatternListElementOrSeparatorGreen::Separator(green) => green.0,
            PatternListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternList);
    type StablePtr = PatternListPtr<'db>;
    type Green = PatternListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PatternListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::PatternList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PatternListOr<'db>(ElementList<'db, Pattern<'db>, 2>);
impl<'db> Deref for PatternListOr<'db> {
    type Target = ElementList<'db, Pattern<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> PatternListOr<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<PatternListOrElementOrSeparatorGreen<'db>>,
    ) -> PatternListOrGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        PatternListOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternListOr,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternListOrPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for PatternListOrPtr<'db> {
    type SyntaxNode = PatternListOr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PatternListOr<'db> {
        PatternListOr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternListOrPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternListOrPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum PatternListOrElementOrSeparatorGreen<'db> {
    Separator(TerminalOrGreen<'db>),
    Element(PatternGreen<'db>),
}
impl<'db> From<TerminalOrGreen<'db>> for PatternListOrElementOrSeparatorGreen<'db> {
    fn from(value: TerminalOrGreen<'db>) -> Self {
        PatternListOrElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<PatternGreen<'db>> for PatternListOrElementOrSeparatorGreen<'db> {
    fn from(value: PatternGreen<'db>) -> Self {
        PatternListOrElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> PatternListOrElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            PatternListOrElementOrSeparatorGreen::Separator(green) => green.0,
            PatternListOrElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternListOrGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternListOr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternListOr);
    type StablePtr = PatternListOrPtr<'db>;
    type Green = PatternListOrGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PatternListOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternListOr,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::PatternListOr {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternListOrPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum PatternStructParam<'db> {
    Single(PatternIdentifier<'db>),
    WithExpr(PatternStructParamWithExpr<'db>),
    Tail(TerminalDotDot<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternStructParamPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for PatternStructParamPtr<'db> {
    type SyntaxNode = PatternStructParam<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        PatternStructParam::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternStructParamPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternStructParamPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<PatternIdentifierPtr<'db>> for PatternStructParamPtr<'db> {
    fn from(value: PatternIdentifierPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternStructParamWithExprPtr<'db>> for PatternStructParamPtr<'db> {
    fn from(value: PatternStructParamWithExprPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotDotPtr<'db>> for PatternStructParamPtr<'db> {
    fn from(value: TerminalDotDotPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternIdentifierGreen<'db>> for PatternStructParamGreen<'db> {
    fn from(value: PatternIdentifierGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternStructParamWithExprGreen<'db>> for PatternStructParamGreen<'db> {
    fn from(value: PatternStructParamWithExprGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotDotGreen<'db>> for PatternStructParamGreen<'db> {
    fn from(value: TerminalDotDotGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternStructParamGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternStructParam<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = PatternStructParamPtr<'db>;
    type Green = PatternStructParamGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::PatternIdentifier => {
                PatternStructParam::Single(PatternIdentifier::from_syntax_node(db, node))
            }
            SyntaxKind::PatternStructParamWithExpr => {
                PatternStructParam::WithExpr(PatternStructParamWithExpr::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDotDot => {
                PatternStructParam::Tail(TerminalDotDot::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "PatternStructParam"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::PatternIdentifier => {
                Some(PatternStructParam::Single(PatternIdentifier::from_syntax_node(db, node)))
            }
            SyntaxKind::PatternStructParamWithExpr => Some(PatternStructParam::WithExpr(
                PatternStructParamWithExpr::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalDotDot => {
                Some(PatternStructParam::Tail(TerminalDotDot::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            PatternStructParam::Single(x) => x.as_syntax_node(),
            PatternStructParam::WithExpr(x) => x.as_syntax_node(),
            PatternStructParam::Tail(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternStructParamPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> PatternStructParam<'db> {
    /// Checks if a kind of a variant of [PatternStructParam].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::PatternIdentifier
                | SyntaxKind::PatternStructParamWithExpr
                | SyntaxKind::TerminalDotDot
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PatternStructParamWithExpr<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> PatternStructParamWithExpr<'db> {
    pub const INDEX_MODIFIERS: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_COLON: usize = 2;
    pub const INDEX_PATTERN: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        modifiers: ModifierListGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        colon: TerminalColonGreen<'db>,
        pattern: PatternGreen<'db>,
    ) -> PatternStructParamWithExprGreen<'db> {
        let children: Vec<GreenId> = vec![modifiers.0, name.0, colon.0, pattern.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternStructParamWithExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStructParamWithExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> PatternStructParamWithExpr<'db> {
    pub fn modifiers(&self, db: &'db dyn SyntaxGroup) -> ModifierList<'db> {
        ModifierList::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[2])
    }
    pub fn pattern(&self, db: &'db dyn SyntaxGroup) -> Pattern<'db> {
        Pattern::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternStructParamWithExprPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> PatternStructParamWithExprPtr<'db> {}
impl<'db> TypedStablePtr<'db> for PatternStructParamWithExprPtr<'db> {
    type SyntaxNode = PatternStructParamWithExpr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PatternStructParamWithExpr<'db> {
        PatternStructParamWithExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternStructParamWithExprPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternStructParamWithExprPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternStructParamWithExprGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternStructParamWithExpr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternStructParamWithExpr);
    type StablePtr = PatternStructParamWithExprPtr<'db>;
    type Green = PatternStructParamWithExprGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PatternStructParamWithExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStructParamWithExpr,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ModifierList::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        Pattern::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternStructParamWithExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternStructParamWithExpr
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternStructParamWithExpr {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternStructParamWithExprPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PatternEnum<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> PatternEnum<'db> {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_PATTERN: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        path: ExprPathGreen<'db>,
        pattern: OptionPatternEnumInnerPatternGreen<'db>,
    ) -> PatternEnumGreen<'db> {
        let children: Vec<GreenId> = vec![path.0, pattern.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternEnum,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> PatternEnum<'db> {
    pub fn path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[0])
    }
    pub fn pattern(&self, db: &'db dyn SyntaxGroup) -> OptionPatternEnumInnerPattern<'db> {
        OptionPatternEnumInnerPattern::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternEnumPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> PatternEnumPtr<'db> {}
impl<'db> TypedStablePtr<'db> for PatternEnumPtr<'db> {
    type SyntaxNode = PatternEnum<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PatternEnum<'db> {
        PatternEnum::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternEnumPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternEnumPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternEnumGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternEnum<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternEnum);
    type StablePtr = PatternEnumPtr<'db>;
    type Green = PatternEnumGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PatternEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternEnum,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ExprPath::missing(db).0,
                        OptionPatternEnumInnerPattern::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternEnum,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternEnum
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternEnum { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternEnumPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct PatternEnumInnerPattern<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> PatternEnumInnerPattern<'db> {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_PATTERN: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lparen: TerminalLParenGreen<'db>,
        pattern: PatternGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
    ) -> PatternEnumInnerPatternGreen<'db> {
        let children: Vec<GreenId> = vec![lparen.0, pattern.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternEnumInnerPatternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternEnumInnerPattern,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> PatternEnumInnerPattern<'db> {
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[0])
    }
    pub fn pattern(&self, db: &'db dyn SyntaxGroup) -> Pattern<'db> {
        Pattern::from_syntax_node(db, self.children[1])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternEnumInnerPatternPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> PatternEnumInnerPatternPtr<'db> {}
impl<'db> TypedStablePtr<'db> for PatternEnumInnerPatternPtr<'db> {
    type SyntaxNode = PatternEnumInnerPattern<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> PatternEnumInnerPattern<'db> {
        PatternEnumInnerPattern::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<PatternEnumInnerPatternPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: PatternEnumInnerPatternPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct PatternEnumInnerPatternGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for PatternEnumInnerPattern<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternEnumInnerPattern);
    type StablePtr = PatternEnumInnerPatternPtr<'db>;
    type Green = PatternEnumInnerPatternGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        PatternEnumInnerPatternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternEnumInnerPattern,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        Pattern::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternEnumInnerPattern,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternEnumInnerPattern
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternEnumInnerPattern {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        PatternEnumInnerPatternPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionPatternEnumInnerPattern<'db> {
    Empty(OptionPatternEnumInnerPatternEmpty<'db>),
    PatternEnumInnerPattern(PatternEnumInnerPattern<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionPatternEnumInnerPatternPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionPatternEnumInnerPatternPtr<'db> {
    type SyntaxNode = OptionPatternEnumInnerPattern<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionPatternEnumInnerPattern::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionPatternEnumInnerPatternPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionPatternEnumInnerPatternPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionPatternEnumInnerPatternEmptyPtr<'db>>
    for OptionPatternEnumInnerPatternPtr<'db>
{
    fn from(value: OptionPatternEnumInnerPatternEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternEnumInnerPatternPtr<'db>> for OptionPatternEnumInnerPatternPtr<'db> {
    fn from(value: PatternEnumInnerPatternPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionPatternEnumInnerPatternEmptyGreen<'db>>
    for OptionPatternEnumInnerPatternGreen<'db>
{
    fn from(value: OptionPatternEnumInnerPatternEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<PatternEnumInnerPatternGreen<'db>> for OptionPatternEnumInnerPatternGreen<'db> {
    fn from(value: PatternEnumInnerPatternGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionPatternEnumInnerPatternGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionPatternEnumInnerPattern<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionPatternEnumInnerPatternPtr<'db>;
    type Green = OptionPatternEnumInnerPatternGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionPatternEnumInnerPatternEmpty => OptionPatternEnumInnerPattern::Empty(
                OptionPatternEnumInnerPatternEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::PatternEnumInnerPattern => {
                OptionPatternEnumInnerPattern::PatternEnumInnerPattern(
                    PatternEnumInnerPattern::from_syntax_node(db, node),
                )
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionPatternEnumInnerPattern"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionPatternEnumInnerPatternEmpty => {
                Some(OptionPatternEnumInnerPattern::Empty(
                    OptionPatternEnumInnerPatternEmpty::from_syntax_node(db, node),
                ))
            }
            SyntaxKind::PatternEnumInnerPattern => {
                Some(OptionPatternEnumInnerPattern::PatternEnumInnerPattern(
                    PatternEnumInnerPattern::from_syntax_node(db, node),
                ))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionPatternEnumInnerPattern::Empty(x) => x.as_syntax_node(),
            OptionPatternEnumInnerPattern::PatternEnumInnerPattern(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionPatternEnumInnerPatternPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionPatternEnumInnerPattern<'db> {
    /// Checks if a kind of a variant of [OptionPatternEnumInnerPattern].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::OptionPatternEnumInnerPatternEmpty | SyntaxKind::PatternEnumInnerPattern
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionPatternEnumInnerPatternEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionPatternEnumInnerPatternEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionPatternEnumInnerPatternEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionPatternEnumInnerPatternEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionPatternEnumInnerPatternEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionPatternEnumInnerPatternEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionPatternEnumInnerPatternEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionPatternEnumInnerPatternEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionPatternEnumInnerPatternEmptyPtr<'db> {
    type SyntaxNode = OptionPatternEnumInnerPatternEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionPatternEnumInnerPatternEmpty<'db> {
        OptionPatternEnumInnerPatternEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionPatternEnumInnerPatternEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionPatternEnumInnerPatternEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionPatternEnumInnerPatternEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionPatternEnumInnerPatternEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionPatternEnumInnerPatternEmpty);
    type StablePtr = OptionPatternEnumInnerPatternEmptyPtr<'db>;
    type Green = OptionPatternEnumInnerPatternEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionPatternEnumInnerPatternEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionPatternEnumInnerPatternEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionPatternEnumInnerPatternEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionPatternEnumInnerPatternEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionPatternEnumInnerPatternEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionPatternEnumInnerPatternEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TypeClause<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TypeClause<'db> {
    pub const INDEX_COLON: usize = 0;
    pub const INDEX_TY: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        colon: TerminalColonGreen<'db>,
        ty: ExprGreen<'db>,
    ) -> TypeClauseGreen<'db> {
        let children: Vec<GreenId> = vec![colon.0, ty.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TypeClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TypeClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TypeClause<'db> {
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[0])
    }
    pub fn ty(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TypeClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypeClausePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TypeClausePtr<'db> {
    type SyntaxNode = TypeClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TypeClause<'db> {
        TypeClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TypeClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TypeClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TypeClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TypeClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TypeClause);
    type StablePtr = TypeClausePtr<'db>;
    type Green = TypeClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TypeClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TypeClause,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalColon::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TypeClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TypeClause
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TypeClause { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TypeClausePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionTypeClause<'db> {
    Empty(OptionTypeClauseEmpty<'db>),
    TypeClause(TypeClause<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTypeClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionTypeClausePtr<'db> {
    type SyntaxNode = OptionTypeClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionTypeClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTypeClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTypeClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionTypeClauseEmptyPtr<'db>> for OptionTypeClausePtr<'db> {
    fn from(value: OptionTypeClauseEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TypeClausePtr<'db>> for OptionTypeClausePtr<'db> {
    fn from(value: TypeClausePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionTypeClauseEmptyGreen<'db>> for OptionTypeClauseGreen<'db> {
    fn from(value: OptionTypeClauseEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TypeClauseGreen<'db>> for OptionTypeClauseGreen<'db> {
    fn from(value: TypeClauseGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTypeClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTypeClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTypeClausePtr<'db>;
    type Green = OptionTypeClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTypeClauseEmpty => {
                OptionTypeClause::Empty(OptionTypeClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::TypeClause => {
                OptionTypeClause::TypeClause(TypeClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTypeClause"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTypeClauseEmpty => {
                Some(OptionTypeClause::Empty(OptionTypeClauseEmpty::from_syntax_node(db, node)))
            }
            SyntaxKind::TypeClause => {
                Some(OptionTypeClause::TypeClause(TypeClause::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionTypeClause::Empty(x) => x.as_syntax_node(),
            OptionTypeClause::TypeClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTypeClausePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionTypeClause<'db> {
    /// Checks if a kind of a variant of [OptionTypeClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTypeClauseEmpty | SyntaxKind::TypeClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionTypeClauseEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionTypeClauseEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionTypeClauseEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTypeClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTypeClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionTypeClauseEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTypeClauseEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionTypeClauseEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionTypeClauseEmptyPtr<'db> {
    type SyntaxNode = OptionTypeClauseEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionTypeClauseEmpty<'db> {
        OptionTypeClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTypeClauseEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTypeClauseEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTypeClauseEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTypeClauseEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTypeClauseEmpty);
    type StablePtr = OptionTypeClauseEmptyPtr<'db>;
    type Green = OptionTypeClauseEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionTypeClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTypeClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTypeClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTypeClauseEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTypeClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTypeClauseEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ReturnTypeClause<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ReturnTypeClause<'db> {
    pub const INDEX_ARROW: usize = 0;
    pub const INDEX_TY: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        arrow: TerminalArrowGreen<'db>,
        ty: ExprGreen<'db>,
    ) -> ReturnTypeClauseGreen<'db> {
        let children: Vec<GreenId> = vec![arrow.0, ty.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ReturnTypeClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ReturnTypeClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ReturnTypeClause<'db> {
    pub fn arrow(&self, db: &'db dyn SyntaxGroup) -> TerminalArrow<'db> {
        TerminalArrow::from_syntax_node(db, self.children[0])
    }
    pub fn ty(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ReturnTypeClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ReturnTypeClausePtr<'db> {}
impl<'db> TypedStablePtr<'db> for ReturnTypeClausePtr<'db> {
    type SyntaxNode = ReturnTypeClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ReturnTypeClause<'db> {
        ReturnTypeClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ReturnTypeClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ReturnTypeClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ReturnTypeClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ReturnTypeClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ReturnTypeClause);
    type StablePtr = ReturnTypeClausePtr<'db>;
    type Green = ReturnTypeClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ReturnTypeClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ReturnTypeClause,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalArrow::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ReturnTypeClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ReturnTypeClause
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ReturnTypeClause {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ReturnTypeClausePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionReturnTypeClause<'db> {
    Empty(OptionReturnTypeClauseEmpty<'db>),
    ReturnTypeClause(ReturnTypeClause<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionReturnTypeClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionReturnTypeClausePtr<'db> {
    type SyntaxNode = OptionReturnTypeClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionReturnTypeClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionReturnTypeClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionReturnTypeClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionReturnTypeClauseEmptyPtr<'db>> for OptionReturnTypeClausePtr<'db> {
    fn from(value: OptionReturnTypeClauseEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ReturnTypeClausePtr<'db>> for OptionReturnTypeClausePtr<'db> {
    fn from(value: ReturnTypeClausePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionReturnTypeClauseEmptyGreen<'db>> for OptionReturnTypeClauseGreen<'db> {
    fn from(value: OptionReturnTypeClauseEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ReturnTypeClauseGreen<'db>> for OptionReturnTypeClauseGreen<'db> {
    fn from(value: ReturnTypeClauseGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionReturnTypeClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionReturnTypeClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionReturnTypeClausePtr<'db>;
    type Green = OptionReturnTypeClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionReturnTypeClauseEmpty => OptionReturnTypeClause::Empty(
                OptionReturnTypeClauseEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::ReturnTypeClause => OptionReturnTypeClause::ReturnTypeClause(
                ReturnTypeClause::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionReturnTypeClause"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionReturnTypeClauseEmpty => Some(OptionReturnTypeClause::Empty(
                OptionReturnTypeClauseEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::ReturnTypeClause => Some(OptionReturnTypeClause::ReturnTypeClause(
                ReturnTypeClause::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionReturnTypeClause::Empty(x) => x.as_syntax_node(),
            OptionReturnTypeClause::ReturnTypeClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionReturnTypeClausePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionReturnTypeClause<'db> {
    /// Checks if a kind of a variant of [OptionReturnTypeClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionReturnTypeClauseEmpty | SyntaxKind::ReturnTypeClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionReturnTypeClauseEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionReturnTypeClauseEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionReturnTypeClauseEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionReturnTypeClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionReturnTypeClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionReturnTypeClauseEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionReturnTypeClauseEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionReturnTypeClauseEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionReturnTypeClauseEmptyPtr<'db> {
    type SyntaxNode = OptionReturnTypeClauseEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionReturnTypeClauseEmpty<'db> {
        OptionReturnTypeClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionReturnTypeClauseEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionReturnTypeClauseEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionReturnTypeClauseEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionReturnTypeClauseEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionReturnTypeClauseEmpty);
    type StablePtr = OptionReturnTypeClauseEmptyPtr<'db>;
    type Green = OptionReturnTypeClauseEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionReturnTypeClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionReturnTypeClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionReturnTypeClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionReturnTypeClauseEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionReturnTypeClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionReturnTypeClauseEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum Statement<'db> {
    Let(StatementLet<'db>),
    Expr(StatementExpr<'db>),
    Continue(StatementContinue<'db>),
    Return(StatementReturn<'db>),
    Break(StatementBreak<'db>),
    Item(StatementItem<'db>),
    Missing(StatementMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for StatementPtr<'db> {
    type SyntaxNode = Statement<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        Statement::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StatementPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StatementPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<StatementLetPtr<'db>> for StatementPtr<'db> {
    fn from(value: StatementLetPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementExprPtr<'db>> for StatementPtr<'db> {
    fn from(value: StatementExprPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementContinuePtr<'db>> for StatementPtr<'db> {
    fn from(value: StatementContinuePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementReturnPtr<'db>> for StatementPtr<'db> {
    fn from(value: StatementReturnPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementBreakPtr<'db>> for StatementPtr<'db> {
    fn from(value: StatementBreakPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementItemPtr<'db>> for StatementPtr<'db> {
    fn from(value: StatementItemPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementMissingPtr<'db>> for StatementPtr<'db> {
    fn from(value: StatementMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementLetGreen<'db>> for StatementGreen<'db> {
    fn from(value: StatementLetGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementExprGreen<'db>> for StatementGreen<'db> {
    fn from(value: StatementExprGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementContinueGreen<'db>> for StatementGreen<'db> {
    fn from(value: StatementContinueGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementReturnGreen<'db>> for StatementGreen<'db> {
    fn from(value: StatementReturnGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementBreakGreen<'db>> for StatementGreen<'db> {
    fn from(value: StatementBreakGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementItemGreen<'db>> for StatementGreen<'db> {
    fn from(value: StatementItemGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<StatementMissingGreen<'db>> for StatementGreen<'db> {
    fn from(value: StatementMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Statement<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = StatementPtr<'db>;
    type Green = StatementGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StatementGreen(StatementMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::StatementLet => Statement::Let(StatementLet::from_syntax_node(db, node)),
            SyntaxKind::StatementExpr => Statement::Expr(StatementExpr::from_syntax_node(db, node)),
            SyntaxKind::StatementContinue => {
                Statement::Continue(StatementContinue::from_syntax_node(db, node))
            }
            SyntaxKind::StatementReturn => {
                Statement::Return(StatementReturn::from_syntax_node(db, node))
            }
            SyntaxKind::StatementBreak => {
                Statement::Break(StatementBreak::from_syntax_node(db, node))
            }
            SyntaxKind::StatementItem => Statement::Item(StatementItem::from_syntax_node(db, node)),
            SyntaxKind::StatementMissing => {
                Statement::Missing(StatementMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Statement"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::StatementLet => {
                Some(Statement::Let(StatementLet::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementExpr => {
                Some(Statement::Expr(StatementExpr::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementContinue => {
                Some(Statement::Continue(StatementContinue::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementReturn => {
                Some(Statement::Return(StatementReturn::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementBreak => {
                Some(Statement::Break(StatementBreak::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementItem => {
                Some(Statement::Item(StatementItem::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementMissing => {
                Some(Statement::Missing(StatementMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            Statement::Let(x) => x.as_syntax_node(),
            Statement::Expr(x) => x.as_syntax_node(),
            Statement::Continue(x) => x.as_syntax_node(),
            Statement::Return(x) => x.as_syntax_node(),
            Statement::Break(x) => x.as_syntax_node(),
            Statement::Item(x) => x.as_syntax_node(),
            Statement::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StatementPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> Statement<'db> {
    /// Checks if a kind of a variant of [Statement].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::StatementLet
                | SyntaxKind::StatementExpr
                | SyntaxKind::StatementContinue
                | SyntaxKind::StatementReturn
                | SyntaxKind::StatementBreak
                | SyntaxKind::StatementItem
                | SyntaxKind::StatementMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StatementList<'db>(ElementList<'db, Statement<'db>, 1>);
impl<'db> Deref for StatementList<'db> {
    type Target = ElementList<'db, Statement<'db>, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> StatementList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<StatementGreen<'db>>,
    ) -> StatementListGreen<'db> {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        StatementListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for StatementListPtr<'db> {
    type SyntaxNode = StatementList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StatementList<'db> {
        StatementList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StatementListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StatementListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StatementList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementList);
    type StablePtr = StatementListPtr<'db>;
    type Green = StatementListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StatementListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::StatementList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StatementListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StatementMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StatementMissing<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> StatementMissingGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StatementMissing<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StatementMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for StatementMissingPtr<'db> {
    type SyntaxNode = StatementMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StatementMissing<'db> {
        StatementMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StatementMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StatementMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StatementMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementMissing);
    type StablePtr = StatementMissingPtr<'db>;
    type Green = StatementMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StatementMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StatementMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StatementLet<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StatementLet<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_LET_KW: usize = 1;
    pub const INDEX_PATTERN: usize = 2;
    pub const INDEX_TYPE_CLAUSE: usize = 3;
    pub const INDEX_EQ: usize = 4;
    pub const INDEX_RHS: usize = 5;
    pub const INDEX_SEMICOLON: usize = 6;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        let_kw: TerminalLetGreen<'db>,
        pattern: PatternGreen<'db>,
        type_clause: OptionTypeClauseGreen<'db>,
        eq: TerminalEqGreen<'db>,
        rhs: ExprGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> StatementLetGreen<'db> {
        let children: Vec<GreenId> =
            vec![attributes.0, let_kw.0, pattern.0, type_clause.0, eq.0, rhs.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementLet,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StatementLet<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn let_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalLet<'db> {
        TerminalLet::from_syntax_node(db, self.children[1])
    }
    pub fn pattern(&self, db: &'db dyn SyntaxGroup) -> Pattern<'db> {
        Pattern::from_syntax_node(db, self.children[2])
    }
    pub fn type_clause(&self, db: &'db dyn SyntaxGroup) -> OptionTypeClause<'db> {
        OptionTypeClause::from_syntax_node(db, self.children[3])
    }
    pub fn eq(&self, db: &'db dyn SyntaxGroup) -> TerminalEq<'db> {
        TerminalEq::from_syntax_node(db, self.children[4])
    }
    pub fn rhs(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[5])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[6])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementLetPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StatementLetPtr<'db> {
    pub fn pattern_green(self, db: &'db dyn SyntaxGroup) -> PatternGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            PatternGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for StatementLetPtr<'db> {
    type SyntaxNode = StatementLet<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StatementLet<'db> {
        StatementLet::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StatementLetPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StatementLetPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementLetGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StatementLet<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementLet);
    type StablePtr = StatementLetPtr<'db>;
    type Green = StatementLetGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StatementLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementLet,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalLet::missing(db).0,
                        Pattern::missing(db).0,
                        OptionTypeClause::missing(db).0,
                        TerminalEq::missing(db).0,
                        Expr::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementLet,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementLet
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementLet { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StatementLetPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionTerminalSemicolon<'db> {
    Empty(OptionTerminalSemicolonEmpty<'db>),
    TerminalSemicolon(TerminalSemicolon<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalSemicolonPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionTerminalSemicolonPtr<'db> {
    type SyntaxNode = OptionTerminalSemicolon<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionTerminalSemicolon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalSemicolonPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalSemicolonPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionTerminalSemicolonEmptyPtr<'db>> for OptionTerminalSemicolonPtr<'db> {
    fn from(value: OptionTerminalSemicolonEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonPtr<'db>> for OptionTerminalSemicolonPtr<'db> {
    fn from(value: TerminalSemicolonPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionTerminalSemicolonEmptyGreen<'db>> for OptionTerminalSemicolonGreen<'db> {
    fn from(value: OptionTerminalSemicolonEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonGreen<'db>> for OptionTerminalSemicolonGreen<'db> {
    fn from(value: TerminalSemicolonGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalSemicolonGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalSemicolon<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalSemicolonPtr<'db>;
    type Green = OptionTerminalSemicolonGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalSemicolonEmpty => OptionTerminalSemicolon::Empty(
                OptionTerminalSemicolonEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::TerminalSemicolon => OptionTerminalSemicolon::TerminalSemicolon(
                TerminalSemicolon::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalSemicolon"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalSemicolonEmpty => Some(OptionTerminalSemicolon::Empty(
                OptionTerminalSemicolonEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalSemicolon => Some(OptionTerminalSemicolon::TerminalSemicolon(
                TerminalSemicolon::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionTerminalSemicolon::Empty(x) => x.as_syntax_node(),
            OptionTerminalSemicolon::TerminalSemicolon(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalSemicolonPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionTerminalSemicolon<'db> {
    /// Checks if a kind of a variant of [OptionTerminalSemicolon].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTerminalSemicolonEmpty | SyntaxKind::TerminalSemicolon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionTerminalSemicolonEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionTerminalSemicolonEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionTerminalSemicolonEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTerminalSemicolonEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalSemicolonEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionTerminalSemicolonEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalSemicolonEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionTerminalSemicolonEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionTerminalSemicolonEmptyPtr<'db> {
    type SyntaxNode = OptionTerminalSemicolonEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionTerminalSemicolonEmpty<'db> {
        OptionTerminalSemicolonEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalSemicolonEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalSemicolonEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalSemicolonEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalSemicolonEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalSemicolonEmpty);
    type StablePtr = OptionTerminalSemicolonEmptyPtr<'db>;
    type Green = OptionTerminalSemicolonEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionTerminalSemicolonEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalSemicolonEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalSemicolonEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalSemicolonEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTerminalSemicolonEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalSemicolonEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StatementExpr<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StatementExpr<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_EXPR: usize = 1;
    pub const INDEX_SEMICOLON: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        expr: ExprGreen<'db>,
        semicolon: OptionTerminalSemicolonGreen<'db>,
    ) -> StatementExprGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, expr.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StatementExpr<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[1])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> OptionTerminalSemicolon<'db> {
        OptionTerminalSemicolon::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementExprPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StatementExprPtr<'db> {}
impl<'db> TypedStablePtr<'db> for StatementExprPtr<'db> {
    type SyntaxNode = StatementExpr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StatementExpr<'db> {
        StatementExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StatementExprPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StatementExprPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementExprGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StatementExpr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementExpr);
    type StablePtr = StatementExprPtr<'db>;
    type Green = StatementExprGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StatementExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementExpr,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Expr::missing(db).0,
                        OptionTerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementExpr
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementExpr {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StatementExprPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StatementContinue<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StatementContinue<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_CONTINUE_KW: usize = 1;
    pub const INDEX_SEMICOLON: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        continue_kw: TerminalContinueGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> StatementContinueGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, continue_kw.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementContinue,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StatementContinue<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn continue_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalContinue<'db> {
        TerminalContinue::from_syntax_node(db, self.children[1])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementContinuePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StatementContinuePtr<'db> {}
impl<'db> TypedStablePtr<'db> for StatementContinuePtr<'db> {
    type SyntaxNode = StatementContinue<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StatementContinue<'db> {
        StatementContinue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StatementContinuePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StatementContinuePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementContinueGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StatementContinue<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementContinue);
    type StablePtr = StatementContinuePtr<'db>;
    type Green = StatementContinueGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StatementContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementContinue,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalContinue::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementContinue,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementContinue
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementContinue {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StatementContinuePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprClause<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprClause<'db> {
    pub const INDEX_EXPR: usize = 0;
    pub fn new_green(db: &'db dyn SyntaxGroup, expr: ExprGreen<'db>) -> ExprClauseGreen<'db> {
        let children: Vec<GreenId> = vec![expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprClause<'db> {
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprClausePtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprClausePtr<'db> {
    type SyntaxNode = ExprClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprClause<'db> {
        ExprClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprClause);
    type StablePtr = ExprClausePtr<'db>;
    type Green = ExprClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprClause,
                details: GreenNodeDetails::Node {
                    children: vec![Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprClause
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprClause { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprClausePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionExprClause<'db> {
    Empty(OptionExprClauseEmpty<'db>),
    ExprClause(ExprClause<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionExprClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionExprClausePtr<'db> {
    type SyntaxNode = OptionExprClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionExprClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionExprClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionExprClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionExprClauseEmptyPtr<'db>> for OptionExprClausePtr<'db> {
    fn from(value: OptionExprClauseEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprClausePtr<'db>> for OptionExprClausePtr<'db> {
    fn from(value: ExprClausePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionExprClauseEmptyGreen<'db>> for OptionExprClauseGreen<'db> {
    fn from(value: OptionExprClauseEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprClauseGreen<'db>> for OptionExprClauseGreen<'db> {
    fn from(value: ExprClauseGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionExprClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionExprClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionExprClausePtr<'db>;
    type Green = OptionExprClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionExprClauseEmpty => {
                OptionExprClause::Empty(OptionExprClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::ExprClause => {
                OptionExprClause::ExprClause(ExprClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionExprClause"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionExprClauseEmpty => {
                Some(OptionExprClause::Empty(OptionExprClauseEmpty::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprClause => {
                Some(OptionExprClause::ExprClause(ExprClause::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionExprClause::Empty(x) => x.as_syntax_node(),
            OptionExprClause::ExprClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionExprClausePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionExprClause<'db> {
    /// Checks if a kind of a variant of [OptionExprClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionExprClauseEmpty | SyntaxKind::ExprClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionExprClauseEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionExprClauseEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionExprClauseEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionExprClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionExprClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionExprClauseEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionExprClauseEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionExprClauseEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionExprClauseEmptyPtr<'db> {
    type SyntaxNode = OptionExprClauseEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionExprClauseEmpty<'db> {
        OptionExprClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionExprClauseEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionExprClauseEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionExprClauseEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionExprClauseEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionExprClauseEmpty);
    type StablePtr = OptionExprClauseEmptyPtr<'db>;
    type Green = OptionExprClauseEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionExprClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionExprClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionExprClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionExprClauseEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionExprClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionExprClauseEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StatementReturn<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StatementReturn<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_RETURN_KW: usize = 1;
    pub const INDEX_EXPR_CLAUSE: usize = 2;
    pub const INDEX_SEMICOLON: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        return_kw: TerminalReturnGreen<'db>,
        expr_clause: OptionExprClauseGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> StatementReturnGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, return_kw.0, expr_clause.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementReturn,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StatementReturn<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn return_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalReturn<'db> {
        TerminalReturn::from_syntax_node(db, self.children[1])
    }
    pub fn expr_clause(&self, db: &'db dyn SyntaxGroup) -> OptionExprClause<'db> {
        OptionExprClause::from_syntax_node(db, self.children[2])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementReturnPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StatementReturnPtr<'db> {}
impl<'db> TypedStablePtr<'db> for StatementReturnPtr<'db> {
    type SyntaxNode = StatementReturn<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StatementReturn<'db> {
        StatementReturn::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StatementReturnPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StatementReturnPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementReturnGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StatementReturn<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementReturn);
    type StablePtr = StatementReturnPtr<'db>;
    type Green = StatementReturnGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StatementReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementReturn,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalReturn::missing(db).0,
                        OptionExprClause::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementReturn,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementReturn
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementReturn {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StatementReturnPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StatementBreak<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StatementBreak<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_BREAK_KW: usize = 1;
    pub const INDEX_EXPR_CLAUSE: usize = 2;
    pub const INDEX_SEMICOLON: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        break_kw: TerminalBreakGreen<'db>,
        expr_clause: OptionExprClauseGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> StatementBreakGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, break_kw.0, expr_clause.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementBreak,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StatementBreak<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn break_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalBreak<'db> {
        TerminalBreak::from_syntax_node(db, self.children[1])
    }
    pub fn expr_clause(&self, db: &'db dyn SyntaxGroup) -> OptionExprClause<'db> {
        OptionExprClause::from_syntax_node(db, self.children[2])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementBreakPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StatementBreakPtr<'db> {}
impl<'db> TypedStablePtr<'db> for StatementBreakPtr<'db> {
    type SyntaxNode = StatementBreak<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StatementBreak<'db> {
        StatementBreak::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StatementBreakPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StatementBreakPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementBreakGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StatementBreak<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementBreak);
    type StablePtr = StatementBreakPtr<'db>;
    type Green = StatementBreakGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StatementBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementBreak,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalBreak::missing(db).0,
                        OptionExprClause::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementBreak,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementBreak
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementBreak {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StatementBreakPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct StatementItem<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> StatementItem<'db> {
    pub const INDEX_ITEM: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        item: ModuleItemGreen<'db>,
    ) -> StatementItemGreen<'db> {
        let children: Vec<GreenId> = vec![item.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementItemGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementItem,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> StatementItem<'db> {
    pub fn item(&self, db: &'db dyn SyntaxGroup) -> ModuleItem<'db> {
        ModuleItem::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementItemPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> StatementItemPtr<'db> {}
impl<'db> TypedStablePtr<'db> for StatementItemPtr<'db> {
    type SyntaxNode = StatementItem<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> StatementItem<'db> {
        StatementItem::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<StatementItemPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: StatementItemPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct StatementItemGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for StatementItem<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementItem);
    type StablePtr = StatementItemPtr<'db>;
    type Green = StatementItemGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        StatementItemGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementItem,
                details: GreenNodeDetails::Node {
                    children: vec![ModuleItem::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementItem,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementItem
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementItem {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        StatementItemPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct Param<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Param<'db> {
    pub const INDEX_MODIFIERS: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_TYPE_CLAUSE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        modifiers: ModifierListGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        type_clause: OptionTypeClauseGreen<'db>,
    ) -> ParamGreen<'db> {
        let children: Vec<GreenId> = vec![modifiers.0, name.0, type_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ParamGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Param,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> Param<'db> {
    pub fn modifiers(&self, db: &'db dyn SyntaxGroup) -> ModifierList<'db> {
        ModifierList::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
    pub fn type_clause(&self, db: &'db dyn SyntaxGroup) -> OptionTypeClause<'db> {
        OptionTypeClause::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParamPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ParamPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ParamPtr<'db> {
    type SyntaxNode = Param<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Param<'db> {
        Param::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ParamPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ParamPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParamGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Param<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Param);
    type StablePtr = ParamPtr<'db>;
    type Green = ParamGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ParamGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Param,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ModifierList::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionTypeClause::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Param,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Param
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::Param { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ParamPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ModifierList<'db>(ElementList<'db, Modifier<'db>, 1>);
impl<'db> Deref for ModifierList<'db> {
    type Target = ElementList<'db, Modifier<'db>, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> ModifierList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<ModifierGreen<'db>>,
    ) -> ModifierListGreen<'db> {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        ModifierListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModifierList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModifierListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ModifierListPtr<'db> {
    type SyntaxNode = ModifierList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ModifierList<'db> {
        ModifierList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ModifierListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ModifierListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModifierListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ModifierList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ModifierList);
    type StablePtr = ModifierListPtr<'db>;
    type Green = ModifierListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ModifierListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModifierList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ModifierList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ModifierListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum Modifier<'db> {
    Ref(TerminalRef<'db>),
    Mut(TerminalMut<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModifierPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ModifierPtr<'db> {
    type SyntaxNode = Modifier<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        Modifier::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ModifierPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ModifierPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TerminalRefPtr<'db>> for ModifierPtr<'db> {
    fn from(value: TerminalRefPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMutPtr<'db>> for ModifierPtr<'db> {
    fn from(value: TerminalMutPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalRefGreen<'db>> for ModifierGreen<'db> {
    fn from(value: TerminalRefGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMutGreen<'db>> for ModifierGreen<'db> {
    fn from(value: TerminalMutGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModifierGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Modifier<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ModifierPtr<'db>;
    type Green = ModifierGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalRef => Modifier::Ref(TerminalRef::from_syntax_node(db, node)),
            SyntaxKind::TerminalMut => Modifier::Mut(TerminalMut::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Modifier"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalRef => Some(Modifier::Ref(TerminalRef::from_syntax_node(db, node))),
            SyntaxKind::TerminalMut => Some(Modifier::Mut(TerminalMut::from_syntax_node(db, node))),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            Modifier::Ref(x) => x.as_syntax_node(),
            Modifier::Mut(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ModifierPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> Modifier<'db> {
    /// Checks if a kind of a variant of [Modifier].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::TerminalRef | SyntaxKind::TerminalMut)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ParamList<'db>(ElementList<'db, Param<'db>, 2>);
impl<'db> Deref for ParamList<'db> {
    type Target = ElementList<'db, Param<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> ParamList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<ParamListElementOrSeparatorGreen<'db>>,
    ) -> ParamListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        ParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParamList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParamListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ParamListPtr<'db> {
    type SyntaxNode = ParamList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ParamList<'db> {
        ParamList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ParamListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ParamListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum ParamListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(ParamGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for ParamListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        ParamListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<ParamGreen<'db>> for ParamListElementOrSeparatorGreen<'db> {
    fn from(value: ParamGreen<'db>) -> Self {
        ParamListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> ParamListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            ParamListElementOrSeparatorGreen::Separator(green) => green.0,
            ParamListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParamListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ParamList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ParamList);
    type StablePtr = ParamListPtr<'db>;
    type Green = ParamListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParamList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ParamList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ParamListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ImplicitsClause<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ImplicitsClause<'db> {
    pub const INDEX_IMPLICITS_KW: usize = 0;
    pub const INDEX_LPAREN: usize = 1;
    pub const INDEX_IMPLICITS: usize = 2;
    pub const INDEX_RPAREN: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        implicits_kw: TerminalImplicitsGreen<'db>,
        lparen: TerminalLParenGreen<'db>,
        implicits: ImplicitsListGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
    ) -> ImplicitsClauseGreen<'db> {
        let children: Vec<GreenId> = vec![implicits_kw.0, lparen.0, implicits.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ImplicitsClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplicitsClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ImplicitsClause<'db> {
    pub fn implicits_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalImplicits<'db> {
        TerminalImplicits::from_syntax_node(db, self.children[0])
    }
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[1])
    }
    pub fn implicits(&self, db: &'db dyn SyntaxGroup) -> ImplicitsList<'db> {
        ImplicitsList::from_syntax_node(db, self.children[2])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplicitsClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ImplicitsClausePtr<'db> {}
impl<'db> TypedStablePtr<'db> for ImplicitsClausePtr<'db> {
    type SyntaxNode = ImplicitsClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ImplicitsClause<'db> {
        ImplicitsClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ImplicitsClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ImplicitsClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplicitsClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ImplicitsClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplicitsClause);
    type StablePtr = ImplicitsClausePtr<'db>;
    type Green = ImplicitsClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ImplicitsClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplicitsClause,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalImplicits::missing(db).0,
                        TerminalLParen::missing(db).0,
                        ImplicitsList::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ImplicitsClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ImplicitsClause
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ImplicitsClause {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ImplicitsClausePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ImplicitsList<'db>(ElementList<'db, ExprPath<'db>, 2>);
impl<'db> Deref for ImplicitsList<'db> {
    type Target = ElementList<'db, ExprPath<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> ImplicitsList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<ImplicitsListElementOrSeparatorGreen<'db>>,
    ) -> ImplicitsListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        ImplicitsListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplicitsList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplicitsListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ImplicitsListPtr<'db> {
    type SyntaxNode = ImplicitsList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ImplicitsList<'db> {
        ImplicitsList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ImplicitsListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ImplicitsListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum ImplicitsListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(ExprPathGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for ImplicitsListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        ImplicitsListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<ExprPathGreen<'db>> for ImplicitsListElementOrSeparatorGreen<'db> {
    fn from(value: ExprPathGreen<'db>) -> Self {
        ImplicitsListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> ImplicitsListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            ImplicitsListElementOrSeparatorGreen::Separator(green) => green.0,
            ImplicitsListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplicitsListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ImplicitsList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplicitsList);
    type StablePtr = ImplicitsListPtr<'db>;
    type Green = ImplicitsListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ImplicitsListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplicitsList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ImplicitsList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ImplicitsListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionImplicitsClause<'db> {
    Empty(OptionImplicitsClauseEmpty<'db>),
    ImplicitsClause(ImplicitsClause<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionImplicitsClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionImplicitsClausePtr<'db> {
    type SyntaxNode = OptionImplicitsClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionImplicitsClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionImplicitsClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionImplicitsClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionImplicitsClauseEmptyPtr<'db>> for OptionImplicitsClausePtr<'db> {
    fn from(value: OptionImplicitsClauseEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ImplicitsClausePtr<'db>> for OptionImplicitsClausePtr<'db> {
    fn from(value: ImplicitsClausePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionImplicitsClauseEmptyGreen<'db>> for OptionImplicitsClauseGreen<'db> {
    fn from(value: OptionImplicitsClauseEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ImplicitsClauseGreen<'db>> for OptionImplicitsClauseGreen<'db> {
    fn from(value: ImplicitsClauseGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionImplicitsClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionImplicitsClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionImplicitsClausePtr<'db>;
    type Green = OptionImplicitsClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionImplicitsClauseEmpty => {
                OptionImplicitsClause::Empty(OptionImplicitsClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::ImplicitsClause => {
                OptionImplicitsClause::ImplicitsClause(ImplicitsClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionImplicitsClause"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionImplicitsClauseEmpty => Some(OptionImplicitsClause::Empty(
                OptionImplicitsClauseEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::ImplicitsClause => Some(OptionImplicitsClause::ImplicitsClause(
                ImplicitsClause::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionImplicitsClause::Empty(x) => x.as_syntax_node(),
            OptionImplicitsClause::ImplicitsClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionImplicitsClausePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionImplicitsClause<'db> {
    /// Checks if a kind of a variant of [OptionImplicitsClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionImplicitsClauseEmpty | SyntaxKind::ImplicitsClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionImplicitsClauseEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionImplicitsClauseEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionImplicitsClauseEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionImplicitsClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionImplicitsClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionImplicitsClauseEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionImplicitsClauseEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionImplicitsClauseEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionImplicitsClauseEmptyPtr<'db> {
    type SyntaxNode = OptionImplicitsClauseEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionImplicitsClauseEmpty<'db> {
        OptionImplicitsClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionImplicitsClauseEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionImplicitsClauseEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionImplicitsClauseEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionImplicitsClauseEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionImplicitsClauseEmpty);
    type StablePtr = OptionImplicitsClauseEmptyPtr<'db>;
    type Green = OptionImplicitsClauseEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionImplicitsClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionImplicitsClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionImplicitsClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionImplicitsClauseEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionImplicitsClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionImplicitsClauseEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionTerminalNoPanic<'db> {
    Empty(OptionTerminalNoPanicEmpty<'db>),
    TerminalNoPanic(TerminalNoPanic<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalNoPanicPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionTerminalNoPanicPtr<'db> {
    type SyntaxNode = OptionTerminalNoPanic<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionTerminalNoPanic::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalNoPanicPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalNoPanicPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionTerminalNoPanicEmptyPtr<'db>> for OptionTerminalNoPanicPtr<'db> {
    fn from(value: OptionTerminalNoPanicEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNoPanicPtr<'db>> for OptionTerminalNoPanicPtr<'db> {
    fn from(value: TerminalNoPanicPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionTerminalNoPanicEmptyGreen<'db>> for OptionTerminalNoPanicGreen<'db> {
    fn from(value: OptionTerminalNoPanicEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNoPanicGreen<'db>> for OptionTerminalNoPanicGreen<'db> {
    fn from(value: TerminalNoPanicGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalNoPanicGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalNoPanic<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalNoPanicPtr<'db>;
    type Green = OptionTerminalNoPanicGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalNoPanicEmpty => {
                OptionTerminalNoPanic::Empty(OptionTerminalNoPanicEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNoPanic => {
                OptionTerminalNoPanic::TerminalNoPanic(TerminalNoPanic::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalNoPanic"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalNoPanicEmpty => Some(OptionTerminalNoPanic::Empty(
                OptionTerminalNoPanicEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalNoPanic => Some(OptionTerminalNoPanic::TerminalNoPanic(
                TerminalNoPanic::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionTerminalNoPanic::Empty(x) => x.as_syntax_node(),
            OptionTerminalNoPanic::TerminalNoPanic(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalNoPanicPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionTerminalNoPanic<'db> {
    /// Checks if a kind of a variant of [OptionTerminalNoPanic].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTerminalNoPanicEmpty | SyntaxKind::TerminalNoPanic)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionTerminalNoPanicEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionTerminalNoPanicEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionTerminalNoPanicEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTerminalNoPanicEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalNoPanicEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionTerminalNoPanicEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalNoPanicEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionTerminalNoPanicEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionTerminalNoPanicEmptyPtr<'db> {
    type SyntaxNode = OptionTerminalNoPanicEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionTerminalNoPanicEmpty<'db> {
        OptionTerminalNoPanicEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalNoPanicEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalNoPanicEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalNoPanicEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalNoPanicEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalNoPanicEmpty);
    type StablePtr = OptionTerminalNoPanicEmptyPtr<'db>;
    type Green = OptionTerminalNoPanicEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionTerminalNoPanicEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalNoPanicEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalNoPanicEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalNoPanicEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTerminalNoPanicEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalNoPanicEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionTerminalConst<'db> {
    Empty(OptionTerminalConstEmpty<'db>),
    TerminalConst(TerminalConst<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalConstPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionTerminalConstPtr<'db> {
    type SyntaxNode = OptionTerminalConst<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionTerminalConst::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalConstPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalConstPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionTerminalConstEmptyPtr<'db>> for OptionTerminalConstPtr<'db> {
    fn from(value: OptionTerminalConstEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalConstPtr<'db>> for OptionTerminalConstPtr<'db> {
    fn from(value: TerminalConstPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionTerminalConstEmptyGreen<'db>> for OptionTerminalConstGreen<'db> {
    fn from(value: OptionTerminalConstEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalConstGreen<'db>> for OptionTerminalConstGreen<'db> {
    fn from(value: TerminalConstGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalConstGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalConst<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalConstPtr<'db>;
    type Green = OptionTerminalConstGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalConstEmpty => {
                OptionTerminalConst::Empty(OptionTerminalConstEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalConst => {
                OptionTerminalConst::TerminalConst(TerminalConst::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalConst"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalConstEmpty => Some(OptionTerminalConst::Empty(
                OptionTerminalConstEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalConst => {
                Some(OptionTerminalConst::TerminalConst(TerminalConst::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionTerminalConst::Empty(x) => x.as_syntax_node(),
            OptionTerminalConst::TerminalConst(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalConstPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionTerminalConst<'db> {
    /// Checks if a kind of a variant of [OptionTerminalConst].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTerminalConstEmpty | SyntaxKind::TerminalConst)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionTerminalConstEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionTerminalConstEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionTerminalConstEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTerminalConstEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalConstEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionTerminalConstEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalConstEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionTerminalConstEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionTerminalConstEmptyPtr<'db> {
    type SyntaxNode = OptionTerminalConstEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionTerminalConstEmpty<'db> {
        OptionTerminalConstEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalConstEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalConstEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalConstEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalConstEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalConstEmpty);
    type StablePtr = OptionTerminalConstEmptyPtr<'db>;
    type Green = OptionTerminalConstEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionTerminalConstEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalConstEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalConstEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalConstEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTerminalConstEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalConstEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct FunctionSignature<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> FunctionSignature<'db> {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_PARAMETERS: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub const INDEX_RET_TY: usize = 3;
    pub const INDEX_IMPLICITS_CLAUSE: usize = 4;
    pub const INDEX_OPTIONAL_NO_PANIC: usize = 5;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lparen: TerminalLParenGreen<'db>,
        parameters: ParamListGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
        ret_ty: OptionReturnTypeClauseGreen<'db>,
        implicits_clause: OptionImplicitsClauseGreen<'db>,
        optional_no_panic: OptionTerminalNoPanicGreen<'db>,
    ) -> FunctionSignatureGreen<'db> {
        let children: Vec<GreenId> = vec![
            lparen.0,
            parameters.0,
            rparen.0,
            ret_ty.0,
            implicits_clause.0,
            optional_no_panic.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        FunctionSignatureGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionSignature,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> FunctionSignature<'db> {
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[0])
    }
    pub fn parameters(&self, db: &'db dyn SyntaxGroup) -> ParamList<'db> {
        ParamList::from_syntax_node(db, self.children[1])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[2])
    }
    pub fn ret_ty(&self, db: &'db dyn SyntaxGroup) -> OptionReturnTypeClause<'db> {
        OptionReturnTypeClause::from_syntax_node(db, self.children[3])
    }
    pub fn implicits_clause(&self, db: &'db dyn SyntaxGroup) -> OptionImplicitsClause<'db> {
        OptionImplicitsClause::from_syntax_node(db, self.children[4])
    }
    pub fn optional_no_panic(&self, db: &'db dyn SyntaxGroup) -> OptionTerminalNoPanic<'db> {
        OptionTerminalNoPanic::from_syntax_node(db, self.children[5])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct FunctionSignaturePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> FunctionSignaturePtr<'db> {}
impl<'db> TypedStablePtr<'db> for FunctionSignaturePtr<'db> {
    type SyntaxNode = FunctionSignature<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> FunctionSignature<'db> {
        FunctionSignature::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<FunctionSignaturePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: FunctionSignaturePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct FunctionSignatureGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for FunctionSignature<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::FunctionSignature);
    type StablePtr = FunctionSignaturePtr<'db>;
    type Green = FunctionSignatureGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        FunctionSignatureGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionSignature,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        ParamList::missing(db).0,
                        TerminalRParen::missing(db).0,
                        OptionReturnTypeClause::missing(db).0,
                        OptionImplicitsClause::missing(db).0,
                        OptionTerminalNoPanic::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::FunctionSignature,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::FunctionSignature
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::FunctionSignature {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        FunctionSignaturePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct Member<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Member<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_NAME: usize = 2;
    pub const INDEX_TYPE_CLAUSE: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        type_clause: TypeClauseGreen<'db>,
    ) -> MemberGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, visibility.0, name.0, type_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        MemberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Member,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> Member<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[2])
    }
    pub fn type_clause(&self, db: &'db dyn SyntaxGroup) -> TypeClause<'db> {
        TypeClause::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MemberPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> MemberPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for MemberPtr<'db> {
    type SyntaxNode = Member<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Member<'db> {
        Member::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MemberPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MemberPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MemberGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Member<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Member);
    type StablePtr = MemberPtr<'db>;
    type Green = MemberGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MemberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Member,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TypeClause::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Member,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Member
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::Member { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MemberPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MemberList<'db>(ElementList<'db, Member<'db>, 2>);
impl<'db> Deref for MemberList<'db> {
    type Target = ElementList<'db, Member<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> MemberList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<MemberListElementOrSeparatorGreen<'db>>,
    ) -> MemberListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        MemberListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MemberList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MemberListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MemberListPtr<'db> {
    type SyntaxNode = MemberList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MemberList<'db> {
        MemberList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MemberListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MemberListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum MemberListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(MemberGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for MemberListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        MemberListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<MemberGreen<'db>> for MemberListElementOrSeparatorGreen<'db> {
    fn from(value: MemberGreen<'db>) -> Self {
        MemberListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> MemberListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            MemberListElementOrSeparatorGreen::Separator(green) => green.0,
            MemberListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MemberListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MemberList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MemberList);
    type StablePtr = MemberListPtr<'db>;
    type Green = MemberListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MemberListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MemberList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::MemberList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MemberListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct Variant<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Variant<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_TYPE_CLAUSE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        type_clause: OptionTypeClauseGreen<'db>,
    ) -> VariantGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, name.0, type_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        VariantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Variant,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> Variant<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
    pub fn type_clause(&self, db: &'db dyn SyntaxGroup) -> OptionTypeClause<'db> {
        OptionTypeClause::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VariantPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> VariantPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for VariantPtr<'db> {
    type SyntaxNode = Variant<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Variant<'db> {
        Variant::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<VariantPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: VariantPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VariantGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Variant<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Variant);
    type StablePtr = VariantPtr<'db>;
    type Green = VariantGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        VariantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Variant,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionTypeClause::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Variant,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Variant
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::Variant { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        VariantPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct VariantList<'db>(ElementList<'db, Variant<'db>, 2>);
impl<'db> Deref for VariantList<'db> {
    type Target = ElementList<'db, Variant<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> VariantList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<VariantListElementOrSeparatorGreen<'db>>,
    ) -> VariantListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        VariantListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VariantList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VariantListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for VariantListPtr<'db> {
    type SyntaxNode = VariantList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> VariantList<'db> {
        VariantList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<VariantListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: VariantListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum VariantListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(VariantGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for VariantListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        VariantListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<VariantGreen<'db>> for VariantListElementOrSeparatorGreen<'db> {
    fn from(value: VariantGreen<'db>) -> Self {
        VariantListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> VariantListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            VariantListElementOrSeparatorGreen::Separator(green) => green.0,
            VariantListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VariantListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for VariantList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::VariantList);
    type StablePtr = VariantListPtr<'db>;
    type Green = VariantListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        VariantListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VariantList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::VariantList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        VariantListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum ModuleItem<'db> {
    Constant(ItemConstant<'db>),
    Module(ItemModule<'db>),
    Use(ItemUse<'db>),
    FreeFunction(FunctionWithBody<'db>),
    ExternFunction(ItemExternFunction<'db>),
    ExternType(ItemExternType<'db>),
    Trait(ItemTrait<'db>),
    Impl(ItemImpl<'db>),
    ImplAlias(ItemImplAlias<'db>),
    Struct(ItemStruct<'db>),
    Enum(ItemEnum<'db>),
    TypeAlias(ItemTypeAlias<'db>),
    InlineMacro(ItemInlineMacro<'db>),
    MacroDeclaration(ItemMacroDeclaration<'db>),
    HeaderDoc(ItemHeaderDoc<'db>),
    Missing(ModuleItemMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModuleItemPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ModuleItemPtr<'db> {
    type SyntaxNode = ModuleItem<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        ModuleItem::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ModuleItemPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ModuleItemPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ItemConstantPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemConstantPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemModulePtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemModulePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemUsePtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemUsePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<FunctionWithBodyPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: FunctionWithBodyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemExternFunctionPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemExternFunctionPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemExternTypePtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemExternTypePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemTraitPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemTraitPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemImplPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemImplPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemImplAliasPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemImplAliasPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemStructPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemStructPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemEnumPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemEnumPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemTypeAliasPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemTypeAliasPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemInlineMacroPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemInlineMacroPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemMacroDeclarationPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemMacroDeclarationPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemHeaderDocPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ItemHeaderDocPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ModuleItemMissingPtr<'db>> for ModuleItemPtr<'db> {
    fn from(value: ModuleItemMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemConstantGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemConstantGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemModuleGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemModuleGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemUseGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemUseGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<FunctionWithBodyGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: FunctionWithBodyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemExternFunctionGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemExternFunctionGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemExternTypeGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemExternTypeGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemTraitGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemTraitGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemImplGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemImplGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemImplAliasGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemImplAliasGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemStructGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemStructGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemEnumGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemEnumGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemTypeAliasGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemTypeAliasGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemInlineMacroGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemInlineMacroGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemMacroDeclarationGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemMacroDeclarationGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemHeaderDocGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ItemHeaderDocGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ModuleItemMissingGreen<'db>> for ModuleItemGreen<'db> {
    fn from(value: ModuleItemMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModuleItemGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ModuleItem<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ModuleItemPtr<'db>;
    type Green = ModuleItemGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ModuleItemGreen(ModuleItemMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ItemConstant => {
                ModuleItem::Constant(ItemConstant::from_syntax_node(db, node))
            }
            SyntaxKind::ItemModule => ModuleItem::Module(ItemModule::from_syntax_node(db, node)),
            SyntaxKind::ItemUse => ModuleItem::Use(ItemUse::from_syntax_node(db, node)),
            SyntaxKind::FunctionWithBody => {
                ModuleItem::FreeFunction(FunctionWithBody::from_syntax_node(db, node))
            }
            SyntaxKind::ItemExternFunction => {
                ModuleItem::ExternFunction(ItemExternFunction::from_syntax_node(db, node))
            }
            SyntaxKind::ItemExternType => {
                ModuleItem::ExternType(ItemExternType::from_syntax_node(db, node))
            }
            SyntaxKind::ItemTrait => ModuleItem::Trait(ItemTrait::from_syntax_node(db, node)),
            SyntaxKind::ItemImpl => ModuleItem::Impl(ItemImpl::from_syntax_node(db, node)),
            SyntaxKind::ItemImplAlias => {
                ModuleItem::ImplAlias(ItemImplAlias::from_syntax_node(db, node))
            }
            SyntaxKind::ItemStruct => ModuleItem::Struct(ItemStruct::from_syntax_node(db, node)),
            SyntaxKind::ItemEnum => ModuleItem::Enum(ItemEnum::from_syntax_node(db, node)),
            SyntaxKind::ItemTypeAlias => {
                ModuleItem::TypeAlias(ItemTypeAlias::from_syntax_node(db, node))
            }
            SyntaxKind::ItemInlineMacro => {
                ModuleItem::InlineMacro(ItemInlineMacro::from_syntax_node(db, node))
            }
            SyntaxKind::ItemMacroDeclaration => {
                ModuleItem::MacroDeclaration(ItemMacroDeclaration::from_syntax_node(db, node))
            }
            SyntaxKind::ItemHeaderDoc => {
                ModuleItem::HeaderDoc(ItemHeaderDoc::from_syntax_node(db, node))
            }
            SyntaxKind::ModuleItemMissing => {
                ModuleItem::Missing(ModuleItemMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "ModuleItem"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ItemConstant => {
                Some(ModuleItem::Constant(ItemConstant::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemModule => {
                Some(ModuleItem::Module(ItemModule::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemUse => Some(ModuleItem::Use(ItemUse::from_syntax_node(db, node))),
            SyntaxKind::FunctionWithBody => {
                Some(ModuleItem::FreeFunction(FunctionWithBody::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemExternFunction => {
                Some(ModuleItem::ExternFunction(ItemExternFunction::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemExternType => {
                Some(ModuleItem::ExternType(ItemExternType::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemTrait => Some(ModuleItem::Trait(ItemTrait::from_syntax_node(db, node))),
            SyntaxKind::ItemImpl => Some(ModuleItem::Impl(ItemImpl::from_syntax_node(db, node))),
            SyntaxKind::ItemImplAlias => {
                Some(ModuleItem::ImplAlias(ItemImplAlias::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemStruct => {
                Some(ModuleItem::Struct(ItemStruct::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemEnum => Some(ModuleItem::Enum(ItemEnum::from_syntax_node(db, node))),
            SyntaxKind::ItemTypeAlias => {
                Some(ModuleItem::TypeAlias(ItemTypeAlias::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemInlineMacro => {
                Some(ModuleItem::InlineMacro(ItemInlineMacro::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemMacroDeclaration => {
                Some(ModuleItem::MacroDeclaration(ItemMacroDeclaration::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemHeaderDoc => {
                Some(ModuleItem::HeaderDoc(ItemHeaderDoc::from_syntax_node(db, node)))
            }
            SyntaxKind::ModuleItemMissing => {
                Some(ModuleItem::Missing(ModuleItemMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            ModuleItem::Constant(x) => x.as_syntax_node(),
            ModuleItem::Module(x) => x.as_syntax_node(),
            ModuleItem::Use(x) => x.as_syntax_node(),
            ModuleItem::FreeFunction(x) => x.as_syntax_node(),
            ModuleItem::ExternFunction(x) => x.as_syntax_node(),
            ModuleItem::ExternType(x) => x.as_syntax_node(),
            ModuleItem::Trait(x) => x.as_syntax_node(),
            ModuleItem::Impl(x) => x.as_syntax_node(),
            ModuleItem::ImplAlias(x) => x.as_syntax_node(),
            ModuleItem::Struct(x) => x.as_syntax_node(),
            ModuleItem::Enum(x) => x.as_syntax_node(),
            ModuleItem::TypeAlias(x) => x.as_syntax_node(),
            ModuleItem::InlineMacro(x) => x.as_syntax_node(),
            ModuleItem::MacroDeclaration(x) => x.as_syntax_node(),
            ModuleItem::HeaderDoc(x) => x.as_syntax_node(),
            ModuleItem::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ModuleItemPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> ModuleItem<'db> {
    /// Checks if a kind of a variant of [ModuleItem].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ItemConstant
                | SyntaxKind::ItemModule
                | SyntaxKind::ItemUse
                | SyntaxKind::FunctionWithBody
                | SyntaxKind::ItemExternFunction
                | SyntaxKind::ItemExternType
                | SyntaxKind::ItemTrait
                | SyntaxKind::ItemImpl
                | SyntaxKind::ItemImplAlias
                | SyntaxKind::ItemStruct
                | SyntaxKind::ItemEnum
                | SyntaxKind::ItemTypeAlias
                | SyntaxKind::ItemInlineMacro
                | SyntaxKind::ItemMacroDeclaration
                | SyntaxKind::ItemHeaderDoc
                | SyntaxKind::ModuleItemMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ModuleItemList<'db>(ElementList<'db, ModuleItem<'db>, 1>);
impl<'db> Deref for ModuleItemList<'db> {
    type Target = ElementList<'db, ModuleItem<'db>, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> ModuleItemList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<ModuleItemGreen<'db>>,
    ) -> ModuleItemListGreen<'db> {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        ModuleItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleItemList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModuleItemListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ModuleItemListPtr<'db> {
    type SyntaxNode = ModuleItemList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ModuleItemList<'db> {
        ModuleItemList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ModuleItemListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ModuleItemListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModuleItemListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ModuleItemList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ModuleItemList);
    type StablePtr = ModuleItemListPtr<'db>;
    type Green = ModuleItemListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ModuleItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleItemList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ModuleItemList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ModuleItemListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ModuleItemMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ModuleItemMissing<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> ModuleItemMissingGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ModuleItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleItemMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ModuleItemMissing<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModuleItemMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ModuleItemMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ModuleItemMissingPtr<'db> {
    type SyntaxNode = ModuleItemMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ModuleItemMissing<'db> {
        ModuleItemMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ModuleItemMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ModuleItemMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModuleItemMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ModuleItemMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ModuleItemMissing);
    type StablePtr = ModuleItemMissingPtr<'db>;
    type Green = ModuleItemMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ModuleItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleItemMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ModuleItemMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ModuleItemMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ModuleItemMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ModuleItemMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct Attribute<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Attribute<'db> {
    pub const INDEX_HASH: usize = 0;
    pub const INDEX_LBRACK: usize = 1;
    pub const INDEX_ATTR: usize = 2;
    pub const INDEX_ARGUMENTS: usize = 3;
    pub const INDEX_RBRACK: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        hash: TerminalHashGreen<'db>,
        lbrack: TerminalLBrackGreen<'db>,
        attr: ExprPathGreen<'db>,
        arguments: OptionArgListParenthesizedGreen<'db>,
        rbrack: TerminalRBrackGreen<'db>,
    ) -> AttributeGreen<'db> {
        let children: Vec<GreenId> = vec![hash.0, lbrack.0, attr.0, arguments.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        AttributeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Attribute,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> Attribute<'db> {
    pub fn hash(&self, db: &'db dyn SyntaxGroup) -> TerminalHash<'db> {
        TerminalHash::from_syntax_node(db, self.children[0])
    }
    pub fn lbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrack<'db> {
        TerminalLBrack::from_syntax_node(db, self.children[1])
    }
    pub fn attr(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[2])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> OptionArgListParenthesized<'db> {
        OptionArgListParenthesized::from_syntax_node(db, self.children[3])
    }
    pub fn rbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrack<'db> {
        TerminalRBrack::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AttributePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> AttributePtr<'db> {}
impl<'db> TypedStablePtr<'db> for AttributePtr<'db> {
    type SyntaxNode = Attribute<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Attribute<'db> {
        Attribute::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<AttributePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: AttributePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AttributeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Attribute<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Attribute);
    type StablePtr = AttributePtr<'db>;
    type Green = AttributeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        AttributeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Attribute,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalHash::missing(db).0,
                        TerminalLBrack::missing(db).0,
                        ExprPath::missing(db).0,
                        OptionArgListParenthesized::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Attribute,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Attribute
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::Attribute { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        AttributePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct AttributeList<'db>(ElementList<'db, Attribute<'db>, 1>);
impl<'db> Deref for AttributeList<'db> {
    type Target = ElementList<'db, Attribute<'db>, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> AttributeList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<AttributeGreen<'db>>,
    ) -> AttributeListGreen<'db> {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        AttributeListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AttributeList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AttributeListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for AttributeListPtr<'db> {
    type SyntaxNode = AttributeList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<AttributeListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: AttributeListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AttributeListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for AttributeList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AttributeList);
    type StablePtr = AttributeListPtr<'db>;
    type Green = AttributeListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        AttributeListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AttributeList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::AttributeList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        AttributeListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct VisibilityDefault<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> VisibilityDefault<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> VisibilityDefaultGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        VisibilityDefaultGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityDefault,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> VisibilityDefault<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VisibilityDefaultPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> VisibilityDefaultPtr<'db> {}
impl<'db> TypedStablePtr<'db> for VisibilityDefaultPtr<'db> {
    type SyntaxNode = VisibilityDefault<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> VisibilityDefault<'db> {
        VisibilityDefault::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<VisibilityDefaultPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: VisibilityDefaultPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VisibilityDefaultGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for VisibilityDefault<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::VisibilityDefault);
    type StablePtr = VisibilityDefaultPtr<'db>;
    type Green = VisibilityDefaultGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        VisibilityDefaultGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityDefault,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::VisibilityDefault,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::VisibilityDefault
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::VisibilityDefault {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        VisibilityDefaultPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct VisibilityPubArgumentClause<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> VisibilityPubArgumentClause<'db> {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_ARGUMENT: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lparen: TerminalLParenGreen<'db>,
        argument: TerminalIdentifierGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
    ) -> VisibilityPubArgumentClauseGreen<'db> {
        let children: Vec<GreenId> = vec![lparen.0, argument.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        VisibilityPubArgumentClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityPubArgumentClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> VisibilityPubArgumentClause<'db> {
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[0])
    }
    pub fn argument(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VisibilityPubArgumentClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> VisibilityPubArgumentClausePtr<'db> {}
impl<'db> TypedStablePtr<'db> for VisibilityPubArgumentClausePtr<'db> {
    type SyntaxNode = VisibilityPubArgumentClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> VisibilityPubArgumentClause<'db> {
        VisibilityPubArgumentClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<VisibilityPubArgumentClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: VisibilityPubArgumentClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VisibilityPubArgumentClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for VisibilityPubArgumentClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::VisibilityPubArgumentClause);
    type StablePtr = VisibilityPubArgumentClausePtr<'db>;
    type Green = VisibilityPubArgumentClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        VisibilityPubArgumentClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityPubArgumentClause,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::VisibilityPubArgumentClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::VisibilityPubArgumentClause
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::VisibilityPubArgumentClause {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        VisibilityPubArgumentClausePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionVisibilityPubArgumentClause<'db> {
    Empty(OptionVisibilityPubArgumentClauseEmpty<'db>),
    VisibilityPubArgumentClause(VisibilityPubArgumentClause<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionVisibilityPubArgumentClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionVisibilityPubArgumentClausePtr<'db> {
    type SyntaxNode = OptionVisibilityPubArgumentClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionVisibilityPubArgumentClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionVisibilityPubArgumentClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionVisibilityPubArgumentClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionVisibilityPubArgumentClauseEmptyPtr<'db>>
    for OptionVisibilityPubArgumentClausePtr<'db>
{
    fn from(value: OptionVisibilityPubArgumentClauseEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<VisibilityPubArgumentClausePtr<'db>> for OptionVisibilityPubArgumentClausePtr<'db> {
    fn from(value: VisibilityPubArgumentClausePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionVisibilityPubArgumentClauseEmptyGreen<'db>>
    for OptionVisibilityPubArgumentClauseGreen<'db>
{
    fn from(value: OptionVisibilityPubArgumentClauseEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<VisibilityPubArgumentClauseGreen<'db>>
    for OptionVisibilityPubArgumentClauseGreen<'db>
{
    fn from(value: VisibilityPubArgumentClauseGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionVisibilityPubArgumentClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionVisibilityPubArgumentClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionVisibilityPubArgumentClausePtr<'db>;
    type Green = OptionVisibilityPubArgumentClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionVisibilityPubArgumentClauseEmpty => {
                OptionVisibilityPubArgumentClause::Empty(
                    OptionVisibilityPubArgumentClauseEmpty::from_syntax_node(db, node),
                )
            }
            SyntaxKind::VisibilityPubArgumentClause => {
                OptionVisibilityPubArgumentClause::VisibilityPubArgumentClause(
                    VisibilityPubArgumentClause::from_syntax_node(db, node),
                )
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionVisibilityPubArgumentClause"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionVisibilityPubArgumentClauseEmpty => {
                Some(OptionVisibilityPubArgumentClause::Empty(
                    OptionVisibilityPubArgumentClauseEmpty::from_syntax_node(db, node),
                ))
            }
            SyntaxKind::VisibilityPubArgumentClause => {
                Some(OptionVisibilityPubArgumentClause::VisibilityPubArgumentClause(
                    VisibilityPubArgumentClause::from_syntax_node(db, node),
                ))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionVisibilityPubArgumentClause::Empty(x) => x.as_syntax_node(),
            OptionVisibilityPubArgumentClause::VisibilityPubArgumentClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionVisibilityPubArgumentClausePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionVisibilityPubArgumentClause<'db> {
    /// Checks if a kind of a variant of [OptionVisibilityPubArgumentClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::OptionVisibilityPubArgumentClauseEmpty
                | SyntaxKind::VisibilityPubArgumentClause
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionVisibilityPubArgumentClauseEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionVisibilityPubArgumentClauseEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionVisibilityPubArgumentClauseEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionVisibilityPubArgumentClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionVisibilityPubArgumentClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionVisibilityPubArgumentClauseEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionVisibilityPubArgumentClauseEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionVisibilityPubArgumentClauseEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionVisibilityPubArgumentClauseEmptyPtr<'db> {
    type SyntaxNode = OptionVisibilityPubArgumentClauseEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionVisibilityPubArgumentClauseEmpty<'db> {
        OptionVisibilityPubArgumentClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionVisibilityPubArgumentClauseEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionVisibilityPubArgumentClauseEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionVisibilityPubArgumentClauseEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionVisibilityPubArgumentClauseEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> =
        Some(SyntaxKind::OptionVisibilityPubArgumentClauseEmpty);
    type StablePtr = OptionVisibilityPubArgumentClauseEmptyPtr<'db>;
    type Green = OptionVisibilityPubArgumentClauseEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionVisibilityPubArgumentClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionVisibilityPubArgumentClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionVisibilityPubArgumentClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionVisibilityPubArgumentClauseEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionVisibilityPubArgumentClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionVisibilityPubArgumentClauseEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct VisibilityPub<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> VisibilityPub<'db> {
    pub const INDEX_PUB_KW: usize = 0;
    pub const INDEX_ARGUMENT_CLAUSE: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        pub_kw: TerminalPubGreen<'db>,
        argument_clause: OptionVisibilityPubArgumentClauseGreen<'db>,
    ) -> VisibilityPubGreen<'db> {
        let children: Vec<GreenId> = vec![pub_kw.0, argument_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        VisibilityPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityPub,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> VisibilityPub<'db> {
    pub fn pub_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalPub<'db> {
        TerminalPub::from_syntax_node(db, self.children[0])
    }
    pub fn argument_clause(
        &self,
        db: &'db dyn SyntaxGroup,
    ) -> OptionVisibilityPubArgumentClause<'db> {
        OptionVisibilityPubArgumentClause::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VisibilityPubPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> VisibilityPubPtr<'db> {}
impl<'db> TypedStablePtr<'db> for VisibilityPubPtr<'db> {
    type SyntaxNode = VisibilityPub<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> VisibilityPub<'db> {
        VisibilityPub::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<VisibilityPubPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: VisibilityPubPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VisibilityPubGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for VisibilityPub<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::VisibilityPub);
    type StablePtr = VisibilityPubPtr<'db>;
    type Green = VisibilityPubGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        VisibilityPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityPub,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalPub::missing(db).0,
                        OptionVisibilityPubArgumentClause::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::VisibilityPub,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::VisibilityPub
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::VisibilityPub {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        VisibilityPubPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum Visibility<'db> {
    Default(VisibilityDefault<'db>),
    Pub(VisibilityPub<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VisibilityPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for VisibilityPtr<'db> {
    type SyntaxNode = Visibility<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        Visibility::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<VisibilityPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: VisibilityPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<VisibilityDefaultPtr<'db>> for VisibilityPtr<'db> {
    fn from(value: VisibilityDefaultPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<VisibilityPubPtr<'db>> for VisibilityPtr<'db> {
    fn from(value: VisibilityPubPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<VisibilityDefaultGreen<'db>> for VisibilityGreen<'db> {
    fn from(value: VisibilityDefaultGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<VisibilityPubGreen<'db>> for VisibilityGreen<'db> {
    fn from(value: VisibilityPubGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct VisibilityGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for Visibility<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = VisibilityPtr<'db>;
    type Green = VisibilityGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::VisibilityDefault => {
                Visibility::Default(VisibilityDefault::from_syntax_node(db, node))
            }
            SyntaxKind::VisibilityPub => Visibility::Pub(VisibilityPub::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Visibility"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::VisibilityDefault => {
                Some(Visibility::Default(VisibilityDefault::from_syntax_node(db, node)))
            }
            SyntaxKind::VisibilityPub => {
                Some(Visibility::Pub(VisibilityPub::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            Visibility::Default(x) => x.as_syntax_node(),
            Visibility::Pub(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        VisibilityPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> Visibility<'db> {
    /// Checks if a kind of a variant of [Visibility].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::VisibilityDefault | SyntaxKind::VisibilityPub)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemModule<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemModule<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_MODULE_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_BODY: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        module_kw: TerminalModuleGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        body: MaybeModuleBodyGreen<'db>,
    ) -> ItemModuleGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, visibility.0, module_kw.0, name.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemModule,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemModule<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn module_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalModule<'db> {
        TerminalModule::from_syntax_node(db, self.children[2])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[3])
    }
    pub fn body(&self, db: &'db dyn SyntaxGroup) -> MaybeModuleBody<'db> {
        MaybeModuleBody::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemModulePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemModulePtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemModulePtr<'db> {
    type SyntaxNode = ItemModule<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemModule<'db> {
        ItemModule::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemModulePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemModulePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemModuleGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemModule<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemModule);
    type StablePtr = ItemModulePtr<'db>;
    type Green = ItemModuleGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemModule,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalModule::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        MaybeModuleBody::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemModule,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemModule
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemModule { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemModulePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum MaybeModuleBody<'db> {
    Some(ModuleBody<'db>),
    None(TerminalSemicolon<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MaybeModuleBodyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MaybeModuleBodyPtr<'db> {
    type SyntaxNode = MaybeModuleBody<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        MaybeModuleBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MaybeModuleBodyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MaybeModuleBodyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ModuleBodyPtr<'db>> for MaybeModuleBodyPtr<'db> {
    fn from(value: ModuleBodyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonPtr<'db>> for MaybeModuleBodyPtr<'db> {
    fn from(value: TerminalSemicolonPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ModuleBodyGreen<'db>> for MaybeModuleBodyGreen<'db> {
    fn from(value: ModuleBodyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonGreen<'db>> for MaybeModuleBodyGreen<'db> {
    fn from(value: TerminalSemicolonGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MaybeModuleBodyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MaybeModuleBody<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeModuleBodyPtr<'db>;
    type Green = MaybeModuleBodyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ModuleBody => MaybeModuleBody::Some(ModuleBody::from_syntax_node(db, node)),
            SyntaxKind::TerminalSemicolon => {
                MaybeModuleBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MaybeModuleBody")
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ModuleBody => {
                Some(MaybeModuleBody::Some(ModuleBody::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalSemicolon => {
                Some(MaybeModuleBody::None(TerminalSemicolon::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            MaybeModuleBody::Some(x) => x.as_syntax_node(),
            MaybeModuleBody::None(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MaybeModuleBodyPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> MaybeModuleBody<'db> {
    /// Checks if a kind of a variant of [MaybeModuleBody].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::ModuleBody | SyntaxKind::TerminalSemicolon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ModuleBody<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ModuleBody<'db> {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ITEMS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen<'db>,
        items: ModuleItemListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> ModuleBodyGreen<'db> {
        let children: Vec<GreenId> = vec![lbrace.0, items.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ModuleBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleBody,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ModuleBody<'db> {
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[0])
    }
    pub fn items(&self, db: &'db dyn SyntaxGroup) -> ModuleItemList<'db> {
        ModuleItemList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModuleBodyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ModuleBodyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ModuleBodyPtr<'db> {
    type SyntaxNode = ModuleBody<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ModuleBody<'db> {
        ModuleBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ModuleBodyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ModuleBodyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ModuleBodyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ModuleBody<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ModuleBody);
    type StablePtr = ModuleBodyPtr<'db>;
    type Green = ModuleBodyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ModuleBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleBody,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        ModuleItemList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ModuleBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ModuleBody
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ModuleBody { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ModuleBodyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct FunctionDeclaration<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> FunctionDeclaration<'db> {
    pub const INDEX_OPTIONAL_CONST: usize = 0;
    pub const INDEX_FUNCTION_KW: usize = 1;
    pub const INDEX_NAME: usize = 2;
    pub const INDEX_GENERIC_PARAMS: usize = 3;
    pub const INDEX_SIGNATURE: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        optional_const: OptionTerminalConstGreen<'db>,
        function_kw: TerminalFunctionGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        generic_params: OptionWrappedGenericParamListGreen<'db>,
        signature: FunctionSignatureGreen<'db>,
    ) -> FunctionDeclarationGreen<'db> {
        let children: Vec<GreenId> =
            vec![optional_const.0, function_kw.0, name.0, generic_params.0, signature.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        FunctionDeclarationGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionDeclaration,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> FunctionDeclaration<'db> {
    pub fn optional_const(&self, db: &'db dyn SyntaxGroup) -> OptionTerminalConst<'db> {
        OptionTerminalConst::from_syntax_node(db, self.children[0])
    }
    pub fn function_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalFunction<'db> {
        TerminalFunction::from_syntax_node(db, self.children[1])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[2])
    }
    pub fn generic_params(&self, db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamList<'db> {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3])
    }
    pub fn signature(&self, db: &'db dyn SyntaxGroup) -> FunctionSignature<'db> {
        FunctionSignature::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct FunctionDeclarationPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> FunctionDeclarationPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for FunctionDeclarationPtr<'db> {
    type SyntaxNode = FunctionDeclaration<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> FunctionDeclaration<'db> {
        FunctionDeclaration::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<FunctionDeclarationPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: FunctionDeclarationPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct FunctionDeclarationGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for FunctionDeclaration<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::FunctionDeclaration);
    type StablePtr = FunctionDeclarationPtr<'db>;
    type Green = FunctionDeclarationGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        FunctionDeclarationGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionDeclaration,
                details: GreenNodeDetails::Node {
                    children: vec![
                        OptionTerminalConst::missing(db).0,
                        TerminalFunction::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        FunctionSignature::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::FunctionDeclaration,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::FunctionDeclaration
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::FunctionDeclaration {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        FunctionDeclarationPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemConstant<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemConstant<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_CONST_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_TYPE_CLAUSE: usize = 4;
    pub const INDEX_EQ: usize = 5;
    pub const INDEX_VALUE: usize = 6;
    pub const INDEX_SEMICOLON: usize = 7;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        const_kw: TerminalConstGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        type_clause: TypeClauseGreen<'db>,
        eq: TerminalEqGreen<'db>,
        value: ExprGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> ItemConstantGreen<'db> {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            const_kw.0,
            name.0,
            type_clause.0,
            eq.0,
            value.0,
            semicolon.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemConstantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemConstant,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemConstant<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn const_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalConst<'db> {
        TerminalConst::from_syntax_node(db, self.children[2])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[3])
    }
    pub fn type_clause(&self, db: &'db dyn SyntaxGroup) -> TypeClause<'db> {
        TypeClause::from_syntax_node(db, self.children[4])
    }
    pub fn eq(&self, db: &'db dyn SyntaxGroup) -> TerminalEq<'db> {
        TerminalEq::from_syntax_node(db, self.children[5])
    }
    pub fn value(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[6])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[7])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemConstantPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemConstantPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemConstantPtr<'db> {
    type SyntaxNode = ItemConstant<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemConstant<'db> {
        ItemConstant::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemConstantPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemConstantPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemConstantGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemConstant<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemConstant);
    type StablePtr = ItemConstantPtr<'db>;
    type Green = ItemConstantGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemConstantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemConstant,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalConst::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TypeClause::missing(db).0,
                        TerminalEq::missing(db).0,
                        Expr::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemConstant,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemConstant
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemConstant { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemConstantPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct FunctionWithBody<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> FunctionWithBody<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_DECLARATION: usize = 2;
    pub const INDEX_BODY: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        declaration: FunctionDeclarationGreen<'db>,
        body: ExprBlockGreen<'db>,
    ) -> FunctionWithBodyGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, visibility.0, declaration.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        FunctionWithBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionWithBody,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> FunctionWithBody<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn declaration(&self, db: &'db dyn SyntaxGroup) -> FunctionDeclaration<'db> {
        FunctionDeclaration::from_syntax_node(db, self.children[2])
    }
    pub fn body(&self, db: &'db dyn SyntaxGroup) -> ExprBlock<'db> {
        ExprBlock::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct FunctionWithBodyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> FunctionWithBodyPtr<'db> {
    pub fn declaration_green(self, db: &'db dyn SyntaxGroup) -> FunctionDeclarationGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            FunctionDeclarationGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for FunctionWithBodyPtr<'db> {
    type SyntaxNode = FunctionWithBody<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> FunctionWithBody<'db> {
        FunctionWithBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<FunctionWithBodyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: FunctionWithBodyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct FunctionWithBodyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for FunctionWithBody<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::FunctionWithBody);
    type StablePtr = FunctionWithBodyPtr<'db>;
    type Green = FunctionWithBodyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        FunctionWithBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionWithBody,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        FunctionDeclaration::missing(db).0,
                        ExprBlock::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::FunctionWithBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::FunctionWithBody
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::FunctionWithBody {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        FunctionWithBodyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemExternFunction<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemExternFunction<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_EXTERN_KW: usize = 2;
    pub const INDEX_DECLARATION: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        extern_kw: TerminalExternGreen<'db>,
        declaration: FunctionDeclarationGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> ItemExternFunctionGreen<'db> {
        let children: Vec<GreenId> =
            vec![attributes.0, visibility.0, extern_kw.0, declaration.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemExternFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemExternFunction,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemExternFunction<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn extern_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalExtern<'db> {
        TerminalExtern::from_syntax_node(db, self.children[2])
    }
    pub fn declaration(&self, db: &'db dyn SyntaxGroup) -> FunctionDeclaration<'db> {
        FunctionDeclaration::from_syntax_node(db, self.children[3])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemExternFunctionPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemExternFunctionPtr<'db> {
    pub fn declaration_green(self, db: &'db dyn SyntaxGroup) -> FunctionDeclarationGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            FunctionDeclarationGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemExternFunctionPtr<'db> {
    type SyntaxNode = ItemExternFunction<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemExternFunction<'db> {
        ItemExternFunction::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemExternFunctionPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemExternFunctionPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemExternFunctionGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemExternFunction<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemExternFunction);
    type StablePtr = ItemExternFunctionPtr<'db>;
    type Green = ItemExternFunctionGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemExternFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemExternFunction,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalExtern::missing(db).0,
                        FunctionDeclaration::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemExternFunction,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemExternFunction
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemExternFunction {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemExternFunctionPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemExternType<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemExternType<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_EXTERN_KW: usize = 2;
    pub const INDEX_TYPE_KW: usize = 3;
    pub const INDEX_NAME: usize = 4;
    pub const INDEX_GENERIC_PARAMS: usize = 5;
    pub const INDEX_SEMICOLON: usize = 6;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        extern_kw: TerminalExternGreen<'db>,
        type_kw: TerminalTypeGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        generic_params: OptionWrappedGenericParamListGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> ItemExternTypeGreen<'db> {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            extern_kw.0,
            type_kw.0,
            name.0,
            generic_params.0,
            semicolon.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemExternTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemExternType,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemExternType<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn extern_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalExtern<'db> {
        TerminalExtern::from_syntax_node(db, self.children[2])
    }
    pub fn type_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalType<'db> {
        TerminalType::from_syntax_node(db, self.children[3])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[4])
    }
    pub fn generic_params(&self, db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamList<'db> {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[5])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[6])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemExternTypePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemExternTypePtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemExternTypePtr<'db> {
    type SyntaxNode = ItemExternType<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemExternType<'db> {
        ItemExternType::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemExternTypePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemExternTypePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemExternTypeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemExternType<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemExternType);
    type StablePtr = ItemExternTypePtr<'db>;
    type Green = ItemExternTypeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemExternTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemExternType,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalExtern::missing(db).0,
                        TerminalType::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemExternType,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemExternType
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemExternType {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemExternTypePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemTrait<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemTrait<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_TRAIT_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_BODY: usize = 5;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        trait_kw: TerminalTraitGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        generic_params: OptionWrappedGenericParamListGreen<'db>,
        body: MaybeTraitBodyGreen<'db>,
    ) -> ItemTraitGreen<'db> {
        let children: Vec<GreenId> =
            vec![attributes.0, visibility.0, trait_kw.0, name.0, generic_params.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemTrait,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemTrait<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn trait_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalTrait<'db> {
        TerminalTrait::from_syntax_node(db, self.children[2])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[3])
    }
    pub fn generic_params(&self, db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamList<'db> {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4])
    }
    pub fn body(&self, db: &'db dyn SyntaxGroup) -> MaybeTraitBody<'db> {
        MaybeTraitBody::from_syntax_node(db, self.children[5])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemTraitPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemTraitPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemTraitPtr<'db> {
    type SyntaxNode = ItemTrait<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemTrait<'db> {
        ItemTrait::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemTraitPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemTraitPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemTraitGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemTrait<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemTrait);
    type StablePtr = ItemTraitPtr<'db>;
    type Green = ItemTraitGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemTrait,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalTrait::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        MaybeTraitBody::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemTrait,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemTrait
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemTrait { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemTraitPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum MaybeTraitBody<'db> {
    Some(TraitBody<'db>),
    None(TerminalSemicolon<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MaybeTraitBodyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MaybeTraitBodyPtr<'db> {
    type SyntaxNode = MaybeTraitBody<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        MaybeTraitBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MaybeTraitBodyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MaybeTraitBodyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TraitBodyPtr<'db>> for MaybeTraitBodyPtr<'db> {
    fn from(value: TraitBodyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonPtr<'db>> for MaybeTraitBodyPtr<'db> {
    fn from(value: TerminalSemicolonPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TraitBodyGreen<'db>> for MaybeTraitBodyGreen<'db> {
    fn from(value: TraitBodyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonGreen<'db>> for MaybeTraitBodyGreen<'db> {
    fn from(value: TerminalSemicolonGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MaybeTraitBodyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MaybeTraitBody<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeTraitBodyPtr<'db>;
    type Green = MaybeTraitBodyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TraitBody => MaybeTraitBody::Some(TraitBody::from_syntax_node(db, node)),
            SyntaxKind::TerminalSemicolon => {
                MaybeTraitBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MaybeTraitBody")
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TraitBody => {
                Some(MaybeTraitBody::Some(TraitBody::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalSemicolon => {
                Some(MaybeTraitBody::None(TerminalSemicolon::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            MaybeTraitBody::Some(x) => x.as_syntax_node(),
            MaybeTraitBody::None(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MaybeTraitBodyPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> MaybeTraitBody<'db> {
    /// Checks if a kind of a variant of [MaybeTraitBody].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::TraitBody | SyntaxKind::TerminalSemicolon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TraitBody<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TraitBody<'db> {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ITEMS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen<'db>,
        items: TraitItemListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> TraitBodyGreen<'db> {
        let children: Vec<GreenId> = vec![lbrace.0, items.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitBody,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TraitBody<'db> {
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[0])
    }
    pub fn items(&self, db: &'db dyn SyntaxGroup) -> TraitItemList<'db> {
        TraitItemList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitBodyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TraitBodyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TraitBodyPtr<'db> {
    type SyntaxNode = TraitBody<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TraitBody<'db> {
        TraitBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TraitBodyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TraitBodyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitBodyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TraitBody<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitBody);
    type StablePtr = TraitBodyPtr<'db>;
    type Green = TraitBodyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TraitBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitBody,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        TraitItemList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitBody
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitBody { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TraitBodyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TraitItemList<'db>(ElementList<'db, TraitItem<'db>, 1>);
impl<'db> Deref for TraitItemList<'db> {
    type Target = ElementList<'db, TraitItem<'db>, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> TraitItemList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<TraitItemGreen<'db>>,
    ) -> TraitItemListGreen<'db> {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        TraitItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TraitItemListPtr<'db> {
    type SyntaxNode = TraitItemList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TraitItemList<'db> {
        TraitItemList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TraitItemListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TraitItemListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TraitItemList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemList);
    type StablePtr = TraitItemListPtr<'db>;
    type Green = TraitItemListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TraitItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::TraitItemList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TraitItemListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum TraitItem<'db> {
    Function(TraitItemFunction<'db>),
    Type(TraitItemType<'db>),
    Constant(TraitItemConstant<'db>),
    Impl(TraitItemImpl<'db>),
    Missing(TraitItemMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TraitItemPtr<'db> {
    type SyntaxNode = TraitItem<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        TraitItem::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TraitItemPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TraitItemPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TraitItemFunctionPtr<'db>> for TraitItemPtr<'db> {
    fn from(value: TraitItemFunctionPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TraitItemTypePtr<'db>> for TraitItemPtr<'db> {
    fn from(value: TraitItemTypePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TraitItemConstantPtr<'db>> for TraitItemPtr<'db> {
    fn from(value: TraitItemConstantPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TraitItemImplPtr<'db>> for TraitItemPtr<'db> {
    fn from(value: TraitItemImplPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TraitItemMissingPtr<'db>> for TraitItemPtr<'db> {
    fn from(value: TraitItemMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TraitItemFunctionGreen<'db>> for TraitItemGreen<'db> {
    fn from(value: TraitItemFunctionGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TraitItemTypeGreen<'db>> for TraitItemGreen<'db> {
    fn from(value: TraitItemTypeGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TraitItemConstantGreen<'db>> for TraitItemGreen<'db> {
    fn from(value: TraitItemConstantGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TraitItemImplGreen<'db>> for TraitItemGreen<'db> {
    fn from(value: TraitItemImplGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TraitItemMissingGreen<'db>> for TraitItemGreen<'db> {
    fn from(value: TraitItemMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TraitItem<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = TraitItemPtr<'db>;
    type Green = TraitItemGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TraitItemGreen(TraitItemMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TraitItemFunction => {
                TraitItem::Function(TraitItemFunction::from_syntax_node(db, node))
            }
            SyntaxKind::TraitItemType => TraitItem::Type(TraitItemType::from_syntax_node(db, node)),
            SyntaxKind::TraitItemConstant => {
                TraitItem::Constant(TraitItemConstant::from_syntax_node(db, node))
            }
            SyntaxKind::TraitItemImpl => TraitItem::Impl(TraitItemImpl::from_syntax_node(db, node)),
            SyntaxKind::TraitItemMissing => {
                TraitItem::Missing(TraitItemMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "TraitItem"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TraitItemFunction => {
                Some(TraitItem::Function(TraitItemFunction::from_syntax_node(db, node)))
            }
            SyntaxKind::TraitItemType => {
                Some(TraitItem::Type(TraitItemType::from_syntax_node(db, node)))
            }
            SyntaxKind::TraitItemConstant => {
                Some(TraitItem::Constant(TraitItemConstant::from_syntax_node(db, node)))
            }
            SyntaxKind::TraitItemImpl => {
                Some(TraitItem::Impl(TraitItemImpl::from_syntax_node(db, node)))
            }
            SyntaxKind::TraitItemMissing => {
                Some(TraitItem::Missing(TraitItemMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            TraitItem::Function(x) => x.as_syntax_node(),
            TraitItem::Type(x) => x.as_syntax_node(),
            TraitItem::Constant(x) => x.as_syntax_node(),
            TraitItem::Impl(x) => x.as_syntax_node(),
            TraitItem::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TraitItemPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> TraitItem<'db> {
    /// Checks if a kind of a variant of [TraitItem].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TraitItemFunction
                | SyntaxKind::TraitItemType
                | SyntaxKind::TraitItemConstant
                | SyntaxKind::TraitItemImpl
                | SyntaxKind::TraitItemMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TraitItemMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TraitItemMissing<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> TraitItemMissingGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TraitItemMissing<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TraitItemMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TraitItemMissingPtr<'db> {
    type SyntaxNode = TraitItemMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TraitItemMissing<'db> {
        TraitItemMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TraitItemMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TraitItemMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TraitItemMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemMissing);
    type StablePtr = TraitItemMissingPtr<'db>;
    type Green = TraitItemMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TraitItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitItemMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TraitItemMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TraitItemFunction<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TraitItemFunction<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_DECLARATION: usize = 1;
    pub const INDEX_BODY: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        declaration: FunctionDeclarationGreen<'db>,
        body: MaybeTraitFunctionBodyGreen<'db>,
    ) -> TraitItemFunctionGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, declaration.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitItemFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemFunction,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TraitItemFunction<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn declaration(&self, db: &'db dyn SyntaxGroup) -> FunctionDeclaration<'db> {
        FunctionDeclaration::from_syntax_node(db, self.children[1])
    }
    pub fn body(&self, db: &'db dyn SyntaxGroup) -> MaybeTraitFunctionBody<'db> {
        MaybeTraitFunctionBody::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemFunctionPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TraitItemFunctionPtr<'db> {
    pub fn declaration_green(self, db: &'db dyn SyntaxGroup) -> FunctionDeclarationGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            FunctionDeclarationGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for TraitItemFunctionPtr<'db> {
    type SyntaxNode = TraitItemFunction<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TraitItemFunction<'db> {
        TraitItemFunction::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TraitItemFunctionPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TraitItemFunctionPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemFunctionGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TraitItemFunction<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemFunction);
    type StablePtr = TraitItemFunctionPtr<'db>;
    type Green = TraitItemFunctionGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TraitItemFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemFunction,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        FunctionDeclaration::missing(db).0,
                        MaybeTraitFunctionBody::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemFunction,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemFunction
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitItemFunction {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TraitItemFunctionPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TraitItemType<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TraitItemType<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_TYPE_KW: usize = 1;
    pub const INDEX_NAME: usize = 2;
    pub const INDEX_GENERIC_PARAMS: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        type_kw: TerminalTypeGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        generic_params: OptionWrappedGenericParamListGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> TraitItemTypeGreen<'db> {
        let children: Vec<GreenId> =
            vec![attributes.0, type_kw.0, name.0, generic_params.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitItemTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemType,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TraitItemType<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn type_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalType<'db> {
        TerminalType::from_syntax_node(db, self.children[1])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[2])
    }
    pub fn generic_params(&self, db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamList<'db> {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemTypePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TraitItemTypePtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for TraitItemTypePtr<'db> {
    type SyntaxNode = TraitItemType<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TraitItemType<'db> {
        TraitItemType::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TraitItemTypePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TraitItemTypePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemTypeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TraitItemType<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemType);
    type StablePtr = TraitItemTypePtr<'db>;
    type Green = TraitItemTypeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TraitItemTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemType,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalType::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemType,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemType
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitItemType {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TraitItemTypePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TraitItemConstant<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TraitItemConstant<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_CONST_KW: usize = 1;
    pub const INDEX_NAME: usize = 2;
    pub const INDEX_TYPE_CLAUSE: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        const_kw: TerminalConstGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        type_clause: TypeClauseGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> TraitItemConstantGreen<'db> {
        let children: Vec<GreenId> =
            vec![attributes.0, const_kw.0, name.0, type_clause.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitItemConstantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemConstant,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TraitItemConstant<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn const_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalConst<'db> {
        TerminalConst::from_syntax_node(db, self.children[1])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[2])
    }
    pub fn type_clause(&self, db: &'db dyn SyntaxGroup) -> TypeClause<'db> {
        TypeClause::from_syntax_node(db, self.children[3])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemConstantPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TraitItemConstantPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for TraitItemConstantPtr<'db> {
    type SyntaxNode = TraitItemConstant<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TraitItemConstant<'db> {
        TraitItemConstant::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TraitItemConstantPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TraitItemConstantPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemConstantGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TraitItemConstant<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemConstant);
    type StablePtr = TraitItemConstantPtr<'db>;
    type Green = TraitItemConstantGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TraitItemConstantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemConstant,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalConst::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TypeClause::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemConstant,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemConstant
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitItemConstant {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TraitItemConstantPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TraitItemImpl<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TraitItemImpl<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_IMPL_KW: usize = 1;
    pub const INDEX_NAME: usize = 2;
    pub const INDEX_COLON: usize = 3;
    pub const INDEX_TRAIT_PATH: usize = 4;
    pub const INDEX_SEMICOLON: usize = 5;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        impl_kw: TerminalImplGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        colon: TerminalColonGreen<'db>,
        trait_path: ExprPathGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> TraitItemImplGreen<'db> {
        let children: Vec<GreenId> =
            vec![attributes.0, impl_kw.0, name.0, colon.0, trait_path.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitItemImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemImpl,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TraitItemImpl<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn impl_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalImpl<'db> {
        TerminalImpl::from_syntax_node(db, self.children[1])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[2])
    }
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[3])
    }
    pub fn trait_path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[4])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[5])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemImplPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TraitItemImplPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for TraitItemImplPtr<'db> {
    type SyntaxNode = TraitItemImpl<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TraitItemImpl<'db> {
        TraitItemImpl::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TraitItemImplPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TraitItemImplPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TraitItemImplGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TraitItemImpl<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemImpl);
    type StablePtr = TraitItemImplPtr<'db>;
    type Green = TraitItemImplGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TraitItemImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemImpl,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalImpl::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        ExprPath::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemImpl,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemImpl
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitItemImpl {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TraitItemImplPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum MaybeTraitFunctionBody<'db> {
    Some(ExprBlock<'db>),
    None(TerminalSemicolon<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MaybeTraitFunctionBodyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MaybeTraitFunctionBodyPtr<'db> {
    type SyntaxNode = MaybeTraitFunctionBody<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        MaybeTraitFunctionBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MaybeTraitFunctionBodyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MaybeTraitFunctionBodyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ExprBlockPtr<'db>> for MaybeTraitFunctionBodyPtr<'db> {
    fn from(value: ExprBlockPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonPtr<'db>> for MaybeTraitFunctionBodyPtr<'db> {
    fn from(value: TerminalSemicolonPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ExprBlockGreen<'db>> for MaybeTraitFunctionBodyGreen<'db> {
    fn from(value: ExprBlockGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonGreen<'db>> for MaybeTraitFunctionBodyGreen<'db> {
    fn from(value: TerminalSemicolonGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MaybeTraitFunctionBodyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MaybeTraitFunctionBody<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeTraitFunctionBodyPtr<'db>;
    type Green = MaybeTraitFunctionBodyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprBlock => {
                MaybeTraitFunctionBody::Some(ExprBlock::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalSemicolon => {
                MaybeTraitFunctionBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "MaybeTraitFunctionBody"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprBlock => {
                Some(MaybeTraitFunctionBody::Some(ExprBlock::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalSemicolon => {
                Some(MaybeTraitFunctionBody::None(TerminalSemicolon::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            MaybeTraitFunctionBody::Some(x) => x.as_syntax_node(),
            MaybeTraitFunctionBody::None(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MaybeTraitFunctionBodyPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> MaybeTraitFunctionBody<'db> {
    /// Checks if a kind of a variant of [MaybeTraitFunctionBody].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::ExprBlock | SyntaxKind::TerminalSemicolon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemImpl<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemImpl<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_IMPL_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_OF_KW: usize = 5;
    pub const INDEX_TRAIT_PATH: usize = 6;
    pub const INDEX_BODY: usize = 7;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        impl_kw: TerminalImplGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        generic_params: OptionWrappedGenericParamListGreen<'db>,
        of_kw: TerminalOfGreen<'db>,
        trait_path: ExprPathGreen<'db>,
        body: MaybeImplBodyGreen<'db>,
    ) -> ItemImplGreen<'db> {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            impl_kw.0,
            name.0,
            generic_params.0,
            of_kw.0,
            trait_path.0,
            body.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemImpl,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemImpl<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn impl_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalImpl<'db> {
        TerminalImpl::from_syntax_node(db, self.children[2])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[3])
    }
    pub fn generic_params(&self, db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamList<'db> {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4])
    }
    pub fn of_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalOf<'db> {
        TerminalOf::from_syntax_node(db, self.children[5])
    }
    pub fn trait_path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[6])
    }
    pub fn body(&self, db: &'db dyn SyntaxGroup) -> MaybeImplBody<'db> {
        MaybeImplBody::from_syntax_node(db, self.children[7])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemImplPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemImplPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemImplPtr<'db> {
    type SyntaxNode = ItemImpl<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemImpl<'db> {
        ItemImpl::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemImplPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemImplPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemImplGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemImpl<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemImpl);
    type StablePtr = ItemImplPtr<'db>;
    type Green = ItemImplGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemImpl,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalImpl::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalOf::missing(db).0,
                        ExprPath::missing(db).0,
                        MaybeImplBody::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemImpl,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemImpl
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemImpl { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemImplPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemHeaderDoc<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemHeaderDoc<'db> {
    pub const INDEX_EMPTY: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        empty: TerminalEmptyGreen<'db>,
    ) -> ItemHeaderDocGreen<'db> {
        let children: Vec<GreenId> = vec![empty.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemHeaderDocGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemHeaderDoc,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemHeaderDoc<'db> {
    pub fn empty(&self, db: &'db dyn SyntaxGroup) -> TerminalEmpty<'db> {
        TerminalEmpty::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemHeaderDocPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemHeaderDocPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ItemHeaderDocPtr<'db> {
    type SyntaxNode = ItemHeaderDoc<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemHeaderDoc<'db> {
        ItemHeaderDoc::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemHeaderDocPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemHeaderDocPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemHeaderDocGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemHeaderDoc<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemHeaderDoc);
    type StablePtr = ItemHeaderDocPtr<'db>;
    type Green = ItemHeaderDocGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemHeaderDocGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemHeaderDoc,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalEmpty::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemHeaderDoc,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemHeaderDoc
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemHeaderDoc {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemHeaderDocPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum MaybeImplBody<'db> {
    Some(ImplBody<'db>),
    None(TerminalSemicolon<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MaybeImplBodyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MaybeImplBodyPtr<'db> {
    type SyntaxNode = MaybeImplBody<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        MaybeImplBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MaybeImplBodyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MaybeImplBodyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ImplBodyPtr<'db>> for MaybeImplBodyPtr<'db> {
    fn from(value: ImplBodyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonPtr<'db>> for MaybeImplBodyPtr<'db> {
    fn from(value: TerminalSemicolonPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ImplBodyGreen<'db>> for MaybeImplBodyGreen<'db> {
    fn from(value: ImplBodyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonGreen<'db>> for MaybeImplBodyGreen<'db> {
    fn from(value: TerminalSemicolonGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MaybeImplBodyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MaybeImplBody<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeImplBodyPtr<'db>;
    type Green = MaybeImplBodyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ImplBody => MaybeImplBody::Some(ImplBody::from_syntax_node(db, node)),
            SyntaxKind::TerminalSemicolon => {
                MaybeImplBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MaybeImplBody"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ImplBody => Some(MaybeImplBody::Some(ImplBody::from_syntax_node(db, node))),
            SyntaxKind::TerminalSemicolon => {
                Some(MaybeImplBody::None(TerminalSemicolon::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            MaybeImplBody::Some(x) => x.as_syntax_node(),
            MaybeImplBody::None(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MaybeImplBodyPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> MaybeImplBody<'db> {
    /// Checks if a kind of a variant of [MaybeImplBody].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::ImplBody | SyntaxKind::TerminalSemicolon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ImplBody<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ImplBody<'db> {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ITEMS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen<'db>,
        items: ImplItemListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> ImplBodyGreen<'db> {
        let children: Vec<GreenId> = vec![lbrace.0, items.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ImplBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplBody,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ImplBody<'db> {
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[0])
    }
    pub fn items(&self, db: &'db dyn SyntaxGroup) -> ImplItemList<'db> {
        ImplItemList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplBodyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ImplBodyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ImplBodyPtr<'db> {
    type SyntaxNode = ImplBody<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ImplBody<'db> {
        ImplBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ImplBodyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ImplBodyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplBodyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ImplBody<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplBody);
    type StablePtr = ImplBodyPtr<'db>;
    type Green = ImplBodyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ImplBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplBody,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        ImplItemList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ImplBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ImplBody
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ImplBody { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ImplBodyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ImplItemList<'db>(ElementList<'db, ImplItem<'db>, 1>);
impl<'db> Deref for ImplItemList<'db> {
    type Target = ElementList<'db, ImplItem<'db>, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> ImplItemList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<ImplItemGreen<'db>>,
    ) -> ImplItemListGreen<'db> {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        ImplItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplItemList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplItemListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ImplItemListPtr<'db> {
    type SyntaxNode = ImplItemList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ImplItemList<'db> {
        ImplItemList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ImplItemListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ImplItemListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplItemListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ImplItemList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplItemList);
    type StablePtr = ImplItemListPtr<'db>;
    type Green = ImplItemListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ImplItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplItemList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ImplItemList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ImplItemListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum ImplItem<'db> {
    Function(FunctionWithBody<'db>),
    Type(ItemTypeAlias<'db>),
    Constant(ItemConstant<'db>),
    Impl(ItemImplAlias<'db>),
    Module(ItemModule<'db>),
    Use(ItemUse<'db>),
    ExternFunction(ItemExternFunction<'db>),
    ExternType(ItemExternType<'db>),
    Trait(ItemTrait<'db>),
    Struct(ItemStruct<'db>),
    Enum(ItemEnum<'db>),
    Missing(ImplItemMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplItemPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for ImplItemPtr<'db> {
    type SyntaxNode = ImplItem<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        ImplItem::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ImplItemPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ImplItemPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<FunctionWithBodyPtr<'db>> for ImplItemPtr<'db> {
    fn from(value: FunctionWithBodyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemTypeAliasPtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ItemTypeAliasPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemConstantPtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ItemConstantPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemImplAliasPtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ItemImplAliasPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemModulePtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ItemModulePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemUsePtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ItemUsePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemExternFunctionPtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ItemExternFunctionPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemExternTypePtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ItemExternTypePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemTraitPtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ItemTraitPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemStructPtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ItemStructPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemEnumPtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ItemEnumPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ImplItemMissingPtr<'db>> for ImplItemPtr<'db> {
    fn from(value: ImplItemMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<FunctionWithBodyGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: FunctionWithBodyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemTypeAliasGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ItemTypeAliasGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemConstantGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ItemConstantGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemImplAliasGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ItemImplAliasGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemModuleGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ItemModuleGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemUseGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ItemUseGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemExternFunctionGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ItemExternFunctionGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemExternTypeGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ItemExternTypeGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemTraitGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ItemTraitGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemStructGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ItemStructGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ItemEnumGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ItemEnumGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ImplItemMissingGreen<'db>> for ImplItemGreen<'db> {
    fn from(value: ImplItemMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplItemGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ImplItem<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ImplItemPtr<'db>;
    type Green = ImplItemGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ImplItemGreen(ImplItemMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::FunctionWithBody => {
                ImplItem::Function(FunctionWithBody::from_syntax_node(db, node))
            }
            SyntaxKind::ItemTypeAlias => ImplItem::Type(ItemTypeAlias::from_syntax_node(db, node)),
            SyntaxKind::ItemConstant => {
                ImplItem::Constant(ItemConstant::from_syntax_node(db, node))
            }
            SyntaxKind::ItemImplAlias => ImplItem::Impl(ItemImplAlias::from_syntax_node(db, node)),
            SyntaxKind::ItemModule => ImplItem::Module(ItemModule::from_syntax_node(db, node)),
            SyntaxKind::ItemUse => ImplItem::Use(ItemUse::from_syntax_node(db, node)),
            SyntaxKind::ItemExternFunction => {
                ImplItem::ExternFunction(ItemExternFunction::from_syntax_node(db, node))
            }
            SyntaxKind::ItemExternType => {
                ImplItem::ExternType(ItemExternType::from_syntax_node(db, node))
            }
            SyntaxKind::ItemTrait => ImplItem::Trait(ItemTrait::from_syntax_node(db, node)),
            SyntaxKind::ItemStruct => ImplItem::Struct(ItemStruct::from_syntax_node(db, node)),
            SyntaxKind::ItemEnum => ImplItem::Enum(ItemEnum::from_syntax_node(db, node)),
            SyntaxKind::ImplItemMissing => {
                ImplItem::Missing(ImplItemMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "ImplItem"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::FunctionWithBody => {
                Some(ImplItem::Function(FunctionWithBody::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemTypeAlias => {
                Some(ImplItem::Type(ItemTypeAlias::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemConstant => {
                Some(ImplItem::Constant(ItemConstant::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemImplAlias => {
                Some(ImplItem::Impl(ItemImplAlias::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemModule => {
                Some(ImplItem::Module(ItemModule::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemUse => Some(ImplItem::Use(ItemUse::from_syntax_node(db, node))),
            SyntaxKind::ItemExternFunction => {
                Some(ImplItem::ExternFunction(ItemExternFunction::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemExternType => {
                Some(ImplItem::ExternType(ItemExternType::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemTrait => Some(ImplItem::Trait(ItemTrait::from_syntax_node(db, node))),
            SyntaxKind::ItemStruct => {
                Some(ImplItem::Struct(ItemStruct::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemEnum => Some(ImplItem::Enum(ItemEnum::from_syntax_node(db, node))),
            SyntaxKind::ImplItemMissing => {
                Some(ImplItem::Missing(ImplItemMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            ImplItem::Function(x) => x.as_syntax_node(),
            ImplItem::Type(x) => x.as_syntax_node(),
            ImplItem::Constant(x) => x.as_syntax_node(),
            ImplItem::Impl(x) => x.as_syntax_node(),
            ImplItem::Module(x) => x.as_syntax_node(),
            ImplItem::Use(x) => x.as_syntax_node(),
            ImplItem::ExternFunction(x) => x.as_syntax_node(),
            ImplItem::ExternType(x) => x.as_syntax_node(),
            ImplItem::Trait(x) => x.as_syntax_node(),
            ImplItem::Struct(x) => x.as_syntax_node(),
            ImplItem::Enum(x) => x.as_syntax_node(),
            ImplItem::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ImplItemPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> ImplItem<'db> {
    /// Checks if a kind of a variant of [ImplItem].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::FunctionWithBody
                | SyntaxKind::ItemTypeAlias
                | SyntaxKind::ItemConstant
                | SyntaxKind::ItemImplAlias
                | SyntaxKind::ItemModule
                | SyntaxKind::ItemUse
                | SyntaxKind::ItemExternFunction
                | SyntaxKind::ItemExternType
                | SyntaxKind::ItemTrait
                | SyntaxKind::ItemStruct
                | SyntaxKind::ItemEnum
                | SyntaxKind::ImplItemMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ImplItemMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ImplItemMissing<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> ImplItemMissingGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ImplItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplItemMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ImplItemMissing<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplItemMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ImplItemMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ImplItemMissingPtr<'db> {
    type SyntaxNode = ImplItemMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ImplItemMissing<'db> {
        ImplItemMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ImplItemMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ImplItemMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ImplItemMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ImplItemMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplItemMissing);
    type StablePtr = ImplItemMissingPtr<'db>;
    type Green = ImplItemMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ImplItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplItemMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ImplItemMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ImplItemMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ImplItemMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ImplItemMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemImplAlias<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemImplAlias<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_IMPL_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_EQ: usize = 5;
    pub const INDEX_IMPL_PATH: usize = 6;
    pub const INDEX_SEMICOLON: usize = 7;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        impl_kw: TerminalImplGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        generic_params: OptionWrappedGenericParamListGreen<'db>,
        eq: TerminalEqGreen<'db>,
        impl_path: ExprPathGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> ItemImplAliasGreen<'db> {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            impl_kw.0,
            name.0,
            generic_params.0,
            eq.0,
            impl_path.0,
            semicolon.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemImplAliasGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemImplAlias,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemImplAlias<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn impl_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalImpl<'db> {
        TerminalImpl::from_syntax_node(db, self.children[2])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[3])
    }
    pub fn generic_params(&self, db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamList<'db> {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4])
    }
    pub fn eq(&self, db: &'db dyn SyntaxGroup) -> TerminalEq<'db> {
        TerminalEq::from_syntax_node(db, self.children[5])
    }
    pub fn impl_path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[6])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[7])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemImplAliasPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemImplAliasPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemImplAliasPtr<'db> {
    type SyntaxNode = ItemImplAlias<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemImplAlias<'db> {
        ItemImplAlias::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemImplAliasPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemImplAliasPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemImplAliasGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemImplAlias<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemImplAlias);
    type StablePtr = ItemImplAliasPtr<'db>;
    type Green = ItemImplAliasGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemImplAliasGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemImplAlias,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalImpl::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalEq::missing(db).0,
                        ExprPath::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemImplAlias,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemImplAlias
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemImplAlias {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemImplAliasPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemStruct<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemStruct<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_STRUCT_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_LBRACE: usize = 5;
    pub const INDEX_MEMBERS: usize = 6;
    pub const INDEX_RBRACE: usize = 7;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        struct_kw: TerminalStructGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        generic_params: OptionWrappedGenericParamListGreen<'db>,
        lbrace: TerminalLBraceGreen<'db>,
        members: MemberListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> ItemStructGreen<'db> {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            struct_kw.0,
            name.0,
            generic_params.0,
            lbrace.0,
            members.0,
            rbrace.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemStruct,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemStruct<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn struct_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalStruct<'db> {
        TerminalStruct::from_syntax_node(db, self.children[2])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[3])
    }
    pub fn generic_params(&self, db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamList<'db> {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4])
    }
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[5])
    }
    pub fn members(&self, db: &'db dyn SyntaxGroup) -> MemberList<'db> {
        MemberList::from_syntax_node(db, self.children[6])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[7])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemStructPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemStructPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemStructPtr<'db> {
    type SyntaxNode = ItemStruct<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemStruct<'db> {
        ItemStruct::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemStructPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemStructPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemStructGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemStruct<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemStruct);
    type StablePtr = ItemStructPtr<'db>;
    type Green = ItemStructGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemStruct,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalStruct::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalLBrace::missing(db).0,
                        MemberList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemStruct,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemStruct
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemStruct { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemStructPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemEnum<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemEnum<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_ENUM_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_LBRACE: usize = 5;
    pub const INDEX_VARIANTS: usize = 6;
    pub const INDEX_RBRACE: usize = 7;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        enum_kw: TerminalEnumGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        generic_params: OptionWrappedGenericParamListGreen<'db>,
        lbrace: TerminalLBraceGreen<'db>,
        variants: VariantListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> ItemEnumGreen<'db> {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            enum_kw.0,
            name.0,
            generic_params.0,
            lbrace.0,
            variants.0,
            rbrace.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemEnum,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemEnum<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn enum_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalEnum<'db> {
        TerminalEnum::from_syntax_node(db, self.children[2])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[3])
    }
    pub fn generic_params(&self, db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamList<'db> {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4])
    }
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[5])
    }
    pub fn variants(&self, db: &'db dyn SyntaxGroup) -> VariantList<'db> {
        VariantList::from_syntax_node(db, self.children[6])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[7])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemEnumPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemEnumPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemEnumPtr<'db> {
    type SyntaxNode = ItemEnum<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemEnum<'db> {
        ItemEnum::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemEnumPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemEnumPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemEnumGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemEnum<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemEnum);
    type StablePtr = ItemEnumPtr<'db>;
    type Green = ItemEnumGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemEnum,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalEnum::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalLBrace::missing(db).0,
                        VariantList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemEnum,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemEnum
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemEnum { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemEnumPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemTypeAlias<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemTypeAlias<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_TYPE_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_EQ: usize = 5;
    pub const INDEX_TY: usize = 6;
    pub const INDEX_SEMICOLON: usize = 7;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        type_kw: TerminalTypeGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        generic_params: OptionWrappedGenericParamListGreen<'db>,
        eq: TerminalEqGreen<'db>,
        ty: ExprGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> ItemTypeAliasGreen<'db> {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            type_kw.0,
            name.0,
            generic_params.0,
            eq.0,
            ty.0,
            semicolon.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemTypeAliasGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemTypeAlias,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemTypeAlias<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn type_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalType<'db> {
        TerminalType::from_syntax_node(db, self.children[2])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[3])
    }
    pub fn generic_params(&self, db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamList<'db> {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4])
    }
    pub fn eq(&self, db: &'db dyn SyntaxGroup) -> TerminalEq<'db> {
        TerminalEq::from_syntax_node(db, self.children[5])
    }
    pub fn ty(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[6])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[7])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemTypeAliasPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemTypeAliasPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemTypeAliasPtr<'db> {
    type SyntaxNode = ItemTypeAlias<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemTypeAlias<'db> {
        ItemTypeAlias::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemTypeAliasPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemTypeAliasPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemTypeAliasGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemTypeAlias<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemTypeAlias);
    type StablePtr = ItemTypeAliasPtr<'db>;
    type Green = ItemTypeAliasGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemTypeAliasGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemTypeAlias,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalType::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalEq::missing(db).0,
                        Expr::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemTypeAlias,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemTypeAlias
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemTypeAlias {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemTypeAliasPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemUse<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemUse<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_USE_KW: usize = 2;
    pub const INDEX_USE_PATH: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        use_kw: TerminalUseGreen<'db>,
        use_path: UsePathGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> ItemUseGreen<'db> {
        let children: Vec<GreenId> =
            vec![attributes.0, visibility.0, use_kw.0, use_path.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemUse,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemUse<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn use_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalUse<'db> {
        TerminalUse::from_syntax_node(db, self.children[2])
    }
    pub fn use_path(&self, db: &'db dyn SyntaxGroup) -> UsePath<'db> {
        UsePath::from_syntax_node(db, self.children[3])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemUsePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemUsePtr<'db> {
    pub fn use_path_green(self, db: &'db dyn SyntaxGroup) -> UsePathGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            UsePathGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemUsePtr<'db> {
    type SyntaxNode = ItemUse<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemUse<'db> {
        ItemUse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemUsePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemUsePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemUseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemUse<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemUse);
    type StablePtr = ItemUsePtr<'db>;
    type Green = ItemUseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemUse,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalUse::missing(db).0,
                        UsePath::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemUse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemUse
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemUse { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemUsePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum UsePath<'db> {
    Leaf(UsePathLeaf<'db>),
    Single(UsePathSingle<'db>),
    Multi(UsePathMulti<'db>),
    Star(UsePathStar<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for UsePathPtr<'db> {
    type SyntaxNode = UsePath<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        UsePath::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<UsePathPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: UsePathPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<UsePathLeafPtr<'db>> for UsePathPtr<'db> {
    fn from(value: UsePathLeafPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<UsePathSinglePtr<'db>> for UsePathPtr<'db> {
    fn from(value: UsePathSinglePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<UsePathMultiPtr<'db>> for UsePathPtr<'db> {
    fn from(value: UsePathMultiPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<UsePathStarPtr<'db>> for UsePathPtr<'db> {
    fn from(value: UsePathStarPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<UsePathLeafGreen<'db>> for UsePathGreen<'db> {
    fn from(value: UsePathLeafGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<UsePathSingleGreen<'db>> for UsePathGreen<'db> {
    fn from(value: UsePathSingleGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<UsePathMultiGreen<'db>> for UsePathGreen<'db> {
    fn from(value: UsePathMultiGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<UsePathStarGreen<'db>> for UsePathGreen<'db> {
    fn from(value: UsePathStarGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for UsePath<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = UsePathPtr<'db>;
    type Green = UsePathGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::UsePathLeaf => UsePath::Leaf(UsePathLeaf::from_syntax_node(db, node)),
            SyntaxKind::UsePathSingle => UsePath::Single(UsePathSingle::from_syntax_node(db, node)),
            SyntaxKind::UsePathMulti => UsePath::Multi(UsePathMulti::from_syntax_node(db, node)),
            SyntaxKind::UsePathStar => UsePath::Star(UsePathStar::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "UsePath"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::UsePathLeaf => Some(UsePath::Leaf(UsePathLeaf::from_syntax_node(db, node))),
            SyntaxKind::UsePathSingle => {
                Some(UsePath::Single(UsePathSingle::from_syntax_node(db, node)))
            }
            SyntaxKind::UsePathMulti => {
                Some(UsePath::Multi(UsePathMulti::from_syntax_node(db, node)))
            }
            SyntaxKind::UsePathStar => Some(UsePath::Star(UsePathStar::from_syntax_node(db, node))),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            UsePath::Leaf(x) => x.as_syntax_node(),
            UsePath::Single(x) => x.as_syntax_node(),
            UsePath::Multi(x) => x.as_syntax_node(),
            UsePath::Star(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        UsePathPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> UsePath<'db> {
    /// Checks if a kind of a variant of [UsePath].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::UsePathLeaf
                | SyntaxKind::UsePathSingle
                | SyntaxKind::UsePathMulti
                | SyntaxKind::UsePathStar
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct UsePathLeaf<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> UsePathLeaf<'db> {
    pub const INDEX_IDENT: usize = 0;
    pub const INDEX_ALIAS_CLAUSE: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        ident: PathSegmentGreen<'db>,
        alias_clause: OptionAliasClauseGreen<'db>,
    ) -> UsePathLeafGreen<'db> {
        let children: Vec<GreenId> = vec![ident.0, alias_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        UsePathLeafGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathLeaf,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> UsePathLeaf<'db> {
    pub fn ident(&self, db: &'db dyn SyntaxGroup) -> PathSegment<'db> {
        PathSegment::from_syntax_node(db, self.children[0])
    }
    pub fn alias_clause(&self, db: &'db dyn SyntaxGroup) -> OptionAliasClause<'db> {
        OptionAliasClause::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathLeafPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> UsePathLeafPtr<'db> {
    pub fn ident_green(self, db: &'db dyn SyntaxGroup) -> PathSegmentGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            PathSegmentGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn alias_clause_green(self, db: &'db dyn SyntaxGroup) -> OptionAliasClauseGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            OptionAliasClauseGreen(key_fields[1])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for UsePathLeafPtr<'db> {
    type SyntaxNode = UsePathLeaf<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> UsePathLeaf<'db> {
        UsePathLeaf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<UsePathLeafPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: UsePathLeafPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathLeafGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for UsePathLeaf<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::UsePathLeaf);
    type StablePtr = UsePathLeafPtr<'db>;
    type Green = UsePathLeafGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        UsePathLeafGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathLeaf,
                details: GreenNodeDetails::Node {
                    children: vec![PathSegment::missing(db).0, OptionAliasClause::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::UsePathLeaf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::UsePathLeaf
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::UsePathLeaf { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        UsePathLeafPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct UsePathSingle<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> UsePathSingle<'db> {
    pub const INDEX_IDENT: usize = 0;
    pub const INDEX_COLON_COLON: usize = 1;
    pub const INDEX_USE_PATH: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        ident: PathSegmentGreen<'db>,
        colon_colon: TerminalColonColonGreen<'db>,
        use_path: UsePathGreen<'db>,
    ) -> UsePathSingleGreen<'db> {
        let children: Vec<GreenId> = vec![ident.0, colon_colon.0, use_path.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        UsePathSingleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathSingle,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> UsePathSingle<'db> {
    pub fn ident(&self, db: &'db dyn SyntaxGroup) -> PathSegment<'db> {
        PathSegment::from_syntax_node(db, self.children[0])
    }
    pub fn colon_colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColonColon<'db> {
        TerminalColonColon::from_syntax_node(db, self.children[1])
    }
    pub fn use_path(&self, db: &'db dyn SyntaxGroup) -> UsePath<'db> {
        UsePath::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathSinglePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> UsePathSinglePtr<'db> {}
impl<'db> TypedStablePtr<'db> for UsePathSinglePtr<'db> {
    type SyntaxNode = UsePathSingle<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> UsePathSingle<'db> {
        UsePathSingle::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<UsePathSinglePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: UsePathSinglePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathSingleGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for UsePathSingle<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::UsePathSingle);
    type StablePtr = UsePathSinglePtr<'db>;
    type Green = UsePathSingleGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        UsePathSingleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathSingle,
                details: GreenNodeDetails::Node {
                    children: vec![
                        PathSegment::missing(db).0,
                        TerminalColonColon::missing(db).0,
                        UsePath::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::UsePathSingle,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::UsePathSingle
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::UsePathSingle {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        UsePathSinglePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct UsePathMulti<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> UsePathMulti<'db> {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_USE_PATHS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen<'db>,
        use_paths: UsePathListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> UsePathMultiGreen<'db> {
        let children: Vec<GreenId> = vec![lbrace.0, use_paths.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        UsePathMultiGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathMulti,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> UsePathMulti<'db> {
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[0])
    }
    pub fn use_paths(&self, db: &'db dyn SyntaxGroup) -> UsePathList<'db> {
        UsePathList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathMultiPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> UsePathMultiPtr<'db> {}
impl<'db> TypedStablePtr<'db> for UsePathMultiPtr<'db> {
    type SyntaxNode = UsePathMulti<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> UsePathMulti<'db> {
        UsePathMulti::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<UsePathMultiPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: UsePathMultiPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathMultiGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for UsePathMulti<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::UsePathMulti);
    type StablePtr = UsePathMultiPtr<'db>;
    type Green = UsePathMultiGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        UsePathMultiGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathMulti,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        UsePathList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::UsePathMulti,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::UsePathMulti
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::UsePathMulti { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        UsePathMultiPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct UsePathStar<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> UsePathStar<'db> {
    pub const INDEX_STAR: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        star: TerminalMulGreen<'db>,
    ) -> UsePathStarGreen<'db> {
        let children: Vec<GreenId> = vec![star.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        UsePathStarGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathStar,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> UsePathStar<'db> {
    pub fn star(&self, db: &'db dyn SyntaxGroup) -> TerminalMul<'db> {
        TerminalMul::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathStarPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> UsePathStarPtr<'db> {}
impl<'db> TypedStablePtr<'db> for UsePathStarPtr<'db> {
    type SyntaxNode = UsePathStar<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> UsePathStar<'db> {
        UsePathStar::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<UsePathStarPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: UsePathStarPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathStarGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for UsePathStar<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::UsePathStar);
    type StablePtr = UsePathStarPtr<'db>;
    type Green = UsePathStarGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        UsePathStarGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathStar,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalMul::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::UsePathStar,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::UsePathStar
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::UsePathStar { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        UsePathStarPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct UsePathList<'db>(ElementList<'db, UsePath<'db>, 2>);
impl<'db> Deref for UsePathList<'db> {
    type Target = ElementList<'db, UsePath<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> UsePathList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<UsePathListElementOrSeparatorGreen<'db>>,
    ) -> UsePathListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        UsePathListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for UsePathListPtr<'db> {
    type SyntaxNode = UsePathList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> UsePathList<'db> {
        UsePathList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<UsePathListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: UsePathListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum UsePathListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(UsePathGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for UsePathListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        UsePathListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<UsePathGreen<'db>> for UsePathListElementOrSeparatorGreen<'db> {
    fn from(value: UsePathGreen<'db>) -> Self {
        UsePathListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> UsePathListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            UsePathListElementOrSeparatorGreen::Separator(green) => green.0,
            UsePathListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct UsePathListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for UsePathList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::UsePathList);
    type StablePtr = UsePathListPtr<'db>;
    type Green = UsePathListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        UsePathListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::UsePathList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        UsePathListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct AliasClause<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> AliasClause<'db> {
    pub const INDEX_AS_KW: usize = 0;
    pub const INDEX_ALIAS: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        as_kw: TerminalAsGreen<'db>,
        alias: TerminalIdentifierGreen<'db>,
    ) -> AliasClauseGreen<'db> {
        let children: Vec<GreenId> = vec![as_kw.0, alias.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        AliasClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AliasClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> AliasClause<'db> {
    pub fn as_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalAs<'db> {
        TerminalAs::from_syntax_node(db, self.children[0])
    }
    pub fn alias(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AliasClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> AliasClausePtr<'db> {
    pub fn alias_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for AliasClausePtr<'db> {
    type SyntaxNode = AliasClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> AliasClause<'db> {
        AliasClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<AliasClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: AliasClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AliasClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for AliasClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AliasClause);
    type StablePtr = AliasClausePtr<'db>;
    type Green = AliasClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        AliasClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AliasClause,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalAs::missing(db).0, TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::AliasClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::AliasClause
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::AliasClause { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        AliasClausePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionAliasClause<'db> {
    Empty(OptionAliasClauseEmpty<'db>),
    AliasClause(AliasClause<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionAliasClausePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionAliasClausePtr<'db> {
    type SyntaxNode = OptionAliasClause<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionAliasClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionAliasClausePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionAliasClausePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionAliasClauseEmptyPtr<'db>> for OptionAliasClausePtr<'db> {
    fn from(value: OptionAliasClauseEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<AliasClausePtr<'db>> for OptionAliasClausePtr<'db> {
    fn from(value: AliasClausePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionAliasClauseEmptyGreen<'db>> for OptionAliasClauseGreen<'db> {
    fn from(value: OptionAliasClauseEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<AliasClauseGreen<'db>> for OptionAliasClauseGreen<'db> {
    fn from(value: AliasClauseGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionAliasClauseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionAliasClause<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionAliasClausePtr<'db>;
    type Green = OptionAliasClauseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionAliasClauseEmpty => {
                OptionAliasClause::Empty(OptionAliasClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::AliasClause => {
                OptionAliasClause::AliasClause(AliasClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionAliasClause"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionAliasClauseEmpty => {
                Some(OptionAliasClause::Empty(OptionAliasClauseEmpty::from_syntax_node(db, node)))
            }
            SyntaxKind::AliasClause => {
                Some(OptionAliasClause::AliasClause(AliasClause::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionAliasClause::Empty(x) => x.as_syntax_node(),
            OptionAliasClause::AliasClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionAliasClausePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionAliasClause<'db> {
    /// Checks if a kind of a variant of [OptionAliasClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionAliasClauseEmpty | SyntaxKind::AliasClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionAliasClauseEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionAliasClauseEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionAliasClauseEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionAliasClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionAliasClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionAliasClauseEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionAliasClauseEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionAliasClauseEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionAliasClauseEmptyPtr<'db> {
    type SyntaxNode = OptionAliasClauseEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionAliasClauseEmpty<'db> {
        OptionAliasClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionAliasClauseEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionAliasClauseEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionAliasClauseEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionAliasClauseEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionAliasClauseEmpty);
    type StablePtr = OptionAliasClauseEmptyPtr<'db>;
    type Green = OptionAliasClauseEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionAliasClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionAliasClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionAliasClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionAliasClauseEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionAliasClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionAliasClauseEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum GenericArg<'db> {
    Unnamed(GenericArgUnnamed<'db>),
    Named(GenericArgNamed<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for GenericArgPtr<'db> {
    type SyntaxNode = GenericArg<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        GenericArg::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericArgPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericArgPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<GenericArgUnnamedPtr<'db>> for GenericArgPtr<'db> {
    fn from(value: GenericArgUnnamedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericArgNamedPtr<'db>> for GenericArgPtr<'db> {
    fn from(value: GenericArgNamedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericArgUnnamedGreen<'db>> for GenericArgGreen<'db> {
    fn from(value: GenericArgUnnamedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericArgNamedGreen<'db>> for GenericArgGreen<'db> {
    fn from(value: GenericArgNamedGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericArg<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = GenericArgPtr<'db>;
    type Green = GenericArgGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericArgUnnamed => {
                GenericArg::Unnamed(GenericArgUnnamed::from_syntax_node(db, node))
            }
            SyntaxKind::GenericArgNamed => {
                GenericArg::Named(GenericArgNamed::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "GenericArg"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericArgUnnamed => {
                Some(GenericArg::Unnamed(GenericArgUnnamed::from_syntax_node(db, node)))
            }
            SyntaxKind::GenericArgNamed => {
                Some(GenericArg::Named(GenericArgNamed::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            GenericArg::Unnamed(x) => x.as_syntax_node(),
            GenericArg::Named(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericArgPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> GenericArg<'db> {
    /// Checks if a kind of a variant of [GenericArg].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::GenericArgUnnamed | SyntaxKind::GenericArgNamed)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericArgNamed<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> GenericArgNamed<'db> {
    pub const INDEX_NAME: usize = 0;
    pub const INDEX_COLON: usize = 1;
    pub const INDEX_VALUE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        name: TerminalIdentifierGreen<'db>,
        colon: TerminalColonGreen<'db>,
        value: GenericArgValueGreen<'db>,
    ) -> GenericArgNamedGreen<'db> {
        let children: Vec<GreenId> = vec![name.0, colon.0, value.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericArgNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgNamed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> GenericArgNamed<'db> {
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[1])
    }
    pub fn value(&self, db: &'db dyn SyntaxGroup) -> GenericArgValue<'db> {
        GenericArgValue::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgNamedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> GenericArgNamedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for GenericArgNamedPtr<'db> {
    type SyntaxNode = GenericArgNamed<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericArgNamed<'db> {
        GenericArgNamed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericArgNamedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericArgNamedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgNamedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericArgNamed<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgNamed);
    type StablePtr = GenericArgNamedPtr<'db>;
    type Green = GenericArgNamedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericArgNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgNamed,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        GenericArgValue::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericArgNamed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericArgNamed
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericArgNamed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericArgNamedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericArgUnnamed<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> GenericArgUnnamed<'db> {
    pub const INDEX_VALUE: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        value: GenericArgValueGreen<'db>,
    ) -> GenericArgUnnamedGreen<'db> {
        let children: Vec<GreenId> = vec![value.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericArgUnnamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgUnnamed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> GenericArgUnnamed<'db> {
    pub fn value(&self, db: &'db dyn SyntaxGroup) -> GenericArgValue<'db> {
        GenericArgValue::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgUnnamedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> GenericArgUnnamedPtr<'db> {}
impl<'db> TypedStablePtr<'db> for GenericArgUnnamedPtr<'db> {
    type SyntaxNode = GenericArgUnnamed<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericArgUnnamed<'db> {
        GenericArgUnnamed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericArgUnnamedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericArgUnnamedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgUnnamedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericArgUnnamed<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgUnnamed);
    type StablePtr = GenericArgUnnamedPtr<'db>;
    type Green = GenericArgUnnamedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericArgUnnamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgUnnamed,
                details: GreenNodeDetails::Node {
                    children: vec![GenericArgValue::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericArgUnnamed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericArgUnnamed
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericArgUnnamed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericArgUnnamedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum GenericArgValue<'db> {
    Expr(GenericArgValueExpr<'db>),
    Underscore(TerminalUnderscore<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgValuePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for GenericArgValuePtr<'db> {
    type SyntaxNode = GenericArgValue<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        GenericArgValue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericArgValuePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericArgValuePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<GenericArgValueExprPtr<'db>> for GenericArgValuePtr<'db> {
    fn from(value: GenericArgValueExprPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalUnderscorePtr<'db>> for GenericArgValuePtr<'db> {
    fn from(value: TerminalUnderscorePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericArgValueExprGreen<'db>> for GenericArgValueGreen<'db> {
    fn from(value: GenericArgValueExprGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalUnderscoreGreen<'db>> for GenericArgValueGreen<'db> {
    fn from(value: TerminalUnderscoreGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgValueGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericArgValue<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = GenericArgValuePtr<'db>;
    type Green = GenericArgValueGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericArgValueExpr => {
                GenericArgValue::Expr(GenericArgValueExpr::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalUnderscore => {
                GenericArgValue::Underscore(TerminalUnderscore::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "GenericArgValue")
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericArgValueExpr => {
                Some(GenericArgValue::Expr(GenericArgValueExpr::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalUnderscore => {
                Some(GenericArgValue::Underscore(TerminalUnderscore::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            GenericArgValue::Expr(x) => x.as_syntax_node(),
            GenericArgValue::Underscore(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericArgValuePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> GenericArgValue<'db> {
    /// Checks if a kind of a variant of [GenericArgValue].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::GenericArgValueExpr | SyntaxKind::TerminalUnderscore)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericArgValueExpr<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> GenericArgValueExpr<'db> {
    pub const INDEX_EXPR: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        expr: ExprGreen<'db>,
    ) -> GenericArgValueExprGreen<'db> {
        let children: Vec<GreenId> = vec![expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericArgValueExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgValueExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> GenericArgValueExpr<'db> {
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgValueExprPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> GenericArgValueExprPtr<'db> {}
impl<'db> TypedStablePtr<'db> for GenericArgValueExprPtr<'db> {
    type SyntaxNode = GenericArgValueExpr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericArgValueExpr<'db> {
        GenericArgValueExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericArgValueExprPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericArgValueExprPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgValueExprGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericArgValueExpr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgValueExpr);
    type StablePtr = GenericArgValueExprPtr<'db>;
    type Green = GenericArgValueExprGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericArgValueExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgValueExpr,
                details: GreenNodeDetails::Node {
                    children: vec![Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericArgValueExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericArgValueExpr
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericArgValueExpr {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericArgValueExprPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericArgs<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> GenericArgs<'db> {
    pub const INDEX_LANGLE: usize = 0;
    pub const INDEX_GENERIC_ARGS: usize = 1;
    pub const INDEX_RANGLE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        langle: TerminalLTGreen<'db>,
        generic_args: GenericArgListGreen<'db>,
        rangle: TerminalGTGreen<'db>,
    ) -> GenericArgsGreen<'db> {
        let children: Vec<GreenId> = vec![langle.0, generic_args.0, rangle.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericArgsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgs,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> GenericArgs<'db> {
    pub fn langle(&self, db: &'db dyn SyntaxGroup) -> TerminalLT<'db> {
        TerminalLT::from_syntax_node(db, self.children[0])
    }
    pub fn generic_args(&self, db: &'db dyn SyntaxGroup) -> GenericArgList<'db> {
        GenericArgList::from_syntax_node(db, self.children[1])
    }
    pub fn rangle(&self, db: &'db dyn SyntaxGroup) -> TerminalGT<'db> {
        TerminalGT::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgsPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> GenericArgsPtr<'db> {}
impl<'db> TypedStablePtr<'db> for GenericArgsPtr<'db> {
    type SyntaxNode = GenericArgs<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericArgs<'db> {
        GenericArgs::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericArgsPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericArgsPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgsGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericArgs<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgs);
    type StablePtr = GenericArgsPtr<'db>;
    type Green = GenericArgsGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericArgsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgs,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLT::missing(db).0,
                        GenericArgList::missing(db).0,
                        TerminalGT::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericArgs,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericArgs
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericArgs { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericArgsPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericArgList<'db>(ElementList<'db, GenericArg<'db>, 2>);
impl<'db> Deref for GenericArgList<'db> {
    type Target = ElementList<'db, GenericArg<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> GenericArgList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<GenericArgListElementOrSeparatorGreen<'db>>,
    ) -> GenericArgListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        GenericArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for GenericArgListPtr<'db> {
    type SyntaxNode = GenericArgList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericArgList<'db> {
        GenericArgList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericArgListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericArgListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum GenericArgListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(GenericArgGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for GenericArgListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        GenericArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<GenericArgGreen<'db>> for GenericArgListElementOrSeparatorGreen<'db> {
    fn from(value: GenericArgGreen<'db>) -> Self {
        GenericArgListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> GenericArgListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            GenericArgListElementOrSeparatorGreen::Separator(green) => green.0,
            GenericArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericArgListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericArgList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgList);
    type StablePtr = GenericArgListPtr<'db>;
    type Green = GenericArgListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::GenericArgList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericArgListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct AssociatedItemConstraint<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> AssociatedItemConstraint<'db> {
    pub const INDEX_ITEM: usize = 0;
    pub const INDEX_COLON: usize = 1;
    pub const INDEX_VALUE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        item: TerminalIdentifierGreen<'db>,
        colon: TerminalColonGreen<'db>,
        value: ExprGreen<'db>,
    ) -> AssociatedItemConstraintGreen<'db> {
        let children: Vec<GreenId> = vec![item.0, colon.0, value.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        AssociatedItemConstraintGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraint,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> AssociatedItemConstraint<'db> {
    pub fn item(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[1])
    }
    pub fn value(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AssociatedItemConstraintPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> AssociatedItemConstraintPtr<'db> {}
impl<'db> TypedStablePtr<'db> for AssociatedItemConstraintPtr<'db> {
    type SyntaxNode = AssociatedItemConstraint<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> AssociatedItemConstraint<'db> {
        AssociatedItemConstraint::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<AssociatedItemConstraintPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: AssociatedItemConstraintPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AssociatedItemConstraintGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for AssociatedItemConstraint<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AssociatedItemConstraint);
    type StablePtr = AssociatedItemConstraintPtr<'db>;
    type Green = AssociatedItemConstraintGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        AssociatedItemConstraintGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraint,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::AssociatedItemConstraint,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::AssociatedItemConstraint
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::AssociatedItemConstraint {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        AssociatedItemConstraintPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct AssociatedItemConstraints<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> AssociatedItemConstraints<'db> {
    pub const INDEX_LBRACK: usize = 0;
    pub const INDEX_ASSOCIATED_ITEM_CONSTRAINTS: usize = 1;
    pub const INDEX_RBRACK: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrack: TerminalLBrackGreen<'db>,
        associated_item_constraints: AssociatedItemConstraintListGreen<'db>,
        rbrack: TerminalRBrackGreen<'db>,
    ) -> AssociatedItemConstraintsGreen<'db> {
        let children: Vec<GreenId> = vec![lbrack.0, associated_item_constraints.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        AssociatedItemConstraintsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraints,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> AssociatedItemConstraints<'db> {
    pub fn lbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrack<'db> {
        TerminalLBrack::from_syntax_node(db, self.children[0])
    }
    pub fn associated_item_constraints(
        &self,
        db: &'db dyn SyntaxGroup,
    ) -> AssociatedItemConstraintList<'db> {
        AssociatedItemConstraintList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrack<'db> {
        TerminalRBrack::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AssociatedItemConstraintsPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> AssociatedItemConstraintsPtr<'db> {}
impl<'db> TypedStablePtr<'db> for AssociatedItemConstraintsPtr<'db> {
    type SyntaxNode = AssociatedItemConstraints<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> AssociatedItemConstraints<'db> {
        AssociatedItemConstraints::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<AssociatedItemConstraintsPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: AssociatedItemConstraintsPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AssociatedItemConstraintsGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for AssociatedItemConstraints<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AssociatedItemConstraints);
    type StablePtr = AssociatedItemConstraintsPtr<'db>;
    type Green = AssociatedItemConstraintsGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        AssociatedItemConstraintsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraints,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrack::missing(db).0,
                        AssociatedItemConstraintList::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::AssociatedItemConstraints,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::AssociatedItemConstraints
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::AssociatedItemConstraints {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        AssociatedItemConstraintsPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct AssociatedItemConstraintList<'db>(ElementList<'db, AssociatedItemConstraint<'db>, 2>);
impl<'db> Deref for AssociatedItemConstraintList<'db> {
    type Target = ElementList<'db, AssociatedItemConstraint<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> AssociatedItemConstraintList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<AssociatedItemConstraintListElementOrSeparatorGreen<'db>>,
    ) -> AssociatedItemConstraintListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        AssociatedItemConstraintListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraintList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AssociatedItemConstraintListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for AssociatedItemConstraintListPtr<'db> {
    type SyntaxNode = AssociatedItemConstraintList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> AssociatedItemConstraintList<'db> {
        AssociatedItemConstraintList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<AssociatedItemConstraintListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: AssociatedItemConstraintListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum AssociatedItemConstraintListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(AssociatedItemConstraintGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>>
    for AssociatedItemConstraintListElementOrSeparatorGreen<'db>
{
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        AssociatedItemConstraintListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<AssociatedItemConstraintGreen<'db>>
    for AssociatedItemConstraintListElementOrSeparatorGreen<'db>
{
    fn from(value: AssociatedItemConstraintGreen<'db>) -> Self {
        AssociatedItemConstraintListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> AssociatedItemConstraintListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            AssociatedItemConstraintListElementOrSeparatorGreen::Separator(green) => green.0,
            AssociatedItemConstraintListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct AssociatedItemConstraintListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for AssociatedItemConstraintList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AssociatedItemConstraintList);
    type StablePtr = AssociatedItemConstraintListPtr<'db>;
    type Green = AssociatedItemConstraintListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        AssociatedItemConstraintListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraintList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::AssociatedItemConstraintList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        AssociatedItemConstraintListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionAssociatedItemConstraints<'db> {
    Empty(OptionAssociatedItemConstraintsEmpty<'db>),
    AssociatedItemConstraints(AssociatedItemConstraints<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionAssociatedItemConstraintsPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionAssociatedItemConstraintsPtr<'db> {
    type SyntaxNode = OptionAssociatedItemConstraints<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionAssociatedItemConstraints::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionAssociatedItemConstraintsPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionAssociatedItemConstraintsPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionAssociatedItemConstraintsEmptyPtr<'db>>
    for OptionAssociatedItemConstraintsPtr<'db>
{
    fn from(value: OptionAssociatedItemConstraintsEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<AssociatedItemConstraintsPtr<'db>> for OptionAssociatedItemConstraintsPtr<'db> {
    fn from(value: AssociatedItemConstraintsPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionAssociatedItemConstraintsEmptyGreen<'db>>
    for OptionAssociatedItemConstraintsGreen<'db>
{
    fn from(value: OptionAssociatedItemConstraintsEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<AssociatedItemConstraintsGreen<'db>> for OptionAssociatedItemConstraintsGreen<'db> {
    fn from(value: AssociatedItemConstraintsGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionAssociatedItemConstraintsGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionAssociatedItemConstraints<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionAssociatedItemConstraintsPtr<'db>;
    type Green = OptionAssociatedItemConstraintsGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionAssociatedItemConstraintsEmpty => {
                OptionAssociatedItemConstraints::Empty(
                    OptionAssociatedItemConstraintsEmpty::from_syntax_node(db, node),
                )
            }
            SyntaxKind::AssociatedItemConstraints => {
                OptionAssociatedItemConstraints::AssociatedItemConstraints(
                    AssociatedItemConstraints::from_syntax_node(db, node),
                )
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionAssociatedItemConstraints"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionAssociatedItemConstraintsEmpty => {
                Some(OptionAssociatedItemConstraints::Empty(
                    OptionAssociatedItemConstraintsEmpty::from_syntax_node(db, node),
                ))
            }
            SyntaxKind::AssociatedItemConstraints => {
                Some(OptionAssociatedItemConstraints::AssociatedItemConstraints(
                    AssociatedItemConstraints::from_syntax_node(db, node),
                ))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionAssociatedItemConstraints::Empty(x) => x.as_syntax_node(),
            OptionAssociatedItemConstraints::AssociatedItemConstraints(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionAssociatedItemConstraintsPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionAssociatedItemConstraints<'db> {
    /// Checks if a kind of a variant of [OptionAssociatedItemConstraints].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::OptionAssociatedItemConstraintsEmpty
                | SyntaxKind::AssociatedItemConstraints
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionAssociatedItemConstraintsEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionAssociatedItemConstraintsEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionAssociatedItemConstraintsEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionAssociatedItemConstraintsEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionAssociatedItemConstraintsEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionAssociatedItemConstraintsEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionAssociatedItemConstraintsEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionAssociatedItemConstraintsEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionAssociatedItemConstraintsEmptyPtr<'db> {
    type SyntaxNode = OptionAssociatedItemConstraintsEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionAssociatedItemConstraintsEmpty<'db> {
        OptionAssociatedItemConstraintsEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionAssociatedItemConstraintsEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionAssociatedItemConstraintsEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionAssociatedItemConstraintsEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionAssociatedItemConstraintsEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> =
        Some(SyntaxKind::OptionAssociatedItemConstraintsEmpty);
    type StablePtr = OptionAssociatedItemConstraintsEmptyPtr<'db>;
    type Green = OptionAssociatedItemConstraintsEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionAssociatedItemConstraintsEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionAssociatedItemConstraintsEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionAssociatedItemConstraintsEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionAssociatedItemConstraintsEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionAssociatedItemConstraintsEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionAssociatedItemConstraintsEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionWrappedGenericParamList<'db> {
    Empty(OptionWrappedGenericParamListEmpty<'db>),
    WrappedGenericParamList(WrappedGenericParamList<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionWrappedGenericParamListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionWrappedGenericParamListPtr<'db> {
    type SyntaxNode = OptionWrappedGenericParamList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionWrappedGenericParamList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionWrappedGenericParamListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionWrappedGenericParamListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionWrappedGenericParamListEmptyPtr<'db>>
    for OptionWrappedGenericParamListPtr<'db>
{
    fn from(value: OptionWrappedGenericParamListEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<WrappedGenericParamListPtr<'db>> for OptionWrappedGenericParamListPtr<'db> {
    fn from(value: WrappedGenericParamListPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionWrappedGenericParamListEmptyGreen<'db>>
    for OptionWrappedGenericParamListGreen<'db>
{
    fn from(value: OptionWrappedGenericParamListEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<WrappedGenericParamListGreen<'db>> for OptionWrappedGenericParamListGreen<'db> {
    fn from(value: WrappedGenericParamListGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionWrappedGenericParamListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionWrappedGenericParamList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionWrappedGenericParamListPtr<'db>;
    type Green = OptionWrappedGenericParamListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionWrappedGenericParamListEmpty => OptionWrappedGenericParamList::Empty(
                OptionWrappedGenericParamListEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::WrappedGenericParamList => {
                OptionWrappedGenericParamList::WrappedGenericParamList(
                    WrappedGenericParamList::from_syntax_node(db, node),
                )
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionWrappedGenericParamList"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionWrappedGenericParamListEmpty => {
                Some(OptionWrappedGenericParamList::Empty(
                    OptionWrappedGenericParamListEmpty::from_syntax_node(db, node),
                ))
            }
            SyntaxKind::WrappedGenericParamList => {
                Some(OptionWrappedGenericParamList::WrappedGenericParamList(
                    WrappedGenericParamList::from_syntax_node(db, node),
                ))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionWrappedGenericParamList::Empty(x) => x.as_syntax_node(),
            OptionWrappedGenericParamList::WrappedGenericParamList(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionWrappedGenericParamListPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionWrappedGenericParamList<'db> {
    /// Checks if a kind of a variant of [OptionWrappedGenericParamList].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::OptionWrappedGenericParamListEmpty | SyntaxKind::WrappedGenericParamList
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionWrappedGenericParamListEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionWrappedGenericParamListEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamListEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionWrappedGenericParamListEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionWrappedGenericParamListEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionWrappedGenericParamListEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionWrappedGenericParamListEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionWrappedGenericParamListEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionWrappedGenericParamListEmptyPtr<'db> {
    type SyntaxNode = OptionWrappedGenericParamListEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionWrappedGenericParamListEmpty<'db> {
        OptionWrappedGenericParamListEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionWrappedGenericParamListEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionWrappedGenericParamListEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionWrappedGenericParamListEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionWrappedGenericParamListEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionWrappedGenericParamListEmpty);
    type StablePtr = OptionWrappedGenericParamListEmptyPtr<'db>;
    type Green = OptionWrappedGenericParamListEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionWrappedGenericParamListEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionWrappedGenericParamListEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionWrappedGenericParamListEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionWrappedGenericParamListEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionWrappedGenericParamListEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionWrappedGenericParamListEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct WrappedGenericParamList<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> WrappedGenericParamList<'db> {
    pub const INDEX_LANGLE: usize = 0;
    pub const INDEX_GENERIC_PARAMS: usize = 1;
    pub const INDEX_RANGLE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        langle: TerminalLTGreen<'db>,
        generic_params: GenericParamListGreen<'db>,
        rangle: TerminalGTGreen<'db>,
    ) -> WrappedGenericParamListGreen<'db> {
        let children: Vec<GreenId> = vec![langle.0, generic_params.0, rangle.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        WrappedGenericParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::WrappedGenericParamList,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> WrappedGenericParamList<'db> {
    pub fn langle(&self, db: &'db dyn SyntaxGroup) -> TerminalLT<'db> {
        TerminalLT::from_syntax_node(db, self.children[0])
    }
    pub fn generic_params(&self, db: &'db dyn SyntaxGroup) -> GenericParamList<'db> {
        GenericParamList::from_syntax_node(db, self.children[1])
    }
    pub fn rangle(&self, db: &'db dyn SyntaxGroup) -> TerminalGT<'db> {
        TerminalGT::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedGenericParamListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> WrappedGenericParamListPtr<'db> {}
impl<'db> TypedStablePtr<'db> for WrappedGenericParamListPtr<'db> {
    type SyntaxNode = WrappedGenericParamList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> WrappedGenericParamList<'db> {
        WrappedGenericParamList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<WrappedGenericParamListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: WrappedGenericParamListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedGenericParamListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for WrappedGenericParamList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::WrappedGenericParamList);
    type StablePtr = WrappedGenericParamListPtr<'db>;
    type Green = WrappedGenericParamListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        WrappedGenericParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::WrappedGenericParamList,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLT::missing(db).0,
                        GenericParamList::missing(db).0,
                        TerminalGT::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::WrappedGenericParamList,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::WrappedGenericParamList
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::WrappedGenericParamList {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        WrappedGenericParamListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericParamList<'db>(ElementList<'db, GenericParam<'db>, 2>);
impl<'db> Deref for GenericParamList<'db> {
    type Target = ElementList<'db, GenericParam<'db>, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> GenericParamList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<GenericParamListElementOrSeparatorGreen<'db>>,
    ) -> GenericParamListGreen<'db> {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        GenericParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for GenericParamListPtr<'db> {
    type SyntaxNode = GenericParamList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericParamList<'db> {
        GenericParamList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericParamListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericParamListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub enum GenericParamListElementOrSeparatorGreen<'db> {
    Separator(TerminalCommaGreen<'db>),
    Element(GenericParamGreen<'db>),
}
impl<'db> From<TerminalCommaGreen<'db>> for GenericParamListElementOrSeparatorGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        GenericParamListElementOrSeparatorGreen::Separator(value)
    }
}
impl<'db> From<GenericParamGreen<'db>> for GenericParamListElementOrSeparatorGreen<'db> {
    fn from(value: GenericParamGreen<'db>) -> Self {
        GenericParamListElementOrSeparatorGreen::Element(value)
    }
}
impl<'db> GenericParamListElementOrSeparatorGreen<'db> {
    fn id(&self) -> GreenId<'db> {
        match self {
            GenericParamListElementOrSeparatorGreen::Separator(green) => green.0,
            GenericParamListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericParamList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamList);
    type StablePtr = GenericParamListPtr<'db>;
    type Green = GenericParamListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::GenericParamList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericParamListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum GenericParam<'db> {
    Type(GenericParamType<'db>),
    Const(GenericParamConst<'db>),
    ImplNamed(GenericParamImplNamed<'db>),
    ImplAnonymous(GenericParamImplAnonymous<'db>),
    NegativeImpl(GenericParamNegativeImpl<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for GenericParamPtr<'db> {
    type SyntaxNode = GenericParam<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        GenericParam::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericParamPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericParamPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<GenericParamTypePtr<'db>> for GenericParamPtr<'db> {
    fn from(value: GenericParamTypePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericParamConstPtr<'db>> for GenericParamPtr<'db> {
    fn from(value: GenericParamConstPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericParamImplNamedPtr<'db>> for GenericParamPtr<'db> {
    fn from(value: GenericParamImplNamedPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericParamImplAnonymousPtr<'db>> for GenericParamPtr<'db> {
    fn from(value: GenericParamImplAnonymousPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericParamNegativeImplPtr<'db>> for GenericParamPtr<'db> {
    fn from(value: GenericParamNegativeImplPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericParamTypeGreen<'db>> for GenericParamGreen<'db> {
    fn from(value: GenericParamTypeGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericParamConstGreen<'db>> for GenericParamGreen<'db> {
    fn from(value: GenericParamConstGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericParamImplNamedGreen<'db>> for GenericParamGreen<'db> {
    fn from(value: GenericParamImplNamedGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericParamImplAnonymousGreen<'db>> for GenericParamGreen<'db> {
    fn from(value: GenericParamImplAnonymousGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<GenericParamNegativeImplGreen<'db>> for GenericParamGreen<'db> {
    fn from(value: GenericParamNegativeImplGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericParam<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = GenericParamPtr<'db>;
    type Green = GenericParamGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericParamType => {
                GenericParam::Type(GenericParamType::from_syntax_node(db, node))
            }
            SyntaxKind::GenericParamConst => {
                GenericParam::Const(GenericParamConst::from_syntax_node(db, node))
            }
            SyntaxKind::GenericParamImplNamed => {
                GenericParam::ImplNamed(GenericParamImplNamed::from_syntax_node(db, node))
            }
            SyntaxKind::GenericParamImplAnonymous => {
                GenericParam::ImplAnonymous(GenericParamImplAnonymous::from_syntax_node(db, node))
            }
            SyntaxKind::GenericParamNegativeImpl => {
                GenericParam::NegativeImpl(GenericParamNegativeImpl::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "GenericParam"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericParamType => {
                Some(GenericParam::Type(GenericParamType::from_syntax_node(db, node)))
            }
            SyntaxKind::GenericParamConst => {
                Some(GenericParam::Const(GenericParamConst::from_syntax_node(db, node)))
            }
            SyntaxKind::GenericParamImplNamed => {
                Some(GenericParam::ImplNamed(GenericParamImplNamed::from_syntax_node(db, node)))
            }
            SyntaxKind::GenericParamImplAnonymous => Some(GenericParam::ImplAnonymous(
                GenericParamImplAnonymous::from_syntax_node(db, node),
            )),
            SyntaxKind::GenericParamNegativeImpl => Some(GenericParam::NegativeImpl(
                GenericParamNegativeImpl::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            GenericParam::Type(x) => x.as_syntax_node(),
            GenericParam::Const(x) => x.as_syntax_node(),
            GenericParam::ImplNamed(x) => x.as_syntax_node(),
            GenericParam::ImplAnonymous(x) => x.as_syntax_node(),
            GenericParam::NegativeImpl(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericParamPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> GenericParam<'db> {
    /// Checks if a kind of a variant of [GenericParam].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::GenericParamType
                | SyntaxKind::GenericParamConst
                | SyntaxKind::GenericParamImplNamed
                | SyntaxKind::GenericParamImplAnonymous
                | SyntaxKind::GenericParamNegativeImpl
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericParamType<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> GenericParamType<'db> {
    pub const INDEX_NAME: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        name: TerminalIdentifierGreen<'db>,
    ) -> GenericParamTypeGreen<'db> {
        let children: Vec<GreenId> = vec![name.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericParamTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamType,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> GenericParamType<'db> {
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamTypePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> GenericParamTypePtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for GenericParamTypePtr<'db> {
    type SyntaxNode = GenericParamType<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericParamType<'db> {
        GenericParamType::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericParamTypePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericParamTypePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamTypeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericParamType<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamType);
    type StablePtr = GenericParamTypePtr<'db>;
    type Green = GenericParamTypeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericParamTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamType,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParamType,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParamType
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericParamType {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericParamTypePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericParamConst<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> GenericParamConst<'db> {
    pub const INDEX_CONST_KW: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_COLON: usize = 2;
    pub const INDEX_TY: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        const_kw: TerminalConstGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        colon: TerminalColonGreen<'db>,
        ty: ExprGreen<'db>,
    ) -> GenericParamConstGreen<'db> {
        let children: Vec<GreenId> = vec![const_kw.0, name.0, colon.0, ty.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericParamConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamConst,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> GenericParamConst<'db> {
    pub fn const_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalConst<'db> {
        TerminalConst::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[2])
    }
    pub fn ty(&self, db: &'db dyn SyntaxGroup) -> Expr<'db> {
        Expr::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamConstPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> GenericParamConstPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for GenericParamConstPtr<'db> {
    type SyntaxNode = GenericParamConst<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericParamConst<'db> {
        GenericParamConst::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericParamConstPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericParamConstPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamConstGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericParamConst<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamConst);
    type StablePtr = GenericParamConstPtr<'db>;
    type Green = GenericParamConstGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericParamConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamConst,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalConst::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParamConst,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParamConst
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericParamConst {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericParamConstPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericParamImplNamed<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> GenericParamImplNamed<'db> {
    pub const INDEX_IMPL_KW: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_COLON: usize = 2;
    pub const INDEX_TRAIT_PATH: usize = 3;
    pub const INDEX_TYPE_CONSTRAINS: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        impl_kw: TerminalImplGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        colon: TerminalColonGreen<'db>,
        trait_path: ExprPathGreen<'db>,
        type_constrains: OptionAssociatedItemConstraintsGreen<'db>,
    ) -> GenericParamImplNamedGreen<'db> {
        let children: Vec<GreenId> =
            vec![impl_kw.0, name.0, colon.0, trait_path.0, type_constrains.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericParamImplNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamImplNamed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> GenericParamImplNamed<'db> {
    pub fn impl_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalImpl<'db> {
        TerminalImpl::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[2])
    }
    pub fn trait_path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[3])
    }
    pub fn type_constrains(
        &self,
        db: &'db dyn SyntaxGroup,
    ) -> OptionAssociatedItemConstraints<'db> {
        OptionAssociatedItemConstraints::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamImplNamedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> GenericParamImplNamedPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for GenericParamImplNamedPtr<'db> {
    type SyntaxNode = GenericParamImplNamed<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericParamImplNamed<'db> {
        GenericParamImplNamed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericParamImplNamedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericParamImplNamedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamImplNamedGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericParamImplNamed<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamImplNamed);
    type StablePtr = GenericParamImplNamedPtr<'db>;
    type Green = GenericParamImplNamedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericParamImplNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamImplNamed,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalImpl::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        ExprPath::missing(db).0,
                        OptionAssociatedItemConstraints::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParamImplNamed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParamImplNamed
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericParamImplNamed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericParamImplNamedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericParamImplAnonymous<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> GenericParamImplAnonymous<'db> {
    pub const INDEX_PLUS: usize = 0;
    pub const INDEX_TRAIT_PATH: usize = 1;
    pub const INDEX_TYPE_CONSTRAINS: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        plus: TerminalPlusGreen<'db>,
        trait_path: ExprPathGreen<'db>,
        type_constrains: OptionAssociatedItemConstraintsGreen<'db>,
    ) -> GenericParamImplAnonymousGreen<'db> {
        let children: Vec<GreenId> = vec![plus.0, trait_path.0, type_constrains.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericParamImplAnonymousGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamImplAnonymous,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> GenericParamImplAnonymous<'db> {
    pub fn plus(&self, db: &'db dyn SyntaxGroup) -> TerminalPlus<'db> {
        TerminalPlus::from_syntax_node(db, self.children[0])
    }
    pub fn trait_path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[1])
    }
    pub fn type_constrains(
        &self,
        db: &'db dyn SyntaxGroup,
    ) -> OptionAssociatedItemConstraints<'db> {
        OptionAssociatedItemConstraints::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamImplAnonymousPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> GenericParamImplAnonymousPtr<'db> {}
impl<'db> TypedStablePtr<'db> for GenericParamImplAnonymousPtr<'db> {
    type SyntaxNode = GenericParamImplAnonymous<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericParamImplAnonymous<'db> {
        GenericParamImplAnonymous::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericParamImplAnonymousPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericParamImplAnonymousPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamImplAnonymousGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericParamImplAnonymous<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamImplAnonymous);
    type StablePtr = GenericParamImplAnonymousPtr<'db>;
    type Green = GenericParamImplAnonymousGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericParamImplAnonymousGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamImplAnonymous,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalPlus::missing(db).0,
                        ExprPath::missing(db).0,
                        OptionAssociatedItemConstraints::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParamImplAnonymous,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParamImplAnonymous
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericParamImplAnonymous {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericParamImplAnonymousPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct GenericParamNegativeImpl<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> GenericParamNegativeImpl<'db> {
    pub const INDEX_MINUS: usize = 0;
    pub const INDEX_TRAIT_PATH: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        minus: TerminalMinusGreen<'db>,
        trait_path: ExprPathGreen<'db>,
    ) -> GenericParamNegativeImplGreen<'db> {
        let children: Vec<GreenId> = vec![minus.0, trait_path.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericParamNegativeImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamNegativeImpl,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> GenericParamNegativeImpl<'db> {
    pub fn minus(&self, db: &'db dyn SyntaxGroup) -> TerminalMinus<'db> {
        TerminalMinus::from_syntax_node(db, self.children[0])
    }
    pub fn trait_path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamNegativeImplPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> GenericParamNegativeImplPtr<'db> {}
impl<'db> TypedStablePtr<'db> for GenericParamNegativeImplPtr<'db> {
    type SyntaxNode = GenericParamNegativeImpl<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> GenericParamNegativeImpl<'db> {
        GenericParamNegativeImpl::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<GenericParamNegativeImplPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: GenericParamNegativeImplPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct GenericParamNegativeImplGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for GenericParamNegativeImpl<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamNegativeImpl);
    type StablePtr = GenericParamNegativeImplPtr<'db>;
    type Green = GenericParamNegativeImplGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        GenericParamNegativeImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamNegativeImpl,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalMinus::missing(db).0, ExprPath::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParamNegativeImpl,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParamNegativeImpl
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericParamNegativeImpl {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        GenericParamNegativeImplPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenList<'db>(ElementList<'db, TokenTree<'db>, 1>);
impl<'db> Deref for TokenList<'db> {
    type Target = ElementList<'db, TokenTree<'db>, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> TokenList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<TokenTreeGreen<'db>>,
    ) -> TokenListGreen<'db> {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        TokenListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenListPtr<'db> {
    type SyntaxNode = TokenList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenList<'db> {
        TokenList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TokenList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenList);
    type StablePtr = TokenListPtr<'db>;
    type Green = TokenListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::TokenList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenTreeLeaf<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TokenTreeLeaf<'db> {
    pub const INDEX_LEAF: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        leaf: TokenNodeGreen<'db>,
    ) -> TokenTreeLeafGreen<'db> {
        let children: Vec<GreenId> = vec![leaf.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TokenTreeLeafGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTreeLeaf,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TokenTreeLeaf<'db> {
    pub fn leaf(&self, db: &'db dyn SyntaxGroup) -> TokenNode<'db> {
        TokenNode::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeLeafPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TokenTreeLeafPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TokenTreeLeafPtr<'db> {
    type SyntaxNode = TokenTreeLeaf<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenTreeLeaf<'db> {
        TokenTreeLeaf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenTreeLeafPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenTreeLeafPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeLeafGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TokenTreeLeaf<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTreeLeaf);
    type StablePtr = TokenTreeLeafPtr<'db>;
    type Green = TokenTreeLeafGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenTreeLeafGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTreeLeaf,
                details: GreenNodeDetails::Node {
                    children: vec![TokenNode::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TokenTreeLeaf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TokenTreeLeaf
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TokenTreeLeaf {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenTreeLeafPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenTreeNode<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TokenTreeNode<'db> {
    pub const INDEX_SUBTREE: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        subtree: WrappedTokenTreeGreen<'db>,
    ) -> TokenTreeNodeGreen<'db> {
        let children: Vec<GreenId> = vec![subtree.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TokenTreeNodeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTreeNode,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TokenTreeNode<'db> {
    pub fn subtree(&self, db: &'db dyn SyntaxGroup) -> WrappedTokenTree<'db> {
        WrappedTokenTree::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeNodePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TokenTreeNodePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TokenTreeNodePtr<'db> {
    type SyntaxNode = TokenTreeNode<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenTreeNode<'db> {
        TokenTreeNode::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenTreeNodePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenTreeNodePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeNodeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TokenTreeNode<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTreeNode);
    type StablePtr = TokenTreeNodePtr<'db>;
    type Green = TokenTreeNodeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenTreeNodeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTreeNode,
                details: GreenNodeDetails::Node {
                    children: vec![WrappedTokenTree::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TokenTreeNode,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TokenTreeNode
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TokenTreeNode {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenTreeNodePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenTreeRepetition<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TokenTreeRepetition<'db> {
    pub const INDEX_DOLLAR: usize = 0;
    pub const INDEX_LPAREN: usize = 1;
    pub const INDEX_ELEMENTS: usize = 2;
    pub const INDEX_RPAREN: usize = 3;
    pub const INDEX_SEPARATOR: usize = 4;
    pub const INDEX_OPERATOR: usize = 5;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        dollar: TerminalDollarGreen<'db>,
        lparen: TerminalLParenGreen<'db>,
        elements: TokenListGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
        separator: OptionTerminalCommaGreen<'db>,
        operator: MacroRepetitionOperatorGreen<'db>,
    ) -> TokenTreeRepetitionGreen<'db> {
        let children: Vec<GreenId> =
            vec![dollar.0, lparen.0, elements.0, rparen.0, separator.0, operator.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TokenTreeRepetitionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTreeRepetition,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TokenTreeRepetition<'db> {
    pub fn dollar(&self, db: &'db dyn SyntaxGroup) -> TerminalDollar<'db> {
        TerminalDollar::from_syntax_node(db, self.children[0])
    }
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[1])
    }
    pub fn elements(&self, db: &'db dyn SyntaxGroup) -> TokenList<'db> {
        TokenList::from_syntax_node(db, self.children[2])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[3])
    }
    pub fn separator(&self, db: &'db dyn SyntaxGroup) -> OptionTerminalComma<'db> {
        OptionTerminalComma::from_syntax_node(db, self.children[4])
    }
    pub fn operator(&self, db: &'db dyn SyntaxGroup) -> MacroRepetitionOperator<'db> {
        MacroRepetitionOperator::from_syntax_node(db, self.children[5])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeRepetitionPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TokenTreeRepetitionPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TokenTreeRepetitionPtr<'db> {
    type SyntaxNode = TokenTreeRepetition<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenTreeRepetition<'db> {
        TokenTreeRepetition::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenTreeRepetitionPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenTreeRepetitionPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeRepetitionGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TokenTreeRepetition<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTreeRepetition);
    type StablePtr = TokenTreeRepetitionPtr<'db>;
    type Green = TokenTreeRepetitionGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenTreeRepetitionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTreeRepetition,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalDollar::missing(db).0,
                        TerminalLParen::missing(db).0,
                        TokenList::missing(db).0,
                        TerminalRParen::missing(db).0,
                        OptionTerminalComma::missing(db).0,
                        MacroRepetitionOperator::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TokenTreeRepetition,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TokenTreeRepetition
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TokenTreeRepetition {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenTreeRepetitionPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenTreeParam<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TokenTreeParam<'db> {
    pub const INDEX_DOLLAR: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        dollar: TerminalDollarGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
    ) -> TokenTreeParamGreen<'db> {
        let children: Vec<GreenId> = vec![dollar.0, name.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TokenTreeParamGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTreeParam,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TokenTreeParam<'db> {
    pub fn dollar(&self, db: &'db dyn SyntaxGroup) -> TerminalDollar<'db> {
        TerminalDollar::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeParamPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TokenTreeParamPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TokenTreeParamPtr<'db> {
    type SyntaxNode = TokenTreeParam<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenTreeParam<'db> {
        TokenTreeParam::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenTreeParamPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenTreeParamPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeParamGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TokenTreeParam<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTreeParam);
    type StablePtr = TokenTreeParamPtr<'db>;
    type Green = TokenTreeParamGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenTreeParamGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTreeParam,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalDollar::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TokenTreeParam,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TokenTreeParam
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TokenTreeParam {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenTreeParamPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum TokenTree<'db> {
    Token(TokenTreeLeaf<'db>),
    Subtree(TokenTreeNode<'db>),
    Repetition(TokenTreeRepetition<'db>),
    Param(TokenTreeParam<'db>),
    Missing(TokenTreeMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenTreePtr<'db> {
    type SyntaxNode = TokenTree<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        TokenTree::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenTreePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenTreePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TokenTreeLeafPtr<'db>> for TokenTreePtr<'db> {
    fn from(value: TokenTreeLeafPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenTreeNodePtr<'db>> for TokenTreePtr<'db> {
    fn from(value: TokenTreeNodePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenTreeRepetitionPtr<'db>> for TokenTreePtr<'db> {
    fn from(value: TokenTreeRepetitionPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenTreeParamPtr<'db>> for TokenTreePtr<'db> {
    fn from(value: TokenTreeParamPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenTreeMissingPtr<'db>> for TokenTreePtr<'db> {
    fn from(value: TokenTreeMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenTreeLeafGreen<'db>> for TokenTreeGreen<'db> {
    fn from(value: TokenTreeLeafGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenTreeNodeGreen<'db>> for TokenTreeGreen<'db> {
    fn from(value: TokenTreeNodeGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenTreeRepetitionGreen<'db>> for TokenTreeGreen<'db> {
    fn from(value: TokenTreeRepetitionGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenTreeParamGreen<'db>> for TokenTreeGreen<'db> {
    fn from(value: TokenTreeParamGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenTreeMissingGreen<'db>> for TokenTreeGreen<'db> {
    fn from(value: TokenTreeMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TokenTree<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = TokenTreePtr<'db>;
    type Green = TokenTreeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenTreeGreen(TokenTreeMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TokenTreeLeaf => {
                TokenTree::Token(TokenTreeLeaf::from_syntax_node(db, node))
            }
            SyntaxKind::TokenTreeNode => {
                TokenTree::Subtree(TokenTreeNode::from_syntax_node(db, node))
            }
            SyntaxKind::TokenTreeRepetition => {
                TokenTree::Repetition(TokenTreeRepetition::from_syntax_node(db, node))
            }
            SyntaxKind::TokenTreeParam => {
                TokenTree::Param(TokenTreeParam::from_syntax_node(db, node))
            }
            SyntaxKind::TokenTreeMissing => {
                TokenTree::Missing(TokenTreeMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "TokenTree"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TokenTreeLeaf => {
                Some(TokenTree::Token(TokenTreeLeaf::from_syntax_node(db, node)))
            }
            SyntaxKind::TokenTreeNode => {
                Some(TokenTree::Subtree(TokenTreeNode::from_syntax_node(db, node)))
            }
            SyntaxKind::TokenTreeRepetition => {
                Some(TokenTree::Repetition(TokenTreeRepetition::from_syntax_node(db, node)))
            }
            SyntaxKind::TokenTreeParam => {
                Some(TokenTree::Param(TokenTreeParam::from_syntax_node(db, node)))
            }
            SyntaxKind::TokenTreeMissing => {
                Some(TokenTree::Missing(TokenTreeMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            TokenTree::Token(x) => x.as_syntax_node(),
            TokenTree::Subtree(x) => x.as_syntax_node(),
            TokenTree::Repetition(x) => x.as_syntax_node(),
            TokenTree::Param(x) => x.as_syntax_node(),
            TokenTree::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenTreePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> TokenTree<'db> {
    /// Checks if a kind of a variant of [TokenTree].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TokenTreeLeaf
                | SyntaxKind::TokenTreeNode
                | SyntaxKind::TokenTreeRepetition
                | SyntaxKind::TokenTreeParam
                | SyntaxKind::TokenTreeMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenTreeMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TokenTreeMissing<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> TokenTreeMissingGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TokenTreeMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTreeMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TokenTreeMissing<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TokenTreeMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TokenTreeMissingPtr<'db> {
    type SyntaxNode = TokenTreeMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenTreeMissing<'db> {
        TokenTreeMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenTreeMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenTreeMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTreeMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TokenTreeMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTreeMissing);
    type StablePtr = TokenTreeMissingPtr<'db>;
    type Green = TokenTreeMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenTreeMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTreeMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TokenTreeMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TokenTreeMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TokenTreeMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenTreeMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum WrappedTokenTree<'db> {
    Parenthesized(ParenthesizedTokenTree<'db>),
    Braced(BracedTokenTree<'db>),
    Bracketed(BracketedTokenTree<'db>),
    Missing(WrappedTokenTreeMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedTokenTreePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for WrappedTokenTreePtr<'db> {
    type SyntaxNode = WrappedTokenTree<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        WrappedTokenTree::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<WrappedTokenTreePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: WrappedTokenTreePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ParenthesizedTokenTreePtr<'db>> for WrappedTokenTreePtr<'db> {
    fn from(value: ParenthesizedTokenTreePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<BracedTokenTreePtr<'db>> for WrappedTokenTreePtr<'db> {
    fn from(value: BracedTokenTreePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<BracketedTokenTreePtr<'db>> for WrappedTokenTreePtr<'db> {
    fn from(value: BracketedTokenTreePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<WrappedTokenTreeMissingPtr<'db>> for WrappedTokenTreePtr<'db> {
    fn from(value: WrappedTokenTreeMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ParenthesizedTokenTreeGreen<'db>> for WrappedTokenTreeGreen<'db> {
    fn from(value: ParenthesizedTokenTreeGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<BracedTokenTreeGreen<'db>> for WrappedTokenTreeGreen<'db> {
    fn from(value: BracedTokenTreeGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<BracketedTokenTreeGreen<'db>> for WrappedTokenTreeGreen<'db> {
    fn from(value: BracketedTokenTreeGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<WrappedTokenTreeMissingGreen<'db>> for WrappedTokenTreeGreen<'db> {
    fn from(value: WrappedTokenTreeMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedTokenTreeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for WrappedTokenTree<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = WrappedTokenTreePtr<'db>;
    type Green = WrappedTokenTreeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        WrappedTokenTreeGreen(WrappedTokenTreeMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ParenthesizedTokenTree => {
                WrappedTokenTree::Parenthesized(ParenthesizedTokenTree::from_syntax_node(db, node))
            }
            SyntaxKind::BracedTokenTree => {
                WrappedTokenTree::Braced(BracedTokenTree::from_syntax_node(db, node))
            }
            SyntaxKind::BracketedTokenTree => {
                WrappedTokenTree::Bracketed(BracketedTokenTree::from_syntax_node(db, node))
            }
            SyntaxKind::WrappedTokenTreeMissing => {
                WrappedTokenTree::Missing(WrappedTokenTreeMissing::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "WrappedTokenTree"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ParenthesizedTokenTree => Some(WrappedTokenTree::Parenthesized(
                ParenthesizedTokenTree::from_syntax_node(db, node),
            )),
            SyntaxKind::BracedTokenTree => {
                Some(WrappedTokenTree::Braced(BracedTokenTree::from_syntax_node(db, node)))
            }
            SyntaxKind::BracketedTokenTree => {
                Some(WrappedTokenTree::Bracketed(BracketedTokenTree::from_syntax_node(db, node)))
            }
            SyntaxKind::WrappedTokenTreeMissing => {
                Some(WrappedTokenTree::Missing(WrappedTokenTreeMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            WrappedTokenTree::Parenthesized(x) => x.as_syntax_node(),
            WrappedTokenTree::Braced(x) => x.as_syntax_node(),
            WrappedTokenTree::Bracketed(x) => x.as_syntax_node(),
            WrappedTokenTree::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        WrappedTokenTreePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> WrappedTokenTree<'db> {
    /// Checks if a kind of a variant of [WrappedTokenTree].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ParenthesizedTokenTree
                | SyntaxKind::BracedTokenTree
                | SyntaxKind::BracketedTokenTree
                | SyntaxKind::WrappedTokenTreeMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct WrappedTokenTreeMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> WrappedTokenTreeMissing<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> WrappedTokenTreeMissingGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        WrappedTokenTreeMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::WrappedTokenTreeMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> WrappedTokenTreeMissing<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedTokenTreeMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> WrappedTokenTreeMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for WrappedTokenTreeMissingPtr<'db> {
    type SyntaxNode = WrappedTokenTreeMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> WrappedTokenTreeMissing<'db> {
        WrappedTokenTreeMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<WrappedTokenTreeMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: WrappedTokenTreeMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedTokenTreeMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for WrappedTokenTreeMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::WrappedTokenTreeMissing);
    type StablePtr = WrappedTokenTreeMissingPtr<'db>;
    type Green = WrappedTokenTreeMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        WrappedTokenTreeMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::WrappedTokenTreeMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::WrappedTokenTreeMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::WrappedTokenTreeMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::WrappedTokenTreeMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        WrappedTokenTreeMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ParenthesizedTokenTree<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ParenthesizedTokenTree<'db> {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_TOKENS: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lparen: TerminalLParenGreen<'db>,
        tokens: TokenListGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
    ) -> ParenthesizedTokenTreeGreen<'db> {
        let children: Vec<GreenId> = vec![lparen.0, tokens.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ParenthesizedTokenTreeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParenthesizedTokenTree,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ParenthesizedTokenTree<'db> {
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[0])
    }
    pub fn tokens(&self, db: &'db dyn SyntaxGroup) -> TokenList<'db> {
        TokenList::from_syntax_node(db, self.children[1])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParenthesizedTokenTreePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ParenthesizedTokenTreePtr<'db> {}
impl<'db> TypedStablePtr<'db> for ParenthesizedTokenTreePtr<'db> {
    type SyntaxNode = ParenthesizedTokenTree<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ParenthesizedTokenTree<'db> {
        ParenthesizedTokenTree::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ParenthesizedTokenTreePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ParenthesizedTokenTreePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParenthesizedTokenTreeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ParenthesizedTokenTree<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ParenthesizedTokenTree);
    type StablePtr = ParenthesizedTokenTreePtr<'db>;
    type Green = ParenthesizedTokenTreeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ParenthesizedTokenTreeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParenthesizedTokenTree,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        TokenList::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ParenthesizedTokenTree,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ParenthesizedTokenTree
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ParenthesizedTokenTree {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ParenthesizedTokenTreePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct BracedTokenTree<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> BracedTokenTree<'db> {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_TOKENS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen<'db>,
        tokens: TokenListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> BracedTokenTreeGreen<'db> {
        let children: Vec<GreenId> = vec![lbrace.0, tokens.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        BracedTokenTreeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::BracedTokenTree,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> BracedTokenTree<'db> {
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[0])
    }
    pub fn tokens(&self, db: &'db dyn SyntaxGroup) -> TokenList<'db> {
        TokenList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BracedTokenTreePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> BracedTokenTreePtr<'db> {}
impl<'db> TypedStablePtr<'db> for BracedTokenTreePtr<'db> {
    type SyntaxNode = BracedTokenTree<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> BracedTokenTree<'db> {
        BracedTokenTree::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<BracedTokenTreePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: BracedTokenTreePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BracedTokenTreeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for BracedTokenTree<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::BracedTokenTree);
    type StablePtr = BracedTokenTreePtr<'db>;
    type Green = BracedTokenTreeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        BracedTokenTreeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::BracedTokenTree,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        TokenList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::BracedTokenTree,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::BracedTokenTree
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::BracedTokenTree {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        BracedTokenTreePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct BracketedTokenTree<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> BracketedTokenTree<'db> {
    pub const INDEX_LBRACK: usize = 0;
    pub const INDEX_TOKENS: usize = 1;
    pub const INDEX_RBRACK: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrack: TerminalLBrackGreen<'db>,
        tokens: TokenListGreen<'db>,
        rbrack: TerminalRBrackGreen<'db>,
    ) -> BracketedTokenTreeGreen<'db> {
        let children: Vec<GreenId> = vec![lbrack.0, tokens.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        BracketedTokenTreeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::BracketedTokenTree,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> BracketedTokenTree<'db> {
    pub fn lbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrack<'db> {
        TerminalLBrack::from_syntax_node(db, self.children[0])
    }
    pub fn tokens(&self, db: &'db dyn SyntaxGroup) -> TokenList<'db> {
        TokenList::from_syntax_node(db, self.children[1])
    }
    pub fn rbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrack<'db> {
        TerminalRBrack::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BracketedTokenTreePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> BracketedTokenTreePtr<'db> {}
impl<'db> TypedStablePtr<'db> for BracketedTokenTreePtr<'db> {
    type SyntaxNode = BracketedTokenTree<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> BracketedTokenTree<'db> {
        BracketedTokenTree::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<BracketedTokenTreePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: BracketedTokenTreePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BracketedTokenTreeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for BracketedTokenTree<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::BracketedTokenTree);
    type StablePtr = BracketedTokenTreePtr<'db>;
    type Green = BracketedTokenTreeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        BracketedTokenTreeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::BracketedTokenTree,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrack::missing(db).0,
                        TokenList::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::BracketedTokenTree,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::BracketedTokenTree
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::BracketedTokenTree {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        BracketedTokenTreePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ExprInlineMacro<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ExprInlineMacro<'db> {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_BANG: usize = 1;
    pub const INDEX_ARGUMENTS: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        path: ExprPathGreen<'db>,
        bang: TerminalNotGreen<'db>,
        arguments: TokenTreeNodeGreen<'db>,
    ) -> ExprInlineMacroGreen<'db> {
        let children: Vec<GreenId> = vec![path.0, bang.0, arguments.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprInlineMacro,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ExprInlineMacro<'db> {
    pub fn path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[0])
    }
    pub fn bang(&self, db: &'db dyn SyntaxGroup) -> TerminalNot<'db> {
        TerminalNot::from_syntax_node(db, self.children[1])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> TokenTreeNode<'db> {
        TokenTreeNode::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprInlineMacroPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ExprInlineMacroPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ExprInlineMacroPtr<'db> {
    type SyntaxNode = ExprInlineMacro<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ExprInlineMacro<'db> {
        ExprInlineMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ExprInlineMacroPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ExprInlineMacroPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ExprInlineMacroGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ExprInlineMacro<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprInlineMacro);
    type StablePtr = ExprInlineMacroPtr<'db>;
    type Green = ExprInlineMacroGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ExprInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprInlineMacro,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ExprPath::missing(db).0,
                        TerminalNot::missing(db).0,
                        TokenTreeNode::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprInlineMacro,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprInlineMacro
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprInlineMacro {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ExprInlineMacroPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemInlineMacro<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemInlineMacro<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_BANG: usize = 2;
    pub const INDEX_ARGUMENTS: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        bang: TerminalNotGreen<'db>,
        arguments: TokenTreeNodeGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> ItemInlineMacroGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, name.0, bang.0, arguments.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemInlineMacro,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemInlineMacro<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
    pub fn bang(&self, db: &'db dyn SyntaxGroup) -> TerminalNot<'db> {
        TerminalNot::from_syntax_node(db, self.children[2])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> TokenTreeNode<'db> {
        TokenTreeNode::from_syntax_node(db, self.children[3])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemInlineMacroPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemInlineMacroPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ItemInlineMacroPtr<'db> {
    type SyntaxNode = ItemInlineMacro<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemInlineMacro<'db> {
        ItemInlineMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemInlineMacroPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemInlineMacroPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemInlineMacroGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemInlineMacro<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemInlineMacro);
    type StablePtr = ItemInlineMacroPtr<'db>;
    type Green = ItemInlineMacroGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemInlineMacro,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalNot::missing(db).0,
                        TokenTreeNode::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemInlineMacro,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemInlineMacro
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemInlineMacro {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemInlineMacroPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ItemMacroDeclaration<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ItemMacroDeclaration<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_MACRO_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_LBRACE: usize = 4;
    pub const INDEX_RULES: usize = 5;
    pub const INDEX_RBRACE: usize = 6;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        visibility: VisibilityGreen<'db>,
        macro_kw: TerminalMacroGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        lbrace: TerminalLBraceGreen<'db>,
        rules: MacroRulesListGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> ItemMacroDeclarationGreen<'db> {
        let children: Vec<GreenId> =
            vec![attributes.0, visibility.0, macro_kw.0, name.0, lbrace.0, rules.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemMacroDeclarationGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemMacroDeclaration,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ItemMacroDeclaration<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn visibility(&self, db: &'db dyn SyntaxGroup) -> Visibility<'db> {
        Visibility::from_syntax_node(db, self.children[1])
    }
    pub fn macro_kw(&self, db: &'db dyn SyntaxGroup) -> TerminalMacro<'db> {
        TerminalMacro::from_syntax_node(db, self.children[2])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[3])
    }
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[4])
    }
    pub fn rules(&self, db: &'db dyn SyntaxGroup) -> MacroRulesList<'db> {
        MacroRulesList::from_syntax_node(db, self.children[5])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[6])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemMacroDeclarationPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ItemMacroDeclarationPtr<'db> {
    pub fn name_green(self, db: &'db dyn SyntaxGroup) -> TerminalIdentifierGreen<'db> {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl<'db> TypedStablePtr<'db> for ItemMacroDeclarationPtr<'db> {
    type SyntaxNode = ItemMacroDeclaration<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ItemMacroDeclaration<'db> {
        ItemMacroDeclaration::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ItemMacroDeclarationPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ItemMacroDeclarationPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ItemMacroDeclarationGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ItemMacroDeclaration<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemMacroDeclaration);
    type StablePtr = ItemMacroDeclarationPtr<'db>;
    type Green = ItemMacroDeclarationGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ItemMacroDeclarationGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemMacroDeclaration,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalMacro::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalLBrace::missing(db).0,
                        MacroRulesList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemMacroDeclaration,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemMacroDeclaration
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemMacroDeclaration {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ItemMacroDeclarationPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MacroRulesList<'db>(ElementList<'db, MacroRule<'db>, 1>);
impl<'db> Deref for MacroRulesList<'db> {
    type Target = ElementList<'db, MacroRule<'db>, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> MacroRulesList<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<MacroRuleGreen<'db>>,
    ) -> MacroRulesListGreen<'db> {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        MacroRulesListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroRulesList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroRulesListPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MacroRulesListPtr<'db> {
    type SyntaxNode = MacroRulesList<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MacroRulesList<'db> {
        MacroRulesList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroRulesListPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroRulesListPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroRulesListGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroRulesList<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MacroRulesList);
    type StablePtr = MacroRulesListPtr<'db>;
    type Green = MacroRulesListGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MacroRulesListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroRulesList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::MacroRulesList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroRulesListPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MacroRule<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> MacroRule<'db> {
    pub const INDEX_LHS: usize = 0;
    pub const INDEX_FAT_ARROW: usize = 1;
    pub const INDEX_RHS: usize = 2;
    pub const INDEX_SEMICOLON: usize = 3;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lhs: WrappedMacroGreen<'db>,
        fat_arrow: TerminalMatchArrowGreen<'db>,
        rhs: WrappedMacroGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> MacroRuleGreen<'db> {
        let children: Vec<GreenId> = vec![lhs.0, fat_arrow.0, rhs.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        MacroRuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroRule,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> MacroRule<'db> {
    pub fn lhs(&self, db: &'db dyn SyntaxGroup) -> WrappedMacro<'db> {
        WrappedMacro::from_syntax_node(db, self.children[0])
    }
    pub fn fat_arrow(&self, db: &'db dyn SyntaxGroup) -> TerminalMatchArrow<'db> {
        TerminalMatchArrow::from_syntax_node(db, self.children[1])
    }
    pub fn rhs(&self, db: &'db dyn SyntaxGroup) -> WrappedMacro<'db> {
        WrappedMacro::from_syntax_node(db, self.children[2])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[3])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroRulePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> MacroRulePtr<'db> {}
impl<'db> TypedStablePtr<'db> for MacroRulePtr<'db> {
    type SyntaxNode = MacroRule<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MacroRule<'db> {
        MacroRule::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroRulePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroRulePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroRuleGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroRule<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MacroRule);
    type StablePtr = MacroRulePtr<'db>;
    type Green = MacroRuleGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MacroRuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroRule,
                details: GreenNodeDetails::Node {
                    children: vec![
                        WrappedMacro::missing(db).0,
                        TerminalMatchArrow::missing(db).0,
                        WrappedMacro::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::MacroRule,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::MacroRule
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::MacroRule { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroRulePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ParamKind<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ParamKind<'db> {
    pub const INDEX_COLON: usize = 0;
    pub const INDEX_KIND: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        colon: TerminalColonGreen<'db>,
        kind: MacroParamKindGreen<'db>,
    ) -> ParamKindGreen<'db> {
        let children: Vec<GreenId> = vec![colon.0, kind.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ParamKindGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParamKind,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ParamKind<'db> {
    pub fn colon(&self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.children[0])
    }
    pub fn kind(&self, db: &'db dyn SyntaxGroup) -> MacroParamKind<'db> {
        MacroParamKind::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParamKindPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ParamKindPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ParamKindPtr<'db> {
    type SyntaxNode = ParamKind<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ParamKind<'db> {
        ParamKind::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ParamKindPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ParamKindPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParamKindGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ParamKind<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ParamKind);
    type StablePtr = ParamKindPtr<'db>;
    type Green = ParamKindGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ParamKindGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParamKind,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalColon::missing(db).0, MacroParamKind::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ParamKind,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ParamKind
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ParamKind { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ParamKindPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionParamKind<'db> {
    Empty(OptionParamKindEmpty<'db>),
    ParamKind(ParamKind<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionParamKindPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionParamKindPtr<'db> {
    type SyntaxNode = OptionParamKind<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionParamKind::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionParamKindPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionParamKindPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionParamKindEmptyPtr<'db>> for OptionParamKindPtr<'db> {
    fn from(value: OptionParamKindEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ParamKindPtr<'db>> for OptionParamKindPtr<'db> {
    fn from(value: ParamKindPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionParamKindEmptyGreen<'db>> for OptionParamKindGreen<'db> {
    fn from(value: OptionParamKindEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ParamKindGreen<'db>> for OptionParamKindGreen<'db> {
    fn from(value: ParamKindGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionParamKindGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionParamKind<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionParamKindPtr<'db>;
    type Green = OptionParamKindGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionParamKindEmpty => {
                OptionParamKind::Empty(OptionParamKindEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::ParamKind => {
                OptionParamKind::ParamKind(ParamKind::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "OptionParamKind")
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionParamKindEmpty => {
                Some(OptionParamKind::Empty(OptionParamKindEmpty::from_syntax_node(db, node)))
            }
            SyntaxKind::ParamKind => {
                Some(OptionParamKind::ParamKind(ParamKind::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionParamKind::Empty(x) => x.as_syntax_node(),
            OptionParamKind::ParamKind(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionParamKindPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionParamKind<'db> {
    /// Checks if a kind of a variant of [OptionParamKind].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionParamKindEmpty | SyntaxKind::ParamKind)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionParamKindEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionParamKindEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionParamKindEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionParamKindEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionParamKindEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionParamKindEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionParamKindEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionParamKindEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionParamKindEmptyPtr<'db> {
    type SyntaxNode = OptionParamKindEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionParamKindEmpty<'db> {
        OptionParamKindEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionParamKindEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionParamKindEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionParamKindEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionParamKindEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionParamKindEmpty);
    type StablePtr = OptionParamKindEmptyPtr<'db>;
    type Green = OptionParamKindEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionParamKindEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionParamKindEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionParamKindEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionParamKindEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionParamKindEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionParamKindEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MacroParam<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> MacroParam<'db> {
    pub const INDEX_DOLLAR: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_KIND: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        dollar: TerminalDollarGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        kind: OptionParamKindGreen<'db>,
    ) -> MacroParamGreen<'db> {
        let children: Vec<GreenId> = vec![dollar.0, name.0, kind.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        MacroParamGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroParam,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> MacroParam<'db> {
    pub fn dollar(&self, db: &'db dyn SyntaxGroup) -> TerminalDollar<'db> {
        TerminalDollar::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
    pub fn kind(&self, db: &'db dyn SyntaxGroup) -> OptionParamKind<'db> {
        OptionParamKind::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroParamPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> MacroParamPtr<'db> {}
impl<'db> TypedStablePtr<'db> for MacroParamPtr<'db> {
    type SyntaxNode = MacroParam<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MacroParam<'db> {
        MacroParam::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroParamPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroParamPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroParamGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroParam<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MacroParam);
    type StablePtr = MacroParamPtr<'db>;
    type Green = MacroParamGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MacroParamGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroParam,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalDollar::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionParamKind::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::MacroParam,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::MacroParam
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::MacroParam { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroParamPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MacroRepetition<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> MacroRepetition<'db> {
    pub const INDEX_DOLLAR: usize = 0;
    pub const INDEX_LPAREN: usize = 1;
    pub const INDEX_ELEMENTS: usize = 2;
    pub const INDEX_RPAREN: usize = 3;
    pub const INDEX_SEPARATOR: usize = 4;
    pub const INDEX_OPERATOR: usize = 5;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        dollar: TerminalDollarGreen<'db>,
        lparen: TerminalLParenGreen<'db>,
        elements: MacroElementsGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
        separator: OptionTerminalCommaGreen<'db>,
        operator: MacroRepetitionOperatorGreen<'db>,
    ) -> MacroRepetitionGreen<'db> {
        let children: Vec<GreenId> =
            vec![dollar.0, lparen.0, elements.0, rparen.0, separator.0, operator.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        MacroRepetitionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroRepetition,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> MacroRepetition<'db> {
    pub fn dollar(&self, db: &'db dyn SyntaxGroup) -> TerminalDollar<'db> {
        TerminalDollar::from_syntax_node(db, self.children[0])
    }
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[1])
    }
    pub fn elements(&self, db: &'db dyn SyntaxGroup) -> MacroElements<'db> {
        MacroElements::from_syntax_node(db, self.children[2])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[3])
    }
    pub fn separator(&self, db: &'db dyn SyntaxGroup) -> OptionTerminalComma<'db> {
        OptionTerminalComma::from_syntax_node(db, self.children[4])
    }
    pub fn operator(&self, db: &'db dyn SyntaxGroup) -> MacroRepetitionOperator<'db> {
        MacroRepetitionOperator::from_syntax_node(db, self.children[5])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroRepetitionPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> MacroRepetitionPtr<'db> {}
impl<'db> TypedStablePtr<'db> for MacroRepetitionPtr<'db> {
    type SyntaxNode = MacroRepetition<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MacroRepetition<'db> {
        MacroRepetition::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroRepetitionPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroRepetitionPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroRepetitionGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroRepetition<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MacroRepetition);
    type StablePtr = MacroRepetitionPtr<'db>;
    type Green = MacroRepetitionGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MacroRepetitionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroRepetition,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalDollar::missing(db).0,
                        TerminalLParen::missing(db).0,
                        MacroElements::missing(db).0,
                        TerminalRParen::missing(db).0,
                        OptionTerminalComma::missing(db).0,
                        MacroRepetitionOperator::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::MacroRepetition,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::MacroRepetition
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::MacroRepetition {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroRepetitionPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum OptionTerminalComma<'db> {
    Empty(OptionTerminalCommaEmpty<'db>),
    TerminalComma(TerminalComma<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalCommaPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for OptionTerminalCommaPtr<'db> {
    type SyntaxNode = OptionTerminalComma<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        OptionTerminalComma::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalCommaPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalCommaPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<OptionTerminalCommaEmptyPtr<'db>> for OptionTerminalCommaPtr<'db> {
    fn from(value: OptionTerminalCommaEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalCommaPtr<'db>> for OptionTerminalCommaPtr<'db> {
    fn from(value: TerminalCommaPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<OptionTerminalCommaEmptyGreen<'db>> for OptionTerminalCommaGreen<'db> {
    fn from(value: OptionTerminalCommaEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalCommaGreen<'db>> for OptionTerminalCommaGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalCommaGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalComma<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalCommaPtr<'db>;
    type Green = OptionTerminalCommaGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalCommaEmpty => {
                OptionTerminalComma::Empty(OptionTerminalCommaEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalComma => {
                OptionTerminalComma::TerminalComma(TerminalComma::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalComma"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalCommaEmpty => Some(OptionTerminalComma::Empty(
                OptionTerminalCommaEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalComma => {
                Some(OptionTerminalComma::TerminalComma(TerminalComma::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            OptionTerminalComma::Empty(x) => x.as_syntax_node(),
            OptionTerminalComma::TerminalComma(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalCommaPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> OptionTerminalComma<'db> {
    /// Checks if a kind of a variant of [OptionTerminalComma].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTerminalCommaEmpty | SyntaxKind::TerminalComma)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct OptionTerminalCommaEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> OptionTerminalCommaEmpty<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> OptionTerminalCommaEmptyGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTerminalCommaEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalCommaEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> OptionTerminalCommaEmpty<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalCommaEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> OptionTerminalCommaEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for OptionTerminalCommaEmptyPtr<'db> {
    type SyntaxNode = OptionTerminalCommaEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> OptionTerminalCommaEmpty<'db> {
        OptionTerminalCommaEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<OptionTerminalCommaEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: OptionTerminalCommaEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct OptionTerminalCommaEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for OptionTerminalCommaEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalCommaEmpty);
    type StablePtr = OptionTerminalCommaEmptyPtr<'db>;
    type Green = OptionTerminalCommaEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        OptionTerminalCommaEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalCommaEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalCommaEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalCommaEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTerminalCommaEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        OptionTerminalCommaEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum MacroRepetitionOperator<'db> {
    ZeroOrOne(TerminalQuestionMark<'db>),
    OneOrMore(TerminalPlus<'db>),
    ZeroOrMore(TerminalMul<'db>),
    Missing(MacroRepetitionOperatorMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroRepetitionOperatorPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MacroRepetitionOperatorPtr<'db> {
    type SyntaxNode = MacroRepetitionOperator<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        MacroRepetitionOperator::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroRepetitionOperatorPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroRepetitionOperatorPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TerminalQuestionMarkPtr<'db>> for MacroRepetitionOperatorPtr<'db> {
    fn from(value: TerminalQuestionMarkPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPlusPtr<'db>> for MacroRepetitionOperatorPtr<'db> {
    fn from(value: TerminalPlusPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulPtr<'db>> for MacroRepetitionOperatorPtr<'db> {
    fn from(value: TerminalMulPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<MacroRepetitionOperatorMissingPtr<'db>> for MacroRepetitionOperatorPtr<'db> {
    fn from(value: MacroRepetitionOperatorMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalQuestionMarkGreen<'db>> for MacroRepetitionOperatorGreen<'db> {
    fn from(value: TerminalQuestionMarkGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPlusGreen<'db>> for MacroRepetitionOperatorGreen<'db> {
    fn from(value: TerminalPlusGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulGreen<'db>> for MacroRepetitionOperatorGreen<'db> {
    fn from(value: TerminalMulGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<MacroRepetitionOperatorMissingGreen<'db>> for MacroRepetitionOperatorGreen<'db> {
    fn from(value: MacroRepetitionOperatorMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroRepetitionOperatorGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroRepetitionOperator<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MacroRepetitionOperatorPtr<'db>;
    type Green = MacroRepetitionOperatorGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MacroRepetitionOperatorGreen(MacroRepetitionOperatorMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalQuestionMark => {
                MacroRepetitionOperator::ZeroOrOne(TerminalQuestionMark::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPlus => {
                MacroRepetitionOperator::OneOrMore(TerminalPlus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMul => {
                MacroRepetitionOperator::ZeroOrMore(TerminalMul::from_syntax_node(db, node))
            }
            SyntaxKind::MacroRepetitionOperatorMissing => MacroRepetitionOperator::Missing(
                MacroRepetitionOperatorMissing::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "MacroRepetitionOperator"
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalQuestionMark => Some(MacroRepetitionOperator::ZeroOrOne(
                TerminalQuestionMark::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalPlus => {
                Some(MacroRepetitionOperator::OneOrMore(TerminalPlus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMul => {
                Some(MacroRepetitionOperator::ZeroOrMore(TerminalMul::from_syntax_node(db, node)))
            }
            SyntaxKind::MacroRepetitionOperatorMissing => Some(MacroRepetitionOperator::Missing(
                MacroRepetitionOperatorMissing::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            MacroRepetitionOperator::ZeroOrOne(x) => x.as_syntax_node(),
            MacroRepetitionOperator::OneOrMore(x) => x.as_syntax_node(),
            MacroRepetitionOperator::ZeroOrMore(x) => x.as_syntax_node(),
            MacroRepetitionOperator::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroRepetitionOperatorPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> MacroRepetitionOperator<'db> {
    /// Checks if a kind of a variant of [MacroRepetitionOperator].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TerminalQuestionMark
                | SyntaxKind::TerminalPlus
                | SyntaxKind::TerminalMul
                | SyntaxKind::MacroRepetitionOperatorMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MacroRepetitionOperatorMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> MacroRepetitionOperatorMissing<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> MacroRepetitionOperatorMissingGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        MacroRepetitionOperatorMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroRepetitionOperatorMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> MacroRepetitionOperatorMissing<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroRepetitionOperatorMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> MacroRepetitionOperatorMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for MacroRepetitionOperatorMissingPtr<'db> {
    type SyntaxNode = MacroRepetitionOperatorMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MacroRepetitionOperatorMissing<'db> {
        MacroRepetitionOperatorMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroRepetitionOperatorMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroRepetitionOperatorMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroRepetitionOperatorMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroRepetitionOperatorMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MacroRepetitionOperatorMissing);
    type StablePtr = MacroRepetitionOperatorMissingPtr<'db>;
    type Green = MacroRepetitionOperatorMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MacroRepetitionOperatorMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroRepetitionOperatorMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::MacroRepetitionOperatorMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::MacroRepetitionOperatorMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::MacroRepetitionOperatorMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroRepetitionOperatorMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ParamIdent<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ParamIdent<'db> {
    pub const INDEX_IDENT: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        ident: TerminalIdentifierGreen<'db>,
    ) -> ParamIdentGreen<'db> {
        let children: Vec<GreenId> = vec![ident.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ParamIdentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParamIdent,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ParamIdent<'db> {
    pub fn ident(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParamIdentPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ParamIdentPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ParamIdentPtr<'db> {
    type SyntaxNode = ParamIdent<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ParamIdent<'db> {
        ParamIdent::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ParamIdentPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ParamIdentPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParamIdentGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ParamIdent<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ParamIdent);
    type StablePtr = ParamIdentPtr<'db>;
    type Green = ParamIdentGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ParamIdentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParamIdent,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ParamIdent,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ParamIdent
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ParamIdent { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ParamIdentPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ParamExpr<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ParamExpr<'db> {
    pub const INDEX_EXPR: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        expr: TerminalIdentifierGreen<'db>,
    ) -> ParamExprGreen<'db> {
        let children: Vec<GreenId> = vec![expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ParamExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParamExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ParamExpr<'db> {
    pub fn expr(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParamExprPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ParamExprPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ParamExprPtr<'db> {
    type SyntaxNode = ParamExpr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ParamExpr<'db> {
        ParamExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ParamExprPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ParamExprPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParamExprGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ParamExpr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ParamExpr);
    type StablePtr = ParamExprPtr<'db>;
    type Green = ParamExprGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ParamExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParamExpr,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ParamExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ParamExpr
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ParamExpr { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ParamExprPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum MacroParamKind<'db> {
    Identifier(ParamIdent<'db>),
    Expr(ParamExpr<'db>),
    Missing(MacroParamKindMissing<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroParamKindPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MacroParamKindPtr<'db> {
    type SyntaxNode = MacroParamKind<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        MacroParamKind::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroParamKindPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroParamKindPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ParamIdentPtr<'db>> for MacroParamKindPtr<'db> {
    fn from(value: ParamIdentPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ParamExprPtr<'db>> for MacroParamKindPtr<'db> {
    fn from(value: ParamExprPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<MacroParamKindMissingPtr<'db>> for MacroParamKindPtr<'db> {
    fn from(value: MacroParamKindMissingPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ParamIdentGreen<'db>> for MacroParamKindGreen<'db> {
    fn from(value: ParamIdentGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ParamExprGreen<'db>> for MacroParamKindGreen<'db> {
    fn from(value: ParamExprGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<MacroParamKindMissingGreen<'db>> for MacroParamKindGreen<'db> {
    fn from(value: MacroParamKindMissingGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroParamKindGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroParamKind<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MacroParamKindPtr<'db>;
    type Green = MacroParamKindGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MacroParamKindGreen(MacroParamKindMissing::missing(db).0)
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ParamIdent => {
                MacroParamKind::Identifier(ParamIdent::from_syntax_node(db, node))
            }
            SyntaxKind::ParamExpr => MacroParamKind::Expr(ParamExpr::from_syntax_node(db, node)),
            SyntaxKind::MacroParamKindMissing => {
                MacroParamKind::Missing(MacroParamKindMissing::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MacroParamKind")
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ParamIdent => {
                Some(MacroParamKind::Identifier(ParamIdent::from_syntax_node(db, node)))
            }
            SyntaxKind::ParamExpr => {
                Some(MacroParamKind::Expr(ParamExpr::from_syntax_node(db, node)))
            }
            SyntaxKind::MacroParamKindMissing => {
                Some(MacroParamKind::Missing(MacroParamKindMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            MacroParamKind::Identifier(x) => x.as_syntax_node(),
            MacroParamKind::Expr(x) => x.as_syntax_node(),
            MacroParamKind::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroParamKindPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> MacroParamKind<'db> {
    /// Checks if a kind of a variant of [MacroParamKind].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ParamIdent | SyntaxKind::ParamExpr | SyntaxKind::MacroParamKindMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MacroParamKindMissing<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> MacroParamKindMissing<'db> {
    pub fn new_green(db: &'db dyn SyntaxGroup) -> MacroParamKindMissingGreen<'db> {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        MacroParamKindMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroParamKindMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> MacroParamKindMissing<'db> {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroParamKindMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> MacroParamKindMissingPtr<'db> {}
impl<'db> TypedStablePtr<'db> for MacroParamKindMissingPtr<'db> {
    type SyntaxNode = MacroParamKindMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MacroParamKindMissing<'db> {
        MacroParamKindMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroParamKindMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroParamKindMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroParamKindMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroParamKindMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MacroParamKindMissing);
    type StablePtr = MacroParamKindMissingPtr<'db>;
    type Green = MacroParamKindMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MacroParamKindMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroParamKindMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::MacroParamKindMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::MacroParamKindMissing
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::MacroParamKindMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroParamKindMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum MacroElement<'db> {
    Token(TokenTreeLeaf<'db>),
    Param(MacroParam<'db>),
    Subtree(MacroWrapper<'db>),
    Repetition(MacroRepetition<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroElementPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MacroElementPtr<'db> {
    type SyntaxNode = MacroElement<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        MacroElement::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroElementPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroElementPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TokenTreeLeafPtr<'db>> for MacroElementPtr<'db> {
    fn from(value: TokenTreeLeafPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<MacroParamPtr<'db>> for MacroElementPtr<'db> {
    fn from(value: MacroParamPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<MacroWrapperPtr<'db>> for MacroElementPtr<'db> {
    fn from(value: MacroWrapperPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<MacroRepetitionPtr<'db>> for MacroElementPtr<'db> {
    fn from(value: MacroRepetitionPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TokenTreeLeafGreen<'db>> for MacroElementGreen<'db> {
    fn from(value: TokenTreeLeafGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<MacroParamGreen<'db>> for MacroElementGreen<'db> {
    fn from(value: MacroParamGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<MacroWrapperGreen<'db>> for MacroElementGreen<'db> {
    fn from(value: MacroWrapperGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<MacroRepetitionGreen<'db>> for MacroElementGreen<'db> {
    fn from(value: MacroRepetitionGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroElementGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroElement<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MacroElementPtr<'db>;
    type Green = MacroElementGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TokenTreeLeaf => {
                MacroElement::Token(TokenTreeLeaf::from_syntax_node(db, node))
            }
            SyntaxKind::MacroParam => MacroElement::Param(MacroParam::from_syntax_node(db, node)),
            SyntaxKind::MacroWrapper => {
                MacroElement::Subtree(MacroWrapper::from_syntax_node(db, node))
            }
            SyntaxKind::MacroRepetition => {
                MacroElement::Repetition(MacroRepetition::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MacroElement"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TokenTreeLeaf => {
                Some(MacroElement::Token(TokenTreeLeaf::from_syntax_node(db, node)))
            }
            SyntaxKind::MacroParam => {
                Some(MacroElement::Param(MacroParam::from_syntax_node(db, node)))
            }
            SyntaxKind::MacroWrapper => {
                Some(MacroElement::Subtree(MacroWrapper::from_syntax_node(db, node)))
            }
            SyntaxKind::MacroRepetition => {
                Some(MacroElement::Repetition(MacroRepetition::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            MacroElement::Token(x) => x.as_syntax_node(),
            MacroElement::Param(x) => x.as_syntax_node(),
            MacroElement::Subtree(x) => x.as_syntax_node(),
            MacroElement::Repetition(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroElementPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> MacroElement<'db> {
    /// Checks if a kind of a variant of [MacroElement].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TokenTreeLeaf
                | SyntaxKind::MacroParam
                | SyntaxKind::MacroWrapper
                | SyntaxKind::MacroRepetition
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MacroElements<'db>(ElementList<'db, MacroElement<'db>, 1>);
impl<'db> Deref for MacroElements<'db> {
    type Target = ElementList<'db, MacroElement<'db>, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'db> MacroElements<'db> {
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        children: Vec<MacroElementGreen<'db>>,
    ) -> MacroElementsGreen<'db> {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        MacroElementsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroElements,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroElementsPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for MacroElementsPtr<'db> {
    type SyntaxNode = MacroElements<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MacroElements<'db> {
        MacroElements::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroElementsPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroElementsPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroElementsGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroElements<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MacroElements);
    type StablePtr = MacroElementsPtr<'db>;
    type Green = MacroElementsGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MacroElementsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroElements,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        if node.kind(db) == SyntaxKind::MacroElements {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroElementsPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct MacroWrapper<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> MacroWrapper<'db> {
    pub const INDEX_SUBTREE: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        subtree: WrappedMacroGreen<'db>,
    ) -> MacroWrapperGreen<'db> {
        let children: Vec<GreenId> = vec![subtree.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        MacroWrapperGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroWrapper,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> MacroWrapper<'db> {
    pub fn subtree(&self, db: &'db dyn SyntaxGroup) -> WrappedMacro<'db> {
        WrappedMacro::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroWrapperPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> MacroWrapperPtr<'db> {}
impl<'db> TypedStablePtr<'db> for MacroWrapperPtr<'db> {
    type SyntaxNode = MacroWrapper<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> MacroWrapper<'db> {
        MacroWrapper::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<MacroWrapperPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: MacroWrapperPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct MacroWrapperGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for MacroWrapper<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MacroWrapper);
    type StablePtr = MacroWrapperPtr<'db>;
    type Green = MacroWrapperGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        MacroWrapperGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MacroWrapper,
                details: GreenNodeDetails::Node {
                    children: vec![WrappedMacro::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::MacroWrapper,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::MacroWrapper
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::MacroWrapper { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        MacroWrapperPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum WrappedMacro<'db> {
    Parenthesized(ParenthesizedMacro<'db>),
    Braced(BracedMacro<'db>),
    Bracketed(BracketedMacro<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedMacroPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for WrappedMacroPtr<'db> {
    type SyntaxNode = WrappedMacro<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        WrappedMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<WrappedMacroPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: WrappedMacroPtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<ParenthesizedMacroPtr<'db>> for WrappedMacroPtr<'db> {
    fn from(value: ParenthesizedMacroPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<BracedMacroPtr<'db>> for WrappedMacroPtr<'db> {
    fn from(value: BracedMacroPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<BracketedMacroPtr<'db>> for WrappedMacroPtr<'db> {
    fn from(value: BracketedMacroPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<ParenthesizedMacroGreen<'db>> for WrappedMacroGreen<'db> {
    fn from(value: ParenthesizedMacroGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<BracedMacroGreen<'db>> for WrappedMacroGreen<'db> {
    fn from(value: BracedMacroGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<BracketedMacroGreen<'db>> for WrappedMacroGreen<'db> {
    fn from(value: BracketedMacroGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct WrappedMacroGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for WrappedMacro<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = WrappedMacroPtr<'db>;
    type Green = WrappedMacroGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ParenthesizedMacro => {
                WrappedMacro::Parenthesized(ParenthesizedMacro::from_syntax_node(db, node))
            }
            SyntaxKind::BracedMacro => {
                WrappedMacro::Braced(BracedMacro::from_syntax_node(db, node))
            }
            SyntaxKind::BracketedMacro => {
                WrappedMacro::Bracketed(BracketedMacro::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "WrappedMacro"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ParenthesizedMacro => {
                Some(WrappedMacro::Parenthesized(ParenthesizedMacro::from_syntax_node(db, node)))
            }
            SyntaxKind::BracedMacro => {
                Some(WrappedMacro::Braced(BracedMacro::from_syntax_node(db, node)))
            }
            SyntaxKind::BracketedMacro => {
                Some(WrappedMacro::Bracketed(BracketedMacro::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            WrappedMacro::Parenthesized(x) => x.as_syntax_node(),
            WrappedMacro::Braced(x) => x.as_syntax_node(),
            WrappedMacro::Bracketed(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        WrappedMacroPtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> WrappedMacro<'db> {
    /// Checks if a kind of a variant of [WrappedMacro].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ParenthesizedMacro | SyntaxKind::BracedMacro | SyntaxKind::BracketedMacro
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct ParenthesizedMacro<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> ParenthesizedMacro<'db> {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_ELEMENTS: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lparen: TerminalLParenGreen<'db>,
        elements: MacroElementsGreen<'db>,
        rparen: TerminalRParenGreen<'db>,
    ) -> ParenthesizedMacroGreen<'db> {
        let children: Vec<GreenId> = vec![lparen.0, elements.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ParenthesizedMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParenthesizedMacro,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> ParenthesizedMacro<'db> {
    pub fn lparen(&self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.children[0])
    }
    pub fn elements(&self, db: &'db dyn SyntaxGroup) -> MacroElements<'db> {
        MacroElements::from_syntax_node(db, self.children[1])
    }
    pub fn rparen(&self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParenthesizedMacroPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> ParenthesizedMacroPtr<'db> {}
impl<'db> TypedStablePtr<'db> for ParenthesizedMacroPtr<'db> {
    type SyntaxNode = ParenthesizedMacro<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> ParenthesizedMacro<'db> {
        ParenthesizedMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<ParenthesizedMacroPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: ParenthesizedMacroPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct ParenthesizedMacroGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for ParenthesizedMacro<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ParenthesizedMacro);
    type StablePtr = ParenthesizedMacroPtr<'db>;
    type Green = ParenthesizedMacroGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        ParenthesizedMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParenthesizedMacro,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        MacroElements::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ParenthesizedMacro,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ParenthesizedMacro
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ParenthesizedMacro {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        ParenthesizedMacroPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct BracedMacro<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> BracedMacro<'db> {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ELEMENTS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen<'db>,
        elements: MacroElementsGreen<'db>,
        rbrace: TerminalRBraceGreen<'db>,
    ) -> BracedMacroGreen<'db> {
        let children: Vec<GreenId> = vec![lbrace.0, elements.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        BracedMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::BracedMacro,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> BracedMacro<'db> {
    pub fn lbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.children[0])
    }
    pub fn elements(&self, db: &'db dyn SyntaxGroup) -> MacroElements<'db> {
        MacroElements::from_syntax_node(db, self.children[1])
    }
    pub fn rbrace(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BracedMacroPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> BracedMacroPtr<'db> {}
impl<'db> TypedStablePtr<'db> for BracedMacroPtr<'db> {
    type SyntaxNode = BracedMacro<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> BracedMacro<'db> {
        BracedMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<BracedMacroPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: BracedMacroPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BracedMacroGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for BracedMacro<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::BracedMacro);
    type StablePtr = BracedMacroPtr<'db>;
    type Green = BracedMacroGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        BracedMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::BracedMacro,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        MacroElements::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::BracedMacro,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::BracedMacro
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::BracedMacro { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        BracedMacroPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct BracketedMacro<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> BracketedMacro<'db> {
    pub const INDEX_LBRACK: usize = 0;
    pub const INDEX_ELEMENTS: usize = 1;
    pub const INDEX_RBRACK: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        lbrack: TerminalLBrackGreen<'db>,
        elements: MacroElementsGreen<'db>,
        rbrack: TerminalRBrackGreen<'db>,
    ) -> BracketedMacroGreen<'db> {
        let children: Vec<GreenId> = vec![lbrack.0, elements.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        BracketedMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::BracketedMacro,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> BracketedMacro<'db> {
    pub fn lbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalLBrack<'db> {
        TerminalLBrack::from_syntax_node(db, self.children[0])
    }
    pub fn elements(&self, db: &'db dyn SyntaxGroup) -> MacroElements<'db> {
        MacroElements::from_syntax_node(db, self.children[1])
    }
    pub fn rbrack(&self, db: &'db dyn SyntaxGroup) -> TerminalRBrack<'db> {
        TerminalRBrack::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BracketedMacroPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> BracketedMacroPtr<'db> {}
impl<'db> TypedStablePtr<'db> for BracketedMacroPtr<'db> {
    type SyntaxNode = BracketedMacro<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> BracketedMacro<'db> {
        BracketedMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<BracketedMacroPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: BracketedMacroPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct BracketedMacroGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for BracketedMacro<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::BracketedMacro);
    type StablePtr = BracketedMacroPtr<'db>;
    type Green = BracketedMacroGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        BracketedMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::BracketedMacro,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrack::missing(db).0,
                        MacroElements::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::BracketedMacro,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::BracketedMacro
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::BracketedMacro {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        BracketedMacroPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct LegacyExprInlineMacro<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> LegacyExprInlineMacro<'db> {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_BANG: usize = 1;
    pub const INDEX_ARGUMENTS: usize = 2;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        path: ExprPathGreen<'db>,
        bang: TerminalNotGreen<'db>,
        arguments: WrappedArgListGreen<'db>,
    ) -> LegacyExprInlineMacroGreen<'db> {
        let children: Vec<GreenId> = vec![path.0, bang.0, arguments.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        LegacyExprInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::LegacyExprInlineMacro,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> LegacyExprInlineMacro<'db> {
    pub fn path(&self, db: &'db dyn SyntaxGroup) -> ExprPath<'db> {
        ExprPath::from_syntax_node(db, self.children[0])
    }
    pub fn bang(&self, db: &'db dyn SyntaxGroup) -> TerminalNot<'db> {
        TerminalNot::from_syntax_node(db, self.children[1])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> WrappedArgList<'db> {
        WrappedArgList::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct LegacyExprInlineMacroPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> LegacyExprInlineMacroPtr<'db> {}
impl<'db> TypedStablePtr<'db> for LegacyExprInlineMacroPtr<'db> {
    type SyntaxNode = LegacyExprInlineMacro<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> LegacyExprInlineMacro<'db> {
        LegacyExprInlineMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<LegacyExprInlineMacroPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: LegacyExprInlineMacroPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct LegacyExprInlineMacroGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for LegacyExprInlineMacro<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::LegacyExprInlineMacro);
    type StablePtr = LegacyExprInlineMacroPtr<'db>;
    type Green = LegacyExprInlineMacroGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        LegacyExprInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::LegacyExprInlineMacro,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ExprPath::missing(db).0,
                        TerminalNot::missing(db).0,
                        WrappedArgList::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::LegacyExprInlineMacro,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::LegacyExprInlineMacro
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::LegacyExprInlineMacro {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        LegacyExprInlineMacroPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct LegacyItemInlineMacro<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> LegacyItemInlineMacro<'db> {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_BANG: usize = 2;
    pub const INDEX_ARGUMENTS: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        attributes: AttributeListGreen<'db>,
        name: TerminalIdentifierGreen<'db>,
        bang: TerminalNotGreen<'db>,
        arguments: WrappedArgListGreen<'db>,
        semicolon: TerminalSemicolonGreen<'db>,
    ) -> LegacyItemInlineMacroGreen<'db> {
        let children: Vec<GreenId> = vec![attributes.0, name.0, bang.0, arguments.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        LegacyItemInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::LegacyItemInlineMacro,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> LegacyItemInlineMacro<'db> {
    pub fn attributes(&self, db: &'db dyn SyntaxGroup) -> AttributeList<'db> {
        AttributeList::from_syntax_node(db, self.children[0])
    }
    pub fn name(&self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.children[1])
    }
    pub fn bang(&self, db: &'db dyn SyntaxGroup) -> TerminalNot<'db> {
        TerminalNot::from_syntax_node(db, self.children[2])
    }
    pub fn arguments(&self, db: &'db dyn SyntaxGroup) -> WrappedArgList<'db> {
        WrappedArgList::from_syntax_node(db, self.children[3])
    }
    pub fn semicolon(&self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.children[4])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct LegacyItemInlineMacroPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> LegacyItemInlineMacroPtr<'db> {}
impl<'db> TypedStablePtr<'db> for LegacyItemInlineMacroPtr<'db> {
    type SyntaxNode = LegacyItemInlineMacro<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> LegacyItemInlineMacro<'db> {
        LegacyItemInlineMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<LegacyItemInlineMacroPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: LegacyItemInlineMacroPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct LegacyItemInlineMacroGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for LegacyItemInlineMacro<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::LegacyItemInlineMacro);
    type StablePtr = LegacyItemInlineMacroPtr<'db>;
    type Green = LegacyItemInlineMacroGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        LegacyItemInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::LegacyItemInlineMacro,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalNot::missing(db).0,
                        WrappedArgList::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::LegacyItemInlineMacro,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::LegacyItemInlineMacro
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::LegacyItemInlineMacro {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        LegacyItemInlineMacroPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TriviumSkippedNode<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> TriviumSkippedNode<'db> {
    pub const INDEX_NODE: usize = 0;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        node: SkippedNodeGreen<'db>,
    ) -> TriviumSkippedNodeGreen<'db> {
        let children: Vec<GreenId> = vec![node.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TriviumSkippedNodeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TriviumSkippedNode,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> TriviumSkippedNode<'db> {
    pub fn node(&self, db: &'db dyn SyntaxGroup) -> SkippedNode<'db> {
        SkippedNode::from_syntax_node(db, self.children[0])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TriviumSkippedNodePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TriviumSkippedNodePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TriviumSkippedNodePtr<'db> {
    type SyntaxNode = TriviumSkippedNode<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TriviumSkippedNode<'db> {
        TriviumSkippedNode::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TriviumSkippedNodePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TriviumSkippedNodePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TriviumSkippedNodeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TriviumSkippedNode<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TriviumSkippedNode);
    type StablePtr = TriviumSkippedNodePtr<'db>;
    type Green = TriviumSkippedNodeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TriviumSkippedNodeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TriviumSkippedNode,
                details: GreenNodeDetails::Node {
                    children: vec![SkippedNode::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TriviumSkippedNode,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TriviumSkippedNode
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TriviumSkippedNode {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TriviumSkippedNodePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum SkippedNode<'db> {
    AttributeList(AttributeList<'db>),
    VisibilityPub(VisibilityPub<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct SkippedNodePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for SkippedNodePtr<'db> {
    type SyntaxNode = SkippedNode<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        SkippedNode::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<SkippedNodePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: SkippedNodePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<AttributeListPtr<'db>> for SkippedNodePtr<'db> {
    fn from(value: AttributeListPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<VisibilityPubPtr<'db>> for SkippedNodePtr<'db> {
    fn from(value: VisibilityPubPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<AttributeListGreen<'db>> for SkippedNodeGreen<'db> {
    fn from(value: AttributeListGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<VisibilityPubGreen<'db>> for SkippedNodeGreen<'db> {
    fn from(value: VisibilityPubGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct SkippedNodeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for SkippedNode<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = SkippedNodePtr<'db>;
    type Green = SkippedNodeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::AttributeList => {
                SkippedNode::AttributeList(AttributeList::from_syntax_node(db, node))
            }
            SyntaxKind::VisibilityPub => {
                SkippedNode::VisibilityPub(VisibilityPub::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "SkippedNode"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::AttributeList => {
                Some(SkippedNode::AttributeList(AttributeList::from_syntax_node(db, node)))
            }
            SyntaxKind::VisibilityPub => {
                Some(SkippedNode::VisibilityPub(VisibilityPub::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            SkippedNode::AttributeList(x) => x.as_syntax_node(),
            SkippedNode::VisibilityPub(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        SkippedNodePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> SkippedNode<'db> {
    /// Checks if a kind of a variant of [SkippedNode].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::AttributeList | SyntaxKind::VisibilityPub)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenIdentifier<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenIdentifier<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenIdentifier,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenIdentifierPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenIdentifierPtr<'db> {
    type SyntaxNode = TokenIdentifier<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenIdentifier<'db> {
        TokenIdentifier::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenIdentifierPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenIdentifierPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenIdentifierGreen<'db>(pub GreenId<'db>);
impl<'db> TokenIdentifierGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenIdentifier<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenIdentifier);
    type StablePtr = TokenIdentifierPtr<'db>;
    type Green = TokenIdentifierGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenIdentifier)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenIdentifierPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalIdentifier<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalIdentifier<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalIdentifier;
    type TokenType = TokenIdentifier<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalIdentifier<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalIdentifier,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalIdentifier<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenIdentifier<'db> {
        TokenIdentifier::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalIdentifierPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalIdentifierPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalIdentifierPtr<'db> {
    type SyntaxNode = TerminalIdentifier<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalIdentifier<'db> {
        TerminalIdentifier::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalIdentifierPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalIdentifierPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalIdentifierGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalIdentifier<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalIdentifier);
    type StablePtr = TerminalIdentifierPtr<'db>;
    type Green = TerminalIdentifierGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalIdentifier,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenIdentifier::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalIdentifier,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalIdentifier
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalIdentifier {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalIdentifierPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenLiteralNumber<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenLiteralNumber<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLiteralNumberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLiteralNumber,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLiteralNumberPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenLiteralNumberPtr<'db> {
    type SyntaxNode = TokenLiteralNumber<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenLiteralNumber<'db> {
        TokenLiteralNumber::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenLiteralNumberPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenLiteralNumberPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLiteralNumberGreen<'db>(pub GreenId<'db>);
impl<'db> TokenLiteralNumberGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenLiteralNumber<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLiteralNumber);
    type StablePtr = TokenLiteralNumberPtr<'db>;
    type Green = TokenLiteralNumberGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenLiteralNumberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenLiteralNumber
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenLiteralNumberPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalLiteralNumber<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalLiteralNumber<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalLiteralNumber;
    type TokenType = TokenLiteralNumber<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalLiteralNumber<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLiteralNumberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLiteralNumber,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalLiteralNumber<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenLiteralNumber<'db> {
        TokenLiteralNumber::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLiteralNumberPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalLiteralNumberPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalLiteralNumberPtr<'db> {
    type SyntaxNode = TerminalLiteralNumber<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalLiteralNumber<'db> {
        TerminalLiteralNumber::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalLiteralNumberPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalLiteralNumberPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLiteralNumberGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalLiteralNumber<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLiteralNumber);
    type StablePtr = TerminalLiteralNumberPtr<'db>;
    type Green = TerminalLiteralNumberGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalLiteralNumberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLiteralNumber,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLiteralNumber::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLiteralNumber,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLiteralNumber
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLiteralNumber {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalLiteralNumberPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenShortString<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenShortString<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenShortStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenShortString,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenShortStringPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenShortStringPtr<'db> {
    type SyntaxNode = TokenShortString<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenShortString<'db> {
        TokenShortString::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenShortStringPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenShortStringPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenShortStringGreen<'db>(pub GreenId<'db>);
impl<'db> TokenShortStringGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenShortString<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenShortString);
    type StablePtr = TokenShortStringPtr<'db>;
    type Green = TokenShortStringGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenShortStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenShortString)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenShortStringPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalShortString<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalShortString<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalShortString;
    type TokenType = TokenShortString<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalShortString<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalShortStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalShortString,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalShortString<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenShortString<'db> {
        TokenShortString::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalShortStringPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalShortStringPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalShortStringPtr<'db> {
    type SyntaxNode = TerminalShortString<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalShortString<'db> {
        TerminalShortString::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalShortStringPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalShortStringPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalShortStringGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalShortString<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalShortString);
    type StablePtr = TerminalShortStringPtr<'db>;
    type Green = TerminalShortStringGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalShortStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalShortString,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenShortString::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalShortString,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalShortString
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalShortString {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalShortStringPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenString<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenString<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenString,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenStringPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenStringPtr<'db> {
    type SyntaxNode = TokenString<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenString<'db> {
        TokenString::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenStringPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenStringPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenStringGreen<'db>(pub GreenId<'db>);
impl<'db> TokenStringGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenString<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenString);
    type StablePtr = TokenStringPtr<'db>;
    type Green = TokenStringGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenString)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenStringPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalString<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalString<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalString;
    type TokenType = TokenString<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalString<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalString,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalString<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenString<'db> {
        TokenString::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalStringPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalStringPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalStringPtr<'db> {
    type SyntaxNode = TerminalString<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalString<'db> {
        TerminalString::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalStringPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalStringPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalStringGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalString<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalString);
    type StablePtr = TerminalStringPtr<'db>;
    type Green = TerminalStringGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalString,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenString::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalString,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalString
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalString {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalStringPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenAs<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenAs<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenAsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenAs,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenAsPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenAsPtr<'db> {
    type SyntaxNode = TokenAs<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenAs<'db> {
        TokenAs::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenAsPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenAsPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenAsGreen<'db>(pub GreenId<'db>);
impl<'db> TokenAsGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenAs<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenAs);
    type StablePtr = TokenAsPtr<'db>;
    type Green = TokenAsGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenAsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenAs)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenAsPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalAs<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalAs<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalAs;
    type TokenType = TokenAs<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalAs<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalAsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAs,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalAs<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenAs<'db> {
        TokenAs::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalAsPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalAsPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalAsPtr<'db> {
    type SyntaxNode = TerminalAs<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalAs<'db> {
        TerminalAs::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalAsPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalAsPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalAsGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalAs<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalAs);
    type StablePtr = TerminalAsPtr<'db>;
    type Green = TerminalAsGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalAsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAs,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenAs::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalAs,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalAs
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalAs { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalAsPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenConst<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenConst<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenConst,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenConstPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenConstPtr<'db> {
    type SyntaxNode = TokenConst<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenConst<'db> {
        TokenConst::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenConstPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenConstPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenConstGreen<'db>(pub GreenId<'db>);
impl<'db> TokenConstGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenConst<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenConst);
    type StablePtr = TokenConstPtr<'db>;
    type Green = TokenConstGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenConst)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenConstPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalConst<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalConst<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalConst;
    type TokenType = TokenConst<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalConst<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalConst,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalConst<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenConst<'db> {
        TokenConst::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalConstPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalConstPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalConstPtr<'db> {
    type SyntaxNode = TerminalConst<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalConst<'db> {
        TerminalConst::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalConstPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalConstPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalConstGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalConst<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalConst);
    type StablePtr = TerminalConstPtr<'db>;
    type Green = TerminalConstGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalConst,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenConst::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalConst,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalConst
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalConst {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalConstPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenElse<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenElse<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenElseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenElse,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenElsePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenElsePtr<'db> {
    type SyntaxNode = TokenElse<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenElse<'db> {
        TokenElse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenElsePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenElsePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenElseGreen<'db>(pub GreenId<'db>);
impl<'db> TokenElseGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenElse<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenElse);
    type StablePtr = TokenElsePtr<'db>;
    type Green = TokenElseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenElseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenElse)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenElsePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalElse<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalElse<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalElse;
    type TokenType = TokenElse<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalElse<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalElseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalElse,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalElse<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenElse<'db> {
        TokenElse::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalElsePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalElsePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalElsePtr<'db> {
    type SyntaxNode = TerminalElse<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalElse<'db> {
        TerminalElse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalElsePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalElsePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalElseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalElse<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalElse);
    type StablePtr = TerminalElsePtr<'db>;
    type Green = TerminalElseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalElseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalElse,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenElse::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalElse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalElse
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalElse { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalElsePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenEnum<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenEnum<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenEnum,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenEnumPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenEnumPtr<'db> {
    type SyntaxNode = TokenEnum<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenEnum<'db> {
        TokenEnum::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenEnumPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenEnumPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenEnumGreen<'db>(pub GreenId<'db>);
impl<'db> TokenEnumGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenEnum<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEnum);
    type StablePtr = TokenEnumPtr<'db>;
    type Green = TokenEnumGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEnum)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenEnumPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalEnum<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalEnum<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalEnum;
    type TokenType = TokenEnum<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalEnum<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEnum,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalEnum<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenEnum<'db> {
        TokenEnum::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalEnumPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalEnumPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalEnumPtr<'db> {
    type SyntaxNode = TerminalEnum<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalEnum<'db> {
        TerminalEnum::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalEnumPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalEnumPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalEnumGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalEnum<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEnum);
    type StablePtr = TerminalEnumPtr<'db>;
    type Green = TerminalEnumGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEnum,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenEnum::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEnum,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEnum
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalEnum { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalEnumPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenExtern<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenExtern<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenExternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenExtern,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenExternPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenExternPtr<'db> {
    type SyntaxNode = TokenExtern<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenExtern<'db> {
        TokenExtern::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenExternPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenExternPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenExternGreen<'db>(pub GreenId<'db>);
impl<'db> TokenExternGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenExtern<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenExtern);
    type StablePtr = TokenExternPtr<'db>;
    type Green = TokenExternGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenExternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenExtern)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenExternPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalExtern<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalExtern<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalExtern;
    type TokenType = TokenExtern<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalExtern<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalExternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalExtern,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalExtern<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenExtern<'db> {
        TokenExtern::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalExternPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalExternPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalExternPtr<'db> {
    type SyntaxNode = TerminalExtern<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalExtern<'db> {
        TerminalExtern::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalExternPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalExternPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalExternGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalExtern<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalExtern);
    type StablePtr = TerminalExternPtr<'db>;
    type Green = TerminalExternGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalExternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalExtern,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenExtern::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalExtern,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalExtern
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalExtern {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalExternPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenFalse<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenFalse<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenFalseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenFalse,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenFalsePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenFalsePtr<'db> {
    type SyntaxNode = TokenFalse<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenFalse<'db> {
        TokenFalse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenFalsePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenFalsePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenFalseGreen<'db>(pub GreenId<'db>);
impl<'db> TokenFalseGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenFalse<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenFalse);
    type StablePtr = TokenFalsePtr<'db>;
    type Green = TokenFalseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenFalseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenFalse)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenFalsePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalFalse<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalFalse<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalFalse;
    type TokenType = TokenFalse<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalFalse<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalFalseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFalse,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalFalse<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenFalse<'db> {
        TokenFalse::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalFalsePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalFalsePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalFalsePtr<'db> {
    type SyntaxNode = TerminalFalse<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalFalse<'db> {
        TerminalFalse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalFalsePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalFalsePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalFalseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalFalse<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalFalse);
    type StablePtr = TerminalFalsePtr<'db>;
    type Green = TerminalFalseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalFalseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFalse,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenFalse::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalFalse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalFalse
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalFalse {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalFalsePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenFunction<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenFunction<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenFunction,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenFunctionPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenFunctionPtr<'db> {
    type SyntaxNode = TokenFunction<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenFunction<'db> {
        TokenFunction::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenFunctionPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenFunctionPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenFunctionGreen<'db>(pub GreenId<'db>);
impl<'db> TokenFunctionGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenFunction<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenFunction);
    type StablePtr = TokenFunctionPtr<'db>;
    type Green = TokenFunctionGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenFunction)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenFunctionPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalFunction<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalFunction<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalFunction;
    type TokenType = TokenFunction<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalFunction<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFunction,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalFunction<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenFunction<'db> {
        TokenFunction::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalFunctionPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalFunctionPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalFunctionPtr<'db> {
    type SyntaxNode = TerminalFunction<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalFunction<'db> {
        TerminalFunction::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalFunctionPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalFunctionPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalFunctionGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalFunction<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalFunction);
    type StablePtr = TerminalFunctionPtr<'db>;
    type Green = TerminalFunctionGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFunction,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenFunction::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalFunction,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalFunction
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalFunction {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalFunctionPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenIf<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenIf<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenIf,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenIfPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenIfPtr<'db> {
    type SyntaxNode = TokenIf<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenIf<'db> {
        TokenIf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenIfPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenIfPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenIfGreen<'db>(pub GreenId<'db>);
impl<'db> TokenIfGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenIf<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenIf);
    type StablePtr = TokenIfPtr<'db>;
    type Green = TokenIfGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenIf)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenIfPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalIf<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalIf<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalIf;
    type TokenType = TokenIf<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalIf<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalIf,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalIf<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenIf<'db> {
        TokenIf::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalIfPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalIfPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalIfPtr<'db> {
    type SyntaxNode = TerminalIf<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalIf<'db> {
        TerminalIf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalIfPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalIfPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalIfGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalIf<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalIf);
    type StablePtr = TerminalIfPtr<'db>;
    type Green = TerminalIfGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalIf,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenIf::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalIf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalIf
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalIf { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalIfPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenWhile<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenWhile<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenWhile,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenWhilePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenWhilePtr<'db> {
    type SyntaxNode = TokenWhile<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenWhile<'db> {
        TokenWhile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenWhilePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenWhilePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenWhileGreen<'db>(pub GreenId<'db>);
impl<'db> TokenWhileGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenWhile<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenWhile);
    type StablePtr = TokenWhilePtr<'db>;
    type Green = TokenWhileGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenWhile)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenWhilePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalWhile<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalWhile<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalWhile;
    type TokenType = TokenWhile<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalWhile<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalWhile,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalWhile<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenWhile<'db> {
        TokenWhile::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalWhilePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalWhilePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalWhilePtr<'db> {
    type SyntaxNode = TerminalWhile<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalWhile<'db> {
        TerminalWhile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalWhilePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalWhilePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalWhileGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalWhile<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalWhile);
    type StablePtr = TerminalWhilePtr<'db>;
    type Green = TerminalWhileGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalWhile,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenWhile::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalWhile,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalWhile
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalWhile {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalWhilePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenFor<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenFor<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenFor,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenForPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenForPtr<'db> {
    type SyntaxNode = TokenFor<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenFor<'db> {
        TokenFor::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenForPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenForPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenForGreen<'db>(pub GreenId<'db>);
impl<'db> TokenForGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenFor<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenFor);
    type StablePtr = TokenForPtr<'db>;
    type Green = TokenForGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenFor)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenForPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalFor<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalFor<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalFor;
    type TokenType = TokenFor<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalFor<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFor,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalFor<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenFor<'db> {
        TokenFor::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalForPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalForPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalForPtr<'db> {
    type SyntaxNode = TerminalFor<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalFor<'db> {
        TerminalFor::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalForPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalForPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalForGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalFor<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalFor);
    type StablePtr = TerminalForPtr<'db>;
    type Green = TerminalForGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFor,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenFor::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalFor,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalFor
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalFor { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalForPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenLoop<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenLoop<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLoop,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLoopPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenLoopPtr<'db> {
    type SyntaxNode = TokenLoop<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenLoop<'db> {
        TokenLoop::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenLoopPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenLoopPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLoopGreen<'db>(pub GreenId<'db>);
impl<'db> TokenLoopGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenLoop<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLoop);
    type StablePtr = TokenLoopPtr<'db>;
    type Green = TokenLoopGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLoop)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenLoopPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalLoop<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalLoop<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalLoop;
    type TokenType = TokenLoop<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalLoop<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLoop,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalLoop<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenLoop<'db> {
        TokenLoop::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLoopPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalLoopPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalLoopPtr<'db> {
    type SyntaxNode = TerminalLoop<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalLoop<'db> {
        TerminalLoop::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalLoopPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalLoopPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLoopGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalLoop<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLoop);
    type StablePtr = TerminalLoopPtr<'db>;
    type Green = TerminalLoopGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLoop,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLoop::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLoop,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLoop
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLoop { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalLoopPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenImpl<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenImpl<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenImpl,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenImplPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenImplPtr<'db> {
    type SyntaxNode = TokenImpl<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenImpl<'db> {
        TokenImpl::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenImplPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenImplPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenImplGreen<'db>(pub GreenId<'db>);
impl<'db> TokenImplGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenImpl<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenImpl);
    type StablePtr = TokenImplPtr<'db>;
    type Green = TokenImplGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenImpl)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenImplPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalImpl<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalImpl<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalImpl;
    type TokenType = TokenImpl<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalImpl<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalImpl,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalImpl<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenImpl<'db> {
        TokenImpl::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalImplPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalImplPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalImplPtr<'db> {
    type SyntaxNode = TerminalImpl<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalImpl<'db> {
        TerminalImpl::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalImplPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalImplPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalImplGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalImpl<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalImpl);
    type StablePtr = TerminalImplPtr<'db>;
    type Green = TerminalImplGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalImpl,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenImpl::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalImpl,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalImpl
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalImpl { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalImplPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenImplicits<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenImplicits<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenImplicitsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenImplicits,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenImplicitsPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenImplicitsPtr<'db> {
    type SyntaxNode = TokenImplicits<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenImplicits<'db> {
        TokenImplicits::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenImplicitsPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenImplicitsPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenImplicitsGreen<'db>(pub GreenId<'db>);
impl<'db> TokenImplicitsGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenImplicits<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenImplicits);
    type StablePtr = TokenImplicitsPtr<'db>;
    type Green = TokenImplicitsGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenImplicitsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenImplicits)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenImplicitsPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalImplicits<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalImplicits<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalImplicits;
    type TokenType = TokenImplicits<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalImplicits<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalImplicitsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalImplicits,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalImplicits<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenImplicits<'db> {
        TokenImplicits::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalImplicitsPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalImplicitsPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalImplicitsPtr<'db> {
    type SyntaxNode = TerminalImplicits<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalImplicits<'db> {
        TerminalImplicits::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalImplicitsPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalImplicitsPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalImplicitsGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalImplicits<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalImplicits);
    type StablePtr = TerminalImplicitsPtr<'db>;
    type Green = TerminalImplicitsGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalImplicitsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalImplicits,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenImplicits::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalImplicits,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalImplicits
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalImplicits {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalImplicitsPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenLet<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenLet<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLet,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLetPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenLetPtr<'db> {
    type SyntaxNode = TokenLet<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenLet<'db> {
        TokenLet::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenLetPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenLetPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLetGreen<'db>(pub GreenId<'db>);
impl<'db> TokenLetGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenLet<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLet);
    type StablePtr = TokenLetPtr<'db>;
    type Green = TokenLetGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLet)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenLetPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalLet<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalLet<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalLet;
    type TokenType = TokenLet<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalLet<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLet,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalLet<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenLet<'db> {
        TokenLet::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLetPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalLetPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalLetPtr<'db> {
    type SyntaxNode = TerminalLet<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalLet<'db> {
        TerminalLet::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalLetPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalLetPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLetGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalLet<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLet);
    type StablePtr = TerminalLetPtr<'db>;
    type Green = TerminalLetGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLet,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLet::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLet,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLet
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLet { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalLetPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenMacro<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenMacro<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMacro,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMacroPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenMacroPtr<'db> {
    type SyntaxNode = TokenMacro<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenMacro<'db> {
        TokenMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenMacroPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenMacroPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMacroGreen<'db>(pub GreenId<'db>);
impl<'db> TokenMacroGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenMacro<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMacro);
    type StablePtr = TokenMacroPtr<'db>;
    type Green = TokenMacroGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMacro)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenMacroPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalMacro<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalMacro<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalMacro;
    type TokenType = TokenMacro<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalMacro<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMacro,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalMacro<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenMacro<'db> {
        TokenMacro::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMacroPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalMacroPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalMacroPtr<'db> {
    type SyntaxNode = TerminalMacro<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalMacro<'db> {
        TerminalMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalMacroPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalMacroPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMacroGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalMacro<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMacro);
    type StablePtr = TerminalMacroPtr<'db>;
    type Green = TerminalMacroGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMacro,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMacro::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMacro,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMacro
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMacro {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalMacroPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenMatch<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenMatch<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMatch,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMatchPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenMatchPtr<'db> {
    type SyntaxNode = TokenMatch<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenMatch<'db> {
        TokenMatch::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenMatchPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenMatchPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMatchGreen<'db>(pub GreenId<'db>);
impl<'db> TokenMatchGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenMatch<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMatch);
    type StablePtr = TokenMatchPtr<'db>;
    type Green = TokenMatchGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMatch)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenMatchPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalMatch<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalMatch<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalMatch;
    type TokenType = TokenMatch<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalMatch<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMatch,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalMatch<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenMatch<'db> {
        TokenMatch::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMatchPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalMatchPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalMatchPtr<'db> {
    type SyntaxNode = TerminalMatch<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalMatch<'db> {
        TerminalMatch::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalMatchPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalMatchPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMatchGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalMatch<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMatch);
    type StablePtr = TerminalMatchPtr<'db>;
    type Green = TerminalMatchGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMatch,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMatch::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMatch,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMatch
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMatch {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalMatchPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenModule<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenModule<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenModule,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenModulePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenModulePtr<'db> {
    type SyntaxNode = TokenModule<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenModule<'db> {
        TokenModule::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenModulePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenModulePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenModuleGreen<'db>(pub GreenId<'db>);
impl<'db> TokenModuleGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenModule<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenModule);
    type StablePtr = TokenModulePtr<'db>;
    type Green = TokenModuleGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenModule)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenModulePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalModule<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalModule<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalModule;
    type TokenType = TokenModule<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalModule<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalModule,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalModule<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenModule<'db> {
        TokenModule::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalModulePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalModulePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalModulePtr<'db> {
    type SyntaxNode = TerminalModule<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalModule<'db> {
        TerminalModule::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalModulePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalModulePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalModuleGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalModule<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalModule);
    type StablePtr = TerminalModulePtr<'db>;
    type Green = TerminalModuleGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalModule,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenModule::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalModule,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalModule
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalModule {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalModulePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenMut<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenMut<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMutGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMut,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMutPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenMutPtr<'db> {
    type SyntaxNode = TokenMut<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenMut<'db> {
        TokenMut::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenMutPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenMutPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMutGreen<'db>(pub GreenId<'db>);
impl<'db> TokenMutGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenMut<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMut);
    type StablePtr = TokenMutPtr<'db>;
    type Green = TokenMutGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenMutGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMut)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenMutPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalMut<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalMut<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalMut;
    type TokenType = TokenMut<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalMut<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMutGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMut,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalMut<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenMut<'db> {
        TokenMut::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMutPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalMutPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalMutPtr<'db> {
    type SyntaxNode = TerminalMut<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalMut<'db> {
        TerminalMut::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalMutPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalMutPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMutGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalMut<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMut);
    type StablePtr = TerminalMutPtr<'db>;
    type Green = TerminalMutGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalMutGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMut,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMut::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMut,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMut
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMut { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalMutPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenNoPanic<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenNoPanic<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNoPanicGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenNoPanic,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenNoPanicPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenNoPanicPtr<'db> {
    type SyntaxNode = TokenNoPanic<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenNoPanic<'db> {
        TokenNoPanic::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenNoPanicPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenNoPanicPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenNoPanicGreen<'db>(pub GreenId<'db>);
impl<'db> TokenNoPanicGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenNoPanic<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNoPanic);
    type StablePtr = TokenNoPanicPtr<'db>;
    type Green = TokenNoPanicGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenNoPanicGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNoPanic)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenNoPanicPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalNoPanic<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalNoPanic<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalNoPanic;
    type TokenType = TokenNoPanic<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalNoPanic<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalNoPanicGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNoPanic,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalNoPanic<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenNoPanic<'db> {
        TokenNoPanic::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalNoPanicPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalNoPanicPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalNoPanicPtr<'db> {
    type SyntaxNode = TerminalNoPanic<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalNoPanic<'db> {
        TerminalNoPanic::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalNoPanicPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalNoPanicPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalNoPanicGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalNoPanic<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalNoPanic);
    type StablePtr = TerminalNoPanicPtr<'db>;
    type Green = TerminalNoPanicGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalNoPanicGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNoPanic,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenNoPanic::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalNoPanic,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalNoPanic
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalNoPanic {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalNoPanicPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenOf<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenOf<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenOfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenOf,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenOfPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenOfPtr<'db> {
    type SyntaxNode = TokenOf<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenOf<'db> {
        TokenOf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenOfPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenOfPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenOfGreen<'db>(pub GreenId<'db>);
impl<'db> TokenOfGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenOf<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenOf);
    type StablePtr = TokenOfPtr<'db>;
    type Green = TokenOfGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenOfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenOf)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenOfPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalOf<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalOf<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalOf;
    type TokenType = TokenOf<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalOf<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalOfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOf,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalOf<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenOf<'db> {
        TokenOf::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalOfPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalOfPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalOfPtr<'db> {
    type SyntaxNode = TerminalOf<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalOf<'db> {
        TerminalOf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalOfPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalOfPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalOfGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalOf<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalOf);
    type StablePtr = TerminalOfPtr<'db>;
    type Green = TerminalOfGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalOfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOf,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenOf::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalOf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalOf
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalOf { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalOfPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenRef<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenRef<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRefGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenRef,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenRefPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenRefPtr<'db> {
    type SyntaxNode = TokenRef<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenRef<'db> {
        TokenRef::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenRefPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenRefPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenRefGreen<'db>(pub GreenId<'db>);
impl<'db> TokenRefGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenRef<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRef);
    type StablePtr = TokenRefPtr<'db>;
    type Green = TokenRefGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenRefGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRef)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenRefPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalRef<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalRef<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalRef;
    type TokenType = TokenRef<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalRef<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalRefGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRef,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalRef<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenRef<'db> {
        TokenRef::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalRefPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalRefPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalRefPtr<'db> {
    type SyntaxNode = TerminalRef<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalRef<'db> {
        TerminalRef::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalRefPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalRefPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalRefGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalRef<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRef);
    type StablePtr = TerminalRefPtr<'db>;
    type Green = TerminalRefGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalRefGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRef,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenRef::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRef,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRef
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalRef { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalRefPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenContinue<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenContinue<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenContinue,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenContinuePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenContinuePtr<'db> {
    type SyntaxNode = TokenContinue<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenContinue<'db> {
        TokenContinue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenContinuePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenContinuePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenContinueGreen<'db>(pub GreenId<'db>);
impl<'db> TokenContinueGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenContinue<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenContinue);
    type StablePtr = TokenContinuePtr<'db>;
    type Green = TokenContinueGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenContinue)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenContinuePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalContinue<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalContinue<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalContinue;
    type TokenType = TokenContinue<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalContinue<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalContinue,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalContinue<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenContinue<'db> {
        TokenContinue::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalContinuePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalContinuePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalContinuePtr<'db> {
    type SyntaxNode = TerminalContinue<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalContinue<'db> {
        TerminalContinue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalContinuePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalContinuePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalContinueGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalContinue<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalContinue);
    type StablePtr = TerminalContinuePtr<'db>;
    type Green = TerminalContinueGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalContinue,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenContinue::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalContinue,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalContinue
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalContinue {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalContinuePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenReturn<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenReturn<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenReturn,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenReturnPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenReturnPtr<'db> {
    type SyntaxNode = TokenReturn<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenReturn<'db> {
        TokenReturn::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenReturnPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenReturnPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenReturnGreen<'db>(pub GreenId<'db>);
impl<'db> TokenReturnGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenReturn<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenReturn);
    type StablePtr = TokenReturnPtr<'db>;
    type Green = TokenReturnGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenReturn)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenReturnPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalReturn<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalReturn<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalReturn;
    type TokenType = TokenReturn<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalReturn<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalReturn,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalReturn<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenReturn<'db> {
        TokenReturn::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalReturnPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalReturnPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalReturnPtr<'db> {
    type SyntaxNode = TerminalReturn<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalReturn<'db> {
        TerminalReturn::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalReturnPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalReturnPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalReturnGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalReturn<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalReturn);
    type StablePtr = TerminalReturnPtr<'db>;
    type Green = TerminalReturnGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalReturn,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenReturn::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalReturn,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalReturn
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalReturn {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalReturnPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenBreak<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenBreak<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenBreak,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenBreakPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenBreakPtr<'db> {
    type SyntaxNode = TokenBreak<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenBreak<'db> {
        TokenBreak::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenBreakPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenBreakPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenBreakGreen<'db>(pub GreenId<'db>);
impl<'db> TokenBreakGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenBreak<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenBreak);
    type StablePtr = TokenBreakPtr<'db>;
    type Green = TokenBreakGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenBreak)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenBreakPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalBreak<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalBreak<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalBreak;
    type TokenType = TokenBreak<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalBreak<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBreak,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalBreak<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenBreak<'db> {
        TokenBreak::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalBreakPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalBreakPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalBreakPtr<'db> {
    type SyntaxNode = TerminalBreak<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalBreak<'db> {
        TerminalBreak::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalBreakPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalBreakPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalBreakGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalBreak<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalBreak);
    type StablePtr = TerminalBreakPtr<'db>;
    type Green = TerminalBreakGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBreak,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenBreak::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalBreak,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalBreak
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalBreak {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalBreakPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenStruct<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenStruct<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenStruct,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenStructPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenStructPtr<'db> {
    type SyntaxNode = TokenStruct<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenStruct<'db> {
        TokenStruct::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenStructPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenStructPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenStructGreen<'db>(pub GreenId<'db>);
impl<'db> TokenStructGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenStruct<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenStruct);
    type StablePtr = TokenStructPtr<'db>;
    type Green = TokenStructGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenStruct)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenStructPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalStruct<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalStruct<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalStruct;
    type TokenType = TokenStruct<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalStruct<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalStruct,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalStruct<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenStruct<'db> {
        TokenStruct::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalStructPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalStructPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalStructPtr<'db> {
    type SyntaxNode = TerminalStruct<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalStruct<'db> {
        TerminalStruct::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalStructPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalStructPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalStructGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalStruct<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalStruct);
    type StablePtr = TerminalStructPtr<'db>;
    type Green = TerminalStructGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalStruct,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenStruct::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalStruct,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalStruct
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalStruct {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalStructPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenTrait<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenTrait<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTrait,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTraitPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenTraitPtr<'db> {
    type SyntaxNode = TokenTrait<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenTrait<'db> {
        TokenTrait::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenTraitPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenTraitPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTraitGreen<'db>(pub GreenId<'db>);
impl<'db> TokenTraitGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenTrait<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTrait);
    type StablePtr = TokenTraitPtr<'db>;
    type Green = TokenTraitGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenTrait)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenTraitPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalTrait<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalTrait<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalTrait;
    type TokenType = TokenTrait<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalTrait<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalTrait,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalTrait<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenTrait<'db> {
        TokenTrait::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalTraitPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalTraitPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalTraitPtr<'db> {
    type SyntaxNode = TerminalTrait<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalTrait<'db> {
        TerminalTrait::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalTraitPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalTraitPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalTraitGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalTrait<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalTrait);
    type StablePtr = TerminalTraitPtr<'db>;
    type Green = TerminalTraitGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalTrait,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenTrait::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalTrait,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalTrait
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalTrait {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalTraitPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenTrue<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenTrue<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenTrueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTrue,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTruePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenTruePtr<'db> {
    type SyntaxNode = TokenTrue<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenTrue<'db> {
        TokenTrue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenTruePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenTruePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTrueGreen<'db>(pub GreenId<'db>);
impl<'db> TokenTrueGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenTrue<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTrue);
    type StablePtr = TokenTruePtr<'db>;
    type Green = TokenTrueGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenTrueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenTrue)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenTruePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalTrue<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalTrue<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalTrue;
    type TokenType = TokenTrue<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalTrue<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalTrueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalTrue,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalTrue<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenTrue<'db> {
        TokenTrue::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalTruePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalTruePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalTruePtr<'db> {
    type SyntaxNode = TerminalTrue<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalTrue<'db> {
        TerminalTrue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalTruePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalTruePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalTrueGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalTrue<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalTrue);
    type StablePtr = TerminalTruePtr<'db>;
    type Green = TerminalTrueGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalTrueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalTrue,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenTrue::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalTrue,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalTrue
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalTrue { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalTruePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenType<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenType<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenType,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTypePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenTypePtr<'db> {
    type SyntaxNode = TokenType<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenType<'db> {
        TokenType::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenTypePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenTypePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenTypeGreen<'db>(pub GreenId<'db>);
impl<'db> TokenTypeGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenType<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenType);
    type StablePtr = TokenTypePtr<'db>;
    type Green = TokenTypeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenType)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenTypePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalType<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalType<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalType;
    type TokenType = TokenType<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalType<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalType,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalType<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenType<'db> {
        TokenType::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalTypePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalTypePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalTypePtr<'db> {
    type SyntaxNode = TerminalType<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalType<'db> {
        TerminalType::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalTypePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalTypePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalTypeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalType<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalType);
    type StablePtr = TerminalTypePtr<'db>;
    type Green = TerminalTypeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalType,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenType::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalType,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalType
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalType { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalTypePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenUse<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenUse<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenUse,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenUsePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenUsePtr<'db> {
    type SyntaxNode = TokenUse<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenUse<'db> {
        TokenUse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenUsePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenUsePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenUseGreen<'db>(pub GreenId<'db>);
impl<'db> TokenUseGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenUse<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenUse);
    type StablePtr = TokenUsePtr<'db>;
    type Green = TokenUseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenUse)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenUsePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalUse<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalUse<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalUse;
    type TokenType = TokenUse<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalUse<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalUse,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalUse<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenUse<'db> {
        TokenUse::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalUsePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalUsePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalUsePtr<'db> {
    type SyntaxNode = TerminalUse<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalUse<'db> {
        TerminalUse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalUsePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalUsePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalUseGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalUse<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalUse);
    type StablePtr = TerminalUsePtr<'db>;
    type Green = TerminalUseGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalUse,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenUse::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalUse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalUse
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalUse { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalUsePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenPub<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenPub<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenPub,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenPubPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenPubPtr<'db> {
    type SyntaxNode = TokenPub<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenPub<'db> {
        TokenPub::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenPubPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenPubPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenPubGreen<'db>(pub GreenId<'db>);
impl<'db> TokenPubGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenPub<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenPub);
    type StablePtr = TokenPubPtr<'db>;
    type Green = TokenPubGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenPub)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenPubPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalPub<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalPub<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalPub;
    type TokenType = TokenPub<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalPub<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPub,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalPub<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenPub<'db> {
        TokenPub::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalPubPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalPubPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalPubPtr<'db> {
    type SyntaxNode = TerminalPub<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalPub<'db> {
        TerminalPub::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalPubPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalPubPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalPubGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalPub<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalPub);
    type StablePtr = TerminalPubPtr<'db>;
    type Green = TerminalPubGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPub,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenPub::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalPub,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalPub
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalPub { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalPubPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenAnd<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenAnd<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenAnd,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenAndPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenAndPtr<'db> {
    type SyntaxNode = TokenAnd<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenAnd<'db> {
        TokenAnd::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenAndPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenAndPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenAndGreen<'db>(pub GreenId<'db>);
impl<'db> TokenAndGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenAnd<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenAnd);
    type StablePtr = TokenAndPtr<'db>;
    type Green = TokenAndGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenAnd)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenAndPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalAnd<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalAnd<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalAnd;
    type TokenType = TokenAnd<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalAnd<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAnd,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalAnd<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenAnd<'db> {
        TokenAnd::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalAndPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalAndPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalAndPtr<'db> {
    type SyntaxNode = TerminalAnd<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalAnd<'db> {
        TerminalAnd::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalAndPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalAndPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalAndGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalAnd<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalAnd);
    type StablePtr = TerminalAndPtr<'db>;
    type Green = TerminalAndGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAnd,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenAnd::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalAnd,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalAnd
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalAnd { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalAndPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenAndAnd<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenAndAnd<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenAndAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenAndAnd,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenAndAndPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenAndAndPtr<'db> {
    type SyntaxNode = TokenAndAnd<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenAndAnd<'db> {
        TokenAndAnd::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenAndAndPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenAndAndPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenAndAndGreen<'db>(pub GreenId<'db>);
impl<'db> TokenAndAndGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenAndAnd<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenAndAnd);
    type StablePtr = TokenAndAndPtr<'db>;
    type Green = TokenAndAndGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenAndAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenAndAnd)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenAndAndPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalAndAnd<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalAndAnd<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalAndAnd;
    type TokenType = TokenAndAnd<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalAndAnd<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalAndAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAndAnd,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalAndAnd<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenAndAnd<'db> {
        TokenAndAnd::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalAndAndPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalAndAndPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalAndAndPtr<'db> {
    type SyntaxNode = TerminalAndAnd<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalAndAnd<'db> {
        TerminalAndAnd::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalAndAndPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalAndAndPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalAndAndGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalAndAnd<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalAndAnd);
    type StablePtr = TerminalAndAndPtr<'db>;
    type Green = TerminalAndAndGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalAndAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAndAnd,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenAndAnd::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalAndAnd,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalAndAnd
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalAndAnd {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalAndAndPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenArrow<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenArrow<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenArrow,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenArrowPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenArrowPtr<'db> {
    type SyntaxNode = TokenArrow<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenArrow<'db> {
        TokenArrow::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenArrowPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenArrowPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenArrowGreen<'db>(pub GreenId<'db>);
impl<'db> TokenArrowGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenArrow<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenArrow);
    type StablePtr = TokenArrowPtr<'db>;
    type Green = TokenArrowGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenArrow)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenArrowPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalArrow<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalArrow<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalArrow;
    type TokenType = TokenArrow<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalArrow<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalArrow,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalArrow<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenArrow<'db> {
        TokenArrow::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalArrowPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalArrowPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalArrowPtr<'db> {
    type SyntaxNode = TerminalArrow<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalArrow<'db> {
        TerminalArrow::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalArrowPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalArrowPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalArrowGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalArrow<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalArrow);
    type StablePtr = TerminalArrowPtr<'db>;
    type Green = TerminalArrowGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalArrow,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenArrow::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalArrow,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalArrow
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalArrow {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalArrowPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenAt<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenAt<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenAtGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenAt,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenAtPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenAtPtr<'db> {
    type SyntaxNode = TokenAt<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenAt<'db> {
        TokenAt::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenAtPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenAtPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenAtGreen<'db>(pub GreenId<'db>);
impl<'db> TokenAtGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenAt<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenAt);
    type StablePtr = TokenAtPtr<'db>;
    type Green = TokenAtGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenAtGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenAt)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenAtPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalAt<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalAt<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalAt;
    type TokenType = TokenAt<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalAt<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalAtGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAt,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalAt<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenAt<'db> {
        TokenAt::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalAtPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalAtPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalAtPtr<'db> {
    type SyntaxNode = TerminalAt<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalAt<'db> {
        TerminalAt::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalAtPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalAtPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalAtGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalAt<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalAt);
    type StablePtr = TerminalAtPtr<'db>;
    type Green = TerminalAtGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalAtGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAt,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenAt::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalAt,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalAt
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalAt { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalAtPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenBadCharacters<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenBadCharacters<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenBadCharactersGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenBadCharacters,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenBadCharactersPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenBadCharactersPtr<'db> {
    type SyntaxNode = TokenBadCharacters<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenBadCharacters<'db> {
        TokenBadCharacters::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenBadCharactersPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenBadCharactersPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenBadCharactersGreen<'db>(pub GreenId<'db>);
impl<'db> TokenBadCharactersGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenBadCharacters<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenBadCharacters);
    type StablePtr = TokenBadCharactersPtr<'db>;
    type Green = TokenBadCharactersGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenBadCharactersGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenBadCharacters
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenBadCharactersPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalBadCharacters<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalBadCharacters<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalBadCharacters;
    type TokenType = TokenBadCharacters<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalBadCharacters<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalBadCharactersGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBadCharacters,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalBadCharacters<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenBadCharacters<'db> {
        TokenBadCharacters::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalBadCharactersPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalBadCharactersPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalBadCharactersPtr<'db> {
    type SyntaxNode = TerminalBadCharacters<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalBadCharacters<'db> {
        TerminalBadCharacters::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalBadCharactersPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalBadCharactersPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalBadCharactersGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalBadCharacters<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalBadCharacters);
    type StablePtr = TerminalBadCharactersPtr<'db>;
    type Green = TerminalBadCharactersGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalBadCharactersGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBadCharacters,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenBadCharacters::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalBadCharacters,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalBadCharacters
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalBadCharacters {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalBadCharactersPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenColon<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenColon<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenColon,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenColonPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenColonPtr<'db> {
    type SyntaxNode = TokenColon<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenColon<'db> {
        TokenColon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenColonPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenColonPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenColonGreen<'db>(pub GreenId<'db>);
impl<'db> TokenColonGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenColon<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenColon);
    type StablePtr = TokenColonPtr<'db>;
    type Green = TokenColonGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenColon)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenColonPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalColon<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalColon<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalColon;
    type TokenType = TokenColon<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalColon<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalColon,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalColon<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenColon<'db> {
        TokenColon::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalColonPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalColonPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalColonPtr<'db> {
    type SyntaxNode = TerminalColon<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalColon<'db> {
        TerminalColon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalColonPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalColonPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalColonGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalColon<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalColon);
    type StablePtr = TerminalColonPtr<'db>;
    type Green = TerminalColonGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalColon,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenColon::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalColon,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalColon
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalColon {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalColonPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenColonColon<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenColonColon<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenColonColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenColonColon,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenColonColonPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenColonColonPtr<'db> {
    type SyntaxNode = TokenColonColon<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenColonColon<'db> {
        TokenColonColon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenColonColonPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenColonColonPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenColonColonGreen<'db>(pub GreenId<'db>);
impl<'db> TokenColonColonGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenColonColon<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenColonColon);
    type StablePtr = TokenColonColonPtr<'db>;
    type Green = TokenColonColonGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenColonColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenColonColon)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenColonColonPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalColonColon<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalColonColon<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalColonColon;
    type TokenType = TokenColonColon<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalColonColon<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalColonColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalColonColon,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalColonColon<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenColonColon<'db> {
        TokenColonColon::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalColonColonPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalColonColonPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalColonColonPtr<'db> {
    type SyntaxNode = TerminalColonColon<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalColonColon<'db> {
        TerminalColonColon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalColonColonPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalColonColonPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalColonColonGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalColonColon<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalColonColon);
    type StablePtr = TerminalColonColonPtr<'db>;
    type Green = TerminalColonColonGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalColonColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalColonColon,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenColonColon::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalColonColon,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalColonColon
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalColonColon {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalColonColonPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenComma<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenComma<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenCommaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenComma,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenCommaPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenCommaPtr<'db> {
    type SyntaxNode = TokenComma<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenComma<'db> {
        TokenComma::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenCommaPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenCommaPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenCommaGreen<'db>(pub GreenId<'db>);
impl<'db> TokenCommaGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenComma<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenComma);
    type StablePtr = TokenCommaPtr<'db>;
    type Green = TokenCommaGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenCommaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenComma)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenCommaPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalComma<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalComma<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalComma;
    type TokenType = TokenComma<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalComma<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalCommaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalComma,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalComma<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenComma<'db> {
        TokenComma::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalCommaPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalCommaPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalCommaPtr<'db> {
    type SyntaxNode = TerminalComma<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalComma<'db> {
        TerminalComma::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalCommaPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalCommaPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalCommaGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalComma<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalComma);
    type StablePtr = TerminalCommaPtr<'db>;
    type Green = TerminalCommaGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalCommaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalComma,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenComma::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalComma,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalComma
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalComma {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalCommaPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenDiv<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenDiv<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDivGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDiv,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDivPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenDivPtr<'db> {
    type SyntaxNode = TokenDiv<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenDiv<'db> {
        TokenDiv::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenDivPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenDivPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDivGreen<'db>(pub GreenId<'db>);
impl<'db> TokenDivGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenDiv<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDiv);
    type StablePtr = TokenDivPtr<'db>;
    type Green = TokenDivGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenDivGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDiv)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenDivPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalDiv<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalDiv<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalDiv;
    type TokenType = TokenDiv<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalDiv<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDivGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDiv,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalDiv<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenDiv<'db> {
        TokenDiv::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDivPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalDivPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalDivPtr<'db> {
    type SyntaxNode = TerminalDiv<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalDiv<'db> {
        TerminalDiv::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalDivPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalDivPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDivGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalDiv<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDiv);
    type StablePtr = TerminalDivPtr<'db>;
    type Green = TerminalDivGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalDivGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDiv,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDiv::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDiv,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDiv
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDiv { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalDivPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenDivEq<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenDivEq<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDivEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDivEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDivEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenDivEqPtr<'db> {
    type SyntaxNode = TokenDivEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenDivEq<'db> {
        TokenDivEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenDivEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenDivEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDivEqGreen<'db>(pub GreenId<'db>);
impl<'db> TokenDivEqGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenDivEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDivEq);
    type StablePtr = TokenDivEqPtr<'db>;
    type Green = TokenDivEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenDivEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDivEq)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenDivEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalDivEq<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalDivEq<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalDivEq;
    type TokenType = TokenDivEq<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalDivEq<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDivEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDivEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalDivEq<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenDivEq<'db> {
        TokenDivEq::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDivEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalDivEqPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalDivEqPtr<'db> {
    type SyntaxNode = TerminalDivEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalDivEq<'db> {
        TerminalDivEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalDivEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalDivEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDivEqGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalDivEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDivEq);
    type StablePtr = TerminalDivEqPtr<'db>;
    type Green = TerminalDivEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalDivEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDivEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDivEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDivEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDivEq
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDivEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalDivEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenDollar<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenDollar<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDollarGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDollar,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDollarPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenDollarPtr<'db> {
    type SyntaxNode = TokenDollar<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenDollar<'db> {
        TokenDollar::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenDollarPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenDollarPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDollarGreen<'db>(pub GreenId<'db>);
impl<'db> TokenDollarGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenDollar<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDollar);
    type StablePtr = TokenDollarPtr<'db>;
    type Green = TokenDollarGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenDollarGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDollar)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenDollarPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalDollar<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalDollar<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalDollar;
    type TokenType = TokenDollar<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalDollar<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDollarGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDollar,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalDollar<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenDollar<'db> {
        TokenDollar::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDollarPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalDollarPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalDollarPtr<'db> {
    type SyntaxNode = TerminalDollar<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalDollar<'db> {
        TerminalDollar::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalDollarPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalDollarPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDollarGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalDollar<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDollar);
    type StablePtr = TerminalDollarPtr<'db>;
    type Green = TerminalDollarGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalDollarGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDollar,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDollar::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDollar,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDollar
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDollar {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalDollarPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenDot<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenDot<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDot,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDotPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenDotPtr<'db> {
    type SyntaxNode = TokenDot<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenDot<'db> {
        TokenDot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenDotPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenDotPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDotGreen<'db>(pub GreenId<'db>);
impl<'db> TokenDotGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenDot<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDot);
    type StablePtr = TokenDotPtr<'db>;
    type Green = TokenDotGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDot)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenDotPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalDot<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalDot<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalDot;
    type TokenType = TokenDot<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalDot<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDot,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalDot<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenDot<'db> {
        TokenDot::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDotPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalDotPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalDotPtr<'db> {
    type SyntaxNode = TerminalDot<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalDot<'db> {
        TerminalDot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalDotPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalDotPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDotGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalDot<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDot);
    type StablePtr = TerminalDotPtr<'db>;
    type Green = TerminalDotGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDot,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDot::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDot
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDot { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalDotPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenDotDot<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenDotDot<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDotDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDotDot,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDotDotPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenDotDotPtr<'db> {
    type SyntaxNode = TokenDotDot<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenDotDot<'db> {
        TokenDotDot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenDotDotPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenDotDotPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDotDotGreen<'db>(pub GreenId<'db>);
impl<'db> TokenDotDotGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenDotDot<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDotDot);
    type StablePtr = TokenDotDotPtr<'db>;
    type Green = TokenDotDotGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenDotDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDotDot)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenDotDotPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalDotDot<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalDotDot<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalDotDot;
    type TokenType = TokenDotDot<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalDotDot<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDotDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDotDot,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalDotDot<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenDotDot<'db> {
        TokenDotDot::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDotDotPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalDotDotPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalDotDotPtr<'db> {
    type SyntaxNode = TerminalDotDot<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalDotDot<'db> {
        TerminalDotDot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalDotDotPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalDotDotPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDotDotGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalDotDot<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDotDot);
    type StablePtr = TerminalDotDotPtr<'db>;
    type Green = TerminalDotDotGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalDotDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDotDot,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDotDot::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDotDot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDotDot
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDotDot {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalDotDotPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenDotDotEq<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenDotDotEq<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDotDotEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDotDotEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDotDotEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenDotDotEqPtr<'db> {
    type SyntaxNode = TokenDotDotEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenDotDotEq<'db> {
        TokenDotDotEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenDotDotEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenDotDotEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenDotDotEqGreen<'db>(pub GreenId<'db>);
impl<'db> TokenDotDotEqGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenDotDotEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDotDotEq);
    type StablePtr = TokenDotDotEqPtr<'db>;
    type Green = TokenDotDotEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenDotDotEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDotDotEq)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenDotDotEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalDotDotEq<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalDotDotEq<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalDotDotEq;
    type TokenType = TokenDotDotEq<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalDotDotEq<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDotDotEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDotDotEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalDotDotEq<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenDotDotEq<'db> {
        TokenDotDotEq::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDotDotEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalDotDotEqPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalDotDotEqPtr<'db> {
    type SyntaxNode = TerminalDotDotEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalDotDotEq<'db> {
        TerminalDotDotEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalDotDotEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalDotDotEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalDotDotEqGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalDotDotEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDotDotEq);
    type StablePtr = TerminalDotDotEqPtr<'db>;
    type Green = TerminalDotDotEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalDotDotEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDotDotEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDotDotEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDotDotEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDotDotEq
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDotDotEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalDotDotEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenEndOfFile<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenEndOfFile<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEndOfFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenEndOfFile,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenEndOfFilePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenEndOfFilePtr<'db> {
    type SyntaxNode = TokenEndOfFile<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenEndOfFile<'db> {
        TokenEndOfFile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenEndOfFilePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenEndOfFilePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenEndOfFileGreen<'db>(pub GreenId<'db>);
impl<'db> TokenEndOfFileGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenEndOfFile<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEndOfFile);
    type StablePtr = TokenEndOfFilePtr<'db>;
    type Green = TokenEndOfFileGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenEndOfFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEndOfFile)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenEndOfFilePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalEndOfFile<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalEndOfFile<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalEndOfFile;
    type TokenType = TokenEndOfFile<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalEndOfFile<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalEndOfFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEndOfFile,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalEndOfFile<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenEndOfFile<'db> {
        TokenEndOfFile::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalEndOfFilePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalEndOfFilePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalEndOfFilePtr<'db> {
    type SyntaxNode = TerminalEndOfFile<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalEndOfFile<'db> {
        TerminalEndOfFile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalEndOfFilePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalEndOfFilePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalEndOfFileGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalEndOfFile<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEndOfFile);
    type StablePtr = TerminalEndOfFilePtr<'db>;
    type Green = TerminalEndOfFileGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalEndOfFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEndOfFile,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenEndOfFile::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEndOfFile,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEndOfFile
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalEndOfFile {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalEndOfFilePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenEq<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenEq<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenEqPtr<'db> {
    type SyntaxNode = TokenEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenEq<'db> {
        TokenEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenEqGreen<'db>(pub GreenId<'db>);
impl<'db> TokenEqGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEq);
    type StablePtr = TokenEqPtr<'db>;
    type Green = TokenEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEq)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalEq<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalEq<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalEq;
    type TokenType = TokenEq<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalEq<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalEq<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenEq<'db> {
        TokenEq::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalEqPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalEqPtr<'db> {
    type SyntaxNode = TerminalEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalEq<'db> {
        TerminalEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalEqGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEq);
    type StablePtr = TerminalEqPtr<'db>;
    type Green = TerminalEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEq
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalEq { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenEqEq<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenEqEq<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEqEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenEqEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenEqEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenEqEqPtr<'db> {
    type SyntaxNode = TokenEqEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenEqEq<'db> {
        TokenEqEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenEqEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenEqEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenEqEqGreen<'db>(pub GreenId<'db>);
impl<'db> TokenEqEqGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenEqEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEqEq);
    type StablePtr = TokenEqEqPtr<'db>;
    type Green = TokenEqEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenEqEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEqEq)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenEqEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalEqEq<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalEqEq<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalEqEq;
    type TokenType = TokenEqEq<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalEqEq<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalEqEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEqEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalEqEq<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenEqEq<'db> {
        TokenEqEq::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalEqEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalEqEqPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalEqEqPtr<'db> {
    type SyntaxNode = TerminalEqEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalEqEq<'db> {
        TerminalEqEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalEqEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalEqEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalEqEqGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalEqEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEqEq);
    type StablePtr = TerminalEqEqPtr<'db>;
    type Green = TerminalEqEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalEqEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEqEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenEqEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEqEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEqEq
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalEqEq { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalEqEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenGE<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenGE<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenGEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenGE,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenGEPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenGEPtr<'db> {
    type SyntaxNode = TokenGE<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenGE<'db> {
        TokenGE::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenGEPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenGEPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenGEGreen<'db>(pub GreenId<'db>);
impl<'db> TokenGEGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenGE<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenGE);
    type StablePtr = TokenGEPtr<'db>;
    type Green = TokenGEGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenGEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenGE)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenGEPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalGE<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalGE<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalGE;
    type TokenType = TokenGE<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalGE<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalGEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalGE,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalGE<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenGE<'db> {
        TokenGE::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalGEPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalGEPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalGEPtr<'db> {
    type SyntaxNode = TerminalGE<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalGE<'db> {
        TerminalGE::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalGEPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalGEPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalGEGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalGE<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalGE);
    type StablePtr = TerminalGEPtr<'db>;
    type Green = TerminalGEGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalGEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalGE,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenGE::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalGE,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalGE
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalGE { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalGEPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenGT<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenGT<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenGTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenGT,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenGTPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenGTPtr<'db> {
    type SyntaxNode = TokenGT<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenGT<'db> {
        TokenGT::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenGTPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenGTPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenGTGreen<'db>(pub GreenId<'db>);
impl<'db> TokenGTGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenGT<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenGT);
    type StablePtr = TokenGTPtr<'db>;
    type Green = TokenGTGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenGTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenGT)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenGTPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalGT<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalGT<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalGT;
    type TokenType = TokenGT<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalGT<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalGTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalGT,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalGT<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenGT<'db> {
        TokenGT::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalGTPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalGTPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalGTPtr<'db> {
    type SyntaxNode = TerminalGT<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalGT<'db> {
        TerminalGT::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalGTPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalGTPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalGTGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalGT<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalGT);
    type StablePtr = TerminalGTPtr<'db>;
    type Green = TerminalGTGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalGTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalGT,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenGT::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalGT,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalGT
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalGT { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalGTPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenHash<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenHash<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenHashGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenHash,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenHashPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenHashPtr<'db> {
    type SyntaxNode = TokenHash<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenHash<'db> {
        TokenHash::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenHashPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenHashPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenHashGreen<'db>(pub GreenId<'db>);
impl<'db> TokenHashGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenHash<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenHash);
    type StablePtr = TokenHashPtr<'db>;
    type Green = TokenHashGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenHashGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenHash)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenHashPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalHash<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalHash<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalHash;
    type TokenType = TokenHash<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalHash<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalHashGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalHash,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalHash<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenHash<'db> {
        TokenHash::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalHashPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalHashPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalHashPtr<'db> {
    type SyntaxNode = TerminalHash<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalHash<'db> {
        TerminalHash::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalHashPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalHashPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalHashGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalHash<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalHash);
    type StablePtr = TerminalHashPtr<'db>;
    type Green = TerminalHashGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalHashGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalHash,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenHash::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalHash,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalHash
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalHash { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalHashPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenLBrace<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenLBrace<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLBrace,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLBracePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenLBracePtr<'db> {
    type SyntaxNode = TokenLBrace<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenLBrace<'db> {
        TokenLBrace::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenLBracePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenLBracePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLBraceGreen<'db>(pub GreenId<'db>);
impl<'db> TokenLBraceGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenLBrace<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLBrace);
    type StablePtr = TokenLBracePtr<'db>;
    type Green = TokenLBraceGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenLBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLBrace)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenLBracePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalLBrace<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalLBrace<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalLBrace;
    type TokenType = TokenLBrace<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalLBrace<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLBrace,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalLBrace<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenLBrace<'db> {
        TokenLBrace::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLBracePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalLBracePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalLBracePtr<'db> {
    type SyntaxNode = TerminalLBrace<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalLBrace<'db> {
        TerminalLBrace::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalLBracePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalLBracePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLBraceGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalLBrace<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLBrace);
    type StablePtr = TerminalLBracePtr<'db>;
    type Green = TerminalLBraceGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalLBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLBrace,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLBrace::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLBrace,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLBrace
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLBrace {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalLBracePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenLBrack<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenLBrack<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLBrack,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLBrackPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenLBrackPtr<'db> {
    type SyntaxNode = TokenLBrack<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenLBrack<'db> {
        TokenLBrack::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenLBrackPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenLBrackPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLBrackGreen<'db>(pub GreenId<'db>);
impl<'db> TokenLBrackGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenLBrack<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLBrack);
    type StablePtr = TokenLBrackPtr<'db>;
    type Green = TokenLBrackGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenLBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLBrack)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenLBrackPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalLBrack<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalLBrack<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalLBrack;
    type TokenType = TokenLBrack<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalLBrack<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLBrack,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalLBrack<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenLBrack<'db> {
        TokenLBrack::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLBrackPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalLBrackPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalLBrackPtr<'db> {
    type SyntaxNode = TerminalLBrack<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalLBrack<'db> {
        TerminalLBrack::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalLBrackPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalLBrackPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLBrackGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalLBrack<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLBrack);
    type StablePtr = TerminalLBrackPtr<'db>;
    type Green = TerminalLBrackGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalLBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLBrack,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLBrack::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLBrack,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLBrack
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLBrack {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalLBrackPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenLE<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenLE<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLE,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLEPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenLEPtr<'db> {
    type SyntaxNode = TokenLE<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenLE<'db> {
        TokenLE::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenLEPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenLEPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLEGreen<'db>(pub GreenId<'db>);
impl<'db> TokenLEGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenLE<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLE);
    type StablePtr = TokenLEPtr<'db>;
    type Green = TokenLEGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenLEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLE)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenLEPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalLE<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalLE<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalLE;
    type TokenType = TokenLE<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalLE<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLE,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalLE<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenLE<'db> {
        TokenLE::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLEPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalLEPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalLEPtr<'db> {
    type SyntaxNode = TerminalLE<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalLE<'db> {
        TerminalLE::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalLEPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalLEPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLEGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalLE<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLE);
    type StablePtr = TerminalLEPtr<'db>;
    type Green = TerminalLEGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalLEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLE,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLE::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLE,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLE
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLE { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalLEPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenLParen<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenLParen<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLParen,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLParenPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenLParenPtr<'db> {
    type SyntaxNode = TokenLParen<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenLParen<'db> {
        TokenLParen::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenLParenPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenLParenPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLParenGreen<'db>(pub GreenId<'db>);
impl<'db> TokenLParenGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenLParen<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLParen);
    type StablePtr = TokenLParenPtr<'db>;
    type Green = TokenLParenGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenLParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLParen)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenLParenPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalLParen<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalLParen<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalLParen;
    type TokenType = TokenLParen<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalLParen<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLParen,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalLParen<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenLParen<'db> {
        TokenLParen::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLParenPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalLParenPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalLParenPtr<'db> {
    type SyntaxNode = TerminalLParen<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalLParen<'db> {
        TerminalLParen::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalLParenPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalLParenPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLParenGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalLParen<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLParen);
    type StablePtr = TerminalLParenPtr<'db>;
    type Green = TerminalLParenGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalLParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLParen,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLParen::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLParen,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLParen
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLParen {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalLParenPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenLT<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenLT<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLT,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLTPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenLTPtr<'db> {
    type SyntaxNode = TokenLT<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenLT<'db> {
        TokenLT::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenLTPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenLTPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenLTGreen<'db>(pub GreenId<'db>);
impl<'db> TokenLTGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenLT<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLT);
    type StablePtr = TokenLTPtr<'db>;
    type Green = TokenLTGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenLTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLT)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenLTPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalLT<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalLT<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalLT;
    type TokenType = TokenLT<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalLT<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLT,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalLT<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenLT<'db> {
        TokenLT::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLTPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalLTPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalLTPtr<'db> {
    type SyntaxNode = TerminalLT<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalLT<'db> {
        TerminalLT::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalLTPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalLTPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalLTGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalLT<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLT);
    type StablePtr = TerminalLTPtr<'db>;
    type Green = TerminalLTGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalLTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLT,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLT::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLT,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLT
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLT { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalLTPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenMatchArrow<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenMatchArrow<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMatchArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMatchArrow,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMatchArrowPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenMatchArrowPtr<'db> {
    type SyntaxNode = TokenMatchArrow<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenMatchArrow<'db> {
        TokenMatchArrow::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenMatchArrowPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenMatchArrowPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMatchArrowGreen<'db>(pub GreenId<'db>);
impl<'db> TokenMatchArrowGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenMatchArrow<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMatchArrow);
    type StablePtr = TokenMatchArrowPtr<'db>;
    type Green = TokenMatchArrowGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenMatchArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMatchArrow)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenMatchArrowPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalMatchArrow<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalMatchArrow<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalMatchArrow;
    type TokenType = TokenMatchArrow<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalMatchArrow<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMatchArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMatchArrow,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalMatchArrow<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenMatchArrow<'db> {
        TokenMatchArrow::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMatchArrowPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalMatchArrowPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalMatchArrowPtr<'db> {
    type SyntaxNode = TerminalMatchArrow<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalMatchArrow<'db> {
        TerminalMatchArrow::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalMatchArrowPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalMatchArrowPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMatchArrowGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalMatchArrow<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMatchArrow);
    type StablePtr = TerminalMatchArrowPtr<'db>;
    type Green = TerminalMatchArrowGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalMatchArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMatchArrow,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMatchArrow::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMatchArrow,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMatchArrow
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMatchArrow {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalMatchArrowPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenMinus<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenMinus<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMinusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMinus,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMinusPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenMinusPtr<'db> {
    type SyntaxNode = TokenMinus<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenMinus<'db> {
        TokenMinus::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenMinusPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenMinusPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMinusGreen<'db>(pub GreenId<'db>);
impl<'db> TokenMinusGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenMinus<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMinus);
    type StablePtr = TokenMinusPtr<'db>;
    type Green = TokenMinusGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenMinusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMinus)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenMinusPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalMinus<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalMinus<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalMinus;
    type TokenType = TokenMinus<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalMinus<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMinusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMinus,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalMinus<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenMinus<'db> {
        TokenMinus::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMinusPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalMinusPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalMinusPtr<'db> {
    type SyntaxNode = TerminalMinus<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalMinus<'db> {
        TerminalMinus::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalMinusPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalMinusPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMinusGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalMinus<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMinus);
    type StablePtr = TerminalMinusPtr<'db>;
    type Green = TerminalMinusGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalMinusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMinus,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMinus::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMinus,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMinus
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMinus {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalMinusPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenMinusEq<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenMinusEq<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMinusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMinusEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMinusEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenMinusEqPtr<'db> {
    type SyntaxNode = TokenMinusEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenMinusEq<'db> {
        TokenMinusEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenMinusEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenMinusEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMinusEqGreen<'db>(pub GreenId<'db>);
impl<'db> TokenMinusEqGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenMinusEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMinusEq);
    type StablePtr = TokenMinusEqPtr<'db>;
    type Green = TokenMinusEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenMinusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMinusEq)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenMinusEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalMinusEq<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalMinusEq<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalMinusEq;
    type TokenType = TokenMinusEq<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalMinusEq<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMinusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMinusEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalMinusEq<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenMinusEq<'db> {
        TokenMinusEq::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMinusEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalMinusEqPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalMinusEqPtr<'db> {
    type SyntaxNode = TerminalMinusEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalMinusEq<'db> {
        TerminalMinusEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalMinusEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalMinusEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMinusEqGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalMinusEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMinusEq);
    type StablePtr = TerminalMinusEqPtr<'db>;
    type Green = TerminalMinusEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalMinusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMinusEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMinusEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMinusEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMinusEq
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMinusEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalMinusEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenMod<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenMod<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenModGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMod,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenModPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenModPtr<'db> {
    type SyntaxNode = TokenMod<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenMod<'db> {
        TokenMod::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenModPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenModPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenModGreen<'db>(pub GreenId<'db>);
impl<'db> TokenModGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenMod<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMod);
    type StablePtr = TokenModPtr<'db>;
    type Green = TokenModGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenModGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMod)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenModPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalMod<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalMod<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalMod;
    type TokenType = TokenMod<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalMod<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalModGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMod,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalMod<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenMod<'db> {
        TokenMod::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalModPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalModPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalModPtr<'db> {
    type SyntaxNode = TerminalMod<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalMod<'db> {
        TerminalMod::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalModPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalModPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalModGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalMod<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMod);
    type StablePtr = TerminalModPtr<'db>;
    type Green = TerminalModGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalModGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMod,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMod::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMod,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMod
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMod { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalModPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenModEq<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenModEq<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenModEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenModEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenModEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenModEqPtr<'db> {
    type SyntaxNode = TokenModEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenModEq<'db> {
        TokenModEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenModEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenModEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenModEqGreen<'db>(pub GreenId<'db>);
impl<'db> TokenModEqGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenModEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenModEq);
    type StablePtr = TokenModEqPtr<'db>;
    type Green = TokenModEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenModEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenModEq)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenModEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalModEq<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalModEq<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalModEq;
    type TokenType = TokenModEq<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalModEq<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalModEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalModEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalModEq<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenModEq<'db> {
        TokenModEq::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalModEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalModEqPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalModEqPtr<'db> {
    type SyntaxNode = TerminalModEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalModEq<'db> {
        TerminalModEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalModEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalModEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalModEqGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalModEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalModEq);
    type StablePtr = TerminalModEqPtr<'db>;
    type Green = TerminalModEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalModEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalModEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenModEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalModEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalModEq
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalModEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalModEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenMul<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenMul<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMulGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMul,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMulPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenMulPtr<'db> {
    type SyntaxNode = TokenMul<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenMul<'db> {
        TokenMul::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenMulPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenMulPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMulGreen<'db>(pub GreenId<'db>);
impl<'db> TokenMulGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenMul<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMul);
    type StablePtr = TokenMulPtr<'db>;
    type Green = TokenMulGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenMulGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMul)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenMulPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalMul<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalMul<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalMul;
    type TokenType = TokenMul<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalMul<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMulGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMul,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalMul<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenMul<'db> {
        TokenMul::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMulPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalMulPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalMulPtr<'db> {
    type SyntaxNode = TerminalMul<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalMul<'db> {
        TerminalMul::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalMulPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalMulPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMulGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalMul<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMul);
    type StablePtr = TerminalMulPtr<'db>;
    type Green = TerminalMulGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalMulGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMul,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMul::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMul,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMul
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMul { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalMulPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenMulEq<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenMulEq<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMulEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMulEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMulEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenMulEqPtr<'db> {
    type SyntaxNode = TokenMulEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenMulEq<'db> {
        TokenMulEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenMulEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenMulEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMulEqGreen<'db>(pub GreenId<'db>);
impl<'db> TokenMulEqGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenMulEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMulEq);
    type StablePtr = TokenMulEqPtr<'db>;
    type Green = TokenMulEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenMulEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMulEq)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenMulEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalMulEq<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalMulEq<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalMulEq;
    type TokenType = TokenMulEq<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalMulEq<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMulEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMulEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalMulEq<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenMulEq<'db> {
        TokenMulEq::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMulEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalMulEqPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalMulEqPtr<'db> {
    type SyntaxNode = TerminalMulEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalMulEq<'db> {
        TerminalMulEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalMulEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalMulEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalMulEqGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalMulEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMulEq);
    type StablePtr = TerminalMulEqPtr<'db>;
    type Green = TerminalMulEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalMulEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMulEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMulEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMulEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMulEq
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMulEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalMulEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenNeq<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenNeq<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNeqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenNeq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenNeqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenNeqPtr<'db> {
    type SyntaxNode = TokenNeq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenNeq<'db> {
        TokenNeq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenNeqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenNeqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenNeqGreen<'db>(pub GreenId<'db>);
impl<'db> TokenNeqGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenNeq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNeq);
    type StablePtr = TokenNeqPtr<'db>;
    type Green = TokenNeqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenNeqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNeq)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenNeqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalNeq<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalNeq<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalNeq;
    type TokenType = TokenNeq<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalNeq<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalNeqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNeq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalNeq<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenNeq<'db> {
        TokenNeq::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalNeqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalNeqPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalNeqPtr<'db> {
    type SyntaxNode = TerminalNeq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalNeq<'db> {
        TerminalNeq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalNeqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalNeqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalNeqGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalNeq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalNeq);
    type StablePtr = TerminalNeqPtr<'db>;
    type Green = TerminalNeqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalNeqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNeq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenNeq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalNeq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalNeq
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalNeq { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalNeqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenNot<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenNot<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenNot,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenNotPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenNotPtr<'db> {
    type SyntaxNode = TokenNot<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenNot<'db> {
        TokenNot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenNotPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenNotPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenNotGreen<'db>(pub GreenId<'db>);
impl<'db> TokenNotGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenNot<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNot);
    type StablePtr = TokenNotPtr<'db>;
    type Green = TokenNotGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNot)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenNotPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalNot<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalNot<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalNot;
    type TokenType = TokenNot<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalNot<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNot,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalNot<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenNot<'db> {
        TokenNot::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalNotPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalNotPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalNotPtr<'db> {
    type SyntaxNode = TerminalNot<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalNot<'db> {
        TerminalNot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalNotPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalNotPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalNotGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalNot<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalNot);
    type StablePtr = TerminalNotPtr<'db>;
    type Green = TerminalNotGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNot,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenNot::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalNot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalNot
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalNot { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalNotPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenBitNot<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenBitNot<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenBitNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenBitNot,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenBitNotPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenBitNotPtr<'db> {
    type SyntaxNode = TokenBitNot<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenBitNot<'db> {
        TokenBitNot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenBitNotPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenBitNotPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenBitNotGreen<'db>(pub GreenId<'db>);
impl<'db> TokenBitNotGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenBitNot<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenBitNot);
    type StablePtr = TokenBitNotPtr<'db>;
    type Green = TokenBitNotGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenBitNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenBitNot)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenBitNotPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalBitNot<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalBitNot<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalBitNot;
    type TokenType = TokenBitNot<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalBitNot<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalBitNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBitNot,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalBitNot<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenBitNot<'db> {
        TokenBitNot::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalBitNotPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalBitNotPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalBitNotPtr<'db> {
    type SyntaxNode = TerminalBitNot<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalBitNot<'db> {
        TerminalBitNot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalBitNotPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalBitNotPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalBitNotGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalBitNot<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalBitNot);
    type StablePtr = TerminalBitNotPtr<'db>;
    type Green = TerminalBitNotGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalBitNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBitNot,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenBitNot::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalBitNot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalBitNot
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalBitNot {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalBitNotPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenOr<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenOr<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenOr,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenOrPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenOrPtr<'db> {
    type SyntaxNode = TokenOr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenOr<'db> {
        TokenOr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenOrPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenOrPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenOrGreen<'db>(pub GreenId<'db>);
impl<'db> TokenOrGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenOr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenOr);
    type StablePtr = TokenOrPtr<'db>;
    type Green = TokenOrGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenOr)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenOrPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalOr<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalOr<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalOr;
    type TokenType = TokenOr<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalOr<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalOr<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenOr<'db> {
        TokenOr::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalOrPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalOrPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalOrPtr<'db> {
    type SyntaxNode = TerminalOr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalOr<'db> {
        TerminalOr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalOrPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalOrPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalOrGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalOr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalOr);
    type StablePtr = TerminalOrPtr<'db>;
    type Green = TerminalOrGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOr,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenOr::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalOr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalOr
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalOr { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalOrPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenOrOr<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenOrOr<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenOrOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenOrOr,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenOrOrPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenOrOrPtr<'db> {
    type SyntaxNode = TokenOrOr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenOrOr<'db> {
        TokenOrOr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenOrOrPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenOrOrPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenOrOrGreen<'db>(pub GreenId<'db>);
impl<'db> TokenOrOrGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenOrOr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenOrOr);
    type StablePtr = TokenOrOrPtr<'db>;
    type Green = TokenOrOrGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenOrOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenOrOr)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenOrOrPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalOrOr<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalOrOr<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalOrOr;
    type TokenType = TokenOrOr<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalOrOr<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalOrOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOrOr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalOrOr<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenOrOr<'db> {
        TokenOrOr::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalOrOrPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalOrOrPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalOrOrPtr<'db> {
    type SyntaxNode = TerminalOrOr<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalOrOr<'db> {
        TerminalOrOr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalOrOrPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalOrOrPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalOrOrGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalOrOr<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalOrOr);
    type StablePtr = TerminalOrOrPtr<'db>;
    type Green = TerminalOrOrGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalOrOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOrOr,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenOrOr::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalOrOr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalOrOr
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalOrOr { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalOrOrPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenPlus<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenPlus<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenPlusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenPlus,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenPlusPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenPlusPtr<'db> {
    type SyntaxNode = TokenPlus<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenPlus<'db> {
        TokenPlus::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenPlusPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenPlusPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenPlusGreen<'db>(pub GreenId<'db>);
impl<'db> TokenPlusGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenPlus<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenPlus);
    type StablePtr = TokenPlusPtr<'db>;
    type Green = TokenPlusGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenPlusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenPlus)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenPlusPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalPlus<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalPlus<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalPlus;
    type TokenType = TokenPlus<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalPlus<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalPlusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPlus,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalPlus<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenPlus<'db> {
        TokenPlus::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalPlusPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalPlusPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalPlusPtr<'db> {
    type SyntaxNode = TerminalPlus<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalPlus<'db> {
        TerminalPlus::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalPlusPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalPlusPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalPlusGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalPlus<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalPlus);
    type StablePtr = TerminalPlusPtr<'db>;
    type Green = TerminalPlusGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalPlusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPlus,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenPlus::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalPlus,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalPlus
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalPlus { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalPlusPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenPlusEq<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenPlusEq<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenPlusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenPlusEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenPlusEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenPlusEqPtr<'db> {
    type SyntaxNode = TokenPlusEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenPlusEq<'db> {
        TokenPlusEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenPlusEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenPlusEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenPlusEqGreen<'db>(pub GreenId<'db>);
impl<'db> TokenPlusEqGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenPlusEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenPlusEq);
    type StablePtr = TokenPlusEqPtr<'db>;
    type Green = TokenPlusEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenPlusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenPlusEq)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenPlusEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalPlusEq<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalPlusEq<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalPlusEq;
    type TokenType = TokenPlusEq<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalPlusEq<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalPlusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPlusEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalPlusEq<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenPlusEq<'db> {
        TokenPlusEq::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalPlusEqPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalPlusEqPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalPlusEqPtr<'db> {
    type SyntaxNode = TerminalPlusEq<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalPlusEq<'db> {
        TerminalPlusEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalPlusEqPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalPlusEqPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalPlusEqGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalPlusEq<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalPlusEq);
    type StablePtr = TerminalPlusEqPtr<'db>;
    type Green = TerminalPlusEqGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalPlusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPlusEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenPlusEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalPlusEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalPlusEq
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalPlusEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalPlusEqPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenQuestionMark<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenQuestionMark<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenQuestionMarkGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenQuestionMark,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenQuestionMarkPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenQuestionMarkPtr<'db> {
    type SyntaxNode = TokenQuestionMark<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenQuestionMark<'db> {
        TokenQuestionMark::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenQuestionMarkPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenQuestionMarkPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenQuestionMarkGreen<'db>(pub GreenId<'db>);
impl<'db> TokenQuestionMarkGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenQuestionMark<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenQuestionMark);
    type StablePtr = TokenQuestionMarkPtr<'db>;
    type Green = TokenQuestionMarkGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenQuestionMarkGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenQuestionMark)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenQuestionMarkPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalQuestionMark<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalQuestionMark<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalQuestionMark;
    type TokenType = TokenQuestionMark<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalQuestionMark<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalQuestionMarkGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalQuestionMark,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalQuestionMark<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenQuestionMark<'db> {
        TokenQuestionMark::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalQuestionMarkPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalQuestionMarkPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalQuestionMarkPtr<'db> {
    type SyntaxNode = TerminalQuestionMark<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalQuestionMark<'db> {
        TerminalQuestionMark::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalQuestionMarkPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalQuestionMarkPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalQuestionMarkGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalQuestionMark<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalQuestionMark);
    type StablePtr = TerminalQuestionMarkPtr<'db>;
    type Green = TerminalQuestionMarkGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalQuestionMarkGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalQuestionMark,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenQuestionMark::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalQuestionMark,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalQuestionMark
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalQuestionMark {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalQuestionMarkPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenRBrace<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenRBrace<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenRBrace,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenRBracePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenRBracePtr<'db> {
    type SyntaxNode = TokenRBrace<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenRBrace<'db> {
        TokenRBrace::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenRBracePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenRBracePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenRBraceGreen<'db>(pub GreenId<'db>);
impl<'db> TokenRBraceGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenRBrace<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRBrace);
    type StablePtr = TokenRBracePtr<'db>;
    type Green = TokenRBraceGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenRBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRBrace)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenRBracePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalRBrace<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalRBrace<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalRBrace;
    type TokenType = TokenRBrace<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalRBrace<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalRBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRBrace,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalRBrace<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenRBrace<'db> {
        TokenRBrace::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalRBracePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalRBracePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalRBracePtr<'db> {
    type SyntaxNode = TerminalRBrace<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalRBrace<'db> {
        TerminalRBrace::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalRBracePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalRBracePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalRBraceGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalRBrace<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRBrace);
    type StablePtr = TerminalRBracePtr<'db>;
    type Green = TerminalRBraceGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalRBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRBrace,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenRBrace::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRBrace,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRBrace
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalRBrace {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalRBracePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenRBrack<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenRBrack<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenRBrack,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenRBrackPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenRBrackPtr<'db> {
    type SyntaxNode = TokenRBrack<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenRBrack<'db> {
        TokenRBrack::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenRBrackPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenRBrackPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenRBrackGreen<'db>(pub GreenId<'db>);
impl<'db> TokenRBrackGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenRBrack<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRBrack);
    type StablePtr = TokenRBrackPtr<'db>;
    type Green = TokenRBrackGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenRBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRBrack)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenRBrackPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalRBrack<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalRBrack<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalRBrack;
    type TokenType = TokenRBrack<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalRBrack<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalRBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRBrack,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalRBrack<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenRBrack<'db> {
        TokenRBrack::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalRBrackPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalRBrackPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalRBrackPtr<'db> {
    type SyntaxNode = TerminalRBrack<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalRBrack<'db> {
        TerminalRBrack::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalRBrackPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalRBrackPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalRBrackGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalRBrack<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRBrack);
    type StablePtr = TerminalRBrackPtr<'db>;
    type Green = TerminalRBrackGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalRBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRBrack,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenRBrack::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRBrack,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRBrack
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalRBrack {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalRBrackPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenRParen<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenRParen<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenRParen,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenRParenPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenRParenPtr<'db> {
    type SyntaxNode = TokenRParen<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenRParen<'db> {
        TokenRParen::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenRParenPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenRParenPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenRParenGreen<'db>(pub GreenId<'db>);
impl<'db> TokenRParenGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenRParen<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRParen);
    type StablePtr = TokenRParenPtr<'db>;
    type Green = TokenRParenGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenRParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRParen)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenRParenPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalRParen<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalRParen<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalRParen;
    type TokenType = TokenRParen<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalRParen<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalRParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRParen,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalRParen<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenRParen<'db> {
        TokenRParen::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalRParenPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalRParenPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalRParenPtr<'db> {
    type SyntaxNode = TerminalRParen<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalRParen<'db> {
        TerminalRParen::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalRParenPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalRParenPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalRParenGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalRParen<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRParen);
    type StablePtr = TerminalRParenPtr<'db>;
    type Green = TerminalRParenGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalRParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRParen,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenRParen::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRParen,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRParen
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalRParen {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalRParenPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenSemicolon<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenSemicolon<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSemicolonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenSemicolon,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenSemicolonPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenSemicolonPtr<'db> {
    type SyntaxNode = TokenSemicolon<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenSemicolon<'db> {
        TokenSemicolon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenSemicolonPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenSemicolonPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenSemicolonGreen<'db>(pub GreenId<'db>);
impl<'db> TokenSemicolonGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenSemicolon<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSemicolon);
    type StablePtr = TokenSemicolonPtr<'db>;
    type Green = TokenSemicolonGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenSemicolonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenSemicolon)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenSemicolonPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalSemicolon<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalSemicolon<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalSemicolon;
    type TokenType = TokenSemicolon<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalSemicolon<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalSemicolonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalSemicolon,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalSemicolon<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenSemicolon<'db> {
        TokenSemicolon::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalSemicolonPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalSemicolonPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalSemicolonPtr<'db> {
    type SyntaxNode = TerminalSemicolon<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalSemicolon<'db> {
        TerminalSemicolon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalSemicolonPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalSemicolonPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalSemicolonGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalSemicolon<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalSemicolon);
    type StablePtr = TerminalSemicolonPtr<'db>;
    type Green = TerminalSemicolonGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalSemicolonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalSemicolon,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenSemicolon::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalSemicolon,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalSemicolon
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalSemicolon {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalSemicolonPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenUnderscore<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenUnderscore<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenUnderscoreGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenUnderscore,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenUnderscorePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenUnderscorePtr<'db> {
    type SyntaxNode = TokenUnderscore<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenUnderscore<'db> {
        TokenUnderscore::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenUnderscorePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenUnderscorePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenUnderscoreGreen<'db>(pub GreenId<'db>);
impl<'db> TokenUnderscoreGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenUnderscore<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenUnderscore);
    type StablePtr = TokenUnderscorePtr<'db>;
    type Green = TokenUnderscoreGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenUnderscoreGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenUnderscore)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenUnderscorePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalUnderscore<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalUnderscore<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalUnderscore;
    type TokenType = TokenUnderscore<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalUnderscore<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalUnderscoreGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalUnderscore,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalUnderscore<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenUnderscore<'db> {
        TokenUnderscore::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalUnderscorePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalUnderscorePtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalUnderscorePtr<'db> {
    type SyntaxNode = TerminalUnderscore<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalUnderscore<'db> {
        TerminalUnderscore::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalUnderscorePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalUnderscorePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalUnderscoreGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalUnderscore<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalUnderscore);
    type StablePtr = TerminalUnderscorePtr<'db>;
    type Green = TerminalUnderscoreGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalUnderscoreGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalUnderscore,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenUnderscore::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalUnderscore,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalUnderscore
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalUnderscore {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalUnderscorePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenXor<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenXor<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenXorGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenXor,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenXorPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenXorPtr<'db> {
    type SyntaxNode = TokenXor<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenXor<'db> {
        TokenXor::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenXorPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenXorPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenXorGreen<'db>(pub GreenId<'db>);
impl<'db> TokenXorGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenXor<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenXor);
    type StablePtr = TokenXorPtr<'db>;
    type Green = TokenXorGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenXorGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenXor)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenXorPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalXor<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalXor<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalXor;
    type TokenType = TokenXor<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalXor<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalXorGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalXor,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalXor<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenXor<'db> {
        TokenXor::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalXorPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalXorPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalXorPtr<'db> {
    type SyntaxNode = TerminalXor<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalXor<'db> {
        TerminalXor::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalXorPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalXorPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalXorGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalXor<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalXor);
    type StablePtr = TerminalXorPtr<'db>;
    type Green = TerminalXorGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalXorGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalXor,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenXor::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalXor,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalXor
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalXor { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalXorPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct SyntaxFile<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> SyntaxFile<'db> {
    pub const INDEX_ITEMS: usize = 0;
    pub const INDEX_EOF: usize = 1;
    pub fn new_green(
        db: &'db dyn SyntaxGroup,
        items: ModuleItemListGreen<'db>,
        eof: TerminalEndOfFileGreen<'db>,
    ) -> SyntaxFileGreen<'db> {
        let children: Vec<GreenId> = vec![items.0, eof.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        SyntaxFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::SyntaxFile,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl<'db> SyntaxFile<'db> {
    pub fn items(&self, db: &'db dyn SyntaxGroup) -> ModuleItemList<'db> {
        ModuleItemList::from_syntax_node(db, self.children[0])
    }
    pub fn eof(&self, db: &'db dyn SyntaxGroup) -> TerminalEndOfFile<'db> {
        TerminalEndOfFile::from_syntax_node(db, self.children[1])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct SyntaxFilePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> SyntaxFilePtr<'db> {}
impl<'db> TypedStablePtr<'db> for SyntaxFilePtr<'db> {
    type SyntaxNode = SyntaxFile<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> SyntaxFile<'db> {
        SyntaxFile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<SyntaxFilePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: SyntaxFilePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct SyntaxFileGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for SyntaxFile<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::SyntaxFile);
    type StablePtr = SyntaxFilePtr<'db>;
    type Green = SyntaxFileGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        SyntaxFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::SyntaxFile,
                details: GreenNodeDetails::Node {
                    children: vec![ModuleItemList::missing(db).0, TerminalEndOfFile::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::SyntaxFile,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::SyntaxFile
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::SyntaxFile { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        SyntaxFilePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenEmpty<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenEmpty<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenEmpty,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenEmptyPtr<'db> {
    type SyntaxNode = TokenEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenEmpty<'db> {
        TokenEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TokenEmptyGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEmpty);
    type StablePtr = TokenEmptyPtr<'db>;
    type Green = TokenEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEmpty)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TerminalEmpty<'db> {
    node: SyntaxNode<'db>,
    children: Arc<Vec<SyntaxNode<'db>>>,
}
impl<'db> Terminal<'db> for TerminalEmpty<'db> {
    const KIND: SyntaxKind = SyntaxKind::TerminalEmpty;
    type TokenType = TokenEmpty<'db>;
    fn new_green(
        db: &'db dyn SyntaxGroup,
        leading_trivia: TriviaGreen<'db>,
        token: <<TerminalEmpty<'db> as Terminal<'db>>::TokenType as TypedSyntaxNode<'db>>::Green,
        trailing_trivia: TriviaGreen<'db>,
    ) -> Self::Green {
        let children: Vec<GreenId<'db>> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl<'db> TerminalEmpty<'db> {
    pub fn leading_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[0])
    }
    pub fn token(&self, db: &'db dyn SyntaxGroup) -> TokenEmpty<'db> {
        TokenEmpty::from_syntax_node(db, self.children[1])
    }
    pub fn trailing_trivia(&self, db: &'db dyn SyntaxGroup) -> Trivia<'db> {
        Trivia::from_syntax_node(db, self.children[2])
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalEmptyPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TerminalEmptyPtr<'db> {}
impl<'db> TypedStablePtr<'db> for TerminalEmptyPtr<'db> {
    type SyntaxNode = TerminalEmpty<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TerminalEmpty<'db> {
        TerminalEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TerminalEmptyPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TerminalEmptyPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TerminalEmptyGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TerminalEmpty<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEmpty);
    type StablePtr = TerminalEmptyPtr<'db>;
    type Green = TerminalEmptyGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TerminalEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEmpty,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenEmpty::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEmpty
        );
        Self { children: node.get_children(db), node }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TerminalEmptyPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenSingleLineComment<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenSingleLineComment<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSingleLineCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenSingleLineComment,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenSingleLineCommentPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenSingleLineCommentPtr<'db> {
    type SyntaxNode = TokenSingleLineComment<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenSingleLineComment<'db> {
        TokenSingleLineComment::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenSingleLineCommentPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenSingleLineCommentPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenSingleLineCommentGreen<'db>(pub GreenId<'db>);
impl<'db> TokenSingleLineCommentGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenSingleLineComment<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSingleLineComment);
    type StablePtr = TokenSingleLineCommentPtr<'db>;
    type Green = TokenSingleLineCommentGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenSingleLineCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenSingleLineComment
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenSingleLineCommentPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenSingleLineInnerComment<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenSingleLineInnerComment<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSingleLineInnerCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenSingleLineInnerComment,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenSingleLineInnerCommentPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenSingleLineInnerCommentPtr<'db> {
    type SyntaxNode = TokenSingleLineInnerComment<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenSingleLineInnerComment<'db> {
        TokenSingleLineInnerComment::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenSingleLineInnerCommentPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenSingleLineInnerCommentPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenSingleLineInnerCommentGreen<'db>(pub GreenId<'db>);
impl<'db> TokenSingleLineInnerCommentGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenSingleLineInnerComment<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSingleLineInnerComment);
    type StablePtr = TokenSingleLineInnerCommentPtr<'db>;
    type Green = TokenSingleLineInnerCommentGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenSingleLineInnerCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenSingleLineInnerComment
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenSingleLineInnerCommentPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenSingleLineDocComment<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenSingleLineDocComment<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSingleLineDocCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenSingleLineDocComment,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenSingleLineDocCommentPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenSingleLineDocCommentPtr<'db> {
    type SyntaxNode = TokenSingleLineDocComment<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenSingleLineDocComment<'db> {
        TokenSingleLineDocComment::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenSingleLineDocCommentPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenSingleLineDocCommentPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenSingleLineDocCommentGreen<'db>(pub GreenId<'db>);
impl<'db> TokenSingleLineDocCommentGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenSingleLineDocComment<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSingleLineDocComment);
    type StablePtr = TokenSingleLineDocCommentPtr<'db>;
    type Green = TokenSingleLineDocCommentGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenSingleLineDocCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenSingleLineDocComment
            ),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenSingleLineDocCommentPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenWhitespace<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenWhitespace<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenWhitespaceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenWhitespace,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenWhitespacePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenWhitespacePtr<'db> {
    type SyntaxNode = TokenWhitespace<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenWhitespace<'db> {
        TokenWhitespace::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenWhitespacePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenWhitespacePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenWhitespaceGreen<'db>(pub GreenId<'db>);
impl<'db> TokenWhitespaceGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenWhitespace<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenWhitespace);
    type StablePtr = TokenWhitespacePtr<'db>;
    type Green = TokenWhitespaceGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenWhitespaceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenWhitespace)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenWhitespacePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenNewline<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenNewline<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNewlineGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenNewline,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenNewlinePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenNewlinePtr<'db> {
    type SyntaxNode = TokenNewline<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenNewline<'db> {
        TokenNewline::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenNewlinePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenNewlinePtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenNewlineGreen<'db>(pub GreenId<'db>);
impl<'db> TokenNewlineGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenNewline<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNewline);
    type StablePtr = TokenNewlinePtr<'db>;
    type Green = TokenNewlineGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenNewlineGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNewline)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenNewlinePtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenMissing<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenMissing<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMissingPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenMissingPtr<'db> {
    type SyntaxNode = TokenMissing<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenMissing<'db> {
        TokenMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenMissingPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenMissingPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenMissingGreen<'db>(pub GreenId<'db>);
impl<'db> TokenMissingGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenMissing<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMissing);
    type StablePtr = TokenMissingPtr<'db>;
    type Green = TokenMissingGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMissing)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenMissingPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub struct TokenSkipped<'db> {
    node: SyntaxNode<'db>,
}
impl<'db> Token<'db> for TokenSkipped<'db> {
    fn new_green(db: &'db dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSkippedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenSkipped,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(
            &self.node.lookup_intern(db).green.lookup_intern(db).details,
            GreenNodeDetails::Token
        )
        .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenSkippedPtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenSkippedPtr<'db> {
    type SyntaxNode = TokenSkipped<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> TokenSkipped<'db> {
        TokenSkipped::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenSkippedPtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenSkippedPtr<'db>) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenSkippedGreen<'db>(pub GreenId<'db>);
impl<'db> TokenSkippedGreen<'db> {
    pub fn text(&self, db: &'db dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl<'db> TypedSyntaxNode<'db> for TokenSkipped<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSkipped);
    type StablePtr = TokenSkippedPtr<'db>;
    type Green = TokenSkippedGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        TokenSkippedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenSkipped)
            }
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        match node.lookup_intern(db).green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        self.node
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenSkippedPtr(self.node.stable_ptr(db))
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq, salsa::Update)]
pub enum TokenNode<'db> {
    TerminalIdentifier(TerminalIdentifier<'db>),
    TerminalLiteralNumber(TerminalLiteralNumber<'db>),
    TerminalShortString(TerminalShortString<'db>),
    TerminalString(TerminalString<'db>),
    TerminalAs(TerminalAs<'db>),
    TerminalConst(TerminalConst<'db>),
    TerminalElse(TerminalElse<'db>),
    TerminalEnum(TerminalEnum<'db>),
    TerminalExtern(TerminalExtern<'db>),
    TerminalFalse(TerminalFalse<'db>),
    TerminalFunction(TerminalFunction<'db>),
    TerminalIf(TerminalIf<'db>),
    TerminalWhile(TerminalWhile<'db>),
    TerminalFor(TerminalFor<'db>),
    TerminalLoop(TerminalLoop<'db>),
    TerminalImpl(TerminalImpl<'db>),
    TerminalImplicits(TerminalImplicits<'db>),
    TerminalLet(TerminalLet<'db>),
    TerminalMacro(TerminalMacro<'db>),
    TerminalMatch(TerminalMatch<'db>),
    TerminalModule(TerminalModule<'db>),
    TerminalMut(TerminalMut<'db>),
    TerminalNoPanic(TerminalNoPanic<'db>),
    TerminalOf(TerminalOf<'db>),
    TerminalRef(TerminalRef<'db>),
    TerminalContinue(TerminalContinue<'db>),
    TerminalReturn(TerminalReturn<'db>),
    TerminalBreak(TerminalBreak<'db>),
    TerminalStruct(TerminalStruct<'db>),
    TerminalTrait(TerminalTrait<'db>),
    TerminalTrue(TerminalTrue<'db>),
    TerminalType(TerminalType<'db>),
    TerminalUse(TerminalUse<'db>),
    TerminalPub(TerminalPub<'db>),
    TerminalAnd(TerminalAnd<'db>),
    TerminalAndAnd(TerminalAndAnd<'db>),
    TerminalArrow(TerminalArrow<'db>),
    TerminalAt(TerminalAt<'db>),
    TerminalBadCharacters(TerminalBadCharacters<'db>),
    TerminalColon(TerminalColon<'db>),
    TerminalColonColon(TerminalColonColon<'db>),
    TerminalComma(TerminalComma<'db>),
    TerminalDiv(TerminalDiv<'db>),
    TerminalDivEq(TerminalDivEq<'db>),
    TerminalDollar(TerminalDollar<'db>),
    TerminalDot(TerminalDot<'db>),
    TerminalDotDot(TerminalDotDot<'db>),
    TerminalDotDotEq(TerminalDotDotEq<'db>),
    TerminalEndOfFile(TerminalEndOfFile<'db>),
    TerminalEq(TerminalEq<'db>),
    TerminalEqEq(TerminalEqEq<'db>),
    TerminalGE(TerminalGE<'db>),
    TerminalGT(TerminalGT<'db>),
    TerminalHash(TerminalHash<'db>),
    TerminalLBrace(TerminalLBrace<'db>),
    TerminalLBrack(TerminalLBrack<'db>),
    TerminalLE(TerminalLE<'db>),
    TerminalLParen(TerminalLParen<'db>),
    TerminalLT(TerminalLT<'db>),
    TerminalMatchArrow(TerminalMatchArrow<'db>),
    TerminalMinus(TerminalMinus<'db>),
    TerminalMinusEq(TerminalMinusEq<'db>),
    TerminalMod(TerminalMod<'db>),
    TerminalModEq(TerminalModEq<'db>),
    TerminalMul(TerminalMul<'db>),
    TerminalMulEq(TerminalMulEq<'db>),
    TerminalNeq(TerminalNeq<'db>),
    TerminalNot(TerminalNot<'db>),
    TerminalBitNot(TerminalBitNot<'db>),
    TerminalOr(TerminalOr<'db>),
    TerminalOrOr(TerminalOrOr<'db>),
    TerminalPlus(TerminalPlus<'db>),
    TerminalPlusEq(TerminalPlusEq<'db>),
    TerminalQuestionMark(TerminalQuestionMark<'db>),
    TerminalRBrace(TerminalRBrace<'db>),
    TerminalRBrack(TerminalRBrack<'db>),
    TerminalRParen(TerminalRParen<'db>),
    TerminalSemicolon(TerminalSemicolon<'db>),
    TerminalUnderscore(TerminalUnderscore<'db>),
    TerminalXor(TerminalXor<'db>),
    TerminalEmpty(TerminalEmpty<'db>),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenNodePtr<'db>(pub SyntaxStablePtrId<'db>);
impl<'db> TypedStablePtr<'db> for TokenNodePtr<'db> {
    type SyntaxNode = TokenNode<'db>;
    fn untyped(self) -> SyntaxStablePtrId<'db> {
        self.0
    }
    fn lookup(&'db self, db: &'db dyn SyntaxGroup) -> Self::SyntaxNode {
        TokenNode::from_syntax_node(db, self.0.lookup(db))
    }
}
impl<'db> From<TokenNodePtr<'db>> for SyntaxStablePtrId<'db> {
    fn from(ptr: TokenNodePtr<'db>) -> Self {
        ptr.untyped()
    }
}
impl<'db> From<TerminalIdentifierPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalIdentifierPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLiteralNumberPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalLiteralNumberPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalShortStringPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalShortStringPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalStringPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalStringPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAsPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalAsPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalConstPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalConstPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalElsePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalElsePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEnumPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalEnumPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalExternPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalExternPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalFalsePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalFalsePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalFunctionPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalFunctionPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalIfPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalIfPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalWhilePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalWhilePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalForPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalForPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLoopPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalLoopPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalImplPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalImplPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalImplicitsPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalImplicitsPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLetPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalLetPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMacroPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalMacroPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMatchPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalMatchPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalModulePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalModulePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMutPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalMutPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNoPanicPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalNoPanicPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOfPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalOfPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalRefPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalRefPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalContinuePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalContinuePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalReturnPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalReturnPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalBreakPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalBreakPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalStructPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalStructPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalTraitPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalTraitPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalTruePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalTruePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalTypePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalTypePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalUsePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalUsePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPubPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalPubPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAndPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalAndPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAndAndPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalAndAndPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalArrowPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalArrowPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAtPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalAtPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalBadCharactersPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalBadCharactersPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalColonPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalColonPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalColonColonPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalColonColonPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalCommaPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalCommaPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDivPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalDivPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDivEqPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalDivEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDollarPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalDollarPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalDotPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotDotPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalDotDotPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotDotEqPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalDotDotEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEndOfFilePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalEndOfFilePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEqPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEqEqPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalEqEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalGEPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalGEPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalGTPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalGTPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalHashPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalHashPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLBracePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalLBracePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLBrackPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalLBrackPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLEPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalLEPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLParenPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalLParenPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLTPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalLTPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMatchArrowPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalMatchArrowPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMinusPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalMinusPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMinusEqPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalMinusEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalModPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalModPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalModEqPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalModEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalMulPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulEqPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalMulEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNeqPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalNeqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNotPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalNotPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalBitNotPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalBitNotPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOrPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalOrPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOrOrPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalOrOrPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPlusPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalPlusPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPlusEqPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalPlusEqPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalQuestionMarkPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalQuestionMarkPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalRBracePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalRBracePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalRBrackPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalRBrackPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalRParenPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalRParenPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalSemicolonPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalUnderscorePtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalUnderscorePtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalXorPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalXorPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEmptyPtr<'db>> for TokenNodePtr<'db> {
    fn from(value: TerminalEmptyPtr<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalIdentifierGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalIdentifierGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLiteralNumberGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalLiteralNumberGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalShortStringGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalShortStringGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalStringGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalStringGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAsGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalAsGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalConstGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalConstGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalElseGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalElseGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEnumGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalEnumGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalExternGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalExternGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalFalseGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalFalseGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalFunctionGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalFunctionGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalIfGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalIfGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalWhileGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalWhileGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalForGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalForGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLoopGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalLoopGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalImplGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalImplGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalImplicitsGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalImplicitsGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLetGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalLetGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMacroGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalMacroGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMatchGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalMatchGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalModuleGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalModuleGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMutGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalMutGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNoPanicGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalNoPanicGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOfGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalOfGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalRefGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalRefGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalContinueGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalContinueGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalReturnGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalReturnGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalBreakGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalBreakGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalStructGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalStructGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalTraitGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalTraitGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalTrueGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalTrueGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalTypeGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalTypeGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalUseGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalUseGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPubGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalPubGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAndGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalAndGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAndAndGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalAndAndGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalArrowGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalArrowGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalAtGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalAtGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalBadCharactersGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalBadCharactersGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalColonGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalColonGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalColonColonGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalColonColonGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalCommaGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalCommaGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDivGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalDivGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDivEqGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalDivEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDollarGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalDollarGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalDotGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotDotGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalDotDotGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalDotDotEqGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalDotDotEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEndOfFileGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalEndOfFileGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEqGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEqEqGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalEqEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalGEGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalGEGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalGTGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalGTGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalHashGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalHashGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLBraceGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalLBraceGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLBrackGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalLBrackGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLEGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalLEGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLParenGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalLParenGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalLTGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalLTGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMatchArrowGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalMatchArrowGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMinusGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalMinusGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMinusEqGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalMinusEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalModGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalModGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalModEqGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalModEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalMulGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalMulEqGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalMulEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNeqGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalNeqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalNotGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalNotGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalBitNotGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalBitNotGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOrGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalOrGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalOrOrGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalOrOrGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPlusGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalPlusGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalPlusEqGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalPlusEqGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalQuestionMarkGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalQuestionMarkGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalRBraceGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalRBraceGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalRBrackGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalRBrackGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalRParenGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalRParenGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalSemicolonGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalSemicolonGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalUnderscoreGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalUnderscoreGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalXorGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalXorGreen<'db>) -> Self {
        Self(value.0)
    }
}
impl<'db> From<TerminalEmptyGreen<'db>> for TokenNodeGreen<'db> {
    fn from(value: TerminalEmptyGreen<'db>) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, salsa::Update)]
pub struct TokenNodeGreen<'db>(pub GreenId<'db>);
impl<'db> TypedSyntaxNode<'db> for TokenNode<'db> {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = TokenNodePtr<'db>;
    type Green = TokenNodeGreen<'db>;
    fn missing(db: &'db dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalIdentifier => {
                TokenNode::TerminalIdentifier(TerminalIdentifier::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLiteralNumber => {
                TokenNode::TerminalLiteralNumber(TerminalLiteralNumber::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalShortString => {
                TokenNode::TerminalShortString(TerminalShortString::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalString => {
                TokenNode::TerminalString(TerminalString::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalAs => TokenNode::TerminalAs(TerminalAs::from_syntax_node(db, node)),
            SyntaxKind::TerminalConst => {
                TokenNode::TerminalConst(TerminalConst::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalElse => {
                TokenNode::TerminalElse(TerminalElse::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEnum => {
                TokenNode::TerminalEnum(TerminalEnum::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalExtern => {
                TokenNode::TerminalExtern(TerminalExtern::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalFalse => {
                TokenNode::TerminalFalse(TerminalFalse::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalFunction => {
                TokenNode::TerminalFunction(TerminalFunction::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalIf => TokenNode::TerminalIf(TerminalIf::from_syntax_node(db, node)),
            SyntaxKind::TerminalWhile => {
                TokenNode::TerminalWhile(TerminalWhile::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalFor => {
                TokenNode::TerminalFor(TerminalFor::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLoop => {
                TokenNode::TerminalLoop(TerminalLoop::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalImpl => {
                TokenNode::TerminalImpl(TerminalImpl::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalImplicits => {
                TokenNode::TerminalImplicits(TerminalImplicits::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLet => {
                TokenNode::TerminalLet(TerminalLet::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMacro => {
                TokenNode::TerminalMacro(TerminalMacro::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMatch => {
                TokenNode::TerminalMatch(TerminalMatch::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalModule => {
                TokenNode::TerminalModule(TerminalModule::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMut => {
                TokenNode::TerminalMut(TerminalMut::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNoPanic => {
                TokenNode::TerminalNoPanic(TerminalNoPanic::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalOf => TokenNode::TerminalOf(TerminalOf::from_syntax_node(db, node)),
            SyntaxKind::TerminalRef => {
                TokenNode::TerminalRef(TerminalRef::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalContinue => {
                TokenNode::TerminalContinue(TerminalContinue::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalReturn => {
                TokenNode::TerminalReturn(TerminalReturn::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalBreak => {
                TokenNode::TerminalBreak(TerminalBreak::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalStruct => {
                TokenNode::TerminalStruct(TerminalStruct::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalTrait => {
                TokenNode::TerminalTrait(TerminalTrait::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalTrue => {
                TokenNode::TerminalTrue(TerminalTrue::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalType => {
                TokenNode::TerminalType(TerminalType::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalUse => {
                TokenNode::TerminalUse(TerminalUse::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPub => {
                TokenNode::TerminalPub(TerminalPub::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalAnd => {
                TokenNode::TerminalAnd(TerminalAnd::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalAndAnd => {
                TokenNode::TerminalAndAnd(TerminalAndAnd::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalArrow => {
                TokenNode::TerminalArrow(TerminalArrow::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalAt => TokenNode::TerminalAt(TerminalAt::from_syntax_node(db, node)),
            SyntaxKind::TerminalBadCharacters => {
                TokenNode::TerminalBadCharacters(TerminalBadCharacters::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalColon => {
                TokenNode::TerminalColon(TerminalColon::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalColonColon => {
                TokenNode::TerminalColonColon(TerminalColonColon::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalComma => {
                TokenNode::TerminalComma(TerminalComma::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDiv => {
                TokenNode::TerminalDiv(TerminalDiv::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDivEq => {
                TokenNode::TerminalDivEq(TerminalDivEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDollar => {
                TokenNode::TerminalDollar(TerminalDollar::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDot => {
                TokenNode::TerminalDot(TerminalDot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDotDot => {
                TokenNode::TerminalDotDot(TerminalDotDot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDotDotEq => {
                TokenNode::TerminalDotDotEq(TerminalDotDotEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEndOfFile => {
                TokenNode::TerminalEndOfFile(TerminalEndOfFile::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEq => TokenNode::TerminalEq(TerminalEq::from_syntax_node(db, node)),
            SyntaxKind::TerminalEqEq => {
                TokenNode::TerminalEqEq(TerminalEqEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalGE => TokenNode::TerminalGE(TerminalGE::from_syntax_node(db, node)),
            SyntaxKind::TerminalGT => TokenNode::TerminalGT(TerminalGT::from_syntax_node(db, node)),
            SyntaxKind::TerminalHash => {
                TokenNode::TerminalHash(TerminalHash::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLBrace => {
                TokenNode::TerminalLBrace(TerminalLBrace::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLBrack => {
                TokenNode::TerminalLBrack(TerminalLBrack::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLE => TokenNode::TerminalLE(TerminalLE::from_syntax_node(db, node)),
            SyntaxKind::TerminalLParen => {
                TokenNode::TerminalLParen(TerminalLParen::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLT => TokenNode::TerminalLT(TerminalLT::from_syntax_node(db, node)),
            SyntaxKind::TerminalMatchArrow => {
                TokenNode::TerminalMatchArrow(TerminalMatchArrow::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinus => {
                TokenNode::TerminalMinus(TerminalMinus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinusEq => {
                TokenNode::TerminalMinusEq(TerminalMinusEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMod => {
                TokenNode::TerminalMod(TerminalMod::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalModEq => {
                TokenNode::TerminalModEq(TerminalModEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMul => {
                TokenNode::TerminalMul(TerminalMul::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMulEq => {
                TokenNode::TerminalMulEq(TerminalMulEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNeq => {
                TokenNode::TerminalNeq(TerminalNeq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNot => {
                TokenNode::TerminalNot(TerminalNot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalBitNot => {
                TokenNode::TerminalBitNot(TerminalBitNot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalOr => TokenNode::TerminalOr(TerminalOr::from_syntax_node(db, node)),
            SyntaxKind::TerminalOrOr => {
                TokenNode::TerminalOrOr(TerminalOrOr::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPlus => {
                TokenNode::TerminalPlus(TerminalPlus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPlusEq => {
                TokenNode::TerminalPlusEq(TerminalPlusEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalQuestionMark => {
                TokenNode::TerminalQuestionMark(TerminalQuestionMark::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalRBrace => {
                TokenNode::TerminalRBrace(TerminalRBrace::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalRBrack => {
                TokenNode::TerminalRBrack(TerminalRBrack::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalRParen => {
                TokenNode::TerminalRParen(TerminalRParen::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalSemicolon => {
                TokenNode::TerminalSemicolon(TerminalSemicolon::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalUnderscore => {
                TokenNode::TerminalUnderscore(TerminalUnderscore::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalXor => {
                TokenNode::TerminalXor(TerminalXor::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEmpty => {
                TokenNode::TerminalEmpty(TerminalEmpty::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "TokenNode"),
        }
    }
    fn cast(db: &'db dyn SyntaxGroup, node: SyntaxNode<'db>) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalIdentifier => {
                Some(TokenNode::TerminalIdentifier(TerminalIdentifier::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLiteralNumber => Some(TokenNode::TerminalLiteralNumber(
                TerminalLiteralNumber::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalShortString => Some(TokenNode::TerminalShortString(
                TerminalShortString::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalString => {
                Some(TokenNode::TerminalString(TerminalString::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAs => {
                Some(TokenNode::TerminalAs(TerminalAs::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalConst => {
                Some(TokenNode::TerminalConst(TerminalConst::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalElse => {
                Some(TokenNode::TerminalElse(TerminalElse::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEnum => {
                Some(TokenNode::TerminalEnum(TerminalEnum::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalExtern => {
                Some(TokenNode::TerminalExtern(TerminalExtern::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalFalse => {
                Some(TokenNode::TerminalFalse(TerminalFalse::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalFunction => {
                Some(TokenNode::TerminalFunction(TerminalFunction::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalIf => {
                Some(TokenNode::TerminalIf(TerminalIf::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalWhile => {
                Some(TokenNode::TerminalWhile(TerminalWhile::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalFor => {
                Some(TokenNode::TerminalFor(TerminalFor::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLoop => {
                Some(TokenNode::TerminalLoop(TerminalLoop::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalImpl => {
                Some(TokenNode::TerminalImpl(TerminalImpl::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalImplicits => {
                Some(TokenNode::TerminalImplicits(TerminalImplicits::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLet => {
                Some(TokenNode::TerminalLet(TerminalLet::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMacro => {
                Some(TokenNode::TerminalMacro(TerminalMacro::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMatch => {
                Some(TokenNode::TerminalMatch(TerminalMatch::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalModule => {
                Some(TokenNode::TerminalModule(TerminalModule::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMut => {
                Some(TokenNode::TerminalMut(TerminalMut::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalNoPanic => {
                Some(TokenNode::TerminalNoPanic(TerminalNoPanic::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalOf => {
                Some(TokenNode::TerminalOf(TerminalOf::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalRef => {
                Some(TokenNode::TerminalRef(TerminalRef::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalContinue => {
                Some(TokenNode::TerminalContinue(TerminalContinue::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalReturn => {
                Some(TokenNode::TerminalReturn(TerminalReturn::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalBreak => {
                Some(TokenNode::TerminalBreak(TerminalBreak::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalStruct => {
                Some(TokenNode::TerminalStruct(TerminalStruct::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalTrait => {
                Some(TokenNode::TerminalTrait(TerminalTrait::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalTrue => {
                Some(TokenNode::TerminalTrue(TerminalTrue::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalType => {
                Some(TokenNode::TerminalType(TerminalType::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalUse => {
                Some(TokenNode::TerminalUse(TerminalUse::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalPub => {
                Some(TokenNode::TerminalPub(TerminalPub::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAnd => {
                Some(TokenNode::TerminalAnd(TerminalAnd::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAndAnd => {
                Some(TokenNode::TerminalAndAnd(TerminalAndAnd::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalArrow => {
                Some(TokenNode::TerminalArrow(TerminalArrow::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAt => {
                Some(TokenNode::TerminalAt(TerminalAt::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalBadCharacters => Some(TokenNode::TerminalBadCharacters(
                TerminalBadCharacters::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalColon => {
                Some(TokenNode::TerminalColon(TerminalColon::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalColonColon => {
                Some(TokenNode::TerminalColonColon(TerminalColonColon::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalComma => {
                Some(TokenNode::TerminalComma(TerminalComma::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDiv => {
                Some(TokenNode::TerminalDiv(TerminalDiv::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDivEq => {
                Some(TokenNode::TerminalDivEq(TerminalDivEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDollar => {
                Some(TokenNode::TerminalDollar(TerminalDollar::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDot => {
                Some(TokenNode::TerminalDot(TerminalDot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDotDot => {
                Some(TokenNode::TerminalDotDot(TerminalDotDot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDotDotEq => {
                Some(TokenNode::TerminalDotDotEq(TerminalDotDotEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEndOfFile => {
                Some(TokenNode::TerminalEndOfFile(TerminalEndOfFile::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEq => {
                Some(TokenNode::TerminalEq(TerminalEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEqEq => {
                Some(TokenNode::TerminalEqEq(TerminalEqEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalGE => {
                Some(TokenNode::TerminalGE(TerminalGE::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalGT => {
                Some(TokenNode::TerminalGT(TerminalGT::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalHash => {
                Some(TokenNode::TerminalHash(TerminalHash::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLBrace => {
                Some(TokenNode::TerminalLBrace(TerminalLBrace::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLBrack => {
                Some(TokenNode::TerminalLBrack(TerminalLBrack::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLE => {
                Some(TokenNode::TerminalLE(TerminalLE::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLParen => {
                Some(TokenNode::TerminalLParen(TerminalLParen::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLT => {
                Some(TokenNode::TerminalLT(TerminalLT::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMatchArrow => {
                Some(TokenNode::TerminalMatchArrow(TerminalMatchArrow::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMinus => {
                Some(TokenNode::TerminalMinus(TerminalMinus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMinusEq => {
                Some(TokenNode::TerminalMinusEq(TerminalMinusEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMod => {
                Some(TokenNode::TerminalMod(TerminalMod::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalModEq => {
                Some(TokenNode::TerminalModEq(TerminalModEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMul => {
                Some(TokenNode::TerminalMul(TerminalMul::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMulEq => {
                Some(TokenNode::TerminalMulEq(TerminalMulEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalNeq => {
                Some(TokenNode::TerminalNeq(TerminalNeq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalNot => {
                Some(TokenNode::TerminalNot(TerminalNot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalBitNot => {
                Some(TokenNode::TerminalBitNot(TerminalBitNot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalOr => {
                Some(TokenNode::TerminalOr(TerminalOr::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalOrOr => {
                Some(TokenNode::TerminalOrOr(TerminalOrOr::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalPlus => {
                Some(TokenNode::TerminalPlus(TerminalPlus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalPlusEq => {
                Some(TokenNode::TerminalPlusEq(TerminalPlusEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalQuestionMark => Some(TokenNode::TerminalQuestionMark(
                TerminalQuestionMark::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalRBrace => {
                Some(TokenNode::TerminalRBrace(TerminalRBrace::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalRBrack => {
                Some(TokenNode::TerminalRBrack(TerminalRBrack::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalRParen => {
                Some(TokenNode::TerminalRParen(TerminalRParen::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalSemicolon => {
                Some(TokenNode::TerminalSemicolon(TerminalSemicolon::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalUnderscore => {
                Some(TokenNode::TerminalUnderscore(TerminalUnderscore::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalXor => {
                Some(TokenNode::TerminalXor(TerminalXor::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEmpty => {
                Some(TokenNode::TerminalEmpty(TerminalEmpty::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode<'db> {
        match self {
            TokenNode::TerminalIdentifier(x) => x.as_syntax_node(),
            TokenNode::TerminalLiteralNumber(x) => x.as_syntax_node(),
            TokenNode::TerminalShortString(x) => x.as_syntax_node(),
            TokenNode::TerminalString(x) => x.as_syntax_node(),
            TokenNode::TerminalAs(x) => x.as_syntax_node(),
            TokenNode::TerminalConst(x) => x.as_syntax_node(),
            TokenNode::TerminalElse(x) => x.as_syntax_node(),
            TokenNode::TerminalEnum(x) => x.as_syntax_node(),
            TokenNode::TerminalExtern(x) => x.as_syntax_node(),
            TokenNode::TerminalFalse(x) => x.as_syntax_node(),
            TokenNode::TerminalFunction(x) => x.as_syntax_node(),
            TokenNode::TerminalIf(x) => x.as_syntax_node(),
            TokenNode::TerminalWhile(x) => x.as_syntax_node(),
            TokenNode::TerminalFor(x) => x.as_syntax_node(),
            TokenNode::TerminalLoop(x) => x.as_syntax_node(),
            TokenNode::TerminalImpl(x) => x.as_syntax_node(),
            TokenNode::TerminalImplicits(x) => x.as_syntax_node(),
            TokenNode::TerminalLet(x) => x.as_syntax_node(),
            TokenNode::TerminalMacro(x) => x.as_syntax_node(),
            TokenNode::TerminalMatch(x) => x.as_syntax_node(),
            TokenNode::TerminalModule(x) => x.as_syntax_node(),
            TokenNode::TerminalMut(x) => x.as_syntax_node(),
            TokenNode::TerminalNoPanic(x) => x.as_syntax_node(),
            TokenNode::TerminalOf(x) => x.as_syntax_node(),
            TokenNode::TerminalRef(x) => x.as_syntax_node(),
            TokenNode::TerminalContinue(x) => x.as_syntax_node(),
            TokenNode::TerminalReturn(x) => x.as_syntax_node(),
            TokenNode::TerminalBreak(x) => x.as_syntax_node(),
            TokenNode::TerminalStruct(x) => x.as_syntax_node(),
            TokenNode::TerminalTrait(x) => x.as_syntax_node(),
            TokenNode::TerminalTrue(x) => x.as_syntax_node(),
            TokenNode::TerminalType(x) => x.as_syntax_node(),
            TokenNode::TerminalUse(x) => x.as_syntax_node(),
            TokenNode::TerminalPub(x) => x.as_syntax_node(),
            TokenNode::TerminalAnd(x) => x.as_syntax_node(),
            TokenNode::TerminalAndAnd(x) => x.as_syntax_node(),
            TokenNode::TerminalArrow(x) => x.as_syntax_node(),
            TokenNode::TerminalAt(x) => x.as_syntax_node(),
            TokenNode::TerminalBadCharacters(x) => x.as_syntax_node(),
            TokenNode::TerminalColon(x) => x.as_syntax_node(),
            TokenNode::TerminalColonColon(x) => x.as_syntax_node(),
            TokenNode::TerminalComma(x) => x.as_syntax_node(),
            TokenNode::TerminalDiv(x) => x.as_syntax_node(),
            TokenNode::TerminalDivEq(x) => x.as_syntax_node(),
            TokenNode::TerminalDollar(x) => x.as_syntax_node(),
            TokenNode::TerminalDot(x) => x.as_syntax_node(),
            TokenNode::TerminalDotDot(x) => x.as_syntax_node(),
            TokenNode::TerminalDotDotEq(x) => x.as_syntax_node(),
            TokenNode::TerminalEndOfFile(x) => x.as_syntax_node(),
            TokenNode::TerminalEq(x) => x.as_syntax_node(),
            TokenNode::TerminalEqEq(x) => x.as_syntax_node(),
            TokenNode::TerminalGE(x) => x.as_syntax_node(),
            TokenNode::TerminalGT(x) => x.as_syntax_node(),
            TokenNode::TerminalHash(x) => x.as_syntax_node(),
            TokenNode::TerminalLBrace(x) => x.as_syntax_node(),
            TokenNode::TerminalLBrack(x) => x.as_syntax_node(),
            TokenNode::TerminalLE(x) => x.as_syntax_node(),
            TokenNode::TerminalLParen(x) => x.as_syntax_node(),
            TokenNode::TerminalLT(x) => x.as_syntax_node(),
            TokenNode::TerminalMatchArrow(x) => x.as_syntax_node(),
            TokenNode::TerminalMinus(x) => x.as_syntax_node(),
            TokenNode::TerminalMinusEq(x) => x.as_syntax_node(),
            TokenNode::TerminalMod(x) => x.as_syntax_node(),
            TokenNode::TerminalModEq(x) => x.as_syntax_node(),
            TokenNode::TerminalMul(x) => x.as_syntax_node(),
            TokenNode::TerminalMulEq(x) => x.as_syntax_node(),
            TokenNode::TerminalNeq(x) => x.as_syntax_node(),
            TokenNode::TerminalNot(x) => x.as_syntax_node(),
            TokenNode::TerminalBitNot(x) => x.as_syntax_node(),
            TokenNode::TerminalOr(x) => x.as_syntax_node(),
            TokenNode::TerminalOrOr(x) => x.as_syntax_node(),
            TokenNode::TerminalPlus(x) => x.as_syntax_node(),
            TokenNode::TerminalPlusEq(x) => x.as_syntax_node(),
            TokenNode::TerminalQuestionMark(x) => x.as_syntax_node(),
            TokenNode::TerminalRBrace(x) => x.as_syntax_node(),
            TokenNode::TerminalRBrack(x) => x.as_syntax_node(),
            TokenNode::TerminalRParen(x) => x.as_syntax_node(),
            TokenNode::TerminalSemicolon(x) => x.as_syntax_node(),
            TokenNode::TerminalUnderscore(x) => x.as_syntax_node(),
            TokenNode::TerminalXor(x) => x.as_syntax_node(),
            TokenNode::TerminalEmpty(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self, db: &'db dyn SyntaxGroup) -> Self::StablePtr {
        TokenNodePtr(self.as_syntax_node().lookup_intern(db).stable_ptr)
    }
}
impl<'db> TokenNode<'db> {
    /// Checks if a kind of a variant of [TokenNode].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TerminalIdentifier
                | SyntaxKind::TerminalLiteralNumber
                | SyntaxKind::TerminalShortString
                | SyntaxKind::TerminalString
                | SyntaxKind::TerminalAs
                | SyntaxKind::TerminalConst
                | SyntaxKind::TerminalElse
                | SyntaxKind::TerminalEnum
                | SyntaxKind::TerminalExtern
                | SyntaxKind::TerminalFalse
                | SyntaxKind::TerminalFunction
                | SyntaxKind::TerminalIf
                | SyntaxKind::TerminalWhile
                | SyntaxKind::TerminalFor
                | SyntaxKind::TerminalLoop
                | SyntaxKind::TerminalImpl
                | SyntaxKind::TerminalImplicits
                | SyntaxKind::TerminalLet
                | SyntaxKind::TerminalMacro
                | SyntaxKind::TerminalMatch
                | SyntaxKind::TerminalModule
                | SyntaxKind::TerminalMut
                | SyntaxKind::TerminalNoPanic
                | SyntaxKind::TerminalOf
                | SyntaxKind::TerminalRef
                | SyntaxKind::TerminalContinue
                | SyntaxKind::TerminalReturn
                | SyntaxKind::TerminalBreak
                | SyntaxKind::TerminalStruct
                | SyntaxKind::TerminalTrait
                | SyntaxKind::TerminalTrue
                | SyntaxKind::TerminalType
                | SyntaxKind::TerminalUse
                | SyntaxKind::TerminalPub
                | SyntaxKind::TerminalAnd
                | SyntaxKind::TerminalAndAnd
                | SyntaxKind::TerminalArrow
                | SyntaxKind::TerminalAt
                | SyntaxKind::TerminalBadCharacters
                | SyntaxKind::TerminalColon
                | SyntaxKind::TerminalColonColon
                | SyntaxKind::TerminalComma
                | SyntaxKind::TerminalDiv
                | SyntaxKind::TerminalDivEq
                | SyntaxKind::TerminalDollar
                | SyntaxKind::TerminalDot
                | SyntaxKind::TerminalDotDot
                | SyntaxKind::TerminalDotDotEq
                | SyntaxKind::TerminalEndOfFile
                | SyntaxKind::TerminalEq
                | SyntaxKind::TerminalEqEq
                | SyntaxKind::TerminalGE
                | SyntaxKind::TerminalGT
                | SyntaxKind::TerminalHash
                | SyntaxKind::TerminalLBrace
                | SyntaxKind::TerminalLBrack
                | SyntaxKind::TerminalLE
                | SyntaxKind::TerminalLParen
                | SyntaxKind::TerminalLT
                | SyntaxKind::TerminalMatchArrow
                | SyntaxKind::TerminalMinus
                | SyntaxKind::TerminalMinusEq
                | SyntaxKind::TerminalMod
                | SyntaxKind::TerminalModEq
                | SyntaxKind::TerminalMul
                | SyntaxKind::TerminalMulEq
                | SyntaxKind::TerminalNeq
                | SyntaxKind::TerminalNot
                | SyntaxKind::TerminalBitNot
                | SyntaxKind::TerminalOr
                | SyntaxKind::TerminalOrOr
                | SyntaxKind::TerminalPlus
                | SyntaxKind::TerminalPlusEq
                | SyntaxKind::TerminalQuestionMark
                | SyntaxKind::TerminalRBrace
                | SyntaxKind::TerminalRBrack
                | SyntaxKind::TerminalRParen
                | SyntaxKind::TerminalSemicolon
                | SyntaxKind::TerminalUnderscore
                | SyntaxKind::TerminalXor
                | SyntaxKind::TerminalEmpty
        )
    }
}
