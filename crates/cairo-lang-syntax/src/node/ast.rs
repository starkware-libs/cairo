// Autogenerated file. To regenerate, please run `cargo run --bin generate-syntax`.
#![allow(clippy::match_single_binding)]
#![allow(clippy::too_many_arguments)]
#![allow(dead_code)]
#![allow(unused_variables)]
use std::ops::Deref;
use std::sync::Arc;

use cairo_lang_filesystem::span::TextWidth;
use cairo_lang_utils::{Intern, LookupIntern, extract_matches};
use smol_str::SmolStr;

use super::element_list::ElementList;
use super::green::GreenNodeDetails;
use super::kind::SyntaxKind;
use super::{
    GreenId, GreenNode, SyntaxGroup, SyntaxNode, SyntaxStablePtr, SyntaxStablePtrId, Terminal,
    Token, TypedStablePtr, TypedSyntaxNode,
};
#[path = "ast_ext.rs"]
mod ast_ext;
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Trivia(ElementList<Trivium, 1>);
impl Deref for Trivia {
    type Target = ElementList<Trivium, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl Trivia {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<TriviumGreen>) -> TriviaGreen {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        TriviaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Trivia,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviaPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TriviaPtr {
    type SyntaxNode = Trivia;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TriviaPtr> for SyntaxStablePtrId {
    fn from(ptr: TriviaPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviaGreen(pub GreenId);
impl TypedSyntaxNode for Trivia {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Trivia);
    type StablePtr = TriviaPtr;
    type Green = TriviaGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TriviaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Trivia,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::Trivia { Some(Self(ElementList::new(node))) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviaPtr(self.node.0.stable_ptr)
    }
}
impl From<&Trivia> for SyntaxStablePtrId {
    fn from(node: &Trivia) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Trivium {
    SingleLineComment(TokenSingleLineComment),
    SingleLineDocComment(TokenSingleLineDocComment),
    SingleLineInnerComment(TokenSingleLineInnerComment),
    Whitespace(TokenWhitespace),
    Newline(TokenNewline),
    Skipped(TokenSkipped),
    SkippedNode(TriviumSkippedNode),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviumPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TriviumPtr {
    type SyntaxNode = Trivium;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Trivium {
        Trivium::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TriviumPtr> for SyntaxStablePtrId {
    fn from(ptr: TriviumPtr) -> Self {
        ptr.untyped()
    }
}
impl From<TokenSingleLineCommentPtr> for TriviumPtr {
    fn from(value: TokenSingleLineCommentPtr) -> Self {
        Self(value.0)
    }
}
impl From<TokenSingleLineDocCommentPtr> for TriviumPtr {
    fn from(value: TokenSingleLineDocCommentPtr) -> Self {
        Self(value.0)
    }
}
impl From<TokenSingleLineInnerCommentPtr> for TriviumPtr {
    fn from(value: TokenSingleLineInnerCommentPtr) -> Self {
        Self(value.0)
    }
}
impl From<TokenWhitespacePtr> for TriviumPtr {
    fn from(value: TokenWhitespacePtr) -> Self {
        Self(value.0)
    }
}
impl From<TokenNewlinePtr> for TriviumPtr {
    fn from(value: TokenNewlinePtr) -> Self {
        Self(value.0)
    }
}
impl From<TokenSkippedPtr> for TriviumPtr {
    fn from(value: TokenSkippedPtr) -> Self {
        Self(value.0)
    }
}
impl From<TriviumSkippedNodePtr> for TriviumPtr {
    fn from(value: TriviumSkippedNodePtr) -> Self {
        Self(value.0)
    }
}
impl From<TokenSingleLineCommentGreen> for TriviumGreen {
    fn from(value: TokenSingleLineCommentGreen) -> Self {
        Self(value.0)
    }
}
impl From<TokenSingleLineDocCommentGreen> for TriviumGreen {
    fn from(value: TokenSingleLineDocCommentGreen) -> Self {
        Self(value.0)
    }
}
impl From<TokenSingleLineInnerCommentGreen> for TriviumGreen {
    fn from(value: TokenSingleLineInnerCommentGreen) -> Self {
        Self(value.0)
    }
}
impl From<TokenWhitespaceGreen> for TriviumGreen {
    fn from(value: TokenWhitespaceGreen) -> Self {
        Self(value.0)
    }
}
impl From<TokenNewlineGreen> for TriviumGreen {
    fn from(value: TokenNewlineGreen) -> Self {
        Self(value.0)
    }
}
impl From<TokenSkippedGreen> for TriviumGreen {
    fn from(value: TokenSkippedGreen) -> Self {
        Self(value.0)
    }
}
impl From<TriviumSkippedNodeGreen> for TriviumGreen {
    fn from(value: TriviumSkippedNodeGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviumGreen(pub GreenId);
impl TypedSyntaxNode for Trivium {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = TriviumPtr;
    type Green = TriviumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TokenSingleLineComment => {
                Trivium::SingleLineComment(TokenSingleLineComment::from_syntax_node(db, node))
            }
            SyntaxKind::TokenSingleLineDocComment => {
                Trivium::SingleLineDocComment(TokenSingleLineDocComment::from_syntax_node(db, node))
            }
            SyntaxKind::TokenSingleLineInnerComment => Trivium::SingleLineInnerComment(
                TokenSingleLineInnerComment::from_syntax_node(db, node),
            ),
            SyntaxKind::TokenWhitespace => {
                Trivium::Whitespace(TokenWhitespace::from_syntax_node(db, node))
            }
            SyntaxKind::TokenNewline => Trivium::Newline(TokenNewline::from_syntax_node(db, node)),
            SyntaxKind::TokenSkipped => Trivium::Skipped(TokenSkipped::from_syntax_node(db, node)),
            SyntaxKind::TriviumSkippedNode => {
                Trivium::SkippedNode(TriviumSkippedNode::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Trivium"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TokenSingleLineComment => {
                Some(Trivium::SingleLineComment(TokenSingleLineComment::from_syntax_node(db, node)))
            }
            SyntaxKind::TokenSingleLineDocComment => Some(Trivium::SingleLineDocComment(
                TokenSingleLineDocComment::from_syntax_node(db, node),
            )),
            SyntaxKind::TokenSingleLineInnerComment => Some(Trivium::SingleLineInnerComment(
                TokenSingleLineInnerComment::from_syntax_node(db, node),
            )),
            SyntaxKind::TokenWhitespace => {
                Some(Trivium::Whitespace(TokenWhitespace::from_syntax_node(db, node)))
            }
            SyntaxKind::TokenNewline => {
                Some(Trivium::Newline(TokenNewline::from_syntax_node(db, node)))
            }
            SyntaxKind::TokenSkipped => {
                Some(Trivium::Skipped(TokenSkipped::from_syntax_node(db, node)))
            }
            SyntaxKind::TriviumSkippedNode => {
                Some(Trivium::SkippedNode(TriviumSkippedNode::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Trivium::SingleLineComment(x) => x.as_syntax_node(),
            Trivium::SingleLineDocComment(x) => x.as_syntax_node(),
            Trivium::SingleLineInnerComment(x) => x.as_syntax_node(),
            Trivium::Whitespace(x) => x.as_syntax_node(),
            Trivium::Newline(x) => x.as_syntax_node(),
            Trivium::Skipped(x) => x.as_syntax_node(),
            Trivium::SkippedNode(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviumPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&Trivium> for SyntaxStablePtrId {
    fn from(node: &Trivium) -> Self {
        node.stable_ptr().untyped()
    }
}
impl Trivium {
    /// Checks if a kind of a variant of [Trivium].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TokenSingleLineComment
                | SyntaxKind::TokenSingleLineDocComment
                | SyntaxKind::TokenSingleLineInnerComment
                | SyntaxKind::TokenWhitespace
                | SyntaxKind::TokenNewline
                | SyntaxKind::TokenSkipped
                | SyntaxKind::TriviumSkippedNode
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Expr {
    Path(ExprPath),
    Literal(TerminalLiteralNumber),
    ShortString(TerminalShortString),
    String(TerminalString),
    False(TerminalFalse),
    True(TerminalTrue),
    Parenthesized(ExprParenthesized),
    Unary(ExprUnary),
    Binary(ExprBinary),
    Tuple(ExprListParenthesized),
    FunctionCall(ExprFunctionCall),
    StructCtorCall(ExprStructCtorCall),
    Block(ExprBlock),
    Match(ExprMatch),
    If(ExprIf),
    Loop(ExprLoop),
    While(ExprWhile),
    For(ExprFor),
    Closure(ExprClosure),
    ErrorPropagate(ExprErrorPropagate),
    FieldInitShorthand(ExprFieldInitShorthand),
    Indexed(ExprIndexed),
    InlineMacro(ExprInlineMacro),
    FixedSizeArray(ExprFixedSizeArray),
    Missing(ExprMissing),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ExprPtr {
    type SyntaxNode = Expr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprPtr) -> Self {
        ptr.untyped()
    }
}
impl From<ExprPathPtr> for ExprPtr {
    fn from(value: ExprPathPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLiteralNumberPtr> for ExprPtr {
    fn from(value: TerminalLiteralNumberPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalShortStringPtr> for ExprPtr {
    fn from(value: TerminalShortStringPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalStringPtr> for ExprPtr {
    fn from(value: TerminalStringPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalFalsePtr> for ExprPtr {
    fn from(value: TerminalFalsePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTruePtr> for ExprPtr {
    fn from(value: TerminalTruePtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprParenthesizedPtr> for ExprPtr {
    fn from(value: ExprParenthesizedPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprUnaryPtr> for ExprPtr {
    fn from(value: ExprUnaryPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprBinaryPtr> for ExprPtr {
    fn from(value: ExprBinaryPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprListParenthesizedPtr> for ExprPtr {
    fn from(value: ExprListParenthesizedPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprFunctionCallPtr> for ExprPtr {
    fn from(value: ExprFunctionCallPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprStructCtorCallPtr> for ExprPtr {
    fn from(value: ExprStructCtorCallPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprBlockPtr> for ExprPtr {
    fn from(value: ExprBlockPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprMatchPtr> for ExprPtr {
    fn from(value: ExprMatchPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprIfPtr> for ExprPtr {
    fn from(value: ExprIfPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprLoopPtr> for ExprPtr {
    fn from(value: ExprLoopPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprWhilePtr> for ExprPtr {
    fn from(value: ExprWhilePtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprForPtr> for ExprPtr {
    fn from(value: ExprForPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprClosurePtr> for ExprPtr {
    fn from(value: ExprClosurePtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprErrorPropagatePtr> for ExprPtr {
    fn from(value: ExprErrorPropagatePtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprFieldInitShorthandPtr> for ExprPtr {
    fn from(value: ExprFieldInitShorthandPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprIndexedPtr> for ExprPtr {
    fn from(value: ExprIndexedPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprInlineMacroPtr> for ExprPtr {
    fn from(value: ExprInlineMacroPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprFixedSizeArrayPtr> for ExprPtr {
    fn from(value: ExprFixedSizeArrayPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprMissingPtr> for ExprPtr {
    fn from(value: ExprMissingPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprPathGreen> for ExprGreen {
    fn from(value: ExprPathGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLiteralNumberGreen> for ExprGreen {
    fn from(value: TerminalLiteralNumberGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalShortStringGreen> for ExprGreen {
    fn from(value: TerminalShortStringGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalStringGreen> for ExprGreen {
    fn from(value: TerminalStringGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalFalseGreen> for ExprGreen {
    fn from(value: TerminalFalseGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTrueGreen> for ExprGreen {
    fn from(value: TerminalTrueGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprParenthesizedGreen> for ExprGreen {
    fn from(value: ExprParenthesizedGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprUnaryGreen> for ExprGreen {
    fn from(value: ExprUnaryGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprBinaryGreen> for ExprGreen {
    fn from(value: ExprBinaryGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprListParenthesizedGreen> for ExprGreen {
    fn from(value: ExprListParenthesizedGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprFunctionCallGreen> for ExprGreen {
    fn from(value: ExprFunctionCallGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprStructCtorCallGreen> for ExprGreen {
    fn from(value: ExprStructCtorCallGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprBlockGreen> for ExprGreen {
    fn from(value: ExprBlockGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprMatchGreen> for ExprGreen {
    fn from(value: ExprMatchGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprIfGreen> for ExprGreen {
    fn from(value: ExprIfGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprLoopGreen> for ExprGreen {
    fn from(value: ExprLoopGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprWhileGreen> for ExprGreen {
    fn from(value: ExprWhileGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprForGreen> for ExprGreen {
    fn from(value: ExprForGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprClosureGreen> for ExprGreen {
    fn from(value: ExprClosureGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprErrorPropagateGreen> for ExprGreen {
    fn from(value: ExprErrorPropagateGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprFieldInitShorthandGreen> for ExprGreen {
    fn from(value: ExprFieldInitShorthandGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprIndexedGreen> for ExprGreen {
    fn from(value: ExprIndexedGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprInlineMacroGreen> for ExprGreen {
    fn from(value: ExprInlineMacroGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprFixedSizeArrayGreen> for ExprGreen {
    fn from(value: ExprFixedSizeArrayGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprMissingGreen> for ExprGreen {
    fn from(value: ExprMissingGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprGreen(pub GreenId);
impl TypedSyntaxNode for Expr {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ExprPtr;
    type Green = ExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprGreen(ExprMissing::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprPath => Expr::Path(ExprPath::from_syntax_node(db, node)),
            SyntaxKind::TerminalLiteralNumber => {
                Expr::Literal(TerminalLiteralNumber::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalShortString => {
                Expr::ShortString(TerminalShortString::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalString => Expr::String(TerminalString::from_syntax_node(db, node)),
            SyntaxKind::TerminalFalse => Expr::False(TerminalFalse::from_syntax_node(db, node)),
            SyntaxKind::TerminalTrue => Expr::True(TerminalTrue::from_syntax_node(db, node)),
            SyntaxKind::ExprParenthesized => {
                Expr::Parenthesized(ExprParenthesized::from_syntax_node(db, node))
            }
            SyntaxKind::ExprUnary => Expr::Unary(ExprUnary::from_syntax_node(db, node)),
            SyntaxKind::ExprBinary => Expr::Binary(ExprBinary::from_syntax_node(db, node)),
            SyntaxKind::ExprListParenthesized => {
                Expr::Tuple(ExprListParenthesized::from_syntax_node(db, node))
            }
            SyntaxKind::ExprFunctionCall => {
                Expr::FunctionCall(ExprFunctionCall::from_syntax_node(db, node))
            }
            SyntaxKind::ExprStructCtorCall => {
                Expr::StructCtorCall(ExprStructCtorCall::from_syntax_node(db, node))
            }
            SyntaxKind::ExprBlock => Expr::Block(ExprBlock::from_syntax_node(db, node)),
            SyntaxKind::ExprMatch => Expr::Match(ExprMatch::from_syntax_node(db, node)),
            SyntaxKind::ExprIf => Expr::If(ExprIf::from_syntax_node(db, node)),
            SyntaxKind::ExprLoop => Expr::Loop(ExprLoop::from_syntax_node(db, node)),
            SyntaxKind::ExprWhile => Expr::While(ExprWhile::from_syntax_node(db, node)),
            SyntaxKind::ExprFor => Expr::For(ExprFor::from_syntax_node(db, node)),
            SyntaxKind::ExprClosure => Expr::Closure(ExprClosure::from_syntax_node(db, node)),
            SyntaxKind::ExprErrorPropagate => {
                Expr::ErrorPropagate(ExprErrorPropagate::from_syntax_node(db, node))
            }
            SyntaxKind::ExprFieldInitShorthand => {
                Expr::FieldInitShorthand(ExprFieldInitShorthand::from_syntax_node(db, node))
            }
            SyntaxKind::ExprIndexed => Expr::Indexed(ExprIndexed::from_syntax_node(db, node)),
            SyntaxKind::ExprInlineMacro => {
                Expr::InlineMacro(ExprInlineMacro::from_syntax_node(db, node))
            }
            SyntaxKind::ExprFixedSizeArray => {
                Expr::FixedSizeArray(ExprFixedSizeArray::from_syntax_node(db, node))
            }
            SyntaxKind::ExprMissing => Expr::Missing(ExprMissing::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Expr"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprPath => Some(Expr::Path(ExprPath::from_syntax_node(db, node))),
            SyntaxKind::TerminalLiteralNumber => {
                Some(Expr::Literal(TerminalLiteralNumber::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalShortString => {
                Some(Expr::ShortString(TerminalShortString::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalString => {
                Some(Expr::String(TerminalString::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalFalse => {
                Some(Expr::False(TerminalFalse::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalTrue => Some(Expr::True(TerminalTrue::from_syntax_node(db, node))),
            SyntaxKind::ExprParenthesized => {
                Some(Expr::Parenthesized(ExprParenthesized::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprUnary => Some(Expr::Unary(ExprUnary::from_syntax_node(db, node))),
            SyntaxKind::ExprBinary => Some(Expr::Binary(ExprBinary::from_syntax_node(db, node))),
            SyntaxKind::ExprListParenthesized => {
                Some(Expr::Tuple(ExprListParenthesized::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprFunctionCall => {
                Some(Expr::FunctionCall(ExprFunctionCall::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprStructCtorCall => {
                Some(Expr::StructCtorCall(ExprStructCtorCall::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprBlock => Some(Expr::Block(ExprBlock::from_syntax_node(db, node))),
            SyntaxKind::ExprMatch => Some(Expr::Match(ExprMatch::from_syntax_node(db, node))),
            SyntaxKind::ExprIf => Some(Expr::If(ExprIf::from_syntax_node(db, node))),
            SyntaxKind::ExprLoop => Some(Expr::Loop(ExprLoop::from_syntax_node(db, node))),
            SyntaxKind::ExprWhile => Some(Expr::While(ExprWhile::from_syntax_node(db, node))),
            SyntaxKind::ExprFor => Some(Expr::For(ExprFor::from_syntax_node(db, node))),
            SyntaxKind::ExprClosure => Some(Expr::Closure(ExprClosure::from_syntax_node(db, node))),
            SyntaxKind::ExprErrorPropagate => {
                Some(Expr::ErrorPropagate(ExprErrorPropagate::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprFieldInitShorthand => {
                Some(Expr::FieldInitShorthand(ExprFieldInitShorthand::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprIndexed => Some(Expr::Indexed(ExprIndexed::from_syntax_node(db, node))),
            SyntaxKind::ExprInlineMacro => {
                Some(Expr::InlineMacro(ExprInlineMacro::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprFixedSizeArray => {
                Some(Expr::FixedSizeArray(ExprFixedSizeArray::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprMissing => Some(Expr::Missing(ExprMissing::from_syntax_node(db, node))),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Expr::Path(x) => x.as_syntax_node(),
            Expr::Literal(x) => x.as_syntax_node(),
            Expr::ShortString(x) => x.as_syntax_node(),
            Expr::String(x) => x.as_syntax_node(),
            Expr::False(x) => x.as_syntax_node(),
            Expr::True(x) => x.as_syntax_node(),
            Expr::Parenthesized(x) => x.as_syntax_node(),
            Expr::Unary(x) => x.as_syntax_node(),
            Expr::Binary(x) => x.as_syntax_node(),
            Expr::Tuple(x) => x.as_syntax_node(),
            Expr::FunctionCall(x) => x.as_syntax_node(),
            Expr::StructCtorCall(x) => x.as_syntax_node(),
            Expr::Block(x) => x.as_syntax_node(),
            Expr::Match(x) => x.as_syntax_node(),
            Expr::If(x) => x.as_syntax_node(),
            Expr::Loop(x) => x.as_syntax_node(),
            Expr::While(x) => x.as_syntax_node(),
            Expr::For(x) => x.as_syntax_node(),
            Expr::Closure(x) => x.as_syntax_node(),
            Expr::ErrorPropagate(x) => x.as_syntax_node(),
            Expr::FieldInitShorthand(x) => x.as_syntax_node(),
            Expr::Indexed(x) => x.as_syntax_node(),
            Expr::InlineMacro(x) => x.as_syntax_node(),
            Expr::FixedSizeArray(x) => x.as_syntax_node(),
            Expr::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&Expr> for SyntaxStablePtrId {
    fn from(node: &Expr) -> Self {
        node.stable_ptr().untyped()
    }
}
impl Expr {
    /// Checks if a kind of a variant of [Expr].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ExprPath
                | SyntaxKind::TerminalLiteralNumber
                | SyntaxKind::TerminalShortString
                | SyntaxKind::TerminalString
                | SyntaxKind::TerminalFalse
                | SyntaxKind::TerminalTrue
                | SyntaxKind::ExprParenthesized
                | SyntaxKind::ExprUnary
                | SyntaxKind::ExprBinary
                | SyntaxKind::ExprListParenthesized
                | SyntaxKind::ExprFunctionCall
                | SyntaxKind::ExprStructCtorCall
                | SyntaxKind::ExprBlock
                | SyntaxKind::ExprMatch
                | SyntaxKind::ExprIf
                | SyntaxKind::ExprLoop
                | SyntaxKind::ExprWhile
                | SyntaxKind::ExprFor
                | SyntaxKind::ExprClosure
                | SyntaxKind::ExprErrorPropagate
                | SyntaxKind::ExprFieldInitShorthand
                | SyntaxKind::ExprIndexed
                | SyntaxKind::ExprInlineMacro
                | SyntaxKind::ExprFixedSizeArray
                | SyntaxKind::ExprMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprList(ElementList<Expr, 2>);
impl Deref for ExprList {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ExprListElementOrSeparatorGreen>,
    ) -> ExprListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        ExprListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ExprListPtr {
    type SyntaxNode = ExprList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprList {
        ExprList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprListPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ExprListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(ExprGreen),
}
impl From<TerminalCommaGreen> for ExprListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        ExprListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ExprGreen> for ExprListElementOrSeparatorGreen {
    fn from(value: ExprGreen) -> Self {
        ExprListElementOrSeparatorGreen::Element(value)
    }
}
impl ExprListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ExprListElementOrSeparatorGreen::Separator(green) => green.0,
            ExprListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListGreen(pub GreenId);
impl TypedSyntaxNode for ExprList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprList);
    type StablePtr = ExprListPtr;
    type Green = ExprListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ExprList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprListPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprList> for SyntaxStablePtrId {
    fn from(node: &ExprList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Arg {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Arg {
    pub const INDEX_MODIFIERS: usize = 0;
    pub const INDEX_ARG_CLAUSE: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        modifiers: ModifierListGreen,
        arg_clause: ArgClauseGreen,
    ) -> ArgGreen {
        let children: Vec<GreenId> = vec![modifiers.0, arg_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Arg,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl Arg {
    pub fn modifiers(&self, db: &dyn SyntaxGroup) -> ModifierList {
        ModifierList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arg_clause(&self, db: &dyn SyntaxGroup) -> ArgClause {
        ArgClause::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgPtr(pub SyntaxStablePtrId);
impl ArgPtr {}
impl TypedStablePtr for ArgPtr {
    type SyntaxNode = Arg;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Arg {
        Arg::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ArgPtr> for SyntaxStablePtrId {
    fn from(ptr: ArgPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgGreen(pub GreenId);
impl TypedSyntaxNode for Arg {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Arg);
    type StablePtr = ArgPtr;
    type Green = ArgGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ArgGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Arg,
                details: GreenNodeDetails::Node {
                    children: vec![ModifierList::missing(db).0, ArgClause::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Arg,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Arg
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::Arg { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgPtr(self.node.0.stable_ptr)
    }
}
impl From<&Arg> for SyntaxStablePtrId {
    fn from(node: &Arg) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum ArgClause {
    Unnamed(ArgClauseUnnamed),
    Named(ArgClauseNamed),
    FieldInitShorthand(ArgClauseFieldInitShorthand),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgClausePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ArgClausePtr {
    type SyntaxNode = ArgClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ArgClause {
        ArgClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ArgClausePtr> for SyntaxStablePtrId {
    fn from(ptr: ArgClausePtr) -> Self {
        ptr.untyped()
    }
}
impl From<ArgClauseUnnamedPtr> for ArgClausePtr {
    fn from(value: ArgClauseUnnamedPtr) -> Self {
        Self(value.0)
    }
}
impl From<ArgClauseNamedPtr> for ArgClausePtr {
    fn from(value: ArgClauseNamedPtr) -> Self {
        Self(value.0)
    }
}
impl From<ArgClauseFieldInitShorthandPtr> for ArgClausePtr {
    fn from(value: ArgClauseFieldInitShorthandPtr) -> Self {
        Self(value.0)
    }
}
impl From<ArgClauseUnnamedGreen> for ArgClauseGreen {
    fn from(value: ArgClauseUnnamedGreen) -> Self {
        Self(value.0)
    }
}
impl From<ArgClauseNamedGreen> for ArgClauseGreen {
    fn from(value: ArgClauseNamedGreen) -> Self {
        Self(value.0)
    }
}
impl From<ArgClauseFieldInitShorthandGreen> for ArgClauseGreen {
    fn from(value: ArgClauseFieldInitShorthandGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgClauseGreen(pub GreenId);
impl TypedSyntaxNode for ArgClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ArgClausePtr;
    type Green = ArgClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ArgClauseUnnamed => {
                ArgClause::Unnamed(ArgClauseUnnamed::from_syntax_node(db, node))
            }
            SyntaxKind::ArgClauseNamed => {
                ArgClause::Named(ArgClauseNamed::from_syntax_node(db, node))
            }
            SyntaxKind::ArgClauseFieldInitShorthand => ArgClause::FieldInitShorthand(
                ArgClauseFieldInitShorthand::from_syntax_node(db, node),
            ),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "ArgClause"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ArgClauseUnnamed => {
                Some(ArgClause::Unnamed(ArgClauseUnnamed::from_syntax_node(db, node)))
            }
            SyntaxKind::ArgClauseNamed => {
                Some(ArgClause::Named(ArgClauseNamed::from_syntax_node(db, node)))
            }
            SyntaxKind::ArgClauseFieldInitShorthand => Some(ArgClause::FieldInitShorthand(
                ArgClauseFieldInitShorthand::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            ArgClause::Unnamed(x) => x.as_syntax_node(),
            ArgClause::Named(x) => x.as_syntax_node(),
            ArgClause::FieldInitShorthand(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&ArgClause> for SyntaxStablePtrId {
    fn from(node: &ArgClause) -> Self {
        node.stable_ptr().untyped()
    }
}
impl ArgClause {
    /// Checks if a kind of a variant of [ArgClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ArgClauseUnnamed
                | SyntaxKind::ArgClauseNamed
                | SyntaxKind::ArgClauseFieldInitShorthand
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgClauseNamed {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ArgClauseNamed {
    pub const INDEX_NAME: usize = 0;
    pub const INDEX_COLON: usize = 1;
    pub const INDEX_VALUE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        name: TerminalIdentifierGreen,
        colon: TerminalColonGreen,
        value: ExprGreen,
    ) -> ArgClauseNamedGreen {
        let children: Vec<GreenId> = vec![name.0, colon.0, value.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgClauseNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseNamed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ArgClauseNamed {
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn value(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgClauseNamedPtr(pub SyntaxStablePtrId);
impl ArgClauseNamedPtr {}
impl TypedStablePtr for ArgClauseNamedPtr {
    type SyntaxNode = ArgClauseNamed;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ArgClauseNamed {
        ArgClauseNamed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ArgClauseNamedPtr> for SyntaxStablePtrId {
    fn from(ptr: ArgClauseNamedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgClauseNamedGreen(pub GreenId);
impl TypedSyntaxNode for ArgClauseNamed {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgClauseNamed);
    type StablePtr = ArgClauseNamedPtr;
    type Green = ArgClauseNamedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ArgClauseNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseNamed,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgClauseNamed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgClauseNamed
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgClauseNamed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgClauseNamedPtr(self.node.0.stable_ptr)
    }
}
impl From<&ArgClauseNamed> for SyntaxStablePtrId {
    fn from(node: &ArgClauseNamed) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgClauseUnnamed {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ArgClauseUnnamed {
    pub const INDEX_VALUE: usize = 0;
    pub fn new_green(db: &dyn SyntaxGroup, value: ExprGreen) -> ArgClauseUnnamedGreen {
        let children: Vec<GreenId> = vec![value.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgClauseUnnamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseUnnamed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ArgClauseUnnamed {
    pub fn value(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgClauseUnnamedPtr(pub SyntaxStablePtrId);
impl ArgClauseUnnamedPtr {}
impl TypedStablePtr for ArgClauseUnnamedPtr {
    type SyntaxNode = ArgClauseUnnamed;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ArgClauseUnnamed {
        ArgClauseUnnamed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ArgClauseUnnamedPtr> for SyntaxStablePtrId {
    fn from(ptr: ArgClauseUnnamedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgClauseUnnamedGreen(pub GreenId);
impl TypedSyntaxNode for ArgClauseUnnamed {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgClauseUnnamed);
    type StablePtr = ArgClauseUnnamedPtr;
    type Green = ArgClauseUnnamedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ArgClauseUnnamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseUnnamed,
                details: GreenNodeDetails::Node {
                    children: vec![Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgClauseUnnamed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgClauseUnnamed
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgClauseUnnamed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgClauseUnnamedPtr(self.node.0.stable_ptr)
    }
}
impl From<&ArgClauseUnnamed> for SyntaxStablePtrId {
    fn from(node: &ArgClauseUnnamed) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgClauseFieldInitShorthand {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ArgClauseFieldInitShorthand {
    pub const INDEX_COLON: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        colon: TerminalColonGreen,
        name: ExprFieldInitShorthandGreen,
    ) -> ArgClauseFieldInitShorthandGreen {
        let children: Vec<GreenId> = vec![colon.0, name.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgClauseFieldInitShorthandGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseFieldInitShorthand,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ArgClauseFieldInitShorthand {
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> ExprFieldInitShorthand {
        ExprFieldInitShorthand::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgClauseFieldInitShorthandPtr(pub SyntaxStablePtrId);
impl ArgClauseFieldInitShorthandPtr {}
impl TypedStablePtr for ArgClauseFieldInitShorthandPtr {
    type SyntaxNode = ArgClauseFieldInitShorthand;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ArgClauseFieldInitShorthand {
        ArgClauseFieldInitShorthand::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ArgClauseFieldInitShorthandPtr> for SyntaxStablePtrId {
    fn from(ptr: ArgClauseFieldInitShorthandPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgClauseFieldInitShorthandGreen(pub GreenId);
impl TypedSyntaxNode for ArgClauseFieldInitShorthand {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgClauseFieldInitShorthand);
    type StablePtr = ArgClauseFieldInitShorthandPtr;
    type Green = ArgClauseFieldInitShorthandGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ArgClauseFieldInitShorthandGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgClauseFieldInitShorthand,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalColon::missing(db).0,
                        ExprFieldInitShorthand::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgClauseFieldInitShorthand,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgClauseFieldInitShorthand
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgClauseFieldInitShorthand {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgClauseFieldInitShorthandPtr(self.node.0.stable_ptr)
    }
}
impl From<&ArgClauseFieldInitShorthand> for SyntaxStablePtrId {
    fn from(node: &ArgClauseFieldInitShorthand) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprFieldInitShorthand {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprFieldInitShorthand {
    pub const INDEX_NAME: usize = 0;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        name: TerminalIdentifierGreen,
    ) -> ExprFieldInitShorthandGreen {
        let children: Vec<GreenId> = vec![name.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprFieldInitShorthandGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFieldInitShorthand,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprFieldInitShorthand {
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprFieldInitShorthandPtr(pub SyntaxStablePtrId);
impl ExprFieldInitShorthandPtr {}
impl TypedStablePtr for ExprFieldInitShorthandPtr {
    type SyntaxNode = ExprFieldInitShorthand;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprFieldInitShorthand {
        ExprFieldInitShorthand::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprFieldInitShorthandPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprFieldInitShorthandPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprFieldInitShorthandGreen(pub GreenId);
impl TypedSyntaxNode for ExprFieldInitShorthand {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprFieldInitShorthand);
    type StablePtr = ExprFieldInitShorthandPtr;
    type Green = ExprFieldInitShorthandGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprFieldInitShorthandGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFieldInitShorthand,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprFieldInitShorthand,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprFieldInitShorthand
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprFieldInitShorthand {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprFieldInitShorthandPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprFieldInitShorthand> for SyntaxStablePtrId {
    fn from(node: &ExprFieldInitShorthand) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgList(ElementList<Arg, 2>);
impl Deref for ArgList {
    type Target = ElementList<Arg, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ArgList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ArgListElementOrSeparatorGreen>,
    ) -> ArgListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        ArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ArgListPtr {
    type SyntaxNode = ArgList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ArgList {
        ArgList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ArgListPtr> for SyntaxStablePtrId {
    fn from(ptr: ArgListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ArgListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(ArgGreen),
}
impl From<TerminalCommaGreen> for ArgListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        ArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ArgGreen> for ArgListElementOrSeparatorGreen {
    fn from(value: ArgGreen) -> Self {
        ArgListElementOrSeparatorGreen::Element(value)
    }
}
impl ArgListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ArgListElementOrSeparatorGreen::Separator(green) => green.0,
            ArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListGreen(pub GreenId);
impl TypedSyntaxNode for ArgList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgList);
    type StablePtr = ArgListPtr;
    type Green = ArgListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ArgList { Some(Self(ElementList::new(node))) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgListPtr(self.node.0.stable_ptr)
    }
}
impl From<&ArgList> for SyntaxStablePtrId {
    fn from(node: &ArgList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprMissing {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> ExprMissingGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprMissing {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMissingPtr(pub SyntaxStablePtrId);
impl ExprMissingPtr {}
impl TypedStablePtr for ExprMissingPtr {
    type SyntaxNode = ExprMissing;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprMissing {
        ExprMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprMissingPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprMissingPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMissingGreen(pub GreenId);
impl TypedSyntaxNode for ExprMissing {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprMissing);
    type StablePtr = ExprMissingPtr;
    type Green = ExprMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprMissing
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprMissing { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprMissingPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprMissing> for SyntaxStablePtrId {
    fn from(node: &ExprMissing) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum PathSegment {
    WithGenericArgs(PathSegmentWithGenericArgs),
    Simple(PathSegmentSimple),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for PathSegmentPtr {
    type SyntaxNode = PathSegment;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PathSegment {
        PathSegment::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PathSegmentPtr> for SyntaxStablePtrId {
    fn from(ptr: PathSegmentPtr) -> Self {
        ptr.untyped()
    }
}
impl From<PathSegmentWithGenericArgsPtr> for PathSegmentPtr {
    fn from(value: PathSegmentWithGenericArgsPtr) -> Self {
        Self(value.0)
    }
}
impl From<PathSegmentSimplePtr> for PathSegmentPtr {
    fn from(value: PathSegmentSimplePtr) -> Self {
        Self(value.0)
    }
}
impl From<PathSegmentWithGenericArgsGreen> for PathSegmentGreen {
    fn from(value: PathSegmentWithGenericArgsGreen) -> Self {
        Self(value.0)
    }
}
impl From<PathSegmentSimpleGreen> for PathSegmentGreen {
    fn from(value: PathSegmentSimpleGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentGreen(pub GreenId);
impl TypedSyntaxNode for PathSegment {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = PathSegmentPtr;
    type Green = PathSegmentGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PathSegmentGreen(PathSegmentSimple::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::PathSegmentWithGenericArgs => {
                PathSegment::WithGenericArgs(PathSegmentWithGenericArgs::from_syntax_node(db, node))
            }
            SyntaxKind::PathSegmentSimple => {
                PathSegment::Simple(PathSegmentSimple::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "PathSegment"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::PathSegmentWithGenericArgs => Some(PathSegment::WithGenericArgs(
                PathSegmentWithGenericArgs::from_syntax_node(db, node),
            )),
            SyntaxKind::PathSegmentSimple => {
                Some(PathSegment::Simple(PathSegmentSimple::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            PathSegment::WithGenericArgs(x) => x.as_syntax_node(),
            PathSegment::Simple(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PathSegmentPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&PathSegment> for SyntaxStablePtrId {
    fn from(node: &PathSegment) -> Self {
        node.stable_ptr().untyped()
    }
}
impl PathSegment {
    /// Checks if a kind of a variant of [PathSegment].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::PathSegmentWithGenericArgs | SyntaxKind::PathSegmentSimple)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PathSegmentSimple {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl PathSegmentSimple {
    pub const INDEX_IDENT: usize = 0;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        ident: TerminalIdentifierGreen,
    ) -> PathSegmentSimpleGreen {
        let children: Vec<GreenId> = vec![ident.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PathSegmentSimpleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PathSegmentSimple,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl PathSegmentSimple {
    pub fn ident(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentSimplePtr(pub SyntaxStablePtrId);
impl PathSegmentSimplePtr {}
impl TypedStablePtr for PathSegmentSimplePtr {
    type SyntaxNode = PathSegmentSimple;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PathSegmentSimple {
        PathSegmentSimple::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PathSegmentSimplePtr> for SyntaxStablePtrId {
    fn from(ptr: PathSegmentSimplePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentSimpleGreen(pub GreenId);
impl TypedSyntaxNode for PathSegmentSimple {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PathSegmentSimple);
    type StablePtr = PathSegmentSimplePtr;
    type Green = PathSegmentSimpleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PathSegmentSimpleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PathSegmentSimple,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PathSegmentSimple,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PathSegmentSimple
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PathSegmentSimple {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PathSegmentSimplePtr(self.node.0.stable_ptr)
    }
}
impl From<&PathSegmentSimple> for SyntaxStablePtrId {
    fn from(node: &PathSegmentSimple) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTerminalColonColon {
    Empty(OptionTerminalColonColonEmpty),
    TerminalColonColon(TerminalColonColon),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalColonColonPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionTerminalColonColonPtr {
    type SyntaxNode = OptionTerminalColonColon;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionTerminalColonColon {
        OptionTerminalColonColon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionTerminalColonColonPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionTerminalColonColonPtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionTerminalColonColonEmptyPtr> for OptionTerminalColonColonPtr {
    fn from(value: OptionTerminalColonColonEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalColonColonPtr> for OptionTerminalColonColonPtr {
    fn from(value: TerminalColonColonPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionTerminalColonColonEmptyGreen> for OptionTerminalColonColonGreen {
    fn from(value: OptionTerminalColonColonEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalColonColonGreen> for OptionTerminalColonColonGreen {
    fn from(value: TerminalColonColonGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalColonColonGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalColonColon {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalColonColonPtr;
    type Green = OptionTerminalColonColonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalColonColonEmpty => OptionTerminalColonColon::Empty(
                OptionTerminalColonColonEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::TerminalColonColon => OptionTerminalColonColon::TerminalColonColon(
                TerminalColonColon::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalColonColon"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalColonColonEmpty => Some(OptionTerminalColonColon::Empty(
                OptionTerminalColonColonEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalColonColon => Some(OptionTerminalColonColon::TerminalColonColon(
                TerminalColonColon::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTerminalColonColon::Empty(x) => x.as_syntax_node(),
            OptionTerminalColonColon::TerminalColonColon(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalColonColonPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionTerminalColonColon> for SyntaxStablePtrId {
    fn from(node: &OptionTerminalColonColon) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionTerminalColonColon {
    /// Checks if a kind of a variant of [OptionTerminalColonColon].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTerminalColonColonEmpty | SyntaxKind::TerminalColonColon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTerminalColonColonEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionTerminalColonColonEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionTerminalColonColonEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTerminalColonColonEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalColonColonEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionTerminalColonColonEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalColonColonEmptyPtr(pub SyntaxStablePtrId);
impl OptionTerminalColonColonEmptyPtr {}
impl TypedStablePtr for OptionTerminalColonColonEmptyPtr {
    type SyntaxNode = OptionTerminalColonColonEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionTerminalColonColonEmpty {
        OptionTerminalColonColonEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionTerminalColonColonEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionTerminalColonColonEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalColonColonEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalColonColonEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalColonColonEmpty);
    type StablePtr = OptionTerminalColonColonEmptyPtr;
    type Green = OptionTerminalColonColonEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionTerminalColonColonEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalColonColonEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalColonColonEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalColonColonEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTerminalColonColonEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalColonColonEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionTerminalColonColonEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionTerminalColonColonEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PathSegmentWithGenericArgs {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl PathSegmentWithGenericArgs {
    pub const INDEX_IDENT: usize = 0;
    pub const INDEX_SEPARATOR: usize = 1;
    pub const INDEX_GENERIC_ARGS: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        ident: TerminalIdentifierGreen,
        separator: OptionTerminalColonColonGreen,
        generic_args: GenericArgsGreen,
    ) -> PathSegmentWithGenericArgsGreen {
        let children: Vec<GreenId> = vec![ident.0, separator.0, generic_args.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PathSegmentWithGenericArgsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PathSegmentWithGenericArgs,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl PathSegmentWithGenericArgs {
    pub fn ident(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn separator(&self, db: &dyn SyntaxGroup) -> OptionTerminalColonColon {
        OptionTerminalColonColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> GenericArgs {
        GenericArgs::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentWithGenericArgsPtr(pub SyntaxStablePtrId);
impl PathSegmentWithGenericArgsPtr {}
impl TypedStablePtr for PathSegmentWithGenericArgsPtr {
    type SyntaxNode = PathSegmentWithGenericArgs;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PathSegmentWithGenericArgs {
        PathSegmentWithGenericArgs::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PathSegmentWithGenericArgsPtr> for SyntaxStablePtrId {
    fn from(ptr: PathSegmentWithGenericArgsPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PathSegmentWithGenericArgsGreen(pub GreenId);
impl TypedSyntaxNode for PathSegmentWithGenericArgs {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PathSegmentWithGenericArgs);
    type StablePtr = PathSegmentWithGenericArgsPtr;
    type Green = PathSegmentWithGenericArgsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PathSegmentWithGenericArgsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PathSegmentWithGenericArgs,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIdentifier::missing(db).0,
                        OptionTerminalColonColon::missing(db).0,
                        GenericArgs::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PathSegmentWithGenericArgs,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PathSegmentWithGenericArgs
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PathSegmentWithGenericArgs {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PathSegmentWithGenericArgsPtr(self.node.0.stable_ptr)
    }
}
impl From<&PathSegmentWithGenericArgs> for SyntaxStablePtrId {
    fn from(node: &PathSegmentWithGenericArgs) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprPath(ElementList<PathSegment, 2>);
impl Deref for ExprPath {
    type Target = ElementList<PathSegment, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprPath {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ExprPathElementOrSeparatorGreen>,
    ) -> ExprPathGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        ExprPathGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprPath,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprPathPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ExprPathPtr {
    type SyntaxNode = ExprPath;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprPathPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprPathPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ExprPathElementOrSeparatorGreen {
    Separator(TerminalColonColonGreen),
    Element(PathSegmentGreen),
}
impl From<TerminalColonColonGreen> for ExprPathElementOrSeparatorGreen {
    fn from(value: TerminalColonColonGreen) -> Self {
        ExprPathElementOrSeparatorGreen::Separator(value)
    }
}
impl From<PathSegmentGreen> for ExprPathElementOrSeparatorGreen {
    fn from(value: PathSegmentGreen) -> Self {
        ExprPathElementOrSeparatorGreen::Element(value)
    }
}
impl ExprPathElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ExprPathElementOrSeparatorGreen::Separator(green) => green.0,
            ExprPathElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprPathGreen(pub GreenId);
impl TypedSyntaxNode for ExprPath {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprPath);
    type StablePtr = ExprPathPtr;
    type Green = ExprPathGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprPathGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprPath,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ExprPath {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprPathPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprPath> for SyntaxStablePtrId {
    fn from(node: &ExprPath) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprParenthesized {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprParenthesized {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_EXPR: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        expr: ExprGreen,
        rparen: TerminalRParenGreen,
    ) -> ExprParenthesizedGreen {
        let children: Vec<GreenId> = vec![lparen.0, expr.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprParenthesized,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprParenthesized {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprParenthesizedPtr(pub SyntaxStablePtrId);
impl ExprParenthesizedPtr {}
impl TypedStablePtr for ExprParenthesizedPtr {
    type SyntaxNode = ExprParenthesized;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprParenthesized {
        ExprParenthesized::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprParenthesizedPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprParenthesizedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprParenthesizedGreen(pub GreenId);
impl TypedSyntaxNode for ExprParenthesized {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprParenthesized);
    type StablePtr = ExprParenthesizedPtr;
    type Green = ExprParenthesizedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprParenthesized,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        Expr::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprParenthesized,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprParenthesized
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprParenthesized {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprParenthesizedPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprParenthesized> for SyntaxStablePtrId {
    fn from(node: &ExprParenthesized) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprUnary {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprUnary {
    pub const INDEX_OP: usize = 0;
    pub const INDEX_EXPR: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        op: UnaryOperatorGreen,
        expr: ExprGreen,
    ) -> ExprUnaryGreen {
        let children: Vec<GreenId> = vec![op.0, expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprUnaryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprUnary,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprUnary {
    pub fn op(&self, db: &dyn SyntaxGroup) -> UnaryOperator {
        UnaryOperator::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprUnaryPtr(pub SyntaxStablePtrId);
impl ExprUnaryPtr {}
impl TypedStablePtr for ExprUnaryPtr {
    type SyntaxNode = ExprUnary;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprUnary {
        ExprUnary::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprUnaryPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprUnaryPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprUnaryGreen(pub GreenId);
impl TypedSyntaxNode for ExprUnary {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprUnary);
    type StablePtr = ExprUnaryPtr;
    type Green = ExprUnaryGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprUnaryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprUnary,
                details: GreenNodeDetails::Node {
                    children: vec![UnaryOperator::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprUnary,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprUnary
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprUnary { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprUnaryPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprUnary> for SyntaxStablePtrId {
    fn from(node: &ExprUnary) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum UnaryOperator {
    Not(TerminalNot),
    BitNot(TerminalBitNot),
    Minus(TerminalMinus),
    At(TerminalAt),
    Desnap(TerminalMul),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UnaryOperatorPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for UnaryOperatorPtr {
    type SyntaxNode = UnaryOperator;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> UnaryOperator {
        UnaryOperator::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<UnaryOperatorPtr> for SyntaxStablePtrId {
    fn from(ptr: UnaryOperatorPtr) -> Self {
        ptr.untyped()
    }
}
impl From<TerminalNotPtr> for UnaryOperatorPtr {
    fn from(value: TerminalNotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalBitNotPtr> for UnaryOperatorPtr {
    fn from(value: TerminalBitNotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusPtr> for UnaryOperatorPtr {
    fn from(value: TerminalMinusPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAtPtr> for UnaryOperatorPtr {
    fn from(value: TerminalAtPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulPtr> for UnaryOperatorPtr {
    fn from(value: TerminalMulPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNotGreen> for UnaryOperatorGreen {
    fn from(value: TerminalNotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalBitNotGreen> for UnaryOperatorGreen {
    fn from(value: TerminalBitNotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusGreen> for UnaryOperatorGreen {
    fn from(value: TerminalMinusGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAtGreen> for UnaryOperatorGreen {
    fn from(value: TerminalAtGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulGreen> for UnaryOperatorGreen {
    fn from(value: TerminalMulGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UnaryOperatorGreen(pub GreenId);
impl TypedSyntaxNode for UnaryOperator {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = UnaryOperatorPtr;
    type Green = UnaryOperatorGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalNot => UnaryOperator::Not(TerminalNot::from_syntax_node(db, node)),
            SyntaxKind::TerminalBitNot => {
                UnaryOperator::BitNot(TerminalBitNot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinus => {
                UnaryOperator::Minus(TerminalMinus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalAt => UnaryOperator::At(TerminalAt::from_syntax_node(db, node)),
            SyntaxKind::TerminalMul => {
                UnaryOperator::Desnap(TerminalMul::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "UnaryOperator"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalNot => {
                Some(UnaryOperator::Not(TerminalNot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalBitNot => {
                Some(UnaryOperator::BitNot(TerminalBitNot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMinus => {
                Some(UnaryOperator::Minus(TerminalMinus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAt => {
                Some(UnaryOperator::At(TerminalAt::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMul => {
                Some(UnaryOperator::Desnap(TerminalMul::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            UnaryOperator::Not(x) => x.as_syntax_node(),
            UnaryOperator::BitNot(x) => x.as_syntax_node(),
            UnaryOperator::Minus(x) => x.as_syntax_node(),
            UnaryOperator::At(x) => x.as_syntax_node(),
            UnaryOperator::Desnap(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        UnaryOperatorPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&UnaryOperator> for SyntaxStablePtrId {
    fn from(node: &UnaryOperator) -> Self {
        node.stable_ptr().untyped()
    }
}
impl UnaryOperator {
    /// Checks if a kind of a variant of [UnaryOperator].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TerminalNot
                | SyntaxKind::TerminalBitNot
                | SyntaxKind::TerminalMinus
                | SyntaxKind::TerminalAt
                | SyntaxKind::TerminalMul
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBinary {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprBinary {
    pub const INDEX_LHS: usize = 0;
    pub const INDEX_OP: usize = 1;
    pub const INDEX_RHS: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lhs: ExprGreen,
        op: BinaryOperatorGreen,
        rhs: ExprGreen,
    ) -> ExprBinaryGreen {
        let children: Vec<GreenId> = vec![lhs.0, op.0, rhs.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprBinaryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprBinary,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprBinary {
    pub fn lhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn op(&self, db: &dyn SyntaxGroup) -> BinaryOperator {
        BinaryOperator::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBinaryPtr(pub SyntaxStablePtrId);
impl ExprBinaryPtr {}
impl TypedStablePtr for ExprBinaryPtr {
    type SyntaxNode = ExprBinary;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprBinary {
        ExprBinary::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprBinaryPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprBinaryPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBinaryGreen(pub GreenId);
impl TypedSyntaxNode for ExprBinary {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprBinary);
    type StablePtr = ExprBinaryPtr;
    type Green = ExprBinaryGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprBinaryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprBinary,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Expr::missing(db).0,
                        BinaryOperator::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprBinary,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprBinary
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprBinary { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprBinaryPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprBinary> for SyntaxStablePtrId {
    fn from(node: &ExprBinary) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum BinaryOperator {
    Dot(TerminalDot),
    Not(TerminalNot),
    Mul(TerminalMul),
    MulEq(TerminalMulEq),
    Div(TerminalDiv),
    DivEq(TerminalDivEq),
    Mod(TerminalMod),
    ModEq(TerminalModEq),
    Plus(TerminalPlus),
    PlusEq(TerminalPlusEq),
    Minus(TerminalMinus),
    MinusEq(TerminalMinusEq),
    EqEq(TerminalEqEq),
    Neq(TerminalNeq),
    Eq(TerminalEq),
    And(TerminalAnd),
    AndAnd(TerminalAndAnd),
    Or(TerminalOr),
    OrOr(TerminalOrOr),
    Xor(TerminalXor),
    LE(TerminalLE),
    GE(TerminalGE),
    LT(TerminalLT),
    GT(TerminalGT),
    DotDot(TerminalDotDot),
    DotDotEq(TerminalDotDotEq),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct BinaryOperatorPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for BinaryOperatorPtr {
    type SyntaxNode = BinaryOperator;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> BinaryOperator {
        BinaryOperator::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<BinaryOperatorPtr> for SyntaxStablePtrId {
    fn from(ptr: BinaryOperatorPtr) -> Self {
        ptr.untyped()
    }
}
impl From<TerminalDotPtr> for BinaryOperatorPtr {
    fn from(value: TerminalDotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNotPtr> for BinaryOperatorPtr {
    fn from(value: TerminalNotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulPtr> for BinaryOperatorPtr {
    fn from(value: TerminalMulPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulEqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalMulEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDivPtr> for BinaryOperatorPtr {
    fn from(value: TerminalDivPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDivEqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalDivEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModPtr> for BinaryOperatorPtr {
    fn from(value: TerminalModPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModEqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalModEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPlusPtr> for BinaryOperatorPtr {
    fn from(value: TerminalPlusPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPlusEqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalPlusEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusPtr> for BinaryOperatorPtr {
    fn from(value: TerminalMinusPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusEqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalMinusEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqEqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalEqEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNeqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalNeqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAndPtr> for BinaryOperatorPtr {
    fn from(value: TerminalAndPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAndAndPtr> for BinaryOperatorPtr {
    fn from(value: TerminalAndAndPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrPtr> for BinaryOperatorPtr {
    fn from(value: TerminalOrPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrOrPtr> for BinaryOperatorPtr {
    fn from(value: TerminalOrOrPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalXorPtr> for BinaryOperatorPtr {
    fn from(value: TerminalXorPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLEPtr> for BinaryOperatorPtr {
    fn from(value: TerminalLEPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGEPtr> for BinaryOperatorPtr {
    fn from(value: TerminalGEPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLTPtr> for BinaryOperatorPtr {
    fn from(value: TerminalLTPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGTPtr> for BinaryOperatorPtr {
    fn from(value: TerminalGTPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotPtr> for BinaryOperatorPtr {
    fn from(value: TerminalDotDotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotEqPtr> for BinaryOperatorPtr {
    fn from(value: TerminalDotDotEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotGreen> for BinaryOperatorGreen {
    fn from(value: TerminalDotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNotGreen> for BinaryOperatorGreen {
    fn from(value: TerminalNotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulGreen> for BinaryOperatorGreen {
    fn from(value: TerminalMulGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulEqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalMulEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDivGreen> for BinaryOperatorGreen {
    fn from(value: TerminalDivGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDivEqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalDivEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModGreen> for BinaryOperatorGreen {
    fn from(value: TerminalModGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModEqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalModEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPlusGreen> for BinaryOperatorGreen {
    fn from(value: TerminalPlusGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPlusEqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalPlusEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusGreen> for BinaryOperatorGreen {
    fn from(value: TerminalMinusGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusEqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalMinusEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqEqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalEqEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNeqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalNeqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAndGreen> for BinaryOperatorGreen {
    fn from(value: TerminalAndGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAndAndGreen> for BinaryOperatorGreen {
    fn from(value: TerminalAndAndGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrGreen> for BinaryOperatorGreen {
    fn from(value: TerminalOrGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrOrGreen> for BinaryOperatorGreen {
    fn from(value: TerminalOrOrGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalXorGreen> for BinaryOperatorGreen {
    fn from(value: TerminalXorGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLEGreen> for BinaryOperatorGreen {
    fn from(value: TerminalLEGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGEGreen> for BinaryOperatorGreen {
    fn from(value: TerminalGEGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLTGreen> for BinaryOperatorGreen {
    fn from(value: TerminalLTGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGTGreen> for BinaryOperatorGreen {
    fn from(value: TerminalGTGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotGreen> for BinaryOperatorGreen {
    fn from(value: TerminalDotDotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotEqGreen> for BinaryOperatorGreen {
    fn from(value: TerminalDotDotEqGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct BinaryOperatorGreen(pub GreenId);
impl TypedSyntaxNode for BinaryOperator {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = BinaryOperatorPtr;
    type Green = BinaryOperatorGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalDot => BinaryOperator::Dot(TerminalDot::from_syntax_node(db, node)),
            SyntaxKind::TerminalNot => BinaryOperator::Not(TerminalNot::from_syntax_node(db, node)),
            SyntaxKind::TerminalMul => BinaryOperator::Mul(TerminalMul::from_syntax_node(db, node)),
            SyntaxKind::TerminalMulEq => {
                BinaryOperator::MulEq(TerminalMulEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDiv => BinaryOperator::Div(TerminalDiv::from_syntax_node(db, node)),
            SyntaxKind::TerminalDivEq => {
                BinaryOperator::DivEq(TerminalDivEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMod => BinaryOperator::Mod(TerminalMod::from_syntax_node(db, node)),
            SyntaxKind::TerminalModEq => {
                BinaryOperator::ModEq(TerminalModEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPlus => {
                BinaryOperator::Plus(TerminalPlus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPlusEq => {
                BinaryOperator::PlusEq(TerminalPlusEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinus => {
                BinaryOperator::Minus(TerminalMinus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinusEq => {
                BinaryOperator::MinusEq(TerminalMinusEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEqEq => {
                BinaryOperator::EqEq(TerminalEqEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNeq => BinaryOperator::Neq(TerminalNeq::from_syntax_node(db, node)),
            SyntaxKind::TerminalEq => BinaryOperator::Eq(TerminalEq::from_syntax_node(db, node)),
            SyntaxKind::TerminalAnd => BinaryOperator::And(TerminalAnd::from_syntax_node(db, node)),
            SyntaxKind::TerminalAndAnd => {
                BinaryOperator::AndAnd(TerminalAndAnd::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalOr => BinaryOperator::Or(TerminalOr::from_syntax_node(db, node)),
            SyntaxKind::TerminalOrOr => {
                BinaryOperator::OrOr(TerminalOrOr::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalXor => BinaryOperator::Xor(TerminalXor::from_syntax_node(db, node)),
            SyntaxKind::TerminalLE => BinaryOperator::LE(TerminalLE::from_syntax_node(db, node)),
            SyntaxKind::TerminalGE => BinaryOperator::GE(TerminalGE::from_syntax_node(db, node)),
            SyntaxKind::TerminalLT => BinaryOperator::LT(TerminalLT::from_syntax_node(db, node)),
            SyntaxKind::TerminalGT => BinaryOperator::GT(TerminalGT::from_syntax_node(db, node)),
            SyntaxKind::TerminalDotDot => {
                BinaryOperator::DotDot(TerminalDotDot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDotDotEq => {
                BinaryOperator::DotDotEq(TerminalDotDotEq::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "BinaryOperator")
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalDot => {
                Some(BinaryOperator::Dot(TerminalDot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalNot => {
                Some(BinaryOperator::Not(TerminalNot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMul => {
                Some(BinaryOperator::Mul(TerminalMul::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMulEq => {
                Some(BinaryOperator::MulEq(TerminalMulEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDiv => {
                Some(BinaryOperator::Div(TerminalDiv::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDivEq => {
                Some(BinaryOperator::DivEq(TerminalDivEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMod => {
                Some(BinaryOperator::Mod(TerminalMod::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalModEq => {
                Some(BinaryOperator::ModEq(TerminalModEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalPlus => {
                Some(BinaryOperator::Plus(TerminalPlus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalPlusEq => {
                Some(BinaryOperator::PlusEq(TerminalPlusEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMinus => {
                Some(BinaryOperator::Minus(TerminalMinus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMinusEq => {
                Some(BinaryOperator::MinusEq(TerminalMinusEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEqEq => {
                Some(BinaryOperator::EqEq(TerminalEqEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalNeq => {
                Some(BinaryOperator::Neq(TerminalNeq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEq => {
                Some(BinaryOperator::Eq(TerminalEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAnd => {
                Some(BinaryOperator::And(TerminalAnd::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAndAnd => {
                Some(BinaryOperator::AndAnd(TerminalAndAnd::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalOr => {
                Some(BinaryOperator::Or(TerminalOr::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalOrOr => {
                Some(BinaryOperator::OrOr(TerminalOrOr::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalXor => {
                Some(BinaryOperator::Xor(TerminalXor::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLE => {
                Some(BinaryOperator::LE(TerminalLE::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalGE => {
                Some(BinaryOperator::GE(TerminalGE::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLT => {
                Some(BinaryOperator::LT(TerminalLT::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalGT => {
                Some(BinaryOperator::GT(TerminalGT::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDotDot => {
                Some(BinaryOperator::DotDot(TerminalDotDot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDotDotEq => {
                Some(BinaryOperator::DotDotEq(TerminalDotDotEq::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            BinaryOperator::Dot(x) => x.as_syntax_node(),
            BinaryOperator::Not(x) => x.as_syntax_node(),
            BinaryOperator::Mul(x) => x.as_syntax_node(),
            BinaryOperator::MulEq(x) => x.as_syntax_node(),
            BinaryOperator::Div(x) => x.as_syntax_node(),
            BinaryOperator::DivEq(x) => x.as_syntax_node(),
            BinaryOperator::Mod(x) => x.as_syntax_node(),
            BinaryOperator::ModEq(x) => x.as_syntax_node(),
            BinaryOperator::Plus(x) => x.as_syntax_node(),
            BinaryOperator::PlusEq(x) => x.as_syntax_node(),
            BinaryOperator::Minus(x) => x.as_syntax_node(),
            BinaryOperator::MinusEq(x) => x.as_syntax_node(),
            BinaryOperator::EqEq(x) => x.as_syntax_node(),
            BinaryOperator::Neq(x) => x.as_syntax_node(),
            BinaryOperator::Eq(x) => x.as_syntax_node(),
            BinaryOperator::And(x) => x.as_syntax_node(),
            BinaryOperator::AndAnd(x) => x.as_syntax_node(),
            BinaryOperator::Or(x) => x.as_syntax_node(),
            BinaryOperator::OrOr(x) => x.as_syntax_node(),
            BinaryOperator::Xor(x) => x.as_syntax_node(),
            BinaryOperator::LE(x) => x.as_syntax_node(),
            BinaryOperator::GE(x) => x.as_syntax_node(),
            BinaryOperator::LT(x) => x.as_syntax_node(),
            BinaryOperator::GT(x) => x.as_syntax_node(),
            BinaryOperator::DotDot(x) => x.as_syntax_node(),
            BinaryOperator::DotDotEq(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        BinaryOperatorPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&BinaryOperator> for SyntaxStablePtrId {
    fn from(node: &BinaryOperator) -> Self {
        node.stable_ptr().untyped()
    }
}
impl BinaryOperator {
    /// Checks if a kind of a variant of [BinaryOperator].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TerminalDot
                | SyntaxKind::TerminalNot
                | SyntaxKind::TerminalMul
                | SyntaxKind::TerminalMulEq
                | SyntaxKind::TerminalDiv
                | SyntaxKind::TerminalDivEq
                | SyntaxKind::TerminalMod
                | SyntaxKind::TerminalModEq
                | SyntaxKind::TerminalPlus
                | SyntaxKind::TerminalPlusEq
                | SyntaxKind::TerminalMinus
                | SyntaxKind::TerminalMinusEq
                | SyntaxKind::TerminalEqEq
                | SyntaxKind::TerminalNeq
                | SyntaxKind::TerminalEq
                | SyntaxKind::TerminalAnd
                | SyntaxKind::TerminalAndAnd
                | SyntaxKind::TerminalOr
                | SyntaxKind::TerminalOrOr
                | SyntaxKind::TerminalXor
                | SyntaxKind::TerminalLE
                | SyntaxKind::TerminalGE
                | SyntaxKind::TerminalLT
                | SyntaxKind::TerminalGT
                | SyntaxKind::TerminalDotDot
                | SyntaxKind::TerminalDotDotEq
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprListParenthesized {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprListParenthesized {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_EXPRESSIONS: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        expressions: ExprListGreen,
        rparen: TerminalRParenGreen,
    ) -> ExprListParenthesizedGreen {
        let children: Vec<GreenId> = vec![lparen.0, expressions.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprListParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprListParenthesized,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprListParenthesized {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expressions(&self, db: &dyn SyntaxGroup) -> ExprList {
        ExprList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListParenthesizedPtr(pub SyntaxStablePtrId);
impl ExprListParenthesizedPtr {}
impl TypedStablePtr for ExprListParenthesizedPtr {
    type SyntaxNode = ExprListParenthesized;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprListParenthesized {
        ExprListParenthesized::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprListParenthesizedPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprListParenthesizedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprListParenthesizedGreen(pub GreenId);
impl TypedSyntaxNode for ExprListParenthesized {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprListParenthesized);
    type StablePtr = ExprListParenthesizedPtr;
    type Green = ExprListParenthesizedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprListParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprListParenthesized,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        ExprList::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprListParenthesized,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprListParenthesized
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprListParenthesized {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprListParenthesizedPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprListParenthesized> for SyntaxStablePtrId {
    fn from(node: &ExprListParenthesized) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprFunctionCall {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprFunctionCall {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        arguments: ArgListParenthesizedGreen,
    ) -> ExprFunctionCallGreen {
        let children: Vec<GreenId> = vec![path.0, arguments.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprFunctionCallGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFunctionCall,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprFunctionCall {
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> ArgListParenthesized {
        ArgListParenthesized::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprFunctionCallPtr(pub SyntaxStablePtrId);
impl ExprFunctionCallPtr {}
impl TypedStablePtr for ExprFunctionCallPtr {
    type SyntaxNode = ExprFunctionCall;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprFunctionCall {
        ExprFunctionCall::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprFunctionCallPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprFunctionCallPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprFunctionCallGreen(pub GreenId);
impl TypedSyntaxNode for ExprFunctionCall {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprFunctionCall);
    type StablePtr = ExprFunctionCallPtr;
    type Green = ExprFunctionCallGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprFunctionCallGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFunctionCall,
                details: GreenNodeDetails::Node {
                    children: vec![ExprPath::missing(db).0, ArgListParenthesized::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprFunctionCall,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprFunctionCall
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprFunctionCall {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprFunctionCallPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprFunctionCall> for SyntaxStablePtrId {
    fn from(node: &ExprFunctionCall) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgListParenthesized {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ArgListParenthesized {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        arguments: ArgListGreen,
        rparen: TerminalRParenGreen,
    ) -> ArgListParenthesizedGreen {
        let children: Vec<GreenId> = vec![lparen.0, arguments.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgListParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListParenthesized,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ArgListParenthesized {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> ArgList {
        ArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListParenthesizedPtr(pub SyntaxStablePtrId);
impl ArgListParenthesizedPtr {}
impl TypedStablePtr for ArgListParenthesizedPtr {
    type SyntaxNode = ArgListParenthesized;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ArgListParenthesized {
        ArgListParenthesized::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ArgListParenthesizedPtr> for SyntaxStablePtrId {
    fn from(ptr: ArgListParenthesizedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListParenthesizedGreen(pub GreenId);
impl TypedSyntaxNode for ArgListParenthesized {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgListParenthesized);
    type StablePtr = ArgListParenthesizedPtr;
    type Green = ArgListParenthesizedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ArgListParenthesizedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListParenthesized,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        ArgList::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgListParenthesized,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgListParenthesized
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgListParenthesized {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgListParenthesizedPtr(self.node.0.stable_ptr)
    }
}
impl From<&ArgListParenthesized> for SyntaxStablePtrId {
    fn from(node: &ArgListParenthesized) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionArgListParenthesized {
    Empty(OptionArgListParenthesizedEmpty),
    ArgListParenthesized(ArgListParenthesized),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionArgListParenthesizedPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionArgListParenthesizedPtr {
    type SyntaxNode = OptionArgListParenthesized;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionArgListParenthesized {
        OptionArgListParenthesized::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionArgListParenthesizedPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionArgListParenthesizedPtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionArgListParenthesizedEmptyPtr> for OptionArgListParenthesizedPtr {
    fn from(value: OptionArgListParenthesizedEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<ArgListParenthesizedPtr> for OptionArgListParenthesizedPtr {
    fn from(value: ArgListParenthesizedPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionArgListParenthesizedEmptyGreen> for OptionArgListParenthesizedGreen {
    fn from(value: OptionArgListParenthesizedEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ArgListParenthesizedGreen> for OptionArgListParenthesizedGreen {
    fn from(value: ArgListParenthesizedGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionArgListParenthesizedGreen(pub GreenId);
impl TypedSyntaxNode for OptionArgListParenthesized {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionArgListParenthesizedPtr;
    type Green = OptionArgListParenthesizedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionArgListParenthesizedEmpty => OptionArgListParenthesized::Empty(
                OptionArgListParenthesizedEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::ArgListParenthesized => OptionArgListParenthesized::ArgListParenthesized(
                ArgListParenthesized::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionArgListParenthesized"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionArgListParenthesizedEmpty => Some(OptionArgListParenthesized::Empty(
                OptionArgListParenthesizedEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::ArgListParenthesized => {
                Some(OptionArgListParenthesized::ArgListParenthesized(
                    ArgListParenthesized::from_syntax_node(db, node),
                ))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionArgListParenthesized::Empty(x) => x.as_syntax_node(),
            OptionArgListParenthesized::ArgListParenthesized(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionArgListParenthesizedPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionArgListParenthesized> for SyntaxStablePtrId {
    fn from(node: &OptionArgListParenthesized) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionArgListParenthesized {
    /// Checks if a kind of a variant of [OptionArgListParenthesized].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::OptionArgListParenthesizedEmpty | SyntaxKind::ArgListParenthesized
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionArgListParenthesizedEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionArgListParenthesizedEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionArgListParenthesizedEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionArgListParenthesizedEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionArgListParenthesizedEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionArgListParenthesizedEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionArgListParenthesizedEmptyPtr(pub SyntaxStablePtrId);
impl OptionArgListParenthesizedEmptyPtr {}
impl TypedStablePtr for OptionArgListParenthesizedEmptyPtr {
    type SyntaxNode = OptionArgListParenthesizedEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionArgListParenthesizedEmpty {
        OptionArgListParenthesizedEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionArgListParenthesizedEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionArgListParenthesizedEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionArgListParenthesizedEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionArgListParenthesizedEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionArgListParenthesizedEmpty);
    type StablePtr = OptionArgListParenthesizedEmptyPtr;
    type Green = OptionArgListParenthesizedEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionArgListParenthesizedEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionArgListParenthesizedEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionArgListParenthesizedEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionArgListParenthesizedEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionArgListParenthesizedEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionArgListParenthesizedEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionArgListParenthesizedEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionArgListParenthesizedEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprStructCtorCall {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprStructCtorCall {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        arguments: StructArgListBracedGreen,
    ) -> ExprStructCtorCallGreen {
        let children: Vec<GreenId> = vec![path.0, arguments.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprStructCtorCallGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprStructCtorCall,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprStructCtorCall {
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> StructArgListBraced {
        StructArgListBraced::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprStructCtorCallPtr(pub SyntaxStablePtrId);
impl ExprStructCtorCallPtr {}
impl TypedStablePtr for ExprStructCtorCallPtr {
    type SyntaxNode = ExprStructCtorCall;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprStructCtorCall {
        ExprStructCtorCall::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprStructCtorCallPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprStructCtorCallPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprStructCtorCallGreen(pub GreenId);
impl TypedSyntaxNode for ExprStructCtorCall {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprStructCtorCall);
    type StablePtr = ExprStructCtorCallPtr;
    type Green = ExprStructCtorCallGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprStructCtorCallGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprStructCtorCall,
                details: GreenNodeDetails::Node {
                    children: vec![ExprPath::missing(db).0, StructArgListBraced::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprStructCtorCall,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprStructCtorCall
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprStructCtorCall {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprStructCtorCallPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprStructCtorCall> for SyntaxStablePtrId {
    fn from(node: &ExprStructCtorCall) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgListBraced {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StructArgListBraced {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        arguments: StructArgListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> StructArgListBracedGreen {
        let children: Vec<GreenId> = vec![lbrace.0, arguments.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StructArgListBracedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgListBraced,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StructArgListBraced {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> StructArgList {
        StructArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgListBracedPtr(pub SyntaxStablePtrId);
impl StructArgListBracedPtr {}
impl TypedStablePtr for StructArgListBracedPtr {
    type SyntaxNode = StructArgListBraced;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StructArgListBraced {
        StructArgListBraced::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StructArgListBracedPtr> for SyntaxStablePtrId {
    fn from(ptr: StructArgListBracedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgListBracedGreen(pub GreenId);
impl TypedSyntaxNode for StructArgListBraced {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgListBraced);
    type StablePtr = StructArgListBracedPtr;
    type Green = StructArgListBracedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgListBracedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgListBraced,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        StructArgList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgListBraced,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgListBraced
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StructArgListBraced {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgListBracedPtr(self.node.0.stable_ptr)
    }
}
impl From<&StructArgListBraced> for SyntaxStablePtrId {
    fn from(node: &StructArgListBraced) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprBlock {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprBlock {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_STATEMENTS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        statements: StatementListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ExprBlockGreen {
        let children: Vec<GreenId> = vec![lbrace.0, statements.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprBlockGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprBlock,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprBlock {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn statements(&self, db: &dyn SyntaxGroup) -> StatementList {
        StatementList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBlockPtr(pub SyntaxStablePtrId);
impl ExprBlockPtr {}
impl TypedStablePtr for ExprBlockPtr {
    type SyntaxNode = ExprBlock;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprBlockPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprBlockPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprBlockGreen(pub GreenId);
impl TypedSyntaxNode for ExprBlock {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprBlock);
    type StablePtr = ExprBlockPtr;
    type Green = ExprBlockGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprBlockGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprBlock,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        StatementList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprBlock,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprBlock
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprBlock { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprBlockPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprBlock> for SyntaxStablePtrId {
    fn from(node: &ExprBlock) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprMatch {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprMatch {
    pub const INDEX_MATCH_KW: usize = 0;
    pub const INDEX_EXPR: usize = 1;
    pub const INDEX_LBRACE: usize = 2;
    pub const INDEX_ARMS: usize = 3;
    pub const INDEX_RBRACE: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        match_kw: TerminalMatchGreen,
        expr: ExprGreen,
        lbrace: TerminalLBraceGreen,
        arms: MatchArmsGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ExprMatchGreen {
        let children: Vec<GreenId> = vec![match_kw.0, expr.0, lbrace.0, arms.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprMatch,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprMatch {
    pub fn match_kw(&self, db: &dyn SyntaxGroup) -> TerminalMatch {
        TerminalMatch::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[2].clone())
    }
    pub fn arms(&self, db: &dyn SyntaxGroup) -> MatchArms {
        MatchArms::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMatchPtr(pub SyntaxStablePtrId);
impl ExprMatchPtr {}
impl TypedStablePtr for ExprMatchPtr {
    type SyntaxNode = ExprMatch;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprMatch {
        ExprMatch::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprMatchPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprMatchPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprMatchGreen(pub GreenId);
impl TypedSyntaxNode for ExprMatch {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprMatch);
    type StablePtr = ExprMatchPtr;
    type Green = ExprMatchGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprMatch,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalMatch::missing(db).0,
                        Expr::missing(db).0,
                        TerminalLBrace::missing(db).0,
                        MatchArms::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprMatch,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprMatch
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprMatch { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprMatchPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprMatch> for SyntaxStablePtrId {
    fn from(node: &ExprMatch) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MatchArms(ElementList<MatchArm, 2>);
impl Deref for MatchArms {
    type Target = ElementList<MatchArm, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl MatchArms {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<MatchArmsElementOrSeparatorGreen>,
    ) -> MatchArmsGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        MatchArmsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MatchArms,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmsPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for MatchArmsPtr {
    type SyntaxNode = MatchArms;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> MatchArms {
        MatchArms::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<MatchArmsPtr> for SyntaxStablePtrId {
    fn from(ptr: MatchArmsPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum MatchArmsElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(MatchArmGreen),
}
impl From<TerminalCommaGreen> for MatchArmsElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        MatchArmsElementOrSeparatorGreen::Separator(value)
    }
}
impl From<MatchArmGreen> for MatchArmsElementOrSeparatorGreen {
    fn from(value: MatchArmGreen) -> Self {
        MatchArmsElementOrSeparatorGreen::Element(value)
    }
}
impl MatchArmsElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            MatchArmsElementOrSeparatorGreen::Separator(green) => green.0,
            MatchArmsElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmsGreen(pub GreenId);
impl TypedSyntaxNode for MatchArms {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MatchArms);
    type StablePtr = MatchArmsPtr;
    type Green = MatchArmsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        MatchArmsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MatchArms,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::MatchArms {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MatchArmsPtr(self.node.0.stable_ptr)
    }
}
impl From<&MatchArms> for SyntaxStablePtrId {
    fn from(node: &MatchArms) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MatchArm {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl MatchArm {
    pub const INDEX_PATTERNS: usize = 0;
    pub const INDEX_ARROW: usize = 1;
    pub const INDEX_EXPRESSION: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        patterns: PatternListOrGreen,
        arrow: TerminalMatchArrowGreen,
        expression: ExprGreen,
    ) -> MatchArmGreen {
        let children: Vec<GreenId> = vec![patterns.0, arrow.0, expression.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        MatchArmGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MatchArm,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl MatchArm {
    pub fn patterns(&self, db: &dyn SyntaxGroup) -> PatternListOr {
        PatternListOr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arrow(&self, db: &dyn SyntaxGroup) -> TerminalMatchArrow {
        TerminalMatchArrow::from_syntax_node(db, self.children[1].clone())
    }
    pub fn expression(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmPtr(pub SyntaxStablePtrId);
impl MatchArmPtr {}
impl TypedStablePtr for MatchArmPtr {
    type SyntaxNode = MatchArm;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> MatchArm {
        MatchArm::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<MatchArmPtr> for SyntaxStablePtrId {
    fn from(ptr: MatchArmPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MatchArmGreen(pub GreenId);
impl TypedSyntaxNode for MatchArm {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MatchArm);
    type StablePtr = MatchArmPtr;
    type Green = MatchArmGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        MatchArmGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MatchArm,
                details: GreenNodeDetails::Node {
                    children: vec![
                        PatternListOr::missing(db).0,
                        TerminalMatchArrow::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::MatchArm,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::MatchArm
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::MatchArm { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MatchArmPtr(self.node.0.stable_ptr)
    }
}
impl From<&MatchArm> for SyntaxStablePtrId {
    fn from(node: &MatchArm) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprIf {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprIf {
    pub const INDEX_IF_KW: usize = 0;
    pub const INDEX_CONDITION: usize = 1;
    pub const INDEX_IF_BLOCK: usize = 2;
    pub const INDEX_ELSE_CLAUSE: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        if_kw: TerminalIfGreen,
        condition: ConditionGreen,
        if_block: ExprBlockGreen,
        else_clause: OptionElseClauseGreen,
    ) -> ExprIfGreen {
        let children: Vec<GreenId> = vec![if_kw.0, condition.0, if_block.0, else_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprIf,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprIf {
    pub fn if_kw(&self, db: &dyn SyntaxGroup) -> TerminalIf {
        TerminalIf::from_syntax_node(db, self.children[0].clone())
    }
    pub fn condition(&self, db: &dyn SyntaxGroup) -> Condition {
        Condition::from_syntax_node(db, self.children[1].clone())
    }
    pub fn if_block(&self, db: &dyn SyntaxGroup) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[2].clone())
    }
    pub fn else_clause(&self, db: &dyn SyntaxGroup) -> OptionElseClause {
        OptionElseClause::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprIfPtr(pub SyntaxStablePtrId);
impl ExprIfPtr {}
impl TypedStablePtr for ExprIfPtr {
    type SyntaxNode = ExprIf;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprIf {
        ExprIf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprIfPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprIfPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprIfGreen(pub GreenId);
impl TypedSyntaxNode for ExprIf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprIf);
    type StablePtr = ExprIfPtr;
    type Green = ExprIfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprIf,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIf::missing(db).0,
                        Condition::missing(db).0,
                        ExprBlock::missing(db).0,
                        OptionElseClause::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprIf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprIf
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprIf { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprIfPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprIf> for SyntaxStablePtrId {
    fn from(node: &ExprIf) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Condition {
    Let(ConditionLet),
    Expr(ConditionExpr),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ConditionPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ConditionPtr {
    type SyntaxNode = Condition;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Condition {
        Condition::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ConditionPtr> for SyntaxStablePtrId {
    fn from(ptr: ConditionPtr) -> Self {
        ptr.untyped()
    }
}
impl From<ConditionLetPtr> for ConditionPtr {
    fn from(value: ConditionLetPtr) -> Self {
        Self(value.0)
    }
}
impl From<ConditionExprPtr> for ConditionPtr {
    fn from(value: ConditionExprPtr) -> Self {
        Self(value.0)
    }
}
impl From<ConditionLetGreen> for ConditionGreen {
    fn from(value: ConditionLetGreen) -> Self {
        Self(value.0)
    }
}
impl From<ConditionExprGreen> for ConditionGreen {
    fn from(value: ConditionExprGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ConditionGreen(pub GreenId);
impl TypedSyntaxNode for Condition {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ConditionPtr;
    type Green = ConditionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ConditionLet => Condition::Let(ConditionLet::from_syntax_node(db, node)),
            SyntaxKind::ConditionExpr => Condition::Expr(ConditionExpr::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Condition"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ConditionLet => {
                Some(Condition::Let(ConditionLet::from_syntax_node(db, node)))
            }
            SyntaxKind::ConditionExpr => {
                Some(Condition::Expr(ConditionExpr::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Condition::Let(x) => x.as_syntax_node(),
            Condition::Expr(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ConditionPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&Condition> for SyntaxStablePtrId {
    fn from(node: &Condition) -> Self {
        node.stable_ptr().untyped()
    }
}
impl Condition {
    /// Checks if a kind of a variant of [Condition].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::ConditionLet | SyntaxKind::ConditionExpr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ConditionLet {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ConditionLet {
    pub const INDEX_LET_KW: usize = 0;
    pub const INDEX_PATTERNS: usize = 1;
    pub const INDEX_EQ: usize = 2;
    pub const INDEX_EXPR: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        let_kw: TerminalLetGreen,
        patterns: PatternListOrGreen,
        eq: TerminalEqGreen,
        expr: ExprGreen,
    ) -> ConditionLetGreen {
        let children: Vec<GreenId> = vec![let_kw.0, patterns.0, eq.0, expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ConditionLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ConditionLet,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ConditionLet {
    pub fn let_kw(&self, db: &dyn SyntaxGroup) -> TerminalLet {
        TerminalLet::from_syntax_node(db, self.children[0].clone())
    }
    pub fn patterns(&self, db: &dyn SyntaxGroup) -> PatternListOr {
        PatternListOr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn eq(&self, db: &dyn SyntaxGroup) -> TerminalEq {
        TerminalEq::from_syntax_node(db, self.children[2].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ConditionLetPtr(pub SyntaxStablePtrId);
impl ConditionLetPtr {}
impl TypedStablePtr for ConditionLetPtr {
    type SyntaxNode = ConditionLet;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ConditionLet {
        ConditionLet::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ConditionLetPtr> for SyntaxStablePtrId {
    fn from(ptr: ConditionLetPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ConditionLetGreen(pub GreenId);
impl TypedSyntaxNode for ConditionLet {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ConditionLet);
    type StablePtr = ConditionLetPtr;
    type Green = ConditionLetGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ConditionLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ConditionLet,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLet::missing(db).0,
                        PatternListOr::missing(db).0,
                        TerminalEq::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ConditionLet,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ConditionLet
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ConditionLet { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ConditionLetPtr(self.node.0.stable_ptr)
    }
}
impl From<&ConditionLet> for SyntaxStablePtrId {
    fn from(node: &ConditionLet) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ConditionExpr {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ConditionExpr {
    pub const INDEX_EXPR: usize = 0;
    pub fn new_green(db: &dyn SyntaxGroup, expr: ExprGreen) -> ConditionExprGreen {
        let children: Vec<GreenId> = vec![expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ConditionExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ConditionExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ConditionExpr {
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ConditionExprPtr(pub SyntaxStablePtrId);
impl ConditionExprPtr {}
impl TypedStablePtr for ConditionExprPtr {
    type SyntaxNode = ConditionExpr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ConditionExpr {
        ConditionExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ConditionExprPtr> for SyntaxStablePtrId {
    fn from(ptr: ConditionExprPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ConditionExprGreen(pub GreenId);
impl TypedSyntaxNode for ConditionExpr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ConditionExpr);
    type StablePtr = ConditionExprPtr;
    type Green = ConditionExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ConditionExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ConditionExpr,
                details: GreenNodeDetails::Node {
                    children: vec![Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ConditionExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ConditionExpr
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ConditionExpr {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ConditionExprPtr(self.node.0.stable_ptr)
    }
}
impl From<&ConditionExpr> for SyntaxStablePtrId {
    fn from(node: &ConditionExpr) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum BlockOrIf {
    Block(ExprBlock),
    If(ExprIf),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct BlockOrIfPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for BlockOrIfPtr {
    type SyntaxNode = BlockOrIf;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> BlockOrIf {
        BlockOrIf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<BlockOrIfPtr> for SyntaxStablePtrId {
    fn from(ptr: BlockOrIfPtr) -> Self {
        ptr.untyped()
    }
}
impl From<ExprBlockPtr> for BlockOrIfPtr {
    fn from(value: ExprBlockPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprIfPtr> for BlockOrIfPtr {
    fn from(value: ExprIfPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprBlockGreen> for BlockOrIfGreen {
    fn from(value: ExprBlockGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprIfGreen> for BlockOrIfGreen {
    fn from(value: ExprIfGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct BlockOrIfGreen(pub GreenId);
impl TypedSyntaxNode for BlockOrIf {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = BlockOrIfPtr;
    type Green = BlockOrIfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprBlock => BlockOrIf::Block(ExprBlock::from_syntax_node(db, node)),
            SyntaxKind::ExprIf => BlockOrIf::If(ExprIf::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "BlockOrIf"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprBlock => Some(BlockOrIf::Block(ExprBlock::from_syntax_node(db, node))),
            SyntaxKind::ExprIf => Some(BlockOrIf::If(ExprIf::from_syntax_node(db, node))),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            BlockOrIf::Block(x) => x.as_syntax_node(),
            BlockOrIf::If(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        BlockOrIfPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&BlockOrIf> for SyntaxStablePtrId {
    fn from(node: &BlockOrIf) -> Self {
        node.stable_ptr().untyped()
    }
}
impl BlockOrIf {
    /// Checks if a kind of a variant of [BlockOrIf].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::ExprBlock | SyntaxKind::ExprIf)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprLoop {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprLoop {
    pub const INDEX_LOOP_KW: usize = 0;
    pub const INDEX_BODY: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        loop_kw: TerminalLoopGreen,
        body: ExprBlockGreen,
    ) -> ExprLoopGreen {
        let children: Vec<GreenId> = vec![loop_kw.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprLoop,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprLoop {
    pub fn loop_kw(&self, db: &dyn SyntaxGroup) -> TerminalLoop {
        TerminalLoop::from_syntax_node(db, self.children[0].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprLoopPtr(pub SyntaxStablePtrId);
impl ExprLoopPtr {}
impl TypedStablePtr for ExprLoopPtr {
    type SyntaxNode = ExprLoop;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprLoop {
        ExprLoop::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprLoopPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprLoopPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprLoopGreen(pub GreenId);
impl TypedSyntaxNode for ExprLoop {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprLoop);
    type StablePtr = ExprLoopPtr;
    type Green = ExprLoopGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprLoop,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalLoop::missing(db).0, ExprBlock::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprLoop,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprLoop
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprLoop { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprLoopPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprLoop> for SyntaxStablePtrId {
    fn from(node: &ExprLoop) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprWhile {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprWhile {
    pub const INDEX_WHILE_KW: usize = 0;
    pub const INDEX_CONDITION: usize = 1;
    pub const INDEX_BODY: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        while_kw: TerminalWhileGreen,
        condition: ConditionGreen,
        body: ExprBlockGreen,
    ) -> ExprWhileGreen {
        let children: Vec<GreenId> = vec![while_kw.0, condition.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprWhile,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprWhile {
    pub fn while_kw(&self, db: &dyn SyntaxGroup) -> TerminalWhile {
        TerminalWhile::from_syntax_node(db, self.children[0].clone())
    }
    pub fn condition(&self, db: &dyn SyntaxGroup) -> Condition {
        Condition::from_syntax_node(db, self.children[1].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprWhilePtr(pub SyntaxStablePtrId);
impl ExprWhilePtr {}
impl TypedStablePtr for ExprWhilePtr {
    type SyntaxNode = ExprWhile;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprWhile {
        ExprWhile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprWhilePtr> for SyntaxStablePtrId {
    fn from(ptr: ExprWhilePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprWhileGreen(pub GreenId);
impl TypedSyntaxNode for ExprWhile {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprWhile);
    type StablePtr = ExprWhilePtr;
    type Green = ExprWhileGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprWhile,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalWhile::missing(db).0,
                        Condition::missing(db).0,
                        ExprBlock::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprWhile,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprWhile
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprWhile { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprWhilePtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprWhile> for SyntaxStablePtrId {
    fn from(node: &ExprWhile) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprFor {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprFor {
    pub const INDEX_FOR_KW: usize = 0;
    pub const INDEX_PATTERN: usize = 1;
    pub const INDEX_IDENTIFIER: usize = 2;
    pub const INDEX_EXPR: usize = 3;
    pub const INDEX_BODY: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        for_kw: TerminalForGreen,
        pattern: PatternGreen,
        identifier: TerminalIdentifierGreen,
        expr: ExprGreen,
        body: ExprBlockGreen,
    ) -> ExprForGreen {
        let children: Vec<GreenId> = vec![for_kw.0, pattern.0, identifier.0, expr.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFor,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprFor {
    pub fn for_kw(&self, db: &dyn SyntaxGroup) -> TerminalFor {
        TerminalFor::from_syntax_node(db, self.children[0].clone())
    }
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.children[1].clone())
    }
    pub fn identifier(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[3].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprForPtr(pub SyntaxStablePtrId);
impl ExprForPtr {
    pub fn pattern_green(self, db: &dyn SyntaxGroup) -> PatternGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            PatternGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn identifier_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[1])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ExprForPtr {
    type SyntaxNode = ExprFor;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprFor {
        ExprFor::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprForPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprForPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprForGreen(pub GreenId);
impl TypedSyntaxNode for ExprFor {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprFor);
    type StablePtr = ExprForPtr;
    type Green = ExprForGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFor,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalFor::missing(db).0,
                        Pattern::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        Expr::missing(db).0,
                        ExprBlock::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprFor,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprFor
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprFor { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprForPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprFor> for SyntaxStablePtrId {
    fn from(node: &ExprFor) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ElseClause {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ElseClause {
    pub const INDEX_ELSE_KW: usize = 0;
    pub const INDEX_ELSE_BLOCK_OR_IF: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        else_kw: TerminalElseGreen,
        else_block_or_if: BlockOrIfGreen,
    ) -> ElseClauseGreen {
        let children: Vec<GreenId> = vec![else_kw.0, else_block_or_if.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ElseClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ElseClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ElseClause {
    pub fn else_kw(&self, db: &dyn SyntaxGroup) -> TerminalElse {
        TerminalElse::from_syntax_node(db, self.children[0].clone())
    }
    pub fn else_block_or_if(&self, db: &dyn SyntaxGroup) -> BlockOrIf {
        BlockOrIf::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ElseClausePtr(pub SyntaxStablePtrId);
impl ElseClausePtr {}
impl TypedStablePtr for ElseClausePtr {
    type SyntaxNode = ElseClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ElseClause {
        ElseClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ElseClausePtr> for SyntaxStablePtrId {
    fn from(ptr: ElseClausePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ElseClauseGreen(pub GreenId);
impl TypedSyntaxNode for ElseClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ElseClause);
    type StablePtr = ElseClausePtr;
    type Green = ElseClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ElseClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ElseClause,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalElse::missing(db).0, BlockOrIf::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ElseClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ElseClause
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ElseClause { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ElseClausePtr(self.node.0.stable_ptr)
    }
}
impl From<&ElseClause> for SyntaxStablePtrId {
    fn from(node: &ElseClause) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionElseClause {
    Empty(OptionElseClauseEmpty),
    ElseClause(ElseClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionElseClausePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionElseClausePtr {
    type SyntaxNode = OptionElseClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionElseClause {
        OptionElseClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionElseClausePtr> for SyntaxStablePtrId {
    fn from(ptr: OptionElseClausePtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionElseClauseEmptyPtr> for OptionElseClausePtr {
    fn from(value: OptionElseClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<ElseClausePtr> for OptionElseClausePtr {
    fn from(value: ElseClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionElseClauseEmptyGreen> for OptionElseClauseGreen {
    fn from(value: OptionElseClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ElseClauseGreen> for OptionElseClauseGreen {
    fn from(value: ElseClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionElseClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionElseClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionElseClausePtr;
    type Green = OptionElseClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionElseClauseEmpty => {
                OptionElseClause::Empty(OptionElseClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::ElseClause => {
                OptionElseClause::ElseClause(ElseClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionElseClause"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionElseClauseEmpty => {
                Some(OptionElseClause::Empty(OptionElseClauseEmpty::from_syntax_node(db, node)))
            }
            SyntaxKind::ElseClause => {
                Some(OptionElseClause::ElseClause(ElseClause::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionElseClause::Empty(x) => x.as_syntax_node(),
            OptionElseClause::ElseClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionElseClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionElseClause> for SyntaxStablePtrId {
    fn from(node: &OptionElseClause) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionElseClause {
    /// Checks if a kind of a variant of [OptionElseClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionElseClauseEmpty | SyntaxKind::ElseClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionElseClauseEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionElseClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionElseClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionElseClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionElseClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionElseClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionElseClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionElseClauseEmptyPtr {}
impl TypedStablePtr for OptionElseClauseEmptyPtr {
    type SyntaxNode = OptionElseClauseEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionElseClauseEmpty {
        OptionElseClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionElseClauseEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionElseClauseEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionElseClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionElseClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionElseClauseEmpty);
    type StablePtr = OptionElseClauseEmptyPtr;
    type Green = OptionElseClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionElseClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionElseClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionElseClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionElseClauseEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionElseClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionElseClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionElseClauseEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionElseClauseEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprErrorPropagate {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprErrorPropagate {
    pub const INDEX_EXPR: usize = 0;
    pub const INDEX_OP: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        expr: ExprGreen,
        op: TerminalQuestionMarkGreen,
    ) -> ExprErrorPropagateGreen {
        let children: Vec<GreenId> = vec![expr.0, op.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprErrorPropagateGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprErrorPropagate,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprErrorPropagate {
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn op(&self, db: &dyn SyntaxGroup) -> TerminalQuestionMark {
        TerminalQuestionMark::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprErrorPropagatePtr(pub SyntaxStablePtrId);
impl ExprErrorPropagatePtr {}
impl TypedStablePtr for ExprErrorPropagatePtr {
    type SyntaxNode = ExprErrorPropagate;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprErrorPropagate {
        ExprErrorPropagate::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprErrorPropagatePtr> for SyntaxStablePtrId {
    fn from(ptr: ExprErrorPropagatePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprErrorPropagateGreen(pub GreenId);
impl TypedSyntaxNode for ExprErrorPropagate {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprErrorPropagate);
    type StablePtr = ExprErrorPropagatePtr;
    type Green = ExprErrorPropagateGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprErrorPropagateGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprErrorPropagate,
                details: GreenNodeDetails::Node {
                    children: vec![Expr::missing(db).0, TerminalQuestionMark::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprErrorPropagate,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprErrorPropagate
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprErrorPropagate {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprErrorPropagatePtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprErrorPropagate> for SyntaxStablePtrId {
    fn from(node: &ExprErrorPropagate) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprIndexed {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprIndexed {
    pub const INDEX_EXPR: usize = 0;
    pub const INDEX_LBRACK: usize = 1;
    pub const INDEX_INDEX_EXPR: usize = 2;
    pub const INDEX_RBRACK: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        expr: ExprGreen,
        lbrack: TerminalLBrackGreen,
        index_expr: ExprGreen,
        rbrack: TerminalRBrackGreen,
    ) -> ExprIndexedGreen {
        let children: Vec<GreenId> = vec![expr.0, lbrack.0, index_expr.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprIndexedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprIndexed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprIndexed {
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lbrack(&self, db: &dyn SyntaxGroup) -> TerminalLBrack {
        TerminalLBrack::from_syntax_node(db, self.children[1].clone())
    }
    pub fn index_expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
    pub fn rbrack(&self, db: &dyn SyntaxGroup) -> TerminalRBrack {
        TerminalRBrack::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprIndexedPtr(pub SyntaxStablePtrId);
impl ExprIndexedPtr {}
impl TypedStablePtr for ExprIndexedPtr {
    type SyntaxNode = ExprIndexed;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprIndexed {
        ExprIndexed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprIndexedPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprIndexedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprIndexedGreen(pub GreenId);
impl TypedSyntaxNode for ExprIndexed {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprIndexed);
    type StablePtr = ExprIndexedPtr;
    type Green = ExprIndexedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprIndexedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprIndexed,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Expr::missing(db).0,
                        TerminalLBrack::missing(db).0,
                        Expr::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprIndexed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprIndexed
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprIndexed { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprIndexedPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprIndexed> for SyntaxStablePtrId {
    fn from(node: &ExprIndexed) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprInlineMacro {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprInlineMacro {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_BANG: usize = 1;
    pub const INDEX_ARGUMENTS: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        bang: TerminalNotGreen,
        arguments: WrappedArgListGreen,
    ) -> ExprInlineMacroGreen {
        let children: Vec<GreenId> = vec![path.0, bang.0, arguments.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprInlineMacro,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprInlineMacro {
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn bang(&self, db: &dyn SyntaxGroup) -> TerminalNot {
        TerminalNot::from_syntax_node(db, self.children[1].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> WrappedArgList {
        WrappedArgList::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprInlineMacroPtr(pub SyntaxStablePtrId);
impl ExprInlineMacroPtr {}
impl TypedStablePtr for ExprInlineMacroPtr {
    type SyntaxNode = ExprInlineMacro;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprInlineMacro {
        ExprInlineMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprInlineMacroPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprInlineMacroPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprInlineMacroGreen(pub GreenId);
impl TypedSyntaxNode for ExprInlineMacro {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprInlineMacro);
    type StablePtr = ExprInlineMacroPtr;
    type Green = ExprInlineMacroGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprInlineMacro,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ExprPath::missing(db).0,
                        TerminalNot::missing(db).0,
                        WrappedArgList::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprInlineMacro,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprInlineMacro
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprInlineMacro {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprInlineMacroPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprInlineMacro> for SyntaxStablePtrId {
    fn from(node: &ExprInlineMacro) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprFixedSizeArray {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprFixedSizeArray {
    pub const INDEX_LBRACK: usize = 0;
    pub const INDEX_EXPRS: usize = 1;
    pub const INDEX_SIZE: usize = 2;
    pub const INDEX_RBRACK: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrack: TerminalLBrackGreen,
        exprs: ExprListGreen,
        size: OptionFixedSizeArraySizeGreen,
        rbrack: TerminalRBrackGreen,
    ) -> ExprFixedSizeArrayGreen {
        let children: Vec<GreenId> = vec![lbrack.0, exprs.0, size.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprFixedSizeArrayGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFixedSizeArray,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprFixedSizeArray {
    pub fn lbrack(&self, db: &dyn SyntaxGroup) -> TerminalLBrack {
        TerminalLBrack::from_syntax_node(db, self.children[0].clone())
    }
    pub fn exprs(&self, db: &dyn SyntaxGroup) -> ExprList {
        ExprList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn size(&self, db: &dyn SyntaxGroup) -> OptionFixedSizeArraySize {
        OptionFixedSizeArraySize::from_syntax_node(db, self.children[2].clone())
    }
    pub fn rbrack(&self, db: &dyn SyntaxGroup) -> TerminalRBrack {
        TerminalRBrack::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprFixedSizeArrayPtr(pub SyntaxStablePtrId);
impl ExprFixedSizeArrayPtr {}
impl TypedStablePtr for ExprFixedSizeArrayPtr {
    type SyntaxNode = ExprFixedSizeArray;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprFixedSizeArray {
        ExprFixedSizeArray::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprFixedSizeArrayPtr> for SyntaxStablePtrId {
    fn from(ptr: ExprFixedSizeArrayPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprFixedSizeArrayGreen(pub GreenId);
impl TypedSyntaxNode for ExprFixedSizeArray {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprFixedSizeArray);
    type StablePtr = ExprFixedSizeArrayPtr;
    type Green = ExprFixedSizeArrayGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprFixedSizeArrayGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprFixedSizeArray,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrack::missing(db).0,
                        ExprList::missing(db).0,
                        OptionFixedSizeArraySize::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprFixedSizeArray,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprFixedSizeArray
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprFixedSizeArray {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprFixedSizeArrayPtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprFixedSizeArray> for SyntaxStablePtrId {
    fn from(node: &ExprFixedSizeArray) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct FixedSizeArraySize {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl FixedSizeArraySize {
    pub const INDEX_SEMICOLON: usize = 0;
    pub const INDEX_SIZE: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        semicolon: TerminalSemicolonGreen,
        size: ExprGreen,
    ) -> FixedSizeArraySizeGreen {
        let children: Vec<GreenId> = vec![semicolon.0, size.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        FixedSizeArraySizeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FixedSizeArraySize,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl FixedSizeArraySize {
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[0].clone())
    }
    pub fn size(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FixedSizeArraySizePtr(pub SyntaxStablePtrId);
impl FixedSizeArraySizePtr {}
impl TypedStablePtr for FixedSizeArraySizePtr {
    type SyntaxNode = FixedSizeArraySize;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> FixedSizeArraySize {
        FixedSizeArraySize::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<FixedSizeArraySizePtr> for SyntaxStablePtrId {
    fn from(ptr: FixedSizeArraySizePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FixedSizeArraySizeGreen(pub GreenId);
impl TypedSyntaxNode for FixedSizeArraySize {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::FixedSizeArraySize);
    type StablePtr = FixedSizeArraySizePtr;
    type Green = FixedSizeArraySizeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        FixedSizeArraySizeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FixedSizeArraySize,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalSemicolon::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::FixedSizeArraySize,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::FixedSizeArraySize
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::FixedSizeArraySize {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        FixedSizeArraySizePtr(self.node.0.stable_ptr)
    }
}
impl From<&FixedSizeArraySize> for SyntaxStablePtrId {
    fn from(node: &FixedSizeArraySize) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionFixedSizeArraySize {
    Empty(OptionFixedSizeArraySizeEmpty),
    FixedSizeArraySize(FixedSizeArraySize),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionFixedSizeArraySizePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionFixedSizeArraySizePtr {
    type SyntaxNode = OptionFixedSizeArraySize;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionFixedSizeArraySize {
        OptionFixedSizeArraySize::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionFixedSizeArraySizePtr> for SyntaxStablePtrId {
    fn from(ptr: OptionFixedSizeArraySizePtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionFixedSizeArraySizeEmptyPtr> for OptionFixedSizeArraySizePtr {
    fn from(value: OptionFixedSizeArraySizeEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<FixedSizeArraySizePtr> for OptionFixedSizeArraySizePtr {
    fn from(value: FixedSizeArraySizePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionFixedSizeArraySizeEmptyGreen> for OptionFixedSizeArraySizeGreen {
    fn from(value: OptionFixedSizeArraySizeEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<FixedSizeArraySizeGreen> for OptionFixedSizeArraySizeGreen {
    fn from(value: FixedSizeArraySizeGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionFixedSizeArraySizeGreen(pub GreenId);
impl TypedSyntaxNode for OptionFixedSizeArraySize {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionFixedSizeArraySizePtr;
    type Green = OptionFixedSizeArraySizeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionFixedSizeArraySizeEmpty => OptionFixedSizeArraySize::Empty(
                OptionFixedSizeArraySizeEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::FixedSizeArraySize => OptionFixedSizeArraySize::FixedSizeArraySize(
                FixedSizeArraySize::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionFixedSizeArraySize"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionFixedSizeArraySizeEmpty => Some(OptionFixedSizeArraySize::Empty(
                OptionFixedSizeArraySizeEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::FixedSizeArraySize => Some(OptionFixedSizeArraySize::FixedSizeArraySize(
                FixedSizeArraySize::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionFixedSizeArraySize::Empty(x) => x.as_syntax_node(),
            OptionFixedSizeArraySize::FixedSizeArraySize(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionFixedSizeArraySizePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionFixedSizeArraySize> for SyntaxStablePtrId {
    fn from(node: &OptionFixedSizeArraySize) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionFixedSizeArraySize {
    /// Checks if a kind of a variant of [OptionFixedSizeArraySize].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionFixedSizeArraySizeEmpty | SyntaxKind::FixedSizeArraySize)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionFixedSizeArraySizeEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionFixedSizeArraySizeEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionFixedSizeArraySizeEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionFixedSizeArraySizeEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionFixedSizeArraySizeEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionFixedSizeArraySizeEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionFixedSizeArraySizeEmptyPtr(pub SyntaxStablePtrId);
impl OptionFixedSizeArraySizeEmptyPtr {}
impl TypedStablePtr for OptionFixedSizeArraySizeEmptyPtr {
    type SyntaxNode = OptionFixedSizeArraySizeEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionFixedSizeArraySizeEmpty {
        OptionFixedSizeArraySizeEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionFixedSizeArraySizeEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionFixedSizeArraySizeEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionFixedSizeArraySizeEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionFixedSizeArraySizeEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionFixedSizeArraySizeEmpty);
    type StablePtr = OptionFixedSizeArraySizeEmptyPtr;
    type Green = OptionFixedSizeArraySizeEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionFixedSizeArraySizeEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionFixedSizeArraySizeEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionFixedSizeArraySizeEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionFixedSizeArraySizeEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionFixedSizeArraySizeEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionFixedSizeArraySizeEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionFixedSizeArraySizeEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionFixedSizeArraySizeEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprClosure {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprClosure {
    pub const INDEX_WRAPPER: usize = 0;
    pub const INDEX_RET_TY: usize = 1;
    pub const INDEX_OPTIONAL_NO_PANIC: usize = 2;
    pub const INDEX_EXPR: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        wrapper: ClosureParamWrapperGreen,
        ret_ty: OptionReturnTypeClauseGreen,
        optional_no_panic: OptionTerminalNoPanicGreen,
        expr: ExprGreen,
    ) -> ExprClosureGreen {
        let children: Vec<GreenId> = vec![wrapper.0, ret_ty.0, optional_no_panic.0, expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprClosureGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprClosure,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprClosure {
    pub fn wrapper(&self, db: &dyn SyntaxGroup) -> ClosureParamWrapper {
        ClosureParamWrapper::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ret_ty(&self, db: &dyn SyntaxGroup) -> OptionReturnTypeClause {
        OptionReturnTypeClause::from_syntax_node(db, self.children[1].clone())
    }
    pub fn optional_no_panic(&self, db: &dyn SyntaxGroup) -> OptionTerminalNoPanic {
        OptionTerminalNoPanic::from_syntax_node(db, self.children[2].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprClosurePtr(pub SyntaxStablePtrId);
impl ExprClosurePtr {}
impl TypedStablePtr for ExprClosurePtr {
    type SyntaxNode = ExprClosure;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprClosure {
        ExprClosure::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprClosurePtr> for SyntaxStablePtrId {
    fn from(ptr: ExprClosurePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprClosureGreen(pub GreenId);
impl TypedSyntaxNode for ExprClosure {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprClosure);
    type StablePtr = ExprClosurePtr;
    type Green = ExprClosureGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprClosureGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprClosure,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ClosureParamWrapper::missing(db).0,
                        OptionReturnTypeClause::missing(db).0,
                        OptionTerminalNoPanic::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprClosure,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprClosure
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprClosure { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprClosurePtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprClosure> for SyntaxStablePtrId {
    fn from(node: &ExprClosure) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum ClosureParamWrapper {
    Nullary(TerminalOrOr),
    NAry(ClosureParamWrapperNAry),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ClosureParamWrapperPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ClosureParamWrapperPtr {
    type SyntaxNode = ClosureParamWrapper;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ClosureParamWrapper {
        ClosureParamWrapper::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ClosureParamWrapperPtr> for SyntaxStablePtrId {
    fn from(ptr: ClosureParamWrapperPtr) -> Self {
        ptr.untyped()
    }
}
impl From<TerminalOrOrPtr> for ClosureParamWrapperPtr {
    fn from(value: TerminalOrOrPtr) -> Self {
        Self(value.0)
    }
}
impl From<ClosureParamWrapperNAryPtr> for ClosureParamWrapperPtr {
    fn from(value: ClosureParamWrapperNAryPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrOrGreen> for ClosureParamWrapperGreen {
    fn from(value: TerminalOrOrGreen) -> Self {
        Self(value.0)
    }
}
impl From<ClosureParamWrapperNAryGreen> for ClosureParamWrapperGreen {
    fn from(value: ClosureParamWrapperNAryGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ClosureParamWrapperGreen(pub GreenId);
impl TypedSyntaxNode for ClosureParamWrapper {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ClosureParamWrapperPtr;
    type Green = ClosureParamWrapperGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalOrOr => {
                ClosureParamWrapper::Nullary(TerminalOrOr::from_syntax_node(db, node))
            }
            SyntaxKind::ClosureParamWrapperNAry => {
                ClosureParamWrapper::NAry(ClosureParamWrapperNAry::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "ClosureParamWrapper"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalOrOr => {
                Some(ClosureParamWrapper::Nullary(TerminalOrOr::from_syntax_node(db, node)))
            }
            SyntaxKind::ClosureParamWrapperNAry => {
                Some(ClosureParamWrapper::NAry(ClosureParamWrapperNAry::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            ClosureParamWrapper::Nullary(x) => x.as_syntax_node(),
            ClosureParamWrapper::NAry(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ClosureParamWrapperPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&ClosureParamWrapper> for SyntaxStablePtrId {
    fn from(node: &ClosureParamWrapper) -> Self {
        node.stable_ptr().untyped()
    }
}
impl ClosureParamWrapper {
    /// Checks if a kind of a variant of [ClosureParamWrapper].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::TerminalOrOr | SyntaxKind::ClosureParamWrapperNAry)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ClosureParamWrapperNAry {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ClosureParamWrapperNAry {
    pub const INDEX_LEFTOR: usize = 0;
    pub const INDEX_PARAMS: usize = 1;
    pub const INDEX_RIGHTOR: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        leftor: TerminalOrGreen,
        params: ParamListGreen,
        rightor: TerminalOrGreen,
    ) -> ClosureParamWrapperNAryGreen {
        let children: Vec<GreenId> = vec![leftor.0, params.0, rightor.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ClosureParamWrapperNAryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ClosureParamWrapperNAry,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ClosureParamWrapperNAry {
    pub fn leftor(&self, db: &dyn SyntaxGroup) -> TerminalOr {
        TerminalOr::from_syntax_node(db, self.children[0].clone())
    }
    pub fn params(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rightor(&self, db: &dyn SyntaxGroup) -> TerminalOr {
        TerminalOr::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ClosureParamWrapperNAryPtr(pub SyntaxStablePtrId);
impl ClosureParamWrapperNAryPtr {}
impl TypedStablePtr for ClosureParamWrapperNAryPtr {
    type SyntaxNode = ClosureParamWrapperNAry;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ClosureParamWrapperNAry {
        ClosureParamWrapperNAry::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ClosureParamWrapperNAryPtr> for SyntaxStablePtrId {
    fn from(ptr: ClosureParamWrapperNAryPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ClosureParamWrapperNAryGreen(pub GreenId);
impl TypedSyntaxNode for ClosureParamWrapperNAry {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ClosureParamWrapperNAry);
    type StablePtr = ClosureParamWrapperNAryPtr;
    type Green = ClosureParamWrapperNAryGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ClosureParamWrapperNAryGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ClosureParamWrapperNAry,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalOr::missing(db).0,
                        ParamList::missing(db).0,
                        TerminalOr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ClosureParamWrapperNAry,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ClosureParamWrapperNAry
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ClosureParamWrapperNAry {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ClosureParamWrapperNAryPtr(self.node.0.stable_ptr)
    }
}
impl From<&ClosureParamWrapperNAry> for SyntaxStablePtrId {
    fn from(node: &ClosureParamWrapperNAry) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgExpr {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StructArgExpr {
    pub const INDEX_COLON: usize = 0;
    pub const INDEX_EXPR: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        colon: TerminalColonGreen,
        expr: ExprGreen,
    ) -> StructArgExprGreen {
        let children: Vec<GreenId> = vec![colon.0, expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StructArgExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StructArgExpr {
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgExprPtr(pub SyntaxStablePtrId);
impl StructArgExprPtr {}
impl TypedStablePtr for StructArgExprPtr {
    type SyntaxNode = StructArgExpr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StructArgExpr {
        StructArgExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StructArgExprPtr> for SyntaxStablePtrId {
    fn from(ptr: StructArgExprPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgExprGreen(pub GreenId);
impl TypedSyntaxNode for StructArgExpr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgExpr);
    type StablePtr = StructArgExprPtr;
    type Green = StructArgExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgExpr,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalColon::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgExpr
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StructArgExpr {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgExprPtr(self.node.0.stable_ptr)
    }
}
impl From<&StructArgExpr> for SyntaxStablePtrId {
    fn from(node: &StructArgExpr) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionStructArgExpr {
    Empty(OptionStructArgExprEmpty),
    StructArgExpr(StructArgExpr),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionStructArgExprPtr {
    type SyntaxNode = OptionStructArgExpr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionStructArgExpr {
        OptionStructArgExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionStructArgExprPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionStructArgExprPtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionStructArgExprEmptyPtr> for OptionStructArgExprPtr {
    fn from(value: OptionStructArgExprEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<StructArgExprPtr> for OptionStructArgExprPtr {
    fn from(value: StructArgExprPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionStructArgExprEmptyGreen> for OptionStructArgExprGreen {
    fn from(value: OptionStructArgExprEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<StructArgExprGreen> for OptionStructArgExprGreen {
    fn from(value: StructArgExprGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprGreen(pub GreenId);
impl TypedSyntaxNode for OptionStructArgExpr {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionStructArgExprPtr;
    type Green = OptionStructArgExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionStructArgExprEmpty => {
                OptionStructArgExpr::Empty(OptionStructArgExprEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::StructArgExpr => {
                OptionStructArgExpr::StructArgExpr(StructArgExpr::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionStructArgExpr"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionStructArgExprEmpty => Some(OptionStructArgExpr::Empty(
                OptionStructArgExprEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::StructArgExpr => {
                Some(OptionStructArgExpr::StructArgExpr(StructArgExpr::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionStructArgExpr::Empty(x) => x.as_syntax_node(),
            OptionStructArgExpr::StructArgExpr(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionStructArgExprPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionStructArgExpr> for SyntaxStablePtrId {
    fn from(node: &OptionStructArgExpr) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionStructArgExpr {
    /// Checks if a kind of a variant of [OptionStructArgExpr].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionStructArgExprEmpty | SyntaxKind::StructArgExpr)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionStructArgExprEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionStructArgExprEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionStructArgExprEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionStructArgExprEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionStructArgExprEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionStructArgExprEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprEmptyPtr(pub SyntaxStablePtrId);
impl OptionStructArgExprEmptyPtr {}
impl TypedStablePtr for OptionStructArgExprEmptyPtr {
    type SyntaxNode = OptionStructArgExprEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionStructArgExprEmpty {
        OptionStructArgExprEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionStructArgExprEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionStructArgExprEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionStructArgExprEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionStructArgExprEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionStructArgExprEmpty);
    type StablePtr = OptionStructArgExprEmptyPtr;
    type Green = OptionStructArgExprEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionStructArgExprEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionStructArgExprEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionStructArgExprEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionStructArgExprEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionStructArgExprEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionStructArgExprEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionStructArgExprEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionStructArgExprEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgSingle {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StructArgSingle {
    pub const INDEX_IDENTIFIER: usize = 0;
    pub const INDEX_ARG_EXPR: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        identifier: TerminalIdentifierGreen,
        arg_expr: OptionStructArgExprGreen,
    ) -> StructArgSingleGreen {
        let children: Vec<GreenId> = vec![identifier.0, arg_expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StructArgSingleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgSingle,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StructArgSingle {
    pub fn identifier(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arg_expr(&self, db: &dyn SyntaxGroup) -> OptionStructArgExpr {
        OptionStructArgExpr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgSinglePtr(pub SyntaxStablePtrId);
impl StructArgSinglePtr {
    pub fn identifier_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for StructArgSinglePtr {
    type SyntaxNode = StructArgSingle;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StructArgSingle {
        StructArgSingle::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StructArgSinglePtr> for SyntaxStablePtrId {
    fn from(ptr: StructArgSinglePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgSingleGreen(pub GreenId);
impl TypedSyntaxNode for StructArgSingle {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgSingle);
    type StablePtr = StructArgSinglePtr;
    type Green = StructArgSingleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgSingleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgSingle,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIdentifier::missing(db).0,
                        OptionStructArgExpr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgSingle,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgSingle
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StructArgSingle {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgSinglePtr(self.node.0.stable_ptr)
    }
}
impl From<&StructArgSingle> for SyntaxStablePtrId {
    fn from(node: &StructArgSingle) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgTail {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StructArgTail {
    pub const INDEX_DOTDOT: usize = 0;
    pub const INDEX_EXPRESSION: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        dotdot: TerminalDotDotGreen,
        expression: ExprGreen,
    ) -> StructArgTailGreen {
        let children: Vec<GreenId> = vec![dotdot.0, expression.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StructArgTailGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgTail,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StructArgTail {
    pub fn dotdot(&self, db: &dyn SyntaxGroup) -> TerminalDotDot {
        TerminalDotDot::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expression(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgTailPtr(pub SyntaxStablePtrId);
impl StructArgTailPtr {}
impl TypedStablePtr for StructArgTailPtr {
    type SyntaxNode = StructArgTail;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StructArgTail {
        StructArgTail::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StructArgTailPtr> for SyntaxStablePtrId {
    fn from(ptr: StructArgTailPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgTailGreen(pub GreenId);
impl TypedSyntaxNode for StructArgTail {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgTail);
    type StablePtr = StructArgTailPtr;
    type Green = StructArgTailGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgTailGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgTail,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalDotDot::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StructArgTail,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StructArgTail
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StructArgTail {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgTailPtr(self.node.0.stable_ptr)
    }
}
impl From<&StructArgTail> for SyntaxStablePtrId {
    fn from(node: &StructArgTail) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum StructArg {
    StructArgSingle(StructArgSingle),
    StructArgTail(StructArgTail),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for StructArgPtr {
    type SyntaxNode = StructArg;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StructArg {
        StructArg::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StructArgPtr> for SyntaxStablePtrId {
    fn from(ptr: StructArgPtr) -> Self {
        ptr.untyped()
    }
}
impl From<StructArgSinglePtr> for StructArgPtr {
    fn from(value: StructArgSinglePtr) -> Self {
        Self(value.0)
    }
}
impl From<StructArgTailPtr> for StructArgPtr {
    fn from(value: StructArgTailPtr) -> Self {
        Self(value.0)
    }
}
impl From<StructArgSingleGreen> for StructArgGreen {
    fn from(value: StructArgSingleGreen) -> Self {
        Self(value.0)
    }
}
impl From<StructArgTailGreen> for StructArgGreen {
    fn from(value: StructArgTailGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgGreen(pub GreenId);
impl TypedSyntaxNode for StructArg {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = StructArgPtr;
    type Green = StructArgGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::StructArgSingle => {
                StructArg::StructArgSingle(StructArgSingle::from_syntax_node(db, node))
            }
            SyntaxKind::StructArgTail => {
                StructArg::StructArgTail(StructArgTail::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "StructArg"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::StructArgSingle => {
                Some(StructArg::StructArgSingle(StructArgSingle::from_syntax_node(db, node)))
            }
            SyntaxKind::StructArgTail => {
                Some(StructArg::StructArgTail(StructArgTail::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            StructArg::StructArgSingle(x) => x.as_syntax_node(),
            StructArg::StructArgTail(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&StructArg> for SyntaxStablePtrId {
    fn from(node: &StructArg) -> Self {
        node.stable_ptr().untyped()
    }
}
impl StructArg {
    /// Checks if a kind of a variant of [StructArg].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::StructArgSingle | SyntaxKind::StructArgTail)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StructArgList(ElementList<StructArg, 2>);
impl Deref for StructArgList {
    type Target = ElementList<StructArg, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StructArgList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<StructArgListElementOrSeparatorGreen>,
    ) -> StructArgListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        StructArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for StructArgListPtr {
    type SyntaxNode = StructArgList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StructArgList {
        StructArgList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StructArgListPtr> for SyntaxStablePtrId {
    fn from(ptr: StructArgListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum StructArgListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(StructArgGreen),
}
impl From<TerminalCommaGreen> for StructArgListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        StructArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<StructArgGreen> for StructArgListElementOrSeparatorGreen {
    fn from(value: StructArgGreen) -> Self {
        StructArgListElementOrSeparatorGreen::Element(value)
    }
}
impl StructArgListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            StructArgListElementOrSeparatorGreen::Separator(green) => green.0,
            StructArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StructArgListGreen(pub GreenId);
impl TypedSyntaxNode for StructArgList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StructArgList);
    type StablePtr = StructArgListPtr;
    type Green = StructArgListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StructArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StructArgList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::StructArgList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StructArgListPtr(self.node.0.stable_ptr)
    }
}
impl From<&StructArgList> for SyntaxStablePtrId {
    fn from(node: &StructArgList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgListBraced {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ArgListBraced {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        arguments: ArgListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ArgListBracedGreen {
        let children: Vec<GreenId> = vec![lbrace.0, arguments.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgListBracedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListBraced,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ArgListBraced {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> ArgList {
        ArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListBracedPtr(pub SyntaxStablePtrId);
impl ArgListBracedPtr {}
impl TypedStablePtr for ArgListBracedPtr {
    type SyntaxNode = ArgListBraced;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ArgListBraced {
        ArgListBraced::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ArgListBracedPtr> for SyntaxStablePtrId {
    fn from(ptr: ArgListBracedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListBracedGreen(pub GreenId);
impl TypedSyntaxNode for ArgListBraced {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgListBraced);
    type StablePtr = ArgListBracedPtr;
    type Green = ArgListBracedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ArgListBracedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListBraced,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        ArgList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgListBraced,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgListBraced
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgListBraced {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgListBracedPtr(self.node.0.stable_ptr)
    }
}
impl From<&ArgListBraced> for SyntaxStablePtrId {
    fn from(node: &ArgListBraced) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ArgListBracketed {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ArgListBracketed {
    pub const INDEX_LBRACK: usize = 0;
    pub const INDEX_ARGUMENTS: usize = 1;
    pub const INDEX_RBRACK: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrack: TerminalLBrackGreen,
        arguments: ArgListGreen,
        rbrack: TerminalRBrackGreen,
    ) -> ArgListBracketedGreen {
        let children: Vec<GreenId> = vec![lbrack.0, arguments.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ArgListBracketedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListBracketed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ArgListBracketed {
    pub fn lbrack(&self, db: &dyn SyntaxGroup) -> TerminalLBrack {
        TerminalLBrack::from_syntax_node(db, self.children[0].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> ArgList {
        ArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrack(&self, db: &dyn SyntaxGroup) -> TerminalRBrack {
        TerminalRBrack::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListBracketedPtr(pub SyntaxStablePtrId);
impl ArgListBracketedPtr {}
impl TypedStablePtr for ArgListBracketedPtr {
    type SyntaxNode = ArgListBracketed;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ArgListBracketed {
        ArgListBracketed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ArgListBracketedPtr> for SyntaxStablePtrId {
    fn from(ptr: ArgListBracketedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ArgListBracketedGreen(pub GreenId);
impl TypedSyntaxNode for ArgListBracketed {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ArgListBracketed);
    type StablePtr = ArgListBracketedPtr;
    type Green = ArgListBracketedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ArgListBracketedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ArgListBracketed,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrack::missing(db).0,
                        ArgList::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ArgListBracketed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ArgListBracketed
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ArgListBracketed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ArgListBracketedPtr(self.node.0.stable_ptr)
    }
}
impl From<&ArgListBracketed> for SyntaxStablePtrId {
    fn from(node: &ArgListBracketed) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum WrappedArgList {
    BracketedArgList(ArgListBracketed),
    ParenthesizedArgList(ArgListParenthesized),
    BracedArgList(ArgListBraced),
    Missing(WrappedArgListMissing),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct WrappedArgListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for WrappedArgListPtr {
    type SyntaxNode = WrappedArgList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> WrappedArgList {
        WrappedArgList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<WrappedArgListPtr> for SyntaxStablePtrId {
    fn from(ptr: WrappedArgListPtr) -> Self {
        ptr.untyped()
    }
}
impl From<ArgListBracketedPtr> for WrappedArgListPtr {
    fn from(value: ArgListBracketedPtr) -> Self {
        Self(value.0)
    }
}
impl From<ArgListParenthesizedPtr> for WrappedArgListPtr {
    fn from(value: ArgListParenthesizedPtr) -> Self {
        Self(value.0)
    }
}
impl From<ArgListBracedPtr> for WrappedArgListPtr {
    fn from(value: ArgListBracedPtr) -> Self {
        Self(value.0)
    }
}
impl From<WrappedArgListMissingPtr> for WrappedArgListPtr {
    fn from(value: WrappedArgListMissingPtr) -> Self {
        Self(value.0)
    }
}
impl From<ArgListBracketedGreen> for WrappedArgListGreen {
    fn from(value: ArgListBracketedGreen) -> Self {
        Self(value.0)
    }
}
impl From<ArgListParenthesizedGreen> for WrappedArgListGreen {
    fn from(value: ArgListParenthesizedGreen) -> Self {
        Self(value.0)
    }
}
impl From<ArgListBracedGreen> for WrappedArgListGreen {
    fn from(value: ArgListBracedGreen) -> Self {
        Self(value.0)
    }
}
impl From<WrappedArgListMissingGreen> for WrappedArgListGreen {
    fn from(value: WrappedArgListMissingGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct WrappedArgListGreen(pub GreenId);
impl TypedSyntaxNode for WrappedArgList {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = WrappedArgListPtr;
    type Green = WrappedArgListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        WrappedArgListGreen(WrappedArgListMissing::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ArgListBracketed => {
                WrappedArgList::BracketedArgList(ArgListBracketed::from_syntax_node(db, node))
            }
            SyntaxKind::ArgListParenthesized => WrappedArgList::ParenthesizedArgList(
                ArgListParenthesized::from_syntax_node(db, node),
            ),
            SyntaxKind::ArgListBraced => {
                WrappedArgList::BracedArgList(ArgListBraced::from_syntax_node(db, node))
            }
            SyntaxKind::WrappedArgListMissing => {
                WrappedArgList::Missing(WrappedArgListMissing::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "WrappedArgList")
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ArgListBracketed => {
                Some(WrappedArgList::BracketedArgList(ArgListBracketed::from_syntax_node(db, node)))
            }
            SyntaxKind::ArgListParenthesized => Some(WrappedArgList::ParenthesizedArgList(
                ArgListParenthesized::from_syntax_node(db, node),
            )),
            SyntaxKind::ArgListBraced => {
                Some(WrappedArgList::BracedArgList(ArgListBraced::from_syntax_node(db, node)))
            }
            SyntaxKind::WrappedArgListMissing => {
                Some(WrappedArgList::Missing(WrappedArgListMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            WrappedArgList::BracketedArgList(x) => x.as_syntax_node(),
            WrappedArgList::ParenthesizedArgList(x) => x.as_syntax_node(),
            WrappedArgList::BracedArgList(x) => x.as_syntax_node(),
            WrappedArgList::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        WrappedArgListPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&WrappedArgList> for SyntaxStablePtrId {
    fn from(node: &WrappedArgList) -> Self {
        node.stable_ptr().untyped()
    }
}
impl WrappedArgList {
    /// Checks if a kind of a variant of [WrappedArgList].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ArgListBracketed
                | SyntaxKind::ArgListParenthesized
                | SyntaxKind::ArgListBraced
                | SyntaxKind::WrappedArgListMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct WrappedArgListMissing {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl WrappedArgListMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> WrappedArgListMissingGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        WrappedArgListMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::WrappedArgListMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl WrappedArgListMissing {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct WrappedArgListMissingPtr(pub SyntaxStablePtrId);
impl WrappedArgListMissingPtr {}
impl TypedStablePtr for WrappedArgListMissingPtr {
    type SyntaxNode = WrappedArgListMissing;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> WrappedArgListMissing {
        WrappedArgListMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<WrappedArgListMissingPtr> for SyntaxStablePtrId {
    fn from(ptr: WrappedArgListMissingPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct WrappedArgListMissingGreen(pub GreenId);
impl TypedSyntaxNode for WrappedArgListMissing {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::WrappedArgListMissing);
    type StablePtr = WrappedArgListMissingPtr;
    type Green = WrappedArgListMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        WrappedArgListMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::WrappedArgListMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::WrappedArgListMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::WrappedArgListMissing
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::WrappedArgListMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        WrappedArgListMissingPtr(self.node.0.stable_ptr)
    }
}
impl From<&WrappedArgListMissing> for SyntaxStablePtrId {
    fn from(node: &WrappedArgListMissing) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Pattern {
    Underscore(TerminalUnderscore),
    Literal(TerminalLiteralNumber),
    False(TerminalFalse),
    True(TerminalTrue),
    ShortString(TerminalShortString),
    String(TerminalString),
    Identifier(PatternIdentifier),
    Struct(PatternStruct),
    Tuple(PatternTuple),
    Enum(PatternEnum),
    FixedSizeArray(PatternFixedSizeArray),
    Path(ExprPath),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for PatternPtr {
    type SyntaxNode = Pattern;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternPtr) -> Self {
        ptr.untyped()
    }
}
impl From<TerminalUnderscorePtr> for PatternPtr {
    fn from(value: TerminalUnderscorePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLiteralNumberPtr> for PatternPtr {
    fn from(value: TerminalLiteralNumberPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalFalsePtr> for PatternPtr {
    fn from(value: TerminalFalsePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTruePtr> for PatternPtr {
    fn from(value: TerminalTruePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalShortStringPtr> for PatternPtr {
    fn from(value: TerminalShortStringPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalStringPtr> for PatternPtr {
    fn from(value: TerminalStringPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternIdentifierPtr> for PatternPtr {
    fn from(value: PatternIdentifierPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternStructPtr> for PatternPtr {
    fn from(value: PatternStructPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternTuplePtr> for PatternPtr {
    fn from(value: PatternTuplePtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternEnumPtr> for PatternPtr {
    fn from(value: PatternEnumPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternFixedSizeArrayPtr> for PatternPtr {
    fn from(value: PatternFixedSizeArrayPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprPathPtr> for PatternPtr {
    fn from(value: ExprPathPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalUnderscoreGreen> for PatternGreen {
    fn from(value: TerminalUnderscoreGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLiteralNumberGreen> for PatternGreen {
    fn from(value: TerminalLiteralNumberGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalFalseGreen> for PatternGreen {
    fn from(value: TerminalFalseGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTrueGreen> for PatternGreen {
    fn from(value: TerminalTrueGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalShortStringGreen> for PatternGreen {
    fn from(value: TerminalShortStringGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalStringGreen> for PatternGreen {
    fn from(value: TerminalStringGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternIdentifierGreen> for PatternGreen {
    fn from(value: PatternIdentifierGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternStructGreen> for PatternGreen {
    fn from(value: PatternStructGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternTupleGreen> for PatternGreen {
    fn from(value: PatternTupleGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternEnumGreen> for PatternGreen {
    fn from(value: PatternEnumGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternFixedSizeArrayGreen> for PatternGreen {
    fn from(value: PatternFixedSizeArrayGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprPathGreen> for PatternGreen {
    fn from(value: ExprPathGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternGreen(pub GreenId);
impl TypedSyntaxNode for Pattern {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = PatternPtr;
    type Green = PatternGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalUnderscore => {
                Pattern::Underscore(TerminalUnderscore::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLiteralNumber => {
                Pattern::Literal(TerminalLiteralNumber::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalFalse => Pattern::False(TerminalFalse::from_syntax_node(db, node)),
            SyntaxKind::TerminalTrue => Pattern::True(TerminalTrue::from_syntax_node(db, node)),
            SyntaxKind::TerminalShortString => {
                Pattern::ShortString(TerminalShortString::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalString => {
                Pattern::String(TerminalString::from_syntax_node(db, node))
            }
            SyntaxKind::PatternIdentifier => {
                Pattern::Identifier(PatternIdentifier::from_syntax_node(db, node))
            }
            SyntaxKind::PatternStruct => Pattern::Struct(PatternStruct::from_syntax_node(db, node)),
            SyntaxKind::PatternTuple => Pattern::Tuple(PatternTuple::from_syntax_node(db, node)),
            SyntaxKind::PatternEnum => Pattern::Enum(PatternEnum::from_syntax_node(db, node)),
            SyntaxKind::PatternFixedSizeArray => {
                Pattern::FixedSizeArray(PatternFixedSizeArray::from_syntax_node(db, node))
            }
            SyntaxKind::ExprPath => Pattern::Path(ExprPath::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Pattern"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalUnderscore => {
                Some(Pattern::Underscore(TerminalUnderscore::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLiteralNumber => {
                Some(Pattern::Literal(TerminalLiteralNumber::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalFalse => {
                Some(Pattern::False(TerminalFalse::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalTrue => {
                Some(Pattern::True(TerminalTrue::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalShortString => {
                Some(Pattern::ShortString(TerminalShortString::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalString => {
                Some(Pattern::String(TerminalString::from_syntax_node(db, node)))
            }
            SyntaxKind::PatternIdentifier => {
                Some(Pattern::Identifier(PatternIdentifier::from_syntax_node(db, node)))
            }
            SyntaxKind::PatternStruct => {
                Some(Pattern::Struct(PatternStruct::from_syntax_node(db, node)))
            }
            SyntaxKind::PatternTuple => {
                Some(Pattern::Tuple(PatternTuple::from_syntax_node(db, node)))
            }
            SyntaxKind::PatternEnum => Some(Pattern::Enum(PatternEnum::from_syntax_node(db, node))),
            SyntaxKind::PatternFixedSizeArray => {
                Some(Pattern::FixedSizeArray(PatternFixedSizeArray::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprPath => Some(Pattern::Path(ExprPath::from_syntax_node(db, node))),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Pattern::Underscore(x) => x.as_syntax_node(),
            Pattern::Literal(x) => x.as_syntax_node(),
            Pattern::False(x) => x.as_syntax_node(),
            Pattern::True(x) => x.as_syntax_node(),
            Pattern::ShortString(x) => x.as_syntax_node(),
            Pattern::String(x) => x.as_syntax_node(),
            Pattern::Identifier(x) => x.as_syntax_node(),
            Pattern::Struct(x) => x.as_syntax_node(),
            Pattern::Tuple(x) => x.as_syntax_node(),
            Pattern::Enum(x) => x.as_syntax_node(),
            Pattern::FixedSizeArray(x) => x.as_syntax_node(),
            Pattern::Path(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&Pattern> for SyntaxStablePtrId {
    fn from(node: &Pattern) -> Self {
        node.stable_ptr().untyped()
    }
}
impl Pattern {
    /// Checks if a kind of a variant of [Pattern].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TerminalUnderscore
                | SyntaxKind::TerminalLiteralNumber
                | SyntaxKind::TerminalFalse
                | SyntaxKind::TerminalTrue
                | SyntaxKind::TerminalShortString
                | SyntaxKind::TerminalString
                | SyntaxKind::PatternIdentifier
                | SyntaxKind::PatternStruct
                | SyntaxKind::PatternTuple
                | SyntaxKind::PatternEnum
                | SyntaxKind::PatternFixedSizeArray
                | SyntaxKind::ExprPath
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternIdentifier {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl PatternIdentifier {
    pub const INDEX_MODIFIERS: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        modifiers: ModifierListGreen,
        name: TerminalIdentifierGreen,
    ) -> PatternIdentifierGreen {
        let children: Vec<GreenId> = vec![modifiers.0, name.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternIdentifier,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl PatternIdentifier {
    pub fn modifiers(&self, db: &dyn SyntaxGroup) -> ModifierList {
        ModifierList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternIdentifierPtr(pub SyntaxStablePtrId);
impl PatternIdentifierPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for PatternIdentifierPtr {
    type SyntaxNode = PatternIdentifier;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternIdentifier {
        PatternIdentifier::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternIdentifierPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternIdentifierPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternIdentifierGreen(pub GreenId);
impl TypedSyntaxNode for PatternIdentifier {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternIdentifier);
    type StablePtr = PatternIdentifierPtr;
    type Green = PatternIdentifierGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternIdentifier,
                details: GreenNodeDetails::Node {
                    children: vec![ModifierList::missing(db).0, TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternIdentifier,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternIdentifier
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternIdentifier {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternIdentifierPtr(self.node.0.stable_ptr)
    }
}
impl From<&PatternIdentifier> for SyntaxStablePtrId {
    fn from(node: &PatternIdentifier) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternStruct {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl PatternStruct {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_LBRACE: usize = 1;
    pub const INDEX_PARAMS: usize = 2;
    pub const INDEX_RBRACE: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        lbrace: TerminalLBraceGreen,
        params: PatternStructParamListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> PatternStructGreen {
        let children: Vec<GreenId> = vec![path.0, lbrace.0, params.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStruct,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl PatternStruct {
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[1].clone())
    }
    pub fn params(&self, db: &dyn SyntaxGroup) -> PatternStructParamList {
        PatternStructParamList::from_syntax_node(db, self.children[2].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructPtr(pub SyntaxStablePtrId);
impl PatternStructPtr {}
impl TypedStablePtr for PatternStructPtr {
    type SyntaxNode = PatternStruct;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternStruct {
        PatternStruct::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternStructPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternStructPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructGreen(pub GreenId);
impl TypedSyntaxNode for PatternStruct {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternStruct);
    type StablePtr = PatternStructPtr;
    type Green = PatternStructGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStruct,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ExprPath::missing(db).0,
                        TerminalLBrace::missing(db).0,
                        PatternStructParamList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternStruct,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternStruct
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternStruct {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternStructPtr(self.node.0.stable_ptr)
    }
}
impl From<&PatternStruct> for SyntaxStablePtrId {
    fn from(node: &PatternStruct) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternStructParamList(ElementList<PatternStructParam, 2>);
impl Deref for PatternStructParamList {
    type Target = ElementList<PatternStructParam, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl PatternStructParamList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<PatternStructParamListElementOrSeparatorGreen>,
    ) -> PatternStructParamListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        PatternStructParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStructParamList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for PatternStructParamListPtr {
    type SyntaxNode = PatternStructParamList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternStructParamList {
        PatternStructParamList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternStructParamListPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternStructParamListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum PatternStructParamListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(PatternStructParamGreen),
}
impl From<TerminalCommaGreen> for PatternStructParamListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        PatternStructParamListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<PatternStructParamGreen> for PatternStructParamListElementOrSeparatorGreen {
    fn from(value: PatternStructParamGreen) -> Self {
        PatternStructParamListElementOrSeparatorGreen::Element(value)
    }
}
impl PatternStructParamListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            PatternStructParamListElementOrSeparatorGreen::Separator(green) => green.0,
            PatternStructParamListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamListGreen(pub GreenId);
impl TypedSyntaxNode for PatternStructParamList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternStructParamList);
    type StablePtr = PatternStructParamListPtr;
    type Green = PatternStructParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternStructParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStructParamList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::PatternStructParamList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternStructParamListPtr(self.node.0.stable_ptr)
    }
}
impl From<&PatternStructParamList> for SyntaxStablePtrId {
    fn from(node: &PatternStructParamList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternTuple {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl PatternTuple {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_PATTERNS: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        patterns: PatternListGreen,
        rparen: TerminalRParenGreen,
    ) -> PatternTupleGreen {
        let children: Vec<GreenId> = vec![lparen.0, patterns.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternTupleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternTuple,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl PatternTuple {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn patterns(&self, db: &dyn SyntaxGroup) -> PatternList {
        PatternList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternTuplePtr(pub SyntaxStablePtrId);
impl PatternTuplePtr {}
impl TypedStablePtr for PatternTuplePtr {
    type SyntaxNode = PatternTuple;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternTuple {
        PatternTuple::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternTuplePtr> for SyntaxStablePtrId {
    fn from(ptr: PatternTuplePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternTupleGreen(pub GreenId);
impl TypedSyntaxNode for PatternTuple {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternTuple);
    type StablePtr = PatternTuplePtr;
    type Green = PatternTupleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternTupleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternTuple,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        PatternList::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternTuple,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternTuple
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternTuple { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternTuplePtr(self.node.0.stable_ptr)
    }
}
impl From<&PatternTuple> for SyntaxStablePtrId {
    fn from(node: &PatternTuple) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternFixedSizeArray {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl PatternFixedSizeArray {
    pub const INDEX_LBRACK: usize = 0;
    pub const INDEX_PATTERNS: usize = 1;
    pub const INDEX_RBRACK: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrack: TerminalLBrackGreen,
        patterns: PatternListGreen,
        rbrack: TerminalRBrackGreen,
    ) -> PatternFixedSizeArrayGreen {
        let children: Vec<GreenId> = vec![lbrack.0, patterns.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternFixedSizeArrayGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternFixedSizeArray,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl PatternFixedSizeArray {
    pub fn lbrack(&self, db: &dyn SyntaxGroup) -> TerminalLBrack {
        TerminalLBrack::from_syntax_node(db, self.children[0].clone())
    }
    pub fn patterns(&self, db: &dyn SyntaxGroup) -> PatternList {
        PatternList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrack(&self, db: &dyn SyntaxGroup) -> TerminalRBrack {
        TerminalRBrack::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternFixedSizeArrayPtr(pub SyntaxStablePtrId);
impl PatternFixedSizeArrayPtr {}
impl TypedStablePtr for PatternFixedSizeArrayPtr {
    type SyntaxNode = PatternFixedSizeArray;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternFixedSizeArray {
        PatternFixedSizeArray::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternFixedSizeArrayPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternFixedSizeArrayPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternFixedSizeArrayGreen(pub GreenId);
impl TypedSyntaxNode for PatternFixedSizeArray {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternFixedSizeArray);
    type StablePtr = PatternFixedSizeArrayPtr;
    type Green = PatternFixedSizeArrayGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternFixedSizeArrayGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternFixedSizeArray,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrack::missing(db).0,
                        PatternList::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternFixedSizeArray,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternFixedSizeArray
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternFixedSizeArray {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternFixedSizeArrayPtr(self.node.0.stable_ptr)
    }
}
impl From<&PatternFixedSizeArray> for SyntaxStablePtrId {
    fn from(node: &PatternFixedSizeArray) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternList(ElementList<Pattern, 2>);
impl Deref for PatternList {
    type Target = ElementList<Pattern, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl PatternList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<PatternListElementOrSeparatorGreen>,
    ) -> PatternListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        PatternListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for PatternListPtr {
    type SyntaxNode = PatternList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternList {
        PatternList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternListPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum PatternListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(PatternGreen),
}
impl From<TerminalCommaGreen> for PatternListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        PatternListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<PatternGreen> for PatternListElementOrSeparatorGreen {
    fn from(value: PatternGreen) -> Self {
        PatternListElementOrSeparatorGreen::Element(value)
    }
}
impl PatternListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            PatternListElementOrSeparatorGreen::Separator(green) => green.0,
            PatternListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternListGreen(pub GreenId);
impl TypedSyntaxNode for PatternList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternList);
    type StablePtr = PatternListPtr;
    type Green = PatternListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::PatternList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternListPtr(self.node.0.stable_ptr)
    }
}
impl From<&PatternList> for SyntaxStablePtrId {
    fn from(node: &PatternList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternListOr(ElementList<Pattern, 2>);
impl Deref for PatternListOr {
    type Target = ElementList<Pattern, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl PatternListOr {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<PatternListOrElementOrSeparatorGreen>,
    ) -> PatternListOrGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        PatternListOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternListOr,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternListOrPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for PatternListOrPtr {
    type SyntaxNode = PatternListOr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternListOr {
        PatternListOr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternListOrPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternListOrPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum PatternListOrElementOrSeparatorGreen {
    Separator(TerminalOrGreen),
    Element(PatternGreen),
}
impl From<TerminalOrGreen> for PatternListOrElementOrSeparatorGreen {
    fn from(value: TerminalOrGreen) -> Self {
        PatternListOrElementOrSeparatorGreen::Separator(value)
    }
}
impl From<PatternGreen> for PatternListOrElementOrSeparatorGreen {
    fn from(value: PatternGreen) -> Self {
        PatternListOrElementOrSeparatorGreen::Element(value)
    }
}
impl PatternListOrElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            PatternListOrElementOrSeparatorGreen::Separator(green) => green.0,
            PatternListOrElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternListOrGreen(pub GreenId);
impl TypedSyntaxNode for PatternListOr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternListOr);
    type StablePtr = PatternListOrPtr;
    type Green = PatternListOrGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternListOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternListOr,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::PatternListOr {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternListOrPtr(self.node.0.stable_ptr)
    }
}
impl From<&PatternListOr> for SyntaxStablePtrId {
    fn from(node: &PatternListOr) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum PatternStructParam {
    Single(PatternIdentifier),
    WithExpr(PatternStructParamWithExpr),
    Tail(TerminalDotDot),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for PatternStructParamPtr {
    type SyntaxNode = PatternStructParam;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternStructParam {
        PatternStructParam::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternStructParamPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternStructParamPtr) -> Self {
        ptr.untyped()
    }
}
impl From<PatternIdentifierPtr> for PatternStructParamPtr {
    fn from(value: PatternIdentifierPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternStructParamWithExprPtr> for PatternStructParamPtr {
    fn from(value: PatternStructParamWithExprPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotPtr> for PatternStructParamPtr {
    fn from(value: TerminalDotDotPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternIdentifierGreen> for PatternStructParamGreen {
    fn from(value: PatternIdentifierGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternStructParamWithExprGreen> for PatternStructParamGreen {
    fn from(value: PatternStructParamWithExprGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotGreen> for PatternStructParamGreen {
    fn from(value: TerminalDotDotGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamGreen(pub GreenId);
impl TypedSyntaxNode for PatternStructParam {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = PatternStructParamPtr;
    type Green = PatternStructParamGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::PatternIdentifier => {
                PatternStructParam::Single(PatternIdentifier::from_syntax_node(db, node))
            }
            SyntaxKind::PatternStructParamWithExpr => {
                PatternStructParam::WithExpr(PatternStructParamWithExpr::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDotDot => {
                PatternStructParam::Tail(TerminalDotDot::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "PatternStructParam"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::PatternIdentifier => {
                Some(PatternStructParam::Single(PatternIdentifier::from_syntax_node(db, node)))
            }
            SyntaxKind::PatternStructParamWithExpr => Some(PatternStructParam::WithExpr(
                PatternStructParamWithExpr::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalDotDot => {
                Some(PatternStructParam::Tail(TerminalDotDot::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            PatternStructParam::Single(x) => x.as_syntax_node(),
            PatternStructParam::WithExpr(x) => x.as_syntax_node(),
            PatternStructParam::Tail(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternStructParamPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&PatternStructParam> for SyntaxStablePtrId {
    fn from(node: &PatternStructParam) -> Self {
        node.stable_ptr().untyped()
    }
}
impl PatternStructParam {
    /// Checks if a kind of a variant of [PatternStructParam].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::PatternIdentifier
                | SyntaxKind::PatternStructParamWithExpr
                | SyntaxKind::TerminalDotDot
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternStructParamWithExpr {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl PatternStructParamWithExpr {
    pub const INDEX_MODIFIERS: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_COLON: usize = 2;
    pub const INDEX_PATTERN: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        modifiers: ModifierListGreen,
        name: TerminalIdentifierGreen,
        colon: TerminalColonGreen,
        pattern: PatternGreen,
    ) -> PatternStructParamWithExprGreen {
        let children: Vec<GreenId> = vec![modifiers.0, name.0, colon.0, pattern.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternStructParamWithExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStructParamWithExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl PatternStructParamWithExpr {
    pub fn modifiers(&self, db: &dyn SyntaxGroup) -> ModifierList {
        ModifierList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[2].clone())
    }
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamWithExprPtr(pub SyntaxStablePtrId);
impl PatternStructParamWithExprPtr {}
impl TypedStablePtr for PatternStructParamWithExprPtr {
    type SyntaxNode = PatternStructParamWithExpr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternStructParamWithExpr {
        PatternStructParamWithExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternStructParamWithExprPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternStructParamWithExprPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternStructParamWithExprGreen(pub GreenId);
impl TypedSyntaxNode for PatternStructParamWithExpr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternStructParamWithExpr);
    type StablePtr = PatternStructParamWithExprPtr;
    type Green = PatternStructParamWithExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternStructParamWithExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternStructParamWithExpr,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ModifierList::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        Pattern::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternStructParamWithExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternStructParamWithExpr
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternStructParamWithExpr {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternStructParamWithExprPtr(self.node.0.stable_ptr)
    }
}
impl From<&PatternStructParamWithExpr> for SyntaxStablePtrId {
    fn from(node: &PatternStructParamWithExpr) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternEnum {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl PatternEnum {
    pub const INDEX_PATH: usize = 0;
    pub const INDEX_PATTERN: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        path: ExprPathGreen,
        pattern: OptionPatternEnumInnerPatternGreen,
    ) -> PatternEnumGreen {
        let children: Vec<GreenId> = vec![path.0, pattern.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternEnum,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl PatternEnum {
    pub fn path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[0].clone())
    }
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> OptionPatternEnumInnerPattern {
        OptionPatternEnumInnerPattern::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternEnumPtr(pub SyntaxStablePtrId);
impl PatternEnumPtr {}
impl TypedStablePtr for PatternEnumPtr {
    type SyntaxNode = PatternEnum;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternEnum {
        PatternEnum::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternEnumPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternEnumPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternEnumGreen(pub GreenId);
impl TypedSyntaxNode for PatternEnum {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternEnum);
    type StablePtr = PatternEnumPtr;
    type Green = PatternEnumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternEnum,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ExprPath::missing(db).0,
                        OptionPatternEnumInnerPattern::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternEnum,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternEnum
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternEnum { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternEnumPtr(self.node.0.stable_ptr)
    }
}
impl From<&PatternEnum> for SyntaxStablePtrId {
    fn from(node: &PatternEnum) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct PatternEnumInnerPattern {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl PatternEnumInnerPattern {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_PATTERN: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        pattern: PatternGreen,
        rparen: TerminalRParenGreen,
    ) -> PatternEnumInnerPatternGreen {
        let children: Vec<GreenId> = vec![lparen.0, pattern.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        PatternEnumInnerPatternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternEnumInnerPattern,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl PatternEnumInnerPattern {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternEnumInnerPatternPtr(pub SyntaxStablePtrId);
impl PatternEnumInnerPatternPtr {}
impl TypedStablePtr for PatternEnumInnerPatternPtr {
    type SyntaxNode = PatternEnumInnerPattern;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> PatternEnumInnerPattern {
        PatternEnumInnerPattern::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<PatternEnumInnerPatternPtr> for SyntaxStablePtrId {
    fn from(ptr: PatternEnumInnerPatternPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct PatternEnumInnerPatternGreen(pub GreenId);
impl TypedSyntaxNode for PatternEnumInnerPattern {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::PatternEnumInnerPattern);
    type StablePtr = PatternEnumInnerPatternPtr;
    type Green = PatternEnumInnerPatternGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        PatternEnumInnerPatternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::PatternEnumInnerPattern,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        Pattern::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::PatternEnumInnerPattern,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::PatternEnumInnerPattern
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::PatternEnumInnerPattern {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        PatternEnumInnerPatternPtr(self.node.0.stable_ptr)
    }
}
impl From<&PatternEnumInnerPattern> for SyntaxStablePtrId {
    fn from(node: &PatternEnumInnerPattern) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionPatternEnumInnerPattern {
    Empty(OptionPatternEnumInnerPatternEmpty),
    PatternEnumInnerPattern(PatternEnumInnerPattern),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionPatternEnumInnerPatternPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionPatternEnumInnerPatternPtr {
    type SyntaxNode = OptionPatternEnumInnerPattern;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionPatternEnumInnerPattern {
        OptionPatternEnumInnerPattern::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionPatternEnumInnerPatternPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionPatternEnumInnerPatternPtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionPatternEnumInnerPatternEmptyPtr> for OptionPatternEnumInnerPatternPtr {
    fn from(value: OptionPatternEnumInnerPatternEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<PatternEnumInnerPatternPtr> for OptionPatternEnumInnerPatternPtr {
    fn from(value: PatternEnumInnerPatternPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionPatternEnumInnerPatternEmptyGreen> for OptionPatternEnumInnerPatternGreen {
    fn from(value: OptionPatternEnumInnerPatternEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<PatternEnumInnerPatternGreen> for OptionPatternEnumInnerPatternGreen {
    fn from(value: PatternEnumInnerPatternGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionPatternEnumInnerPatternGreen(pub GreenId);
impl TypedSyntaxNode for OptionPatternEnumInnerPattern {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionPatternEnumInnerPatternPtr;
    type Green = OptionPatternEnumInnerPatternGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionPatternEnumInnerPatternEmpty => OptionPatternEnumInnerPattern::Empty(
                OptionPatternEnumInnerPatternEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::PatternEnumInnerPattern => {
                OptionPatternEnumInnerPattern::PatternEnumInnerPattern(
                    PatternEnumInnerPattern::from_syntax_node(db, node),
                )
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionPatternEnumInnerPattern"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionPatternEnumInnerPatternEmpty => {
                Some(OptionPatternEnumInnerPattern::Empty(
                    OptionPatternEnumInnerPatternEmpty::from_syntax_node(db, node),
                ))
            }
            SyntaxKind::PatternEnumInnerPattern => {
                Some(OptionPatternEnumInnerPattern::PatternEnumInnerPattern(
                    PatternEnumInnerPattern::from_syntax_node(db, node),
                ))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionPatternEnumInnerPattern::Empty(x) => x.as_syntax_node(),
            OptionPatternEnumInnerPattern::PatternEnumInnerPattern(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionPatternEnumInnerPatternPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionPatternEnumInnerPattern> for SyntaxStablePtrId {
    fn from(node: &OptionPatternEnumInnerPattern) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionPatternEnumInnerPattern {
    /// Checks if a kind of a variant of [OptionPatternEnumInnerPattern].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::OptionPatternEnumInnerPatternEmpty | SyntaxKind::PatternEnumInnerPattern
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionPatternEnumInnerPatternEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionPatternEnumInnerPatternEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionPatternEnumInnerPatternEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionPatternEnumInnerPatternEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionPatternEnumInnerPatternEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionPatternEnumInnerPatternEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionPatternEnumInnerPatternEmptyPtr(pub SyntaxStablePtrId);
impl OptionPatternEnumInnerPatternEmptyPtr {}
impl TypedStablePtr for OptionPatternEnumInnerPatternEmptyPtr {
    type SyntaxNode = OptionPatternEnumInnerPatternEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionPatternEnumInnerPatternEmpty {
        OptionPatternEnumInnerPatternEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionPatternEnumInnerPatternEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionPatternEnumInnerPatternEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionPatternEnumInnerPatternEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionPatternEnumInnerPatternEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionPatternEnumInnerPatternEmpty);
    type StablePtr = OptionPatternEnumInnerPatternEmptyPtr;
    type Green = OptionPatternEnumInnerPatternEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionPatternEnumInnerPatternEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionPatternEnumInnerPatternEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionPatternEnumInnerPatternEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionPatternEnumInnerPatternEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionPatternEnumInnerPatternEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionPatternEnumInnerPatternEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionPatternEnumInnerPatternEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionPatternEnumInnerPatternEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TypeClause {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl TypeClause {
    pub const INDEX_COLON: usize = 0;
    pub const INDEX_TY: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        colon: TerminalColonGreen,
        ty: ExprGreen,
    ) -> TypeClauseGreen {
        let children: Vec<GreenId> = vec![colon.0, ty.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TypeClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TypeClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl TypeClause {
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ty(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TypeClausePtr(pub SyntaxStablePtrId);
impl TypeClausePtr {}
impl TypedStablePtr for TypeClausePtr {
    type SyntaxNode = TypeClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TypeClause {
        TypeClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TypeClausePtr> for SyntaxStablePtrId {
    fn from(ptr: TypeClausePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for TypeClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TypeClause);
    type StablePtr = TypeClausePtr;
    type Green = TypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TypeClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TypeClause,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalColon::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TypeClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TypeClause
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TypeClause { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TypeClausePtr(self.node.0.stable_ptr)
    }
}
impl From<&TypeClause> for SyntaxStablePtrId {
    fn from(node: &TypeClause) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTypeClause {
    Empty(OptionTypeClauseEmpty),
    TypeClause(TypeClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClausePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionTypeClausePtr {
    type SyntaxNode = OptionTypeClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionTypeClause {
        OptionTypeClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionTypeClausePtr> for SyntaxStablePtrId {
    fn from(ptr: OptionTypeClausePtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionTypeClauseEmptyPtr> for OptionTypeClausePtr {
    fn from(value: OptionTypeClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TypeClausePtr> for OptionTypeClausePtr {
    fn from(value: TypeClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionTypeClauseEmptyGreen> for OptionTypeClauseGreen {
    fn from(value: OptionTypeClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TypeClauseGreen> for OptionTypeClauseGreen {
    fn from(value: TypeClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionTypeClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTypeClausePtr;
    type Green = OptionTypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTypeClauseEmpty => {
                OptionTypeClause::Empty(OptionTypeClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::TypeClause => {
                OptionTypeClause::TypeClause(TypeClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTypeClause"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTypeClauseEmpty => {
                Some(OptionTypeClause::Empty(OptionTypeClauseEmpty::from_syntax_node(db, node)))
            }
            SyntaxKind::TypeClause => {
                Some(OptionTypeClause::TypeClause(TypeClause::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTypeClause::Empty(x) => x.as_syntax_node(),
            OptionTypeClause::TypeClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTypeClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionTypeClause> for SyntaxStablePtrId {
    fn from(node: &OptionTypeClause) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionTypeClause {
    /// Checks if a kind of a variant of [OptionTypeClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTypeClauseEmpty | SyntaxKind::TypeClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTypeClauseEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionTypeClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionTypeClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTypeClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTypeClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionTypeClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionTypeClauseEmptyPtr {}
impl TypedStablePtr for OptionTypeClauseEmptyPtr {
    type SyntaxNode = OptionTypeClauseEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionTypeClauseEmpty {
        OptionTypeClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionTypeClauseEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionTypeClauseEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTypeClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionTypeClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTypeClauseEmpty);
    type StablePtr = OptionTypeClauseEmptyPtr;
    type Green = OptionTypeClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionTypeClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTypeClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTypeClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTypeClauseEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTypeClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTypeClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionTypeClauseEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionTypeClauseEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ReturnTypeClause {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ReturnTypeClause {
    pub const INDEX_ARROW: usize = 0;
    pub const INDEX_TY: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        arrow: TerminalArrowGreen,
        ty: ExprGreen,
    ) -> ReturnTypeClauseGreen {
        let children: Vec<GreenId> = vec![arrow.0, ty.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ReturnTypeClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ReturnTypeClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ReturnTypeClause {
    pub fn arrow(&self, db: &dyn SyntaxGroup) -> TerminalArrow {
        TerminalArrow::from_syntax_node(db, self.children[0].clone())
    }
    pub fn ty(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ReturnTypeClausePtr(pub SyntaxStablePtrId);
impl ReturnTypeClausePtr {}
impl TypedStablePtr for ReturnTypeClausePtr {
    type SyntaxNode = ReturnTypeClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ReturnTypeClause {
        ReturnTypeClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ReturnTypeClausePtr> for SyntaxStablePtrId {
    fn from(ptr: ReturnTypeClausePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ReturnTypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for ReturnTypeClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ReturnTypeClause);
    type StablePtr = ReturnTypeClausePtr;
    type Green = ReturnTypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ReturnTypeClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ReturnTypeClause,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalArrow::missing(db).0, Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ReturnTypeClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ReturnTypeClause
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ReturnTypeClause {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ReturnTypeClausePtr(self.node.0.stable_ptr)
    }
}
impl From<&ReturnTypeClause> for SyntaxStablePtrId {
    fn from(node: &ReturnTypeClause) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionReturnTypeClause {
    Empty(OptionReturnTypeClauseEmpty),
    ReturnTypeClause(ReturnTypeClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClausePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionReturnTypeClausePtr {
    type SyntaxNode = OptionReturnTypeClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionReturnTypeClause {
        OptionReturnTypeClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionReturnTypeClausePtr> for SyntaxStablePtrId {
    fn from(ptr: OptionReturnTypeClausePtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionReturnTypeClauseEmptyPtr> for OptionReturnTypeClausePtr {
    fn from(value: OptionReturnTypeClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<ReturnTypeClausePtr> for OptionReturnTypeClausePtr {
    fn from(value: ReturnTypeClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionReturnTypeClauseEmptyGreen> for OptionReturnTypeClauseGreen {
    fn from(value: OptionReturnTypeClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ReturnTypeClauseGreen> for OptionReturnTypeClauseGreen {
    fn from(value: ReturnTypeClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionReturnTypeClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionReturnTypeClausePtr;
    type Green = OptionReturnTypeClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionReturnTypeClauseEmpty => OptionReturnTypeClause::Empty(
                OptionReturnTypeClauseEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::ReturnTypeClause => OptionReturnTypeClause::ReturnTypeClause(
                ReturnTypeClause::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionReturnTypeClause"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionReturnTypeClauseEmpty => Some(OptionReturnTypeClause::Empty(
                OptionReturnTypeClauseEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::ReturnTypeClause => Some(OptionReturnTypeClause::ReturnTypeClause(
                ReturnTypeClause::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionReturnTypeClause::Empty(x) => x.as_syntax_node(),
            OptionReturnTypeClause::ReturnTypeClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionReturnTypeClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionReturnTypeClause> for SyntaxStablePtrId {
    fn from(node: &OptionReturnTypeClause) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionReturnTypeClause {
    /// Checks if a kind of a variant of [OptionReturnTypeClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionReturnTypeClauseEmpty | SyntaxKind::ReturnTypeClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionReturnTypeClauseEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionReturnTypeClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionReturnTypeClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionReturnTypeClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionReturnTypeClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionReturnTypeClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionReturnTypeClauseEmptyPtr {}
impl TypedStablePtr for OptionReturnTypeClauseEmptyPtr {
    type SyntaxNode = OptionReturnTypeClauseEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionReturnTypeClauseEmpty {
        OptionReturnTypeClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionReturnTypeClauseEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionReturnTypeClauseEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionReturnTypeClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionReturnTypeClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionReturnTypeClauseEmpty);
    type StablePtr = OptionReturnTypeClauseEmptyPtr;
    type Green = OptionReturnTypeClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionReturnTypeClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionReturnTypeClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionReturnTypeClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionReturnTypeClauseEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionReturnTypeClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionReturnTypeClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionReturnTypeClauseEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionReturnTypeClauseEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Statement {
    Let(StatementLet),
    Expr(StatementExpr),
    Continue(StatementContinue),
    Return(StatementReturn),
    Break(StatementBreak),
    Item(StatementItem),
    Missing(StatementMissing),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for StatementPtr {
    type SyntaxNode = Statement;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Statement {
        Statement::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StatementPtr> for SyntaxStablePtrId {
    fn from(ptr: StatementPtr) -> Self {
        ptr.untyped()
    }
}
impl From<StatementLetPtr> for StatementPtr {
    fn from(value: StatementLetPtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementExprPtr> for StatementPtr {
    fn from(value: StatementExprPtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementContinuePtr> for StatementPtr {
    fn from(value: StatementContinuePtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementReturnPtr> for StatementPtr {
    fn from(value: StatementReturnPtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementBreakPtr> for StatementPtr {
    fn from(value: StatementBreakPtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementItemPtr> for StatementPtr {
    fn from(value: StatementItemPtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementMissingPtr> for StatementPtr {
    fn from(value: StatementMissingPtr) -> Self {
        Self(value.0)
    }
}
impl From<StatementLetGreen> for StatementGreen {
    fn from(value: StatementLetGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementExprGreen> for StatementGreen {
    fn from(value: StatementExprGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementContinueGreen> for StatementGreen {
    fn from(value: StatementContinueGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementReturnGreen> for StatementGreen {
    fn from(value: StatementReturnGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementBreakGreen> for StatementGreen {
    fn from(value: StatementBreakGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementItemGreen> for StatementGreen {
    fn from(value: StatementItemGreen) -> Self {
        Self(value.0)
    }
}
impl From<StatementMissingGreen> for StatementGreen {
    fn from(value: StatementMissingGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementGreen(pub GreenId);
impl TypedSyntaxNode for Statement {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = StatementPtr;
    type Green = StatementGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementGreen(StatementMissing::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::StatementLet => Statement::Let(StatementLet::from_syntax_node(db, node)),
            SyntaxKind::StatementExpr => Statement::Expr(StatementExpr::from_syntax_node(db, node)),
            SyntaxKind::StatementContinue => {
                Statement::Continue(StatementContinue::from_syntax_node(db, node))
            }
            SyntaxKind::StatementReturn => {
                Statement::Return(StatementReturn::from_syntax_node(db, node))
            }
            SyntaxKind::StatementBreak => {
                Statement::Break(StatementBreak::from_syntax_node(db, node))
            }
            SyntaxKind::StatementItem => Statement::Item(StatementItem::from_syntax_node(db, node)),
            SyntaxKind::StatementMissing => {
                Statement::Missing(StatementMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Statement"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::StatementLet => {
                Some(Statement::Let(StatementLet::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementExpr => {
                Some(Statement::Expr(StatementExpr::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementContinue => {
                Some(Statement::Continue(StatementContinue::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementReturn => {
                Some(Statement::Return(StatementReturn::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementBreak => {
                Some(Statement::Break(StatementBreak::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementItem => {
                Some(Statement::Item(StatementItem::from_syntax_node(db, node)))
            }
            SyntaxKind::StatementMissing => {
                Some(Statement::Missing(StatementMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Statement::Let(x) => x.as_syntax_node(),
            Statement::Expr(x) => x.as_syntax_node(),
            Statement::Continue(x) => x.as_syntax_node(),
            Statement::Return(x) => x.as_syntax_node(),
            Statement::Break(x) => x.as_syntax_node(),
            Statement::Item(x) => x.as_syntax_node(),
            Statement::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&Statement> for SyntaxStablePtrId {
    fn from(node: &Statement) -> Self {
        node.stable_ptr().untyped()
    }
}
impl Statement {
    /// Checks if a kind of a variant of [Statement].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::StatementLet
                | SyntaxKind::StatementExpr
                | SyntaxKind::StatementContinue
                | SyntaxKind::StatementReturn
                | SyntaxKind::StatementBreak
                | SyntaxKind::StatementItem
                | SyntaxKind::StatementMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementList(ElementList<Statement, 1>);
impl Deref for StatementList {
    type Target = ElementList<Statement, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl StatementList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<StatementGreen>) -> StatementListGreen {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        StatementListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for StatementListPtr {
    type SyntaxNode = StatementList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StatementList {
        StatementList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StatementListPtr> for SyntaxStablePtrId {
    fn from(ptr: StatementListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementListGreen(pub GreenId);
impl TypedSyntaxNode for StatementList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementList);
    type StablePtr = StatementListPtr;
    type Green = StatementListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::StatementList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementListPtr(self.node.0.stable_ptr)
    }
}
impl From<&StatementList> for SyntaxStablePtrId {
    fn from(node: &StatementList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementMissing {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StatementMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> StatementMissingGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StatementMissing {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementMissingPtr(pub SyntaxStablePtrId);
impl StatementMissingPtr {}
impl TypedStablePtr for StatementMissingPtr {
    type SyntaxNode = StatementMissing;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StatementMissing {
        StatementMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StatementMissingPtr> for SyntaxStablePtrId {
    fn from(ptr: StatementMissingPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementMissingGreen(pub GreenId);
impl TypedSyntaxNode for StatementMissing {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementMissing);
    type StablePtr = StatementMissingPtr;
    type Green = StatementMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementMissing
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementMissingPtr(self.node.0.stable_ptr)
    }
}
impl From<&StatementMissing> for SyntaxStablePtrId {
    fn from(node: &StatementMissing) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementLet {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StatementLet {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_LET_KW: usize = 1;
    pub const INDEX_PATTERN: usize = 2;
    pub const INDEX_TYPE_CLAUSE: usize = 3;
    pub const INDEX_EQ: usize = 4;
    pub const INDEX_RHS: usize = 5;
    pub const INDEX_SEMICOLON: usize = 6;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        let_kw: TerminalLetGreen,
        pattern: PatternGreen,
        type_clause: OptionTypeClauseGreen,
        eq: TerminalEqGreen,
        rhs: ExprGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> StatementLetGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, let_kw.0, pattern.0, type_clause.0, eq.0, rhs.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementLet,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StatementLet {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn let_kw(&self, db: &dyn SyntaxGroup) -> TerminalLet {
        TerminalLet::from_syntax_node(db, self.children[1].clone())
    }
    pub fn pattern(&self, db: &dyn SyntaxGroup) -> Pattern {
        Pattern::from_syntax_node(db, self.children[2].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> OptionTypeClause {
        OptionTypeClause::from_syntax_node(db, self.children[3].clone())
    }
    pub fn eq(&self, db: &dyn SyntaxGroup) -> TerminalEq {
        TerminalEq::from_syntax_node(db, self.children[4].clone())
    }
    pub fn rhs(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[5].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[6].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementLetPtr(pub SyntaxStablePtrId);
impl StatementLetPtr {
    pub fn pattern_green(self, db: &dyn SyntaxGroup) -> PatternGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            PatternGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for StatementLetPtr {
    type SyntaxNode = StatementLet;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StatementLet {
        StatementLet::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StatementLetPtr> for SyntaxStablePtrId {
    fn from(ptr: StatementLetPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementLetGreen(pub GreenId);
impl TypedSyntaxNode for StatementLet {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementLet);
    type StablePtr = StatementLetPtr;
    type Green = StatementLetGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementLet,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalLet::missing(db).0,
                        Pattern::missing(db).0,
                        OptionTypeClause::missing(db).0,
                        TerminalEq::missing(db).0,
                        Expr::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementLet,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementLet
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementLet { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementLetPtr(self.node.0.stable_ptr)
    }
}
impl From<&StatementLet> for SyntaxStablePtrId {
    fn from(node: &StatementLet) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTerminalSemicolon {
    Empty(OptionTerminalSemicolonEmpty),
    TerminalSemicolon(TerminalSemicolon),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalSemicolonPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionTerminalSemicolonPtr {
    type SyntaxNode = OptionTerminalSemicolon;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionTerminalSemicolon {
        OptionTerminalSemicolon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionTerminalSemicolonPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionTerminalSemicolonPtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionTerminalSemicolonEmptyPtr> for OptionTerminalSemicolonPtr {
    fn from(value: OptionTerminalSemicolonEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonPtr> for OptionTerminalSemicolonPtr {
    fn from(value: TerminalSemicolonPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionTerminalSemicolonEmptyGreen> for OptionTerminalSemicolonGreen {
    fn from(value: OptionTerminalSemicolonEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonGreen> for OptionTerminalSemicolonGreen {
    fn from(value: TerminalSemicolonGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalSemicolonGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalSemicolon {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalSemicolonPtr;
    type Green = OptionTerminalSemicolonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalSemicolonEmpty => OptionTerminalSemicolon::Empty(
                OptionTerminalSemicolonEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::TerminalSemicolon => OptionTerminalSemicolon::TerminalSemicolon(
                TerminalSemicolon::from_syntax_node(db, node),
            ),
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalSemicolon"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalSemicolonEmpty => Some(OptionTerminalSemicolon::Empty(
                OptionTerminalSemicolonEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalSemicolon => Some(OptionTerminalSemicolon::TerminalSemicolon(
                TerminalSemicolon::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTerminalSemicolon::Empty(x) => x.as_syntax_node(),
            OptionTerminalSemicolon::TerminalSemicolon(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalSemicolonPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionTerminalSemicolon> for SyntaxStablePtrId {
    fn from(node: &OptionTerminalSemicolon) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionTerminalSemicolon {
    /// Checks if a kind of a variant of [OptionTerminalSemicolon].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTerminalSemicolonEmpty | SyntaxKind::TerminalSemicolon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTerminalSemicolonEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionTerminalSemicolonEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionTerminalSemicolonEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTerminalSemicolonEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalSemicolonEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionTerminalSemicolonEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalSemicolonEmptyPtr(pub SyntaxStablePtrId);
impl OptionTerminalSemicolonEmptyPtr {}
impl TypedStablePtr for OptionTerminalSemicolonEmptyPtr {
    type SyntaxNode = OptionTerminalSemicolonEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionTerminalSemicolonEmpty {
        OptionTerminalSemicolonEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionTerminalSemicolonEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionTerminalSemicolonEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalSemicolonEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalSemicolonEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalSemicolonEmpty);
    type StablePtr = OptionTerminalSemicolonEmptyPtr;
    type Green = OptionTerminalSemicolonEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionTerminalSemicolonEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalSemicolonEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalSemicolonEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalSemicolonEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTerminalSemicolonEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalSemicolonEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionTerminalSemicolonEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionTerminalSemicolonEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementExpr {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StatementExpr {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_EXPR: usize = 1;
    pub const INDEX_SEMICOLON: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        expr: ExprGreen,
        semicolon: OptionTerminalSemicolonGreen,
    ) -> StatementExprGreen {
        let children: Vec<GreenId> = vec![attributes.0, expr.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StatementExpr {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> OptionTerminalSemicolon {
        OptionTerminalSemicolon::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementExprPtr(pub SyntaxStablePtrId);
impl StatementExprPtr {}
impl TypedStablePtr for StatementExprPtr {
    type SyntaxNode = StatementExpr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StatementExpr {
        StatementExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StatementExprPtr> for SyntaxStablePtrId {
    fn from(ptr: StatementExprPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementExprGreen(pub GreenId);
impl TypedSyntaxNode for StatementExpr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementExpr);
    type StablePtr = StatementExprPtr;
    type Green = StatementExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementExpr,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Expr::missing(db).0,
                        OptionTerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementExpr
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementExpr {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementExprPtr(self.node.0.stable_ptr)
    }
}
impl From<&StatementExpr> for SyntaxStablePtrId {
    fn from(node: &StatementExpr) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementContinue {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StatementContinue {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_CONTINUE_KW: usize = 1;
    pub const INDEX_SEMICOLON: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        continue_kw: TerminalContinueGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> StatementContinueGreen {
        let children: Vec<GreenId> = vec![attributes.0, continue_kw.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementContinue,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StatementContinue {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn continue_kw(&self, db: &dyn SyntaxGroup) -> TerminalContinue {
        TerminalContinue::from_syntax_node(db, self.children[1].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementContinuePtr(pub SyntaxStablePtrId);
impl StatementContinuePtr {}
impl TypedStablePtr for StatementContinuePtr {
    type SyntaxNode = StatementContinue;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StatementContinue {
        StatementContinue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StatementContinuePtr> for SyntaxStablePtrId {
    fn from(ptr: StatementContinuePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementContinueGreen(pub GreenId);
impl TypedSyntaxNode for StatementContinue {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementContinue);
    type StablePtr = StatementContinuePtr;
    type Green = StatementContinueGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementContinue,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalContinue::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementContinue,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementContinue
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementContinue {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementContinuePtr(self.node.0.stable_ptr)
    }
}
impl From<&StatementContinue> for SyntaxStablePtrId {
    fn from(node: &StatementContinue) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ExprClause {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ExprClause {
    pub const INDEX_EXPR: usize = 0;
    pub fn new_green(db: &dyn SyntaxGroup, expr: ExprGreen) -> ExprClauseGreen {
        let children: Vec<GreenId> = vec![expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ExprClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ExprClause {
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprClausePtr(pub SyntaxStablePtrId);
impl ExprClausePtr {}
impl TypedStablePtr for ExprClausePtr {
    type SyntaxNode = ExprClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ExprClause {
        ExprClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ExprClausePtr> for SyntaxStablePtrId {
    fn from(ptr: ExprClausePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ExprClauseGreen(pub GreenId);
impl TypedSyntaxNode for ExprClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ExprClause);
    type StablePtr = ExprClausePtr;
    type Green = ExprClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ExprClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ExprClause,
                details: GreenNodeDetails::Node {
                    children: vec![Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ExprClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ExprClause
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ExprClause { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ExprClausePtr(self.node.0.stable_ptr)
    }
}
impl From<&ExprClause> for SyntaxStablePtrId {
    fn from(node: &ExprClause) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionExprClause {
    Empty(OptionExprClauseEmpty),
    ExprClause(ExprClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionExprClausePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionExprClausePtr {
    type SyntaxNode = OptionExprClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionExprClause {
        OptionExprClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionExprClausePtr> for SyntaxStablePtrId {
    fn from(ptr: OptionExprClausePtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionExprClauseEmptyPtr> for OptionExprClausePtr {
    fn from(value: OptionExprClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprClausePtr> for OptionExprClausePtr {
    fn from(value: ExprClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionExprClauseEmptyGreen> for OptionExprClauseGreen {
    fn from(value: OptionExprClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ExprClauseGreen> for OptionExprClauseGreen {
    fn from(value: ExprClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionExprClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionExprClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionExprClausePtr;
    type Green = OptionExprClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionExprClauseEmpty => {
                OptionExprClause::Empty(OptionExprClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::ExprClause => {
                OptionExprClause::ExprClause(ExprClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionExprClause"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionExprClauseEmpty => {
                Some(OptionExprClause::Empty(OptionExprClauseEmpty::from_syntax_node(db, node)))
            }
            SyntaxKind::ExprClause => {
                Some(OptionExprClause::ExprClause(ExprClause::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionExprClause::Empty(x) => x.as_syntax_node(),
            OptionExprClause::ExprClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionExprClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionExprClause> for SyntaxStablePtrId {
    fn from(node: &OptionExprClause) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionExprClause {
    /// Checks if a kind of a variant of [OptionExprClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionExprClauseEmpty | SyntaxKind::ExprClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionExprClauseEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionExprClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionExprClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionExprClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionExprClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionExprClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionExprClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionExprClauseEmptyPtr {}
impl TypedStablePtr for OptionExprClauseEmptyPtr {
    type SyntaxNode = OptionExprClauseEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionExprClauseEmpty {
        OptionExprClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionExprClauseEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionExprClauseEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionExprClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionExprClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionExprClauseEmpty);
    type StablePtr = OptionExprClauseEmptyPtr;
    type Green = OptionExprClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionExprClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionExprClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionExprClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionExprClauseEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionExprClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionExprClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionExprClauseEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionExprClauseEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementReturn {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StatementReturn {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_RETURN_KW: usize = 1;
    pub const INDEX_EXPR_CLAUSE: usize = 2;
    pub const INDEX_SEMICOLON: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        return_kw: TerminalReturnGreen,
        expr_clause: OptionExprClauseGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> StatementReturnGreen {
        let children: Vec<GreenId> = vec![attributes.0, return_kw.0, expr_clause.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementReturn,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StatementReturn {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn return_kw(&self, db: &dyn SyntaxGroup) -> TerminalReturn {
        TerminalReturn::from_syntax_node(db, self.children[1].clone())
    }
    pub fn expr_clause(&self, db: &dyn SyntaxGroup) -> OptionExprClause {
        OptionExprClause::from_syntax_node(db, self.children[2].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementReturnPtr(pub SyntaxStablePtrId);
impl StatementReturnPtr {}
impl TypedStablePtr for StatementReturnPtr {
    type SyntaxNode = StatementReturn;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StatementReturn {
        StatementReturn::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StatementReturnPtr> for SyntaxStablePtrId {
    fn from(ptr: StatementReturnPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementReturnGreen(pub GreenId);
impl TypedSyntaxNode for StatementReturn {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementReturn);
    type StablePtr = StatementReturnPtr;
    type Green = StatementReturnGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementReturn,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalReturn::missing(db).0,
                        OptionExprClause::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementReturn,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementReturn
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementReturn {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementReturnPtr(self.node.0.stable_ptr)
    }
}
impl From<&StatementReturn> for SyntaxStablePtrId {
    fn from(node: &StatementReturn) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementBreak {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StatementBreak {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_BREAK_KW: usize = 1;
    pub const INDEX_EXPR_CLAUSE: usize = 2;
    pub const INDEX_SEMICOLON: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        break_kw: TerminalBreakGreen,
        expr_clause: OptionExprClauseGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> StatementBreakGreen {
        let children: Vec<GreenId> = vec![attributes.0, break_kw.0, expr_clause.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementBreak,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StatementBreak {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn break_kw(&self, db: &dyn SyntaxGroup) -> TerminalBreak {
        TerminalBreak::from_syntax_node(db, self.children[1].clone())
    }
    pub fn expr_clause(&self, db: &dyn SyntaxGroup) -> OptionExprClause {
        OptionExprClause::from_syntax_node(db, self.children[2].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementBreakPtr(pub SyntaxStablePtrId);
impl StatementBreakPtr {}
impl TypedStablePtr for StatementBreakPtr {
    type SyntaxNode = StatementBreak;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StatementBreak {
        StatementBreak::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StatementBreakPtr> for SyntaxStablePtrId {
    fn from(ptr: StatementBreakPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementBreakGreen(pub GreenId);
impl TypedSyntaxNode for StatementBreak {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementBreak);
    type StablePtr = StatementBreakPtr;
    type Green = StatementBreakGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementBreak,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalBreak::missing(db).0,
                        OptionExprClause::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementBreak,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementBreak
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementBreak {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementBreakPtr(self.node.0.stable_ptr)
    }
}
impl From<&StatementBreak> for SyntaxStablePtrId {
    fn from(node: &StatementBreak) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct StatementItem {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl StatementItem {
    pub const INDEX_ITEM: usize = 0;
    pub fn new_green(db: &dyn SyntaxGroup, item: ModuleItemGreen) -> StatementItemGreen {
        let children: Vec<GreenId> = vec![item.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        StatementItemGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementItem,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl StatementItem {
    pub fn item(&self, db: &dyn SyntaxGroup) -> ModuleItem {
        ModuleItem::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementItemPtr(pub SyntaxStablePtrId);
impl StatementItemPtr {}
impl TypedStablePtr for StatementItemPtr {
    type SyntaxNode = StatementItem;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> StatementItem {
        StatementItem::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<StatementItemPtr> for SyntaxStablePtrId {
    fn from(ptr: StatementItemPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct StatementItemGreen(pub GreenId);
impl TypedSyntaxNode for StatementItem {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::StatementItem);
    type StablePtr = StatementItemPtr;
    type Green = StatementItemGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        StatementItemGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::StatementItem,
                details: GreenNodeDetails::Node {
                    children: vec![ModuleItem::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::StatementItem,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::StatementItem
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::StatementItem {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        StatementItemPtr(self.node.0.stable_ptr)
    }
}
impl From<&StatementItem> for SyntaxStablePtrId {
    fn from(node: &StatementItem) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Param {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Param {
    pub const INDEX_MODIFIERS: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_TYPE_CLAUSE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        modifiers: ModifierListGreen,
        name: TerminalIdentifierGreen,
        type_clause: OptionTypeClauseGreen,
    ) -> ParamGreen {
        let children: Vec<GreenId> = vec![modifiers.0, name.0, type_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ParamGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Param,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl Param {
    pub fn modifiers(&self, db: &dyn SyntaxGroup) -> ModifierList {
        ModifierList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> OptionTypeClause {
        OptionTypeClause::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamPtr(pub SyntaxStablePtrId);
impl ParamPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ParamPtr {
    type SyntaxNode = Param;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Param {
        Param::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ParamPtr> for SyntaxStablePtrId {
    fn from(ptr: ParamPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamGreen(pub GreenId);
impl TypedSyntaxNode for Param {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Param);
    type StablePtr = ParamPtr;
    type Green = ParamGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ParamGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Param,
                details: GreenNodeDetails::Node {
                    children: vec![
                        ModifierList::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionTypeClause::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Param,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Param
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::Param { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamPtr(self.node.0.stable_ptr)
    }
}
impl From<&Param> for SyntaxStablePtrId {
    fn from(node: &Param) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ModifierList(ElementList<Modifier, 1>);
impl Deref for ModifierList {
    type Target = ElementList<Modifier, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ModifierList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<ModifierGreen>) -> ModifierListGreen {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        ModifierListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModifierList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModifierListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ModifierListPtr {
    type SyntaxNode = ModifierList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ModifierList {
        ModifierList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ModifierListPtr> for SyntaxStablePtrId {
    fn from(ptr: ModifierListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModifierListGreen(pub GreenId);
impl TypedSyntaxNode for ModifierList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ModifierList);
    type StablePtr = ModifierListPtr;
    type Green = ModifierListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ModifierListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModifierList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ModifierList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ModifierListPtr(self.node.0.stable_ptr)
    }
}
impl From<&ModifierList> for SyntaxStablePtrId {
    fn from(node: &ModifierList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Modifier {
    Ref(TerminalRef),
    Mut(TerminalMut),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModifierPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ModifierPtr {
    type SyntaxNode = Modifier;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Modifier {
        Modifier::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ModifierPtr> for SyntaxStablePtrId {
    fn from(ptr: ModifierPtr) -> Self {
        ptr.untyped()
    }
}
impl From<TerminalRefPtr> for ModifierPtr {
    fn from(value: TerminalRefPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMutPtr> for ModifierPtr {
    fn from(value: TerminalMutPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalRefGreen> for ModifierGreen {
    fn from(value: TerminalRefGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMutGreen> for ModifierGreen {
    fn from(value: TerminalMutGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModifierGreen(pub GreenId);
impl TypedSyntaxNode for Modifier {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ModifierPtr;
    type Green = ModifierGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalRef => Modifier::Ref(TerminalRef::from_syntax_node(db, node)),
            SyntaxKind::TerminalMut => Modifier::Mut(TerminalMut::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Modifier"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalRef => Some(Modifier::Ref(TerminalRef::from_syntax_node(db, node))),
            SyntaxKind::TerminalMut => Some(Modifier::Mut(TerminalMut::from_syntax_node(db, node))),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Modifier::Ref(x) => x.as_syntax_node(),
            Modifier::Mut(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ModifierPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&Modifier> for SyntaxStablePtrId {
    fn from(node: &Modifier) -> Self {
        node.stable_ptr().untyped()
    }
}
impl Modifier {
    /// Checks if a kind of a variant of [Modifier].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::TerminalRef | SyntaxKind::TerminalMut)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ParamList(ElementList<Param, 2>);
impl Deref for ParamList {
    type Target = ElementList<Param, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ParamList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ParamListElementOrSeparatorGreen>,
    ) -> ParamListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        ParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParamList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ParamListPtr {
    type SyntaxNode = ParamList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ParamListPtr> for SyntaxStablePtrId {
    fn from(ptr: ParamListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ParamListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(ParamGreen),
}
impl From<TerminalCommaGreen> for ParamListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        ParamListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ParamGreen> for ParamListElementOrSeparatorGreen {
    fn from(value: ParamGreen) -> Self {
        ParamListElementOrSeparatorGreen::Element(value)
    }
}
impl ParamListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ParamListElementOrSeparatorGreen::Separator(green) => green.0,
            ParamListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ParamListGreen(pub GreenId);
impl TypedSyntaxNode for ParamList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ParamList);
    type StablePtr = ParamListPtr;
    type Green = ParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ParamList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ParamList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ParamListPtr(self.node.0.stable_ptr)
    }
}
impl From<&ParamList> for SyntaxStablePtrId {
    fn from(node: &ParamList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ImplicitsClause {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ImplicitsClause {
    pub const INDEX_IMPLICITS_KW: usize = 0;
    pub const INDEX_LPAREN: usize = 1;
    pub const INDEX_IMPLICITS: usize = 2;
    pub const INDEX_RPAREN: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        implicits_kw: TerminalImplicitsGreen,
        lparen: TerminalLParenGreen,
        implicits: ImplicitsListGreen,
        rparen: TerminalRParenGreen,
    ) -> ImplicitsClauseGreen {
        let children: Vec<GreenId> = vec![implicits_kw.0, lparen.0, implicits.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ImplicitsClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplicitsClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ImplicitsClause {
    pub fn implicits_kw(&self, db: &dyn SyntaxGroup) -> TerminalImplicits {
        TerminalImplicits::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[1].clone())
    }
    pub fn implicits(&self, db: &dyn SyntaxGroup) -> ImplicitsList {
        ImplicitsList::from_syntax_node(db, self.children[2].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplicitsClausePtr(pub SyntaxStablePtrId);
impl ImplicitsClausePtr {}
impl TypedStablePtr for ImplicitsClausePtr {
    type SyntaxNode = ImplicitsClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ImplicitsClause {
        ImplicitsClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ImplicitsClausePtr> for SyntaxStablePtrId {
    fn from(ptr: ImplicitsClausePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplicitsClauseGreen(pub GreenId);
impl TypedSyntaxNode for ImplicitsClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplicitsClause);
    type StablePtr = ImplicitsClausePtr;
    type Green = ImplicitsClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ImplicitsClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplicitsClause,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalImplicits::missing(db).0,
                        TerminalLParen::missing(db).0,
                        ImplicitsList::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ImplicitsClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ImplicitsClause
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ImplicitsClause {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ImplicitsClausePtr(self.node.0.stable_ptr)
    }
}
impl From<&ImplicitsClause> for SyntaxStablePtrId {
    fn from(node: &ImplicitsClause) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ImplicitsList(ElementList<ExprPath, 2>);
impl Deref for ImplicitsList {
    type Target = ElementList<ExprPath, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ImplicitsList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<ImplicitsListElementOrSeparatorGreen>,
    ) -> ImplicitsListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        ImplicitsListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplicitsList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplicitsListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ImplicitsListPtr {
    type SyntaxNode = ImplicitsList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ImplicitsList {
        ImplicitsList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ImplicitsListPtr> for SyntaxStablePtrId {
    fn from(ptr: ImplicitsListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum ImplicitsListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(ExprPathGreen),
}
impl From<TerminalCommaGreen> for ImplicitsListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        ImplicitsListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<ExprPathGreen> for ImplicitsListElementOrSeparatorGreen {
    fn from(value: ExprPathGreen) -> Self {
        ImplicitsListElementOrSeparatorGreen::Element(value)
    }
}
impl ImplicitsListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            ImplicitsListElementOrSeparatorGreen::Separator(green) => green.0,
            ImplicitsListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplicitsListGreen(pub GreenId);
impl TypedSyntaxNode for ImplicitsList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplicitsList);
    type StablePtr = ImplicitsListPtr;
    type Green = ImplicitsListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ImplicitsListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplicitsList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ImplicitsList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ImplicitsListPtr(self.node.0.stable_ptr)
    }
}
impl From<&ImplicitsList> for SyntaxStablePtrId {
    fn from(node: &ImplicitsList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionImplicitsClause {
    Empty(OptionImplicitsClauseEmpty),
    ImplicitsClause(ImplicitsClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionImplicitsClausePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionImplicitsClausePtr {
    type SyntaxNode = OptionImplicitsClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionImplicitsClause {
        OptionImplicitsClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionImplicitsClausePtr> for SyntaxStablePtrId {
    fn from(ptr: OptionImplicitsClausePtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionImplicitsClauseEmptyPtr> for OptionImplicitsClausePtr {
    fn from(value: OptionImplicitsClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<ImplicitsClausePtr> for OptionImplicitsClausePtr {
    fn from(value: ImplicitsClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionImplicitsClauseEmptyGreen> for OptionImplicitsClauseGreen {
    fn from(value: OptionImplicitsClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ImplicitsClauseGreen> for OptionImplicitsClauseGreen {
    fn from(value: ImplicitsClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionImplicitsClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionImplicitsClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionImplicitsClausePtr;
    type Green = OptionImplicitsClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionImplicitsClauseEmpty => {
                OptionImplicitsClause::Empty(OptionImplicitsClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::ImplicitsClause => {
                OptionImplicitsClause::ImplicitsClause(ImplicitsClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionImplicitsClause"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionImplicitsClauseEmpty => Some(OptionImplicitsClause::Empty(
                OptionImplicitsClauseEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::ImplicitsClause => Some(OptionImplicitsClause::ImplicitsClause(
                ImplicitsClause::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionImplicitsClause::Empty(x) => x.as_syntax_node(),
            OptionImplicitsClause::ImplicitsClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionImplicitsClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionImplicitsClause> for SyntaxStablePtrId {
    fn from(node: &OptionImplicitsClause) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionImplicitsClause {
    /// Checks if a kind of a variant of [OptionImplicitsClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionImplicitsClauseEmpty | SyntaxKind::ImplicitsClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionImplicitsClauseEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionImplicitsClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionImplicitsClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionImplicitsClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionImplicitsClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionImplicitsClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionImplicitsClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionImplicitsClauseEmptyPtr {}
impl TypedStablePtr for OptionImplicitsClauseEmptyPtr {
    type SyntaxNode = OptionImplicitsClauseEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionImplicitsClauseEmpty {
        OptionImplicitsClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionImplicitsClauseEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionImplicitsClauseEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionImplicitsClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionImplicitsClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionImplicitsClauseEmpty);
    type StablePtr = OptionImplicitsClauseEmptyPtr;
    type Green = OptionImplicitsClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionImplicitsClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionImplicitsClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionImplicitsClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionImplicitsClauseEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionImplicitsClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionImplicitsClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionImplicitsClauseEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionImplicitsClauseEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTerminalNoPanic {
    Empty(OptionTerminalNoPanicEmpty),
    TerminalNoPanic(TerminalNoPanic),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalNoPanicPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionTerminalNoPanicPtr {
    type SyntaxNode = OptionTerminalNoPanic;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionTerminalNoPanic {
        OptionTerminalNoPanic::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionTerminalNoPanicPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionTerminalNoPanicPtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionTerminalNoPanicEmptyPtr> for OptionTerminalNoPanicPtr {
    fn from(value: OptionTerminalNoPanicEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNoPanicPtr> for OptionTerminalNoPanicPtr {
    fn from(value: TerminalNoPanicPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionTerminalNoPanicEmptyGreen> for OptionTerminalNoPanicGreen {
    fn from(value: OptionTerminalNoPanicEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNoPanicGreen> for OptionTerminalNoPanicGreen {
    fn from(value: TerminalNoPanicGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalNoPanicGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalNoPanic {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalNoPanicPtr;
    type Green = OptionTerminalNoPanicGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalNoPanicEmpty => {
                OptionTerminalNoPanic::Empty(OptionTerminalNoPanicEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNoPanic => {
                OptionTerminalNoPanic::TerminalNoPanic(TerminalNoPanic::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalNoPanic"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalNoPanicEmpty => Some(OptionTerminalNoPanic::Empty(
                OptionTerminalNoPanicEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalNoPanic => Some(OptionTerminalNoPanic::TerminalNoPanic(
                TerminalNoPanic::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTerminalNoPanic::Empty(x) => x.as_syntax_node(),
            OptionTerminalNoPanic::TerminalNoPanic(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalNoPanicPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionTerminalNoPanic> for SyntaxStablePtrId {
    fn from(node: &OptionTerminalNoPanic) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionTerminalNoPanic {
    /// Checks if a kind of a variant of [OptionTerminalNoPanic].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTerminalNoPanicEmpty | SyntaxKind::TerminalNoPanic)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTerminalNoPanicEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionTerminalNoPanicEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionTerminalNoPanicEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTerminalNoPanicEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalNoPanicEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionTerminalNoPanicEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalNoPanicEmptyPtr(pub SyntaxStablePtrId);
impl OptionTerminalNoPanicEmptyPtr {}
impl TypedStablePtr for OptionTerminalNoPanicEmptyPtr {
    type SyntaxNode = OptionTerminalNoPanicEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionTerminalNoPanicEmpty {
        OptionTerminalNoPanicEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionTerminalNoPanicEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionTerminalNoPanicEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalNoPanicEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalNoPanicEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalNoPanicEmpty);
    type StablePtr = OptionTerminalNoPanicEmptyPtr;
    type Green = OptionTerminalNoPanicEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionTerminalNoPanicEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalNoPanicEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalNoPanicEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalNoPanicEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTerminalNoPanicEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalNoPanicEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionTerminalNoPanicEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionTerminalNoPanicEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionTerminalConst {
    Empty(OptionTerminalConstEmpty),
    TerminalConst(TerminalConst),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalConstPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionTerminalConstPtr {
    type SyntaxNode = OptionTerminalConst;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionTerminalConst {
        OptionTerminalConst::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionTerminalConstPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionTerminalConstPtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionTerminalConstEmptyPtr> for OptionTerminalConstPtr {
    fn from(value: OptionTerminalConstEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalConstPtr> for OptionTerminalConstPtr {
    fn from(value: TerminalConstPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionTerminalConstEmptyGreen> for OptionTerminalConstGreen {
    fn from(value: OptionTerminalConstEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalConstGreen> for OptionTerminalConstGreen {
    fn from(value: TerminalConstGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalConstGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalConst {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionTerminalConstPtr;
    type Green = OptionTerminalConstGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalConstEmpty => {
                OptionTerminalConst::Empty(OptionTerminalConstEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalConst => {
                OptionTerminalConst::TerminalConst(TerminalConst::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionTerminalConst"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionTerminalConstEmpty => Some(OptionTerminalConst::Empty(
                OptionTerminalConstEmpty::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalConst => {
                Some(OptionTerminalConst::TerminalConst(TerminalConst::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionTerminalConst::Empty(x) => x.as_syntax_node(),
            OptionTerminalConst::TerminalConst(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalConstPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionTerminalConst> for SyntaxStablePtrId {
    fn from(node: &OptionTerminalConst) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionTerminalConst {
    /// Checks if a kind of a variant of [OptionTerminalConst].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionTerminalConstEmpty | SyntaxKind::TerminalConst)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionTerminalConstEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionTerminalConstEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionTerminalConstEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionTerminalConstEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalConstEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionTerminalConstEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalConstEmptyPtr(pub SyntaxStablePtrId);
impl OptionTerminalConstEmptyPtr {}
impl TypedStablePtr for OptionTerminalConstEmptyPtr {
    type SyntaxNode = OptionTerminalConstEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionTerminalConstEmpty {
        OptionTerminalConstEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionTerminalConstEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionTerminalConstEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionTerminalConstEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionTerminalConstEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionTerminalConstEmpty);
    type StablePtr = OptionTerminalConstEmptyPtr;
    type Green = OptionTerminalConstEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionTerminalConstEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionTerminalConstEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionTerminalConstEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionTerminalConstEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionTerminalConstEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionTerminalConstEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionTerminalConstEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionTerminalConstEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct FunctionSignature {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl FunctionSignature {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_PARAMETERS: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub const INDEX_RET_TY: usize = 3;
    pub const INDEX_IMPLICITS_CLAUSE: usize = 4;
    pub const INDEX_OPTIONAL_NO_PANIC: usize = 5;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        parameters: ParamListGreen,
        rparen: TerminalRParenGreen,
        ret_ty: OptionReturnTypeClauseGreen,
        implicits_clause: OptionImplicitsClauseGreen,
        optional_no_panic: OptionTerminalNoPanicGreen,
    ) -> FunctionSignatureGreen {
        let children: Vec<GreenId> = vec![
            lparen.0,
            parameters.0,
            rparen.0,
            ret_ty.0,
            implicits_clause.0,
            optional_no_panic.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        FunctionSignatureGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionSignature,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl FunctionSignature {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn parameters(&self, db: &dyn SyntaxGroup) -> ParamList {
        ParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
    pub fn ret_ty(&self, db: &dyn SyntaxGroup) -> OptionReturnTypeClause {
        OptionReturnTypeClause::from_syntax_node(db, self.children[3].clone())
    }
    pub fn implicits_clause(&self, db: &dyn SyntaxGroup) -> OptionImplicitsClause {
        OptionImplicitsClause::from_syntax_node(db, self.children[4].clone())
    }
    pub fn optional_no_panic(&self, db: &dyn SyntaxGroup) -> OptionTerminalNoPanic {
        OptionTerminalNoPanic::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FunctionSignaturePtr(pub SyntaxStablePtrId);
impl FunctionSignaturePtr {}
impl TypedStablePtr for FunctionSignaturePtr {
    type SyntaxNode = FunctionSignature;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<FunctionSignaturePtr> for SyntaxStablePtrId {
    fn from(ptr: FunctionSignaturePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FunctionSignatureGreen(pub GreenId);
impl TypedSyntaxNode for FunctionSignature {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::FunctionSignature);
    type StablePtr = FunctionSignaturePtr;
    type Green = FunctionSignatureGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        FunctionSignatureGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionSignature,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        ParamList::missing(db).0,
                        TerminalRParen::missing(db).0,
                        OptionReturnTypeClause::missing(db).0,
                        OptionImplicitsClause::missing(db).0,
                        OptionTerminalNoPanic::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::FunctionSignature,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::FunctionSignature
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::FunctionSignature {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        FunctionSignaturePtr(self.node.0.stable_ptr)
    }
}
impl From<&FunctionSignature> for SyntaxStablePtrId {
    fn from(node: &FunctionSignature) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Member {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Member {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_NAME: usize = 2;
    pub const INDEX_TYPE_CLAUSE: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        name: TerminalIdentifierGreen,
        type_clause: TypeClauseGreen,
    ) -> MemberGreen {
        let children: Vec<GreenId> = vec![attributes.0, visibility.0, name.0, type_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        MemberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Member,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl Member {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> TypeClause {
        TypeClause::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MemberPtr(pub SyntaxStablePtrId);
impl MemberPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for MemberPtr {
    type SyntaxNode = Member;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Member {
        Member::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<MemberPtr> for SyntaxStablePtrId {
    fn from(ptr: MemberPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MemberGreen(pub GreenId);
impl TypedSyntaxNode for Member {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Member);
    type StablePtr = MemberPtr;
    type Green = MemberGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        MemberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Member,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TypeClause::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Member,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Member
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::Member { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MemberPtr(self.node.0.stable_ptr)
    }
}
impl From<&Member> for SyntaxStablePtrId {
    fn from(node: &Member) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MemberList(ElementList<Member, 2>);
impl Deref for MemberList {
    type Target = ElementList<Member, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl MemberList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<MemberListElementOrSeparatorGreen>,
    ) -> MemberListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        MemberListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MemberList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MemberListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for MemberListPtr {
    type SyntaxNode = MemberList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> MemberList {
        MemberList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<MemberListPtr> for SyntaxStablePtrId {
    fn from(ptr: MemberListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum MemberListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(MemberGreen),
}
impl From<TerminalCommaGreen> for MemberListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        MemberListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<MemberGreen> for MemberListElementOrSeparatorGreen {
    fn from(value: MemberGreen) -> Self {
        MemberListElementOrSeparatorGreen::Element(value)
    }
}
impl MemberListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            MemberListElementOrSeparatorGreen::Separator(green) => green.0,
            MemberListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MemberListGreen(pub GreenId);
impl TypedSyntaxNode for MemberList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::MemberList);
    type StablePtr = MemberListPtr;
    type Green = MemberListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        MemberListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::MemberList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::MemberList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MemberListPtr(self.node.0.stable_ptr)
    }
}
impl From<&MemberList> for SyntaxStablePtrId {
    fn from(node: &MemberList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Variant {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Variant {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_TYPE_CLAUSE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        name: TerminalIdentifierGreen,
        type_clause: OptionTypeClauseGreen,
    ) -> VariantGreen {
        let children: Vec<GreenId> = vec![attributes.0, name.0, type_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        VariantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Variant,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl Variant {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> OptionTypeClause {
        OptionTypeClause::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VariantPtr(pub SyntaxStablePtrId);
impl VariantPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for VariantPtr {
    type SyntaxNode = Variant;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Variant {
        Variant::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<VariantPtr> for SyntaxStablePtrId {
    fn from(ptr: VariantPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VariantGreen(pub GreenId);
impl TypedSyntaxNode for Variant {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Variant);
    type StablePtr = VariantPtr;
    type Green = VariantGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        VariantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Variant,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionTypeClause::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Variant,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Variant
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::Variant { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        VariantPtr(self.node.0.stable_ptr)
    }
}
impl From<&Variant> for SyntaxStablePtrId {
    fn from(node: &Variant) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct VariantList(ElementList<Variant, 2>);
impl Deref for VariantList {
    type Target = ElementList<Variant, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl VariantList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<VariantListElementOrSeparatorGreen>,
    ) -> VariantListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        VariantListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VariantList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VariantListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for VariantListPtr {
    type SyntaxNode = VariantList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> VariantList {
        VariantList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<VariantListPtr> for SyntaxStablePtrId {
    fn from(ptr: VariantListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum VariantListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(VariantGreen),
}
impl From<TerminalCommaGreen> for VariantListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        VariantListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<VariantGreen> for VariantListElementOrSeparatorGreen {
    fn from(value: VariantGreen) -> Self {
        VariantListElementOrSeparatorGreen::Element(value)
    }
}
impl VariantListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            VariantListElementOrSeparatorGreen::Separator(green) => green.0,
            VariantListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VariantListGreen(pub GreenId);
impl TypedSyntaxNode for VariantList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::VariantList);
    type StablePtr = VariantListPtr;
    type Green = VariantListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        VariantListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VariantList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::VariantList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        VariantListPtr(self.node.0.stable_ptr)
    }
}
impl From<&VariantList> for SyntaxStablePtrId {
    fn from(node: &VariantList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum ModuleItem {
    Constant(ItemConstant),
    Module(ItemModule),
    Use(ItemUse),
    FreeFunction(FunctionWithBody),
    ExternFunction(ItemExternFunction),
    ExternType(ItemExternType),
    Trait(ItemTrait),
    Impl(ItemImpl),
    ImplAlias(ItemImplAlias),
    Struct(ItemStruct),
    Enum(ItemEnum),
    TypeAlias(ItemTypeAlias),
    InlineMacro(ItemInlineMacro),
    HeaderDoc(ItemHeaderDoc),
    Missing(ModuleItemMissing),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModuleItemPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ModuleItemPtr {
    type SyntaxNode = ModuleItem;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ModuleItem {
        ModuleItem::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ModuleItemPtr> for SyntaxStablePtrId {
    fn from(ptr: ModuleItemPtr) -> Self {
        ptr.untyped()
    }
}
impl From<ItemConstantPtr> for ModuleItemPtr {
    fn from(value: ItemConstantPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemModulePtr> for ModuleItemPtr {
    fn from(value: ItemModulePtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemUsePtr> for ModuleItemPtr {
    fn from(value: ItemUsePtr) -> Self {
        Self(value.0)
    }
}
impl From<FunctionWithBodyPtr> for ModuleItemPtr {
    fn from(value: FunctionWithBodyPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternFunctionPtr> for ModuleItemPtr {
    fn from(value: ItemExternFunctionPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternTypePtr> for ModuleItemPtr {
    fn from(value: ItemExternTypePtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemTraitPtr> for ModuleItemPtr {
    fn from(value: ItemTraitPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemImplPtr> for ModuleItemPtr {
    fn from(value: ItemImplPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemImplAliasPtr> for ModuleItemPtr {
    fn from(value: ItemImplAliasPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemStructPtr> for ModuleItemPtr {
    fn from(value: ItemStructPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemEnumPtr> for ModuleItemPtr {
    fn from(value: ItemEnumPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemTypeAliasPtr> for ModuleItemPtr {
    fn from(value: ItemTypeAliasPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemInlineMacroPtr> for ModuleItemPtr {
    fn from(value: ItemInlineMacroPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemHeaderDocPtr> for ModuleItemPtr {
    fn from(value: ItemHeaderDocPtr) -> Self {
        Self(value.0)
    }
}
impl From<ModuleItemMissingPtr> for ModuleItemPtr {
    fn from(value: ModuleItemMissingPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemConstantGreen> for ModuleItemGreen {
    fn from(value: ItemConstantGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemModuleGreen> for ModuleItemGreen {
    fn from(value: ItemModuleGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemUseGreen> for ModuleItemGreen {
    fn from(value: ItemUseGreen) -> Self {
        Self(value.0)
    }
}
impl From<FunctionWithBodyGreen> for ModuleItemGreen {
    fn from(value: FunctionWithBodyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternFunctionGreen> for ModuleItemGreen {
    fn from(value: ItemExternFunctionGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternTypeGreen> for ModuleItemGreen {
    fn from(value: ItemExternTypeGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemTraitGreen> for ModuleItemGreen {
    fn from(value: ItemTraitGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemImplGreen> for ModuleItemGreen {
    fn from(value: ItemImplGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemImplAliasGreen> for ModuleItemGreen {
    fn from(value: ItemImplAliasGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemStructGreen> for ModuleItemGreen {
    fn from(value: ItemStructGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemEnumGreen> for ModuleItemGreen {
    fn from(value: ItemEnumGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemTypeAliasGreen> for ModuleItemGreen {
    fn from(value: ItemTypeAliasGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemInlineMacroGreen> for ModuleItemGreen {
    fn from(value: ItemInlineMacroGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemHeaderDocGreen> for ModuleItemGreen {
    fn from(value: ItemHeaderDocGreen) -> Self {
        Self(value.0)
    }
}
impl From<ModuleItemMissingGreen> for ModuleItemGreen {
    fn from(value: ModuleItemMissingGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModuleItemGreen(pub GreenId);
impl TypedSyntaxNode for ModuleItem {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ModuleItemPtr;
    type Green = ModuleItemGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ModuleItemGreen(ModuleItemMissing::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ItemConstant => {
                ModuleItem::Constant(ItemConstant::from_syntax_node(db, node))
            }
            SyntaxKind::ItemModule => ModuleItem::Module(ItemModule::from_syntax_node(db, node)),
            SyntaxKind::ItemUse => ModuleItem::Use(ItemUse::from_syntax_node(db, node)),
            SyntaxKind::FunctionWithBody => {
                ModuleItem::FreeFunction(FunctionWithBody::from_syntax_node(db, node))
            }
            SyntaxKind::ItemExternFunction => {
                ModuleItem::ExternFunction(ItemExternFunction::from_syntax_node(db, node))
            }
            SyntaxKind::ItemExternType => {
                ModuleItem::ExternType(ItemExternType::from_syntax_node(db, node))
            }
            SyntaxKind::ItemTrait => ModuleItem::Trait(ItemTrait::from_syntax_node(db, node)),
            SyntaxKind::ItemImpl => ModuleItem::Impl(ItemImpl::from_syntax_node(db, node)),
            SyntaxKind::ItemImplAlias => {
                ModuleItem::ImplAlias(ItemImplAlias::from_syntax_node(db, node))
            }
            SyntaxKind::ItemStruct => ModuleItem::Struct(ItemStruct::from_syntax_node(db, node)),
            SyntaxKind::ItemEnum => ModuleItem::Enum(ItemEnum::from_syntax_node(db, node)),
            SyntaxKind::ItemTypeAlias => {
                ModuleItem::TypeAlias(ItemTypeAlias::from_syntax_node(db, node))
            }
            SyntaxKind::ItemInlineMacro => {
                ModuleItem::InlineMacro(ItemInlineMacro::from_syntax_node(db, node))
            }
            SyntaxKind::ItemHeaderDoc => {
                ModuleItem::HeaderDoc(ItemHeaderDoc::from_syntax_node(db, node))
            }
            SyntaxKind::ModuleItemMissing => {
                ModuleItem::Missing(ModuleItemMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "ModuleItem"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ItemConstant => {
                Some(ModuleItem::Constant(ItemConstant::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemModule => {
                Some(ModuleItem::Module(ItemModule::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemUse => Some(ModuleItem::Use(ItemUse::from_syntax_node(db, node))),
            SyntaxKind::FunctionWithBody => {
                Some(ModuleItem::FreeFunction(FunctionWithBody::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemExternFunction => {
                Some(ModuleItem::ExternFunction(ItemExternFunction::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemExternType => {
                Some(ModuleItem::ExternType(ItemExternType::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemTrait => Some(ModuleItem::Trait(ItemTrait::from_syntax_node(db, node))),
            SyntaxKind::ItemImpl => Some(ModuleItem::Impl(ItemImpl::from_syntax_node(db, node))),
            SyntaxKind::ItemImplAlias => {
                Some(ModuleItem::ImplAlias(ItemImplAlias::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemStruct => {
                Some(ModuleItem::Struct(ItemStruct::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemEnum => Some(ModuleItem::Enum(ItemEnum::from_syntax_node(db, node))),
            SyntaxKind::ItemTypeAlias => {
                Some(ModuleItem::TypeAlias(ItemTypeAlias::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemInlineMacro => {
                Some(ModuleItem::InlineMacro(ItemInlineMacro::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemHeaderDoc => {
                Some(ModuleItem::HeaderDoc(ItemHeaderDoc::from_syntax_node(db, node)))
            }
            SyntaxKind::ModuleItemMissing => {
                Some(ModuleItem::Missing(ModuleItemMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            ModuleItem::Constant(x) => x.as_syntax_node(),
            ModuleItem::Module(x) => x.as_syntax_node(),
            ModuleItem::Use(x) => x.as_syntax_node(),
            ModuleItem::FreeFunction(x) => x.as_syntax_node(),
            ModuleItem::ExternFunction(x) => x.as_syntax_node(),
            ModuleItem::ExternType(x) => x.as_syntax_node(),
            ModuleItem::Trait(x) => x.as_syntax_node(),
            ModuleItem::Impl(x) => x.as_syntax_node(),
            ModuleItem::ImplAlias(x) => x.as_syntax_node(),
            ModuleItem::Struct(x) => x.as_syntax_node(),
            ModuleItem::Enum(x) => x.as_syntax_node(),
            ModuleItem::TypeAlias(x) => x.as_syntax_node(),
            ModuleItem::InlineMacro(x) => x.as_syntax_node(),
            ModuleItem::HeaderDoc(x) => x.as_syntax_node(),
            ModuleItem::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ModuleItemPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&ModuleItem> for SyntaxStablePtrId {
    fn from(node: &ModuleItem) -> Self {
        node.stable_ptr().untyped()
    }
}
impl ModuleItem {
    /// Checks if a kind of a variant of [ModuleItem].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::ItemConstant
                | SyntaxKind::ItemModule
                | SyntaxKind::ItemUse
                | SyntaxKind::FunctionWithBody
                | SyntaxKind::ItemExternFunction
                | SyntaxKind::ItemExternType
                | SyntaxKind::ItemTrait
                | SyntaxKind::ItemImpl
                | SyntaxKind::ItemImplAlias
                | SyntaxKind::ItemStruct
                | SyntaxKind::ItemEnum
                | SyntaxKind::ItemTypeAlias
                | SyntaxKind::ItemInlineMacro
                | SyntaxKind::ItemHeaderDoc
                | SyntaxKind::ModuleItemMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ModuleItemList(ElementList<ModuleItem, 1>);
impl Deref for ModuleItemList {
    type Target = ElementList<ModuleItem, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ModuleItemList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<ModuleItemGreen>) -> ModuleItemListGreen {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        ModuleItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleItemList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModuleItemListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ModuleItemListPtr {
    type SyntaxNode = ModuleItemList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ModuleItemList {
        ModuleItemList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ModuleItemListPtr> for SyntaxStablePtrId {
    fn from(ptr: ModuleItemListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModuleItemListGreen(pub GreenId);
impl TypedSyntaxNode for ModuleItemList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ModuleItemList);
    type StablePtr = ModuleItemListPtr;
    type Green = ModuleItemListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ModuleItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleItemList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ModuleItemList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ModuleItemListPtr(self.node.0.stable_ptr)
    }
}
impl From<&ModuleItemList> for SyntaxStablePtrId {
    fn from(node: &ModuleItemList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ModuleItemMissing {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ModuleItemMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> ModuleItemMissingGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ModuleItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleItemMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ModuleItemMissing {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModuleItemMissingPtr(pub SyntaxStablePtrId);
impl ModuleItemMissingPtr {}
impl TypedStablePtr for ModuleItemMissingPtr {
    type SyntaxNode = ModuleItemMissing;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ModuleItemMissing {
        ModuleItemMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ModuleItemMissingPtr> for SyntaxStablePtrId {
    fn from(ptr: ModuleItemMissingPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModuleItemMissingGreen(pub GreenId);
impl TypedSyntaxNode for ModuleItemMissing {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ModuleItemMissing);
    type StablePtr = ModuleItemMissingPtr;
    type Green = ModuleItemMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ModuleItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleItemMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ModuleItemMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ModuleItemMissing
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ModuleItemMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ModuleItemMissingPtr(self.node.0.stable_ptr)
    }
}
impl From<&ModuleItemMissing> for SyntaxStablePtrId {
    fn from(node: &ModuleItemMissing) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Attribute {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Attribute {
    pub const INDEX_HASH: usize = 0;
    pub const INDEX_LBRACK: usize = 1;
    pub const INDEX_ATTR: usize = 2;
    pub const INDEX_ARGUMENTS: usize = 3;
    pub const INDEX_RBRACK: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        hash: TerminalHashGreen,
        lbrack: TerminalLBrackGreen,
        attr: ExprPathGreen,
        arguments: OptionArgListParenthesizedGreen,
        rbrack: TerminalRBrackGreen,
    ) -> AttributeGreen {
        let children: Vec<GreenId> = vec![hash.0, lbrack.0, attr.0, arguments.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        AttributeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Attribute,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl Attribute {
    pub fn hash(&self, db: &dyn SyntaxGroup) -> TerminalHash {
        TerminalHash::from_syntax_node(db, self.children[0].clone())
    }
    pub fn lbrack(&self, db: &dyn SyntaxGroup) -> TerminalLBrack {
        TerminalLBrack::from_syntax_node(db, self.children[1].clone())
    }
    pub fn attr(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[2].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> OptionArgListParenthesized {
        OptionArgListParenthesized::from_syntax_node(db, self.children[3].clone())
    }
    pub fn rbrack(&self, db: &dyn SyntaxGroup) -> TerminalRBrack {
        TerminalRBrack::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributePtr(pub SyntaxStablePtrId);
impl AttributePtr {}
impl TypedStablePtr for AttributePtr {
    type SyntaxNode = Attribute;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Attribute {
        Attribute::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<AttributePtr> for SyntaxStablePtrId {
    fn from(ptr: AttributePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributeGreen(pub GreenId);
impl TypedSyntaxNode for Attribute {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::Attribute);
    type StablePtr = AttributePtr;
    type Green = AttributeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        AttributeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::Attribute,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalHash::missing(db).0,
                        TerminalLBrack::missing(db).0,
                        ExprPath::missing(db).0,
                        OptionArgListParenthesized::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::Attribute,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::Attribute
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::Attribute { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        AttributePtr(self.node.0.stable_ptr)
    }
}
impl From<&Attribute> for SyntaxStablePtrId {
    fn from(node: &Attribute) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct AttributeList(ElementList<Attribute, 1>);
impl Deref for AttributeList {
    type Target = ElementList<Attribute, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl AttributeList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<AttributeGreen>) -> AttributeListGreen {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        AttributeListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AttributeList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributeListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for AttributeListPtr {
    type SyntaxNode = AttributeList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<AttributeListPtr> for SyntaxStablePtrId {
    fn from(ptr: AttributeListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AttributeListGreen(pub GreenId);
impl TypedSyntaxNode for AttributeList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AttributeList);
    type StablePtr = AttributeListPtr;
    type Green = AttributeListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        AttributeListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AttributeList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::AttributeList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        AttributeListPtr(self.node.0.stable_ptr)
    }
}
impl From<&AttributeList> for SyntaxStablePtrId {
    fn from(node: &AttributeList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct VisibilityDefault {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl VisibilityDefault {
    pub fn new_green(db: &dyn SyntaxGroup) -> VisibilityDefaultGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        VisibilityDefaultGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityDefault,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl VisibilityDefault {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VisibilityDefaultPtr(pub SyntaxStablePtrId);
impl VisibilityDefaultPtr {}
impl TypedStablePtr for VisibilityDefaultPtr {
    type SyntaxNode = VisibilityDefault;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> VisibilityDefault {
        VisibilityDefault::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<VisibilityDefaultPtr> for SyntaxStablePtrId {
    fn from(ptr: VisibilityDefaultPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VisibilityDefaultGreen(pub GreenId);
impl TypedSyntaxNode for VisibilityDefault {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::VisibilityDefault);
    type StablePtr = VisibilityDefaultPtr;
    type Green = VisibilityDefaultGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        VisibilityDefaultGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityDefault,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::VisibilityDefault,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::VisibilityDefault
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::VisibilityDefault {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        VisibilityDefaultPtr(self.node.0.stable_ptr)
    }
}
impl From<&VisibilityDefault> for SyntaxStablePtrId {
    fn from(node: &VisibilityDefault) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct VisibilityPubArgumentClause {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl VisibilityPubArgumentClause {
    pub const INDEX_LPAREN: usize = 0;
    pub const INDEX_ARGUMENT: usize = 1;
    pub const INDEX_RPAREN: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lparen: TerminalLParenGreen,
        argument: TerminalIdentifierGreen,
        rparen: TerminalRParenGreen,
    ) -> VisibilityPubArgumentClauseGreen {
        let children: Vec<GreenId> = vec![lparen.0, argument.0, rparen.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        VisibilityPubArgumentClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityPubArgumentClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl VisibilityPubArgumentClause {
    pub fn lparen(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.children[0].clone())
    }
    pub fn argument(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rparen(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VisibilityPubArgumentClausePtr(pub SyntaxStablePtrId);
impl VisibilityPubArgumentClausePtr {}
impl TypedStablePtr for VisibilityPubArgumentClausePtr {
    type SyntaxNode = VisibilityPubArgumentClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> VisibilityPubArgumentClause {
        VisibilityPubArgumentClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<VisibilityPubArgumentClausePtr> for SyntaxStablePtrId {
    fn from(ptr: VisibilityPubArgumentClausePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VisibilityPubArgumentClauseGreen(pub GreenId);
impl TypedSyntaxNode for VisibilityPubArgumentClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::VisibilityPubArgumentClause);
    type StablePtr = VisibilityPubArgumentClausePtr;
    type Green = VisibilityPubArgumentClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        VisibilityPubArgumentClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityPubArgumentClause,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLParen::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalRParen::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::VisibilityPubArgumentClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::VisibilityPubArgumentClause
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::VisibilityPubArgumentClause {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        VisibilityPubArgumentClausePtr(self.node.0.stable_ptr)
    }
}
impl From<&VisibilityPubArgumentClause> for SyntaxStablePtrId {
    fn from(node: &VisibilityPubArgumentClause) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionVisibilityPubArgumentClause {
    Empty(OptionVisibilityPubArgumentClauseEmpty),
    VisibilityPubArgumentClause(VisibilityPubArgumentClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionVisibilityPubArgumentClausePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionVisibilityPubArgumentClausePtr {
    type SyntaxNode = OptionVisibilityPubArgumentClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionVisibilityPubArgumentClause {
        OptionVisibilityPubArgumentClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionVisibilityPubArgumentClausePtr> for SyntaxStablePtrId {
    fn from(ptr: OptionVisibilityPubArgumentClausePtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionVisibilityPubArgumentClauseEmptyPtr> for OptionVisibilityPubArgumentClausePtr {
    fn from(value: OptionVisibilityPubArgumentClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<VisibilityPubArgumentClausePtr> for OptionVisibilityPubArgumentClausePtr {
    fn from(value: VisibilityPubArgumentClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionVisibilityPubArgumentClauseEmptyGreen> for OptionVisibilityPubArgumentClauseGreen {
    fn from(value: OptionVisibilityPubArgumentClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<VisibilityPubArgumentClauseGreen> for OptionVisibilityPubArgumentClauseGreen {
    fn from(value: VisibilityPubArgumentClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionVisibilityPubArgumentClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionVisibilityPubArgumentClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionVisibilityPubArgumentClausePtr;
    type Green = OptionVisibilityPubArgumentClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionVisibilityPubArgumentClauseEmpty => {
                OptionVisibilityPubArgumentClause::Empty(
                    OptionVisibilityPubArgumentClauseEmpty::from_syntax_node(db, node),
                )
            }
            SyntaxKind::VisibilityPubArgumentClause => {
                OptionVisibilityPubArgumentClause::VisibilityPubArgumentClause(
                    VisibilityPubArgumentClause::from_syntax_node(db, node),
                )
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionVisibilityPubArgumentClause"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionVisibilityPubArgumentClauseEmpty => {
                Some(OptionVisibilityPubArgumentClause::Empty(
                    OptionVisibilityPubArgumentClauseEmpty::from_syntax_node(db, node),
                ))
            }
            SyntaxKind::VisibilityPubArgumentClause => {
                Some(OptionVisibilityPubArgumentClause::VisibilityPubArgumentClause(
                    VisibilityPubArgumentClause::from_syntax_node(db, node),
                ))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionVisibilityPubArgumentClause::Empty(x) => x.as_syntax_node(),
            OptionVisibilityPubArgumentClause::VisibilityPubArgumentClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionVisibilityPubArgumentClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionVisibilityPubArgumentClause> for SyntaxStablePtrId {
    fn from(node: &OptionVisibilityPubArgumentClause) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionVisibilityPubArgumentClause {
    /// Checks if a kind of a variant of [OptionVisibilityPubArgumentClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::OptionVisibilityPubArgumentClauseEmpty
                | SyntaxKind::VisibilityPubArgumentClause
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionVisibilityPubArgumentClauseEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionVisibilityPubArgumentClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionVisibilityPubArgumentClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionVisibilityPubArgumentClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionVisibilityPubArgumentClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionVisibilityPubArgumentClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionVisibilityPubArgumentClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionVisibilityPubArgumentClauseEmptyPtr {}
impl TypedStablePtr for OptionVisibilityPubArgumentClauseEmptyPtr {
    type SyntaxNode = OptionVisibilityPubArgumentClauseEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionVisibilityPubArgumentClauseEmpty {
        OptionVisibilityPubArgumentClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionVisibilityPubArgumentClauseEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionVisibilityPubArgumentClauseEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionVisibilityPubArgumentClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionVisibilityPubArgumentClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> =
        Some(SyntaxKind::OptionVisibilityPubArgumentClauseEmpty);
    type StablePtr = OptionVisibilityPubArgumentClauseEmptyPtr;
    type Green = OptionVisibilityPubArgumentClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionVisibilityPubArgumentClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionVisibilityPubArgumentClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionVisibilityPubArgumentClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionVisibilityPubArgumentClauseEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionVisibilityPubArgumentClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionVisibilityPubArgumentClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionVisibilityPubArgumentClauseEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionVisibilityPubArgumentClauseEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct VisibilityPub {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl VisibilityPub {
    pub const INDEX_PUB_KW: usize = 0;
    pub const INDEX_ARGUMENT_CLAUSE: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        pub_kw: TerminalPubGreen,
        argument_clause: OptionVisibilityPubArgumentClauseGreen,
    ) -> VisibilityPubGreen {
        let children: Vec<GreenId> = vec![pub_kw.0, argument_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        VisibilityPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityPub,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl VisibilityPub {
    pub fn pub_kw(&self, db: &dyn SyntaxGroup) -> TerminalPub {
        TerminalPub::from_syntax_node(db, self.children[0].clone())
    }
    pub fn argument_clause(&self, db: &dyn SyntaxGroup) -> OptionVisibilityPubArgumentClause {
        OptionVisibilityPubArgumentClause::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VisibilityPubPtr(pub SyntaxStablePtrId);
impl VisibilityPubPtr {}
impl TypedStablePtr for VisibilityPubPtr {
    type SyntaxNode = VisibilityPub;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> VisibilityPub {
        VisibilityPub::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<VisibilityPubPtr> for SyntaxStablePtrId {
    fn from(ptr: VisibilityPubPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VisibilityPubGreen(pub GreenId);
impl TypedSyntaxNode for VisibilityPub {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::VisibilityPub);
    type StablePtr = VisibilityPubPtr;
    type Green = VisibilityPubGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        VisibilityPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::VisibilityPub,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalPub::missing(db).0,
                        OptionVisibilityPubArgumentClause::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::VisibilityPub,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::VisibilityPub
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::VisibilityPub {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        VisibilityPubPtr(self.node.0.stable_ptr)
    }
}
impl From<&VisibilityPub> for SyntaxStablePtrId {
    fn from(node: &VisibilityPub) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum Visibility {
    Default(VisibilityDefault),
    Pub(VisibilityPub),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VisibilityPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for VisibilityPtr {
    type SyntaxNode = Visibility;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<VisibilityPtr> for SyntaxStablePtrId {
    fn from(ptr: VisibilityPtr) -> Self {
        ptr.untyped()
    }
}
impl From<VisibilityDefaultPtr> for VisibilityPtr {
    fn from(value: VisibilityDefaultPtr) -> Self {
        Self(value.0)
    }
}
impl From<VisibilityPubPtr> for VisibilityPtr {
    fn from(value: VisibilityPubPtr) -> Self {
        Self(value.0)
    }
}
impl From<VisibilityDefaultGreen> for VisibilityGreen {
    fn from(value: VisibilityDefaultGreen) -> Self {
        Self(value.0)
    }
}
impl From<VisibilityPubGreen> for VisibilityGreen {
    fn from(value: VisibilityPubGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct VisibilityGreen(pub GreenId);
impl TypedSyntaxNode for Visibility {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = VisibilityPtr;
    type Green = VisibilityGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::VisibilityDefault => {
                Visibility::Default(VisibilityDefault::from_syntax_node(db, node))
            }
            SyntaxKind::VisibilityPub => Visibility::Pub(VisibilityPub::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "Visibility"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::VisibilityDefault => {
                Some(Visibility::Default(VisibilityDefault::from_syntax_node(db, node)))
            }
            SyntaxKind::VisibilityPub => {
                Some(Visibility::Pub(VisibilityPub::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            Visibility::Default(x) => x.as_syntax_node(),
            Visibility::Pub(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        VisibilityPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&Visibility> for SyntaxStablePtrId {
    fn from(node: &Visibility) -> Self {
        node.stable_ptr().untyped()
    }
}
impl Visibility {
    /// Checks if a kind of a variant of [Visibility].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::VisibilityDefault | SyntaxKind::VisibilityPub)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemModule {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemModule {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_MODULE_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_BODY: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        module_kw: TerminalModuleGreen,
        name: TerminalIdentifierGreen,
        body: MaybeModuleBodyGreen,
    ) -> ItemModuleGreen {
        let children: Vec<GreenId> = vec![attributes.0, visibility.0, module_kw.0, name.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemModule,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemModule {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn module_kw(&self, db: &dyn SyntaxGroup) -> TerminalModule {
        TerminalModule::from_syntax_node(db, self.children[2].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> MaybeModuleBody {
        MaybeModuleBody::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemModulePtr(pub SyntaxStablePtrId);
impl ItemModulePtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemModulePtr {
    type SyntaxNode = ItemModule;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemModule {
        ItemModule::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemModulePtr> for SyntaxStablePtrId {
    fn from(ptr: ItemModulePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemModuleGreen(pub GreenId);
impl TypedSyntaxNode for ItemModule {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemModule);
    type StablePtr = ItemModulePtr;
    type Green = ItemModuleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemModule,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalModule::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        MaybeModuleBody::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemModule,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemModule
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemModule { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemModulePtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemModule> for SyntaxStablePtrId {
    fn from(node: &ItemModule) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum MaybeModuleBody {
    Some(ModuleBody),
    None(TerminalSemicolon),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeModuleBodyPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for MaybeModuleBodyPtr {
    type SyntaxNode = MaybeModuleBody;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> MaybeModuleBody {
        MaybeModuleBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<MaybeModuleBodyPtr> for SyntaxStablePtrId {
    fn from(ptr: MaybeModuleBodyPtr) -> Self {
        ptr.untyped()
    }
}
impl From<ModuleBodyPtr> for MaybeModuleBodyPtr {
    fn from(value: ModuleBodyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonPtr> for MaybeModuleBodyPtr {
    fn from(value: TerminalSemicolonPtr) -> Self {
        Self(value.0)
    }
}
impl From<ModuleBodyGreen> for MaybeModuleBodyGreen {
    fn from(value: ModuleBodyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonGreen> for MaybeModuleBodyGreen {
    fn from(value: TerminalSemicolonGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeModuleBodyGreen(pub GreenId);
impl TypedSyntaxNode for MaybeModuleBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeModuleBodyPtr;
    type Green = MaybeModuleBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ModuleBody => MaybeModuleBody::Some(ModuleBody::from_syntax_node(db, node)),
            SyntaxKind::TerminalSemicolon => {
                MaybeModuleBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MaybeModuleBody")
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ModuleBody => {
                Some(MaybeModuleBody::Some(ModuleBody::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalSemicolon => {
                Some(MaybeModuleBody::None(TerminalSemicolon::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            MaybeModuleBody::Some(x) => x.as_syntax_node(),
            MaybeModuleBody::None(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MaybeModuleBodyPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&MaybeModuleBody> for SyntaxStablePtrId {
    fn from(node: &MaybeModuleBody) -> Self {
        node.stable_ptr().untyped()
    }
}
impl MaybeModuleBody {
    /// Checks if a kind of a variant of [MaybeModuleBody].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::ModuleBody | SyntaxKind::TerminalSemicolon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ModuleBody {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ModuleBody {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ITEMS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        items: ModuleItemListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ModuleBodyGreen {
        let children: Vec<GreenId> = vec![lbrace.0, items.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ModuleBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleBody,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ModuleBody {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> ModuleItemList {
        ModuleItemList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModuleBodyPtr(pub SyntaxStablePtrId);
impl ModuleBodyPtr {}
impl TypedStablePtr for ModuleBodyPtr {
    type SyntaxNode = ModuleBody;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ModuleBody {
        ModuleBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ModuleBodyPtr> for SyntaxStablePtrId {
    fn from(ptr: ModuleBodyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ModuleBodyGreen(pub GreenId);
impl TypedSyntaxNode for ModuleBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ModuleBody);
    type StablePtr = ModuleBodyPtr;
    type Green = ModuleBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ModuleBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ModuleBody,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        ModuleItemList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ModuleBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ModuleBody
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ModuleBody { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ModuleBodyPtr(self.node.0.stable_ptr)
    }
}
impl From<&ModuleBody> for SyntaxStablePtrId {
    fn from(node: &ModuleBody) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct FunctionDeclaration {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl FunctionDeclaration {
    pub const INDEX_OPTIONAL_CONST: usize = 0;
    pub const INDEX_FUNCTION_KW: usize = 1;
    pub const INDEX_NAME: usize = 2;
    pub const INDEX_GENERIC_PARAMS: usize = 3;
    pub const INDEX_SIGNATURE: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        optional_const: OptionTerminalConstGreen,
        function_kw: TerminalFunctionGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        signature: FunctionSignatureGreen,
    ) -> FunctionDeclarationGreen {
        let children: Vec<GreenId> =
            vec![optional_const.0, function_kw.0, name.0, generic_params.0, signature.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        FunctionDeclarationGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionDeclaration,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl FunctionDeclaration {
    pub fn optional_const(&self, db: &dyn SyntaxGroup) -> OptionTerminalConst {
        OptionTerminalConst::from_syntax_node(db, self.children[0].clone())
    }
    pub fn function_kw(&self, db: &dyn SyntaxGroup) -> TerminalFunction {
        TerminalFunction::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn signature(&self, db: &dyn SyntaxGroup) -> FunctionSignature {
        FunctionSignature::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FunctionDeclarationPtr(pub SyntaxStablePtrId);
impl FunctionDeclarationPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for FunctionDeclarationPtr {
    type SyntaxNode = FunctionDeclaration;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> FunctionDeclaration {
        FunctionDeclaration::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<FunctionDeclarationPtr> for SyntaxStablePtrId {
    fn from(ptr: FunctionDeclarationPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FunctionDeclarationGreen(pub GreenId);
impl TypedSyntaxNode for FunctionDeclaration {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::FunctionDeclaration);
    type StablePtr = FunctionDeclarationPtr;
    type Green = FunctionDeclarationGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        FunctionDeclarationGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionDeclaration,
                details: GreenNodeDetails::Node {
                    children: vec![
                        OptionTerminalConst::missing(db).0,
                        TerminalFunction::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        FunctionSignature::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::FunctionDeclaration,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::FunctionDeclaration
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::FunctionDeclaration {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        FunctionDeclarationPtr(self.node.0.stable_ptr)
    }
}
impl From<&FunctionDeclaration> for SyntaxStablePtrId {
    fn from(node: &FunctionDeclaration) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemConstant {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemConstant {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_CONST_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_TYPE_CLAUSE: usize = 4;
    pub const INDEX_EQ: usize = 5;
    pub const INDEX_VALUE: usize = 6;
    pub const INDEX_SEMICOLON: usize = 7;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        const_kw: TerminalConstGreen,
        name: TerminalIdentifierGreen,
        type_clause: TypeClauseGreen,
        eq: TerminalEqGreen,
        value: ExprGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> ItemConstantGreen {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            const_kw.0,
            name.0,
            type_clause.0,
            eq.0,
            value.0,
            semicolon.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemConstantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemConstant,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemConstant {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn const_kw(&self, db: &dyn SyntaxGroup) -> TerminalConst {
        TerminalConst::from_syntax_node(db, self.children[2].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> TypeClause {
        TypeClause::from_syntax_node(db, self.children[4].clone())
    }
    pub fn eq(&self, db: &dyn SyntaxGroup) -> TerminalEq {
        TerminalEq::from_syntax_node(db, self.children[5].clone())
    }
    pub fn value(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[6].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[7].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemConstantPtr(pub SyntaxStablePtrId);
impl ItemConstantPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemConstantPtr {
    type SyntaxNode = ItemConstant;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemConstant {
        ItemConstant::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemConstantPtr> for SyntaxStablePtrId {
    fn from(ptr: ItemConstantPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemConstantGreen(pub GreenId);
impl TypedSyntaxNode for ItemConstant {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemConstant);
    type StablePtr = ItemConstantPtr;
    type Green = ItemConstantGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemConstantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemConstant,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalConst::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TypeClause::missing(db).0,
                        TerminalEq::missing(db).0,
                        Expr::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemConstant,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemConstant
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemConstant { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemConstantPtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemConstant> for SyntaxStablePtrId {
    fn from(node: &ItemConstant) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct FunctionWithBody {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl FunctionWithBody {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_DECLARATION: usize = 2;
    pub const INDEX_BODY: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        declaration: FunctionDeclarationGreen,
        body: ExprBlockGreen,
    ) -> FunctionWithBodyGreen {
        let children: Vec<GreenId> = vec![attributes.0, visibility.0, declaration.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        FunctionWithBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionWithBody,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl FunctionWithBody {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn declaration(&self, db: &dyn SyntaxGroup) -> FunctionDeclaration {
        FunctionDeclaration::from_syntax_node(db, self.children[2].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> ExprBlock {
        ExprBlock::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FunctionWithBodyPtr(pub SyntaxStablePtrId);
impl FunctionWithBodyPtr {
    pub fn declaration_green(self, db: &dyn SyntaxGroup) -> FunctionDeclarationGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            FunctionDeclarationGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for FunctionWithBodyPtr {
    type SyntaxNode = FunctionWithBody;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> FunctionWithBody {
        FunctionWithBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<FunctionWithBodyPtr> for SyntaxStablePtrId {
    fn from(ptr: FunctionWithBodyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct FunctionWithBodyGreen(pub GreenId);
impl TypedSyntaxNode for FunctionWithBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::FunctionWithBody);
    type StablePtr = FunctionWithBodyPtr;
    type Green = FunctionWithBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        FunctionWithBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::FunctionWithBody,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        FunctionDeclaration::missing(db).0,
                        ExprBlock::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::FunctionWithBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::FunctionWithBody
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::FunctionWithBody {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        FunctionWithBodyPtr(self.node.0.stable_ptr)
    }
}
impl From<&FunctionWithBody> for SyntaxStablePtrId {
    fn from(node: &FunctionWithBody) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemExternFunction {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemExternFunction {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_EXTERN_KW: usize = 2;
    pub const INDEX_DECLARATION: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        extern_kw: TerminalExternGreen,
        declaration: FunctionDeclarationGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> ItemExternFunctionGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, visibility.0, extern_kw.0, declaration.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemExternFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemExternFunction,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemExternFunction {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn extern_kw(&self, db: &dyn SyntaxGroup) -> TerminalExtern {
        TerminalExtern::from_syntax_node(db, self.children[2].clone())
    }
    pub fn declaration(&self, db: &dyn SyntaxGroup) -> FunctionDeclaration {
        FunctionDeclaration::from_syntax_node(db, self.children[3].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternFunctionPtr(pub SyntaxStablePtrId);
impl ItemExternFunctionPtr {
    pub fn declaration_green(self, db: &dyn SyntaxGroup) -> FunctionDeclarationGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            FunctionDeclarationGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemExternFunctionPtr {
    type SyntaxNode = ItemExternFunction;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemExternFunction {
        ItemExternFunction::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemExternFunctionPtr> for SyntaxStablePtrId {
    fn from(ptr: ItemExternFunctionPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternFunctionGreen(pub GreenId);
impl TypedSyntaxNode for ItemExternFunction {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemExternFunction);
    type StablePtr = ItemExternFunctionPtr;
    type Green = ItemExternFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemExternFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemExternFunction,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalExtern::missing(db).0,
                        FunctionDeclaration::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemExternFunction,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemExternFunction
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemExternFunction {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemExternFunctionPtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemExternFunction> for SyntaxStablePtrId {
    fn from(node: &ItemExternFunction) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemExternType {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemExternType {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_EXTERN_KW: usize = 2;
    pub const INDEX_TYPE_KW: usize = 3;
    pub const INDEX_NAME: usize = 4;
    pub const INDEX_GENERIC_PARAMS: usize = 5;
    pub const INDEX_SEMICOLON: usize = 6;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        extern_kw: TerminalExternGreen,
        type_kw: TerminalTypeGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> ItemExternTypeGreen {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            extern_kw.0,
            type_kw.0,
            name.0,
            generic_params.0,
            semicolon.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemExternTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemExternType,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemExternType {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn extern_kw(&self, db: &dyn SyntaxGroup) -> TerminalExtern {
        TerminalExtern::from_syntax_node(db, self.children[2].clone())
    }
    pub fn type_kw(&self, db: &dyn SyntaxGroup) -> TerminalType {
        TerminalType::from_syntax_node(db, self.children[3].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[4].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[5].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[6].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternTypePtr(pub SyntaxStablePtrId);
impl ItemExternTypePtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemExternTypePtr {
    type SyntaxNode = ItemExternType;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemExternType {
        ItemExternType::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemExternTypePtr> for SyntaxStablePtrId {
    fn from(ptr: ItemExternTypePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemExternTypeGreen(pub GreenId);
impl TypedSyntaxNode for ItemExternType {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemExternType);
    type StablePtr = ItemExternTypePtr;
    type Green = ItemExternTypeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemExternTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemExternType,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalExtern::missing(db).0,
                        TerminalType::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemExternType,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemExternType
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemExternType {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemExternTypePtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemExternType> for SyntaxStablePtrId {
    fn from(node: &ItemExternType) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemTrait {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemTrait {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_TRAIT_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_BODY: usize = 5;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        trait_kw: TerminalTraitGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        body: MaybeTraitBodyGreen,
    ) -> ItemTraitGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, visibility.0, trait_kw.0, name.0, generic_params.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemTrait,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemTrait {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trait_kw(&self, db: &dyn SyntaxGroup) -> TerminalTrait {
        TerminalTrait::from_syntax_node(db, self.children[2].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> MaybeTraitBody {
        MaybeTraitBody::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemTraitPtr(pub SyntaxStablePtrId);
impl ItemTraitPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemTraitPtr {
    type SyntaxNode = ItemTrait;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemTrait {
        ItemTrait::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemTraitPtr> for SyntaxStablePtrId {
    fn from(ptr: ItemTraitPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemTraitGreen(pub GreenId);
impl TypedSyntaxNode for ItemTrait {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemTrait);
    type StablePtr = ItemTraitPtr;
    type Green = ItemTraitGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemTrait,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalTrait::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        MaybeTraitBody::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemTrait,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemTrait
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemTrait { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemTraitPtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemTrait> for SyntaxStablePtrId {
    fn from(node: &ItemTrait) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum MaybeTraitBody {
    Some(TraitBody),
    None(TerminalSemicolon),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeTraitBodyPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for MaybeTraitBodyPtr {
    type SyntaxNode = MaybeTraitBody;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> MaybeTraitBody {
        MaybeTraitBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<MaybeTraitBodyPtr> for SyntaxStablePtrId {
    fn from(ptr: MaybeTraitBodyPtr) -> Self {
        ptr.untyped()
    }
}
impl From<TraitBodyPtr> for MaybeTraitBodyPtr {
    fn from(value: TraitBodyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonPtr> for MaybeTraitBodyPtr {
    fn from(value: TerminalSemicolonPtr) -> Self {
        Self(value.0)
    }
}
impl From<TraitBodyGreen> for MaybeTraitBodyGreen {
    fn from(value: TraitBodyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonGreen> for MaybeTraitBodyGreen {
    fn from(value: TerminalSemicolonGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeTraitBodyGreen(pub GreenId);
impl TypedSyntaxNode for MaybeTraitBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeTraitBodyPtr;
    type Green = MaybeTraitBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TraitBody => MaybeTraitBody::Some(TraitBody::from_syntax_node(db, node)),
            SyntaxKind::TerminalSemicolon => {
                MaybeTraitBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MaybeTraitBody")
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TraitBody => {
                Some(MaybeTraitBody::Some(TraitBody::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalSemicolon => {
                Some(MaybeTraitBody::None(TerminalSemicolon::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            MaybeTraitBody::Some(x) => x.as_syntax_node(),
            MaybeTraitBody::None(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MaybeTraitBodyPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&MaybeTraitBody> for SyntaxStablePtrId {
    fn from(node: &MaybeTraitBody) -> Self {
        node.stable_ptr().untyped()
    }
}
impl MaybeTraitBody {
    /// Checks if a kind of a variant of [MaybeTraitBody].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::TraitBody | SyntaxKind::TerminalSemicolon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TraitBody {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl TraitBody {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ITEMS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        items: TraitItemListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> TraitBodyGreen {
        let children: Vec<GreenId> = vec![lbrace.0, items.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitBody,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl TraitBody {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> TraitItemList {
        TraitItemList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitBodyPtr(pub SyntaxStablePtrId);
impl TraitBodyPtr {}
impl TypedStablePtr for TraitBodyPtr {
    type SyntaxNode = TraitBody;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TraitBody {
        TraitBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TraitBodyPtr> for SyntaxStablePtrId {
    fn from(ptr: TraitBodyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitBodyGreen(pub GreenId);
impl TypedSyntaxNode for TraitBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitBody);
    type StablePtr = TraitBodyPtr;
    type Green = TraitBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitBody,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        TraitItemList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitBody
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitBody { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitBodyPtr(self.node.0.stable_ptr)
    }
}
impl From<&TraitBody> for SyntaxStablePtrId {
    fn from(node: &TraitBody) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TraitItemList(ElementList<TraitItem, 1>);
impl Deref for TraitItemList {
    type Target = ElementList<TraitItem, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl TraitItemList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<TraitItemGreen>) -> TraitItemListGreen {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        TraitItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TraitItemListPtr {
    type SyntaxNode = TraitItemList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TraitItemList {
        TraitItemList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TraitItemListPtr> for SyntaxStablePtrId {
    fn from(ptr: TraitItemListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemListGreen(pub GreenId);
impl TypedSyntaxNode for TraitItemList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemList);
    type StablePtr = TraitItemListPtr;
    type Green = TraitItemListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::TraitItemList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitItemListPtr(self.node.0.stable_ptr)
    }
}
impl From<&TraitItemList> for SyntaxStablePtrId {
    fn from(node: &TraitItemList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum TraitItem {
    Function(TraitItemFunction),
    Type(TraitItemType),
    Constant(TraitItemConstant),
    Impl(TraitItemImpl),
    Missing(TraitItemMissing),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TraitItemPtr {
    type SyntaxNode = TraitItem;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TraitItem {
        TraitItem::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TraitItemPtr> for SyntaxStablePtrId {
    fn from(ptr: TraitItemPtr) -> Self {
        ptr.untyped()
    }
}
impl From<TraitItemFunctionPtr> for TraitItemPtr {
    fn from(value: TraitItemFunctionPtr) -> Self {
        Self(value.0)
    }
}
impl From<TraitItemTypePtr> for TraitItemPtr {
    fn from(value: TraitItemTypePtr) -> Self {
        Self(value.0)
    }
}
impl From<TraitItemConstantPtr> for TraitItemPtr {
    fn from(value: TraitItemConstantPtr) -> Self {
        Self(value.0)
    }
}
impl From<TraitItemImplPtr> for TraitItemPtr {
    fn from(value: TraitItemImplPtr) -> Self {
        Self(value.0)
    }
}
impl From<TraitItemMissingPtr> for TraitItemPtr {
    fn from(value: TraitItemMissingPtr) -> Self {
        Self(value.0)
    }
}
impl From<TraitItemFunctionGreen> for TraitItemGreen {
    fn from(value: TraitItemFunctionGreen) -> Self {
        Self(value.0)
    }
}
impl From<TraitItemTypeGreen> for TraitItemGreen {
    fn from(value: TraitItemTypeGreen) -> Self {
        Self(value.0)
    }
}
impl From<TraitItemConstantGreen> for TraitItemGreen {
    fn from(value: TraitItemConstantGreen) -> Self {
        Self(value.0)
    }
}
impl From<TraitItemImplGreen> for TraitItemGreen {
    fn from(value: TraitItemImplGreen) -> Self {
        Self(value.0)
    }
}
impl From<TraitItemMissingGreen> for TraitItemGreen {
    fn from(value: TraitItemMissingGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemGreen(pub GreenId);
impl TypedSyntaxNode for TraitItem {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = TraitItemPtr;
    type Green = TraitItemGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitItemGreen(TraitItemMissing::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TraitItemFunction => {
                TraitItem::Function(TraitItemFunction::from_syntax_node(db, node))
            }
            SyntaxKind::TraitItemType => TraitItem::Type(TraitItemType::from_syntax_node(db, node)),
            SyntaxKind::TraitItemConstant => {
                TraitItem::Constant(TraitItemConstant::from_syntax_node(db, node))
            }
            SyntaxKind::TraitItemImpl => TraitItem::Impl(TraitItemImpl::from_syntax_node(db, node)),
            SyntaxKind::TraitItemMissing => {
                TraitItem::Missing(TraitItemMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "TraitItem"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TraitItemFunction => {
                Some(TraitItem::Function(TraitItemFunction::from_syntax_node(db, node)))
            }
            SyntaxKind::TraitItemType => {
                Some(TraitItem::Type(TraitItemType::from_syntax_node(db, node)))
            }
            SyntaxKind::TraitItemConstant => {
                Some(TraitItem::Constant(TraitItemConstant::from_syntax_node(db, node)))
            }
            SyntaxKind::TraitItemImpl => {
                Some(TraitItem::Impl(TraitItemImpl::from_syntax_node(db, node)))
            }
            SyntaxKind::TraitItemMissing => {
                Some(TraitItem::Missing(TraitItemMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            TraitItem::Function(x) => x.as_syntax_node(),
            TraitItem::Type(x) => x.as_syntax_node(),
            TraitItem::Constant(x) => x.as_syntax_node(),
            TraitItem::Impl(x) => x.as_syntax_node(),
            TraitItem::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitItemPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&TraitItem> for SyntaxStablePtrId {
    fn from(node: &TraitItem) -> Self {
        node.stable_ptr().untyped()
    }
}
impl TraitItem {
    /// Checks if a kind of a variant of [TraitItem].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TraitItemFunction
                | SyntaxKind::TraitItemType
                | SyntaxKind::TraitItemConstant
                | SyntaxKind::TraitItemImpl
                | SyntaxKind::TraitItemMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TraitItemMissing {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl TraitItemMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> TraitItemMissingGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl TraitItemMissing {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemMissingPtr(pub SyntaxStablePtrId);
impl TraitItemMissingPtr {}
impl TypedStablePtr for TraitItemMissingPtr {
    type SyntaxNode = TraitItemMissing;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TraitItemMissing {
        TraitItemMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TraitItemMissingPtr> for SyntaxStablePtrId {
    fn from(ptr: TraitItemMissingPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemMissingGreen(pub GreenId);
impl TypedSyntaxNode for TraitItemMissing {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemMissing);
    type StablePtr = TraitItemMissingPtr;
    type Green = TraitItemMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemMissing
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitItemMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitItemMissingPtr(self.node.0.stable_ptr)
    }
}
impl From<&TraitItemMissing> for SyntaxStablePtrId {
    fn from(node: &TraitItemMissing) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TraitItemFunction {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl TraitItemFunction {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_DECLARATION: usize = 1;
    pub const INDEX_BODY: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        declaration: FunctionDeclarationGreen,
        body: MaybeTraitFunctionBodyGreen,
    ) -> TraitItemFunctionGreen {
        let children: Vec<GreenId> = vec![attributes.0, declaration.0, body.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitItemFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemFunction,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl TraitItemFunction {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn declaration(&self, db: &dyn SyntaxGroup) -> FunctionDeclaration {
        FunctionDeclaration::from_syntax_node(db, self.children[1].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> MaybeTraitFunctionBody {
        MaybeTraitFunctionBody::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemFunctionPtr(pub SyntaxStablePtrId);
impl TraitItemFunctionPtr {
    pub fn declaration_green(self, db: &dyn SyntaxGroup) -> FunctionDeclarationGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            FunctionDeclarationGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for TraitItemFunctionPtr {
    type SyntaxNode = TraitItemFunction;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TraitItemFunction {
        TraitItemFunction::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TraitItemFunctionPtr> for SyntaxStablePtrId {
    fn from(ptr: TraitItemFunctionPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemFunctionGreen(pub GreenId);
impl TypedSyntaxNode for TraitItemFunction {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemFunction);
    type StablePtr = TraitItemFunctionPtr;
    type Green = TraitItemFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitItemFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemFunction,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        FunctionDeclaration::missing(db).0,
                        MaybeTraitFunctionBody::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemFunction,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemFunction
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitItemFunction {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitItemFunctionPtr(self.node.0.stable_ptr)
    }
}
impl From<&TraitItemFunction> for SyntaxStablePtrId {
    fn from(node: &TraitItemFunction) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TraitItemType {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl TraitItemType {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_TYPE_KW: usize = 1;
    pub const INDEX_NAME: usize = 2;
    pub const INDEX_GENERIC_PARAMS: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        type_kw: TerminalTypeGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> TraitItemTypeGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, type_kw.0, name.0, generic_params.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitItemTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemType,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl TraitItemType {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn type_kw(&self, db: &dyn SyntaxGroup) -> TerminalType {
        TerminalType::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemTypePtr(pub SyntaxStablePtrId);
impl TraitItemTypePtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for TraitItemTypePtr {
    type SyntaxNode = TraitItemType;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TraitItemType {
        TraitItemType::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TraitItemTypePtr> for SyntaxStablePtrId {
    fn from(ptr: TraitItemTypePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemTypeGreen(pub GreenId);
impl TypedSyntaxNode for TraitItemType {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemType);
    type StablePtr = TraitItemTypePtr;
    type Green = TraitItemTypeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitItemTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemType,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalType::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemType,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemType
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitItemType {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitItemTypePtr(self.node.0.stable_ptr)
    }
}
impl From<&TraitItemType> for SyntaxStablePtrId {
    fn from(node: &TraitItemType) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TraitItemConstant {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl TraitItemConstant {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_CONST_KW: usize = 1;
    pub const INDEX_NAME: usize = 2;
    pub const INDEX_TYPE_CLAUSE: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        const_kw: TerminalConstGreen,
        name: TerminalIdentifierGreen,
        type_clause: TypeClauseGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> TraitItemConstantGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, const_kw.0, name.0, type_clause.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitItemConstantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemConstant,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl TraitItemConstant {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn const_kw(&self, db: &dyn SyntaxGroup) -> TerminalConst {
        TerminalConst::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn type_clause(&self, db: &dyn SyntaxGroup) -> TypeClause {
        TypeClause::from_syntax_node(db, self.children[3].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemConstantPtr(pub SyntaxStablePtrId);
impl TraitItemConstantPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for TraitItemConstantPtr {
    type SyntaxNode = TraitItemConstant;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TraitItemConstant {
        TraitItemConstant::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TraitItemConstantPtr> for SyntaxStablePtrId {
    fn from(ptr: TraitItemConstantPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemConstantGreen(pub GreenId);
impl TypedSyntaxNode for TraitItemConstant {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemConstant);
    type StablePtr = TraitItemConstantPtr;
    type Green = TraitItemConstantGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitItemConstantGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemConstant,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalConst::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TypeClause::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemConstant,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemConstant
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitItemConstant {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitItemConstantPtr(self.node.0.stable_ptr)
    }
}
impl From<&TraitItemConstant> for SyntaxStablePtrId {
    fn from(node: &TraitItemConstant) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TraitItemImpl {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl TraitItemImpl {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_IMPL_KW: usize = 1;
    pub const INDEX_NAME: usize = 2;
    pub const INDEX_COLON: usize = 3;
    pub const INDEX_TRAIT_PATH: usize = 4;
    pub const INDEX_SEMICOLON: usize = 5;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        impl_kw: TerminalImplGreen,
        name: TerminalIdentifierGreen,
        colon: TerminalColonGreen,
        trait_path: ExprPathGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> TraitItemImplGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, impl_kw.0, name.0, colon.0, trait_path.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TraitItemImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemImpl,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl TraitItemImpl {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn impl_kw(&self, db: &dyn SyntaxGroup) -> TerminalImpl {
        TerminalImpl::from_syntax_node(db, self.children[1].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[2].clone())
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[3].clone())
    }
    pub fn trait_path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[4].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[5].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemImplPtr(pub SyntaxStablePtrId);
impl TraitItemImplPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for TraitItemImplPtr {
    type SyntaxNode = TraitItemImpl;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TraitItemImpl {
        TraitItemImpl::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TraitItemImplPtr> for SyntaxStablePtrId {
    fn from(ptr: TraitItemImplPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TraitItemImplGreen(pub GreenId);
impl TypedSyntaxNode for TraitItemImpl {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TraitItemImpl);
    type StablePtr = TraitItemImplPtr;
    type Green = TraitItemImplGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TraitItemImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TraitItemImpl,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalImpl::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        ExprPath::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TraitItemImpl,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TraitItemImpl
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TraitItemImpl {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TraitItemImplPtr(self.node.0.stable_ptr)
    }
}
impl From<&TraitItemImpl> for SyntaxStablePtrId {
    fn from(node: &TraitItemImpl) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum MaybeTraitFunctionBody {
    Some(ExprBlock),
    None(TerminalSemicolon),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeTraitFunctionBodyPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for MaybeTraitFunctionBodyPtr {
    type SyntaxNode = MaybeTraitFunctionBody;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> MaybeTraitFunctionBody {
        MaybeTraitFunctionBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<MaybeTraitFunctionBodyPtr> for SyntaxStablePtrId {
    fn from(ptr: MaybeTraitFunctionBodyPtr) -> Self {
        ptr.untyped()
    }
}
impl From<ExprBlockPtr> for MaybeTraitFunctionBodyPtr {
    fn from(value: ExprBlockPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonPtr> for MaybeTraitFunctionBodyPtr {
    fn from(value: TerminalSemicolonPtr) -> Self {
        Self(value.0)
    }
}
impl From<ExprBlockGreen> for MaybeTraitFunctionBodyGreen {
    fn from(value: ExprBlockGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonGreen> for MaybeTraitFunctionBodyGreen {
    fn from(value: TerminalSemicolonGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeTraitFunctionBodyGreen(pub GreenId);
impl TypedSyntaxNode for MaybeTraitFunctionBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeTraitFunctionBodyPtr;
    type Green = MaybeTraitFunctionBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprBlock => {
                MaybeTraitFunctionBody::Some(ExprBlock::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalSemicolon => {
                MaybeTraitFunctionBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "MaybeTraitFunctionBody"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ExprBlock => {
                Some(MaybeTraitFunctionBody::Some(ExprBlock::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalSemicolon => {
                Some(MaybeTraitFunctionBody::None(TerminalSemicolon::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            MaybeTraitFunctionBody::Some(x) => x.as_syntax_node(),
            MaybeTraitFunctionBody::None(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MaybeTraitFunctionBodyPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&MaybeTraitFunctionBody> for SyntaxStablePtrId {
    fn from(node: &MaybeTraitFunctionBody) -> Self {
        node.stable_ptr().untyped()
    }
}
impl MaybeTraitFunctionBody {
    /// Checks if a kind of a variant of [MaybeTraitFunctionBody].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::ExprBlock | SyntaxKind::TerminalSemicolon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemImpl {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemImpl {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_IMPL_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_OF_KW: usize = 5;
    pub const INDEX_TRAIT_PATH: usize = 6;
    pub const INDEX_BODY: usize = 7;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        impl_kw: TerminalImplGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        of_kw: TerminalOfGreen,
        trait_path: ExprPathGreen,
        body: MaybeImplBodyGreen,
    ) -> ItemImplGreen {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            impl_kw.0,
            name.0,
            generic_params.0,
            of_kw.0,
            trait_path.0,
            body.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemImpl,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemImpl {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn impl_kw(&self, db: &dyn SyntaxGroup) -> TerminalImpl {
        TerminalImpl::from_syntax_node(db, self.children[2].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4].clone())
    }
    pub fn of_kw(&self, db: &dyn SyntaxGroup) -> TerminalOf {
        TerminalOf::from_syntax_node(db, self.children[5].clone())
    }
    pub fn trait_path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[6].clone())
    }
    pub fn body(&self, db: &dyn SyntaxGroup) -> MaybeImplBody {
        MaybeImplBody::from_syntax_node(db, self.children[7].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemImplPtr(pub SyntaxStablePtrId);
impl ItemImplPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemImplPtr {
    type SyntaxNode = ItemImpl;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemImpl {
        ItemImpl::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemImplPtr> for SyntaxStablePtrId {
    fn from(ptr: ItemImplPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemImplGreen(pub GreenId);
impl TypedSyntaxNode for ItemImpl {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemImpl);
    type StablePtr = ItemImplPtr;
    type Green = ItemImplGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemImpl,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalImpl::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalOf::missing(db).0,
                        ExprPath::missing(db).0,
                        MaybeImplBody::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemImpl,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemImpl
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemImpl { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemImplPtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemImpl> for SyntaxStablePtrId {
    fn from(node: &ItemImpl) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemInlineMacro {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemInlineMacro {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_BANG: usize = 2;
    pub const INDEX_ARGUMENTS: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        name: TerminalIdentifierGreen,
        bang: TerminalNotGreen,
        arguments: WrappedArgListGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> ItemInlineMacroGreen {
        let children: Vec<GreenId> = vec![attributes.0, name.0, bang.0, arguments.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemInlineMacro,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemInlineMacro {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn bang(&self, db: &dyn SyntaxGroup) -> TerminalNot {
        TerminalNot::from_syntax_node(db, self.children[2].clone())
    }
    pub fn arguments(&self, db: &dyn SyntaxGroup) -> WrappedArgList {
        WrappedArgList::from_syntax_node(db, self.children[3].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemInlineMacroPtr(pub SyntaxStablePtrId);
impl ItemInlineMacroPtr {}
impl TypedStablePtr for ItemInlineMacroPtr {
    type SyntaxNode = ItemInlineMacro;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemInlineMacro {
        ItemInlineMacro::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemInlineMacroPtr> for SyntaxStablePtrId {
    fn from(ptr: ItemInlineMacroPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemInlineMacroGreen(pub GreenId);
impl TypedSyntaxNode for ItemInlineMacro {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemInlineMacro);
    type StablePtr = ItemInlineMacroPtr;
    type Green = ItemInlineMacroGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemInlineMacroGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemInlineMacro,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalNot::missing(db).0,
                        WrappedArgList::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemInlineMacro,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemInlineMacro
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemInlineMacro {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemInlineMacroPtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemInlineMacro> for SyntaxStablePtrId {
    fn from(node: &ItemInlineMacro) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemHeaderDoc {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemHeaderDoc {
    pub const INDEX_EMPTY: usize = 0;
    pub fn new_green(db: &dyn SyntaxGroup, empty: TerminalEmptyGreen) -> ItemHeaderDocGreen {
        let children: Vec<GreenId> = vec![empty.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemHeaderDocGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemHeaderDoc,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemHeaderDoc {
    pub fn empty(&self, db: &dyn SyntaxGroup) -> TerminalEmpty {
        TerminalEmpty::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemHeaderDocPtr(pub SyntaxStablePtrId);
impl ItemHeaderDocPtr {}
impl TypedStablePtr for ItemHeaderDocPtr {
    type SyntaxNode = ItemHeaderDoc;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemHeaderDoc {
        ItemHeaderDoc::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemHeaderDocPtr> for SyntaxStablePtrId {
    fn from(ptr: ItemHeaderDocPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemHeaderDocGreen(pub GreenId);
impl TypedSyntaxNode for ItemHeaderDoc {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemHeaderDoc);
    type StablePtr = ItemHeaderDocPtr;
    type Green = ItemHeaderDocGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemHeaderDocGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemHeaderDoc,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalEmpty::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemHeaderDoc,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemHeaderDoc
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemHeaderDoc {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemHeaderDocPtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemHeaderDoc> for SyntaxStablePtrId {
    fn from(node: &ItemHeaderDoc) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum MaybeImplBody {
    Some(ImplBody),
    None(TerminalSemicolon),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeImplBodyPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for MaybeImplBodyPtr {
    type SyntaxNode = MaybeImplBody;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> MaybeImplBody {
        MaybeImplBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<MaybeImplBodyPtr> for SyntaxStablePtrId {
    fn from(ptr: MaybeImplBodyPtr) -> Self {
        ptr.untyped()
    }
}
impl From<ImplBodyPtr> for MaybeImplBodyPtr {
    fn from(value: ImplBodyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonPtr> for MaybeImplBodyPtr {
    fn from(value: TerminalSemicolonPtr) -> Self {
        Self(value.0)
    }
}
impl From<ImplBodyGreen> for MaybeImplBodyGreen {
    fn from(value: ImplBodyGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonGreen> for MaybeImplBodyGreen {
    fn from(value: TerminalSemicolonGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct MaybeImplBodyGreen(pub GreenId);
impl TypedSyntaxNode for MaybeImplBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = MaybeImplBodyPtr;
    type Green = MaybeImplBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ImplBody => MaybeImplBody::Some(ImplBody::from_syntax_node(db, node)),
            SyntaxKind::TerminalSemicolon => {
                MaybeImplBody::None(TerminalSemicolon::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "MaybeImplBody"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::ImplBody => Some(MaybeImplBody::Some(ImplBody::from_syntax_node(db, node))),
            SyntaxKind::TerminalSemicolon => {
                Some(MaybeImplBody::None(TerminalSemicolon::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            MaybeImplBody::Some(x) => x.as_syntax_node(),
            MaybeImplBody::None(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        MaybeImplBodyPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&MaybeImplBody> for SyntaxStablePtrId {
    fn from(node: &MaybeImplBody) -> Self {
        node.stable_ptr().untyped()
    }
}
impl MaybeImplBody {
    /// Checks if a kind of a variant of [MaybeImplBody].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::ImplBody | SyntaxKind::TerminalSemicolon)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ImplBody {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ImplBody {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_ITEMS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        items: ImplItemListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ImplBodyGreen {
        let children: Vec<GreenId> = vec![lbrace.0, items.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ImplBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplBody,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ImplBody {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn items(&self, db: &dyn SyntaxGroup) -> ImplItemList {
        ImplItemList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplBodyPtr(pub SyntaxStablePtrId);
impl ImplBodyPtr {}
impl TypedStablePtr for ImplBodyPtr {
    type SyntaxNode = ImplBody;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ImplBody {
        ImplBody::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ImplBodyPtr> for SyntaxStablePtrId {
    fn from(ptr: ImplBodyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplBodyGreen(pub GreenId);
impl TypedSyntaxNode for ImplBody {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplBody);
    type StablePtr = ImplBodyPtr;
    type Green = ImplBodyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ImplBodyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplBody,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        ImplItemList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ImplBody,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ImplBody
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ImplBody { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ImplBodyPtr(self.node.0.stable_ptr)
    }
}
impl From<&ImplBody> for SyntaxStablePtrId {
    fn from(node: &ImplBody) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ImplItemList(ElementList<ImplItem, 1>);
impl Deref for ImplItemList {
    type Target = ElementList<ImplItem, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ImplItemList {
    pub fn new_green(db: &dyn SyntaxGroup, children: Vec<ImplItemGreen>) -> ImplItemListGreen {
        let width = children.iter().map(|id| id.0.lookup_intern(db).width()).sum();
        ImplItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplItemList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.0).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplItemListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ImplItemListPtr {
    type SyntaxNode = ImplItemList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ImplItemList {
        ImplItemList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ImplItemListPtr> for SyntaxStablePtrId {
    fn from(ptr: ImplItemListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplItemListGreen(pub GreenId);
impl TypedSyntaxNode for ImplItemList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplItemList);
    type StablePtr = ImplItemListPtr;
    type Green = ImplItemListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ImplItemListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplItemList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::ImplItemList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ImplItemListPtr(self.node.0.stable_ptr)
    }
}
impl From<&ImplItemList> for SyntaxStablePtrId {
    fn from(node: &ImplItemList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum ImplItem {
    Function(FunctionWithBody),
    Type(ItemTypeAlias),
    Constant(ItemConstant),
    Impl(ItemImplAlias),
    Module(ItemModule),
    Use(ItemUse),
    ExternFunction(ItemExternFunction),
    ExternType(ItemExternType),
    Trait(ItemTrait),
    Struct(ItemStruct),
    Enum(ItemEnum),
    Missing(ImplItemMissing),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplItemPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for ImplItemPtr {
    type SyntaxNode = ImplItem;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ImplItem {
        ImplItem::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ImplItemPtr> for SyntaxStablePtrId {
    fn from(ptr: ImplItemPtr) -> Self {
        ptr.untyped()
    }
}
impl From<FunctionWithBodyPtr> for ImplItemPtr {
    fn from(value: FunctionWithBodyPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemTypeAliasPtr> for ImplItemPtr {
    fn from(value: ItemTypeAliasPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemConstantPtr> for ImplItemPtr {
    fn from(value: ItemConstantPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemImplAliasPtr> for ImplItemPtr {
    fn from(value: ItemImplAliasPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemModulePtr> for ImplItemPtr {
    fn from(value: ItemModulePtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemUsePtr> for ImplItemPtr {
    fn from(value: ItemUsePtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternFunctionPtr> for ImplItemPtr {
    fn from(value: ItemExternFunctionPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternTypePtr> for ImplItemPtr {
    fn from(value: ItemExternTypePtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemTraitPtr> for ImplItemPtr {
    fn from(value: ItemTraitPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemStructPtr> for ImplItemPtr {
    fn from(value: ItemStructPtr) -> Self {
        Self(value.0)
    }
}
impl From<ItemEnumPtr> for ImplItemPtr {
    fn from(value: ItemEnumPtr) -> Self {
        Self(value.0)
    }
}
impl From<ImplItemMissingPtr> for ImplItemPtr {
    fn from(value: ImplItemMissingPtr) -> Self {
        Self(value.0)
    }
}
impl From<FunctionWithBodyGreen> for ImplItemGreen {
    fn from(value: FunctionWithBodyGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemTypeAliasGreen> for ImplItemGreen {
    fn from(value: ItemTypeAliasGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemConstantGreen> for ImplItemGreen {
    fn from(value: ItemConstantGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemImplAliasGreen> for ImplItemGreen {
    fn from(value: ItemImplAliasGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemModuleGreen> for ImplItemGreen {
    fn from(value: ItemModuleGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemUseGreen> for ImplItemGreen {
    fn from(value: ItemUseGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternFunctionGreen> for ImplItemGreen {
    fn from(value: ItemExternFunctionGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemExternTypeGreen> for ImplItemGreen {
    fn from(value: ItemExternTypeGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemTraitGreen> for ImplItemGreen {
    fn from(value: ItemTraitGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemStructGreen> for ImplItemGreen {
    fn from(value: ItemStructGreen) -> Self {
        Self(value.0)
    }
}
impl From<ItemEnumGreen> for ImplItemGreen {
    fn from(value: ItemEnumGreen) -> Self {
        Self(value.0)
    }
}
impl From<ImplItemMissingGreen> for ImplItemGreen {
    fn from(value: ImplItemMissingGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplItemGreen(pub GreenId);
impl TypedSyntaxNode for ImplItem {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = ImplItemPtr;
    type Green = ImplItemGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ImplItemGreen(ImplItemMissing::missing(db).0)
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::FunctionWithBody => {
                ImplItem::Function(FunctionWithBody::from_syntax_node(db, node))
            }
            SyntaxKind::ItemTypeAlias => ImplItem::Type(ItemTypeAlias::from_syntax_node(db, node)),
            SyntaxKind::ItemConstant => {
                ImplItem::Constant(ItemConstant::from_syntax_node(db, node))
            }
            SyntaxKind::ItemImplAlias => ImplItem::Impl(ItemImplAlias::from_syntax_node(db, node)),
            SyntaxKind::ItemModule => ImplItem::Module(ItemModule::from_syntax_node(db, node)),
            SyntaxKind::ItemUse => ImplItem::Use(ItemUse::from_syntax_node(db, node)),
            SyntaxKind::ItemExternFunction => {
                ImplItem::ExternFunction(ItemExternFunction::from_syntax_node(db, node))
            }
            SyntaxKind::ItemExternType => {
                ImplItem::ExternType(ItemExternType::from_syntax_node(db, node))
            }
            SyntaxKind::ItemTrait => ImplItem::Trait(ItemTrait::from_syntax_node(db, node)),
            SyntaxKind::ItemStruct => ImplItem::Struct(ItemStruct::from_syntax_node(db, node)),
            SyntaxKind::ItemEnum => ImplItem::Enum(ItemEnum::from_syntax_node(db, node)),
            SyntaxKind::ImplItemMissing => {
                ImplItem::Missing(ImplItemMissing::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "ImplItem"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::FunctionWithBody => {
                Some(ImplItem::Function(FunctionWithBody::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemTypeAlias => {
                Some(ImplItem::Type(ItemTypeAlias::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemConstant => {
                Some(ImplItem::Constant(ItemConstant::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemImplAlias => {
                Some(ImplItem::Impl(ItemImplAlias::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemModule => {
                Some(ImplItem::Module(ItemModule::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemUse => Some(ImplItem::Use(ItemUse::from_syntax_node(db, node))),
            SyntaxKind::ItemExternFunction => {
                Some(ImplItem::ExternFunction(ItemExternFunction::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemExternType => {
                Some(ImplItem::ExternType(ItemExternType::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemTrait => Some(ImplItem::Trait(ItemTrait::from_syntax_node(db, node))),
            SyntaxKind::ItemStruct => {
                Some(ImplItem::Struct(ItemStruct::from_syntax_node(db, node)))
            }
            SyntaxKind::ItemEnum => Some(ImplItem::Enum(ItemEnum::from_syntax_node(db, node))),
            SyntaxKind::ImplItemMissing => {
                Some(ImplItem::Missing(ImplItemMissing::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            ImplItem::Function(x) => x.as_syntax_node(),
            ImplItem::Type(x) => x.as_syntax_node(),
            ImplItem::Constant(x) => x.as_syntax_node(),
            ImplItem::Impl(x) => x.as_syntax_node(),
            ImplItem::Module(x) => x.as_syntax_node(),
            ImplItem::Use(x) => x.as_syntax_node(),
            ImplItem::ExternFunction(x) => x.as_syntax_node(),
            ImplItem::ExternType(x) => x.as_syntax_node(),
            ImplItem::Trait(x) => x.as_syntax_node(),
            ImplItem::Struct(x) => x.as_syntax_node(),
            ImplItem::Enum(x) => x.as_syntax_node(),
            ImplItem::Missing(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ImplItemPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&ImplItem> for SyntaxStablePtrId {
    fn from(node: &ImplItem) -> Self {
        node.stable_ptr().untyped()
    }
}
impl ImplItem {
    /// Checks if a kind of a variant of [ImplItem].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::FunctionWithBody
                | SyntaxKind::ItemTypeAlias
                | SyntaxKind::ItemConstant
                | SyntaxKind::ItemImplAlias
                | SyntaxKind::ItemModule
                | SyntaxKind::ItemUse
                | SyntaxKind::ItemExternFunction
                | SyntaxKind::ItemExternType
                | SyntaxKind::ItemTrait
                | SyntaxKind::ItemStruct
                | SyntaxKind::ItemEnum
                | SyntaxKind::ImplItemMissing
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ImplItemMissing {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ImplItemMissing {
    pub fn new_green(db: &dyn SyntaxGroup) -> ImplItemMissingGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ImplItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplItemMissing,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ImplItemMissing {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplItemMissingPtr(pub SyntaxStablePtrId);
impl ImplItemMissingPtr {}
impl TypedStablePtr for ImplItemMissingPtr {
    type SyntaxNode = ImplItemMissing;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ImplItemMissing {
        ImplItemMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ImplItemMissingPtr> for SyntaxStablePtrId {
    fn from(ptr: ImplItemMissingPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ImplItemMissingGreen(pub GreenId);
impl TypedSyntaxNode for ImplItemMissing {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ImplItemMissing);
    type StablePtr = ImplItemMissingPtr;
    type Green = ImplItemMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ImplItemMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ImplItemMissing,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ImplItemMissing,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ImplItemMissing
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ImplItemMissing {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ImplItemMissingPtr(self.node.0.stable_ptr)
    }
}
impl From<&ImplItemMissing> for SyntaxStablePtrId {
    fn from(node: &ImplItemMissing) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemImplAlias {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemImplAlias {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_IMPL_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_EQ: usize = 5;
    pub const INDEX_IMPL_PATH: usize = 6;
    pub const INDEX_SEMICOLON: usize = 7;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        impl_kw: TerminalImplGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        eq: TerminalEqGreen,
        impl_path: ExprPathGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> ItemImplAliasGreen {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            impl_kw.0,
            name.0,
            generic_params.0,
            eq.0,
            impl_path.0,
            semicolon.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemImplAliasGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemImplAlias,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemImplAlias {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn impl_kw(&self, db: &dyn SyntaxGroup) -> TerminalImpl {
        TerminalImpl::from_syntax_node(db, self.children[2].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4].clone())
    }
    pub fn eq(&self, db: &dyn SyntaxGroup) -> TerminalEq {
        TerminalEq::from_syntax_node(db, self.children[5].clone())
    }
    pub fn impl_path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[6].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[7].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemImplAliasPtr(pub SyntaxStablePtrId);
impl ItemImplAliasPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemImplAliasPtr {
    type SyntaxNode = ItemImplAlias;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemImplAlias {
        ItemImplAlias::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemImplAliasPtr> for SyntaxStablePtrId {
    fn from(ptr: ItemImplAliasPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemImplAliasGreen(pub GreenId);
impl TypedSyntaxNode for ItemImplAlias {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemImplAlias);
    type StablePtr = ItemImplAliasPtr;
    type Green = ItemImplAliasGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemImplAliasGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemImplAlias,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalImpl::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalEq::missing(db).0,
                        ExprPath::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemImplAlias,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemImplAlias
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemImplAlias {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemImplAliasPtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemImplAlias> for SyntaxStablePtrId {
    fn from(node: &ItemImplAlias) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemStruct {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemStruct {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_STRUCT_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_LBRACE: usize = 5;
    pub const INDEX_MEMBERS: usize = 6;
    pub const INDEX_RBRACE: usize = 7;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        struct_kw: TerminalStructGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        lbrace: TerminalLBraceGreen,
        members: MemberListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ItemStructGreen {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            struct_kw.0,
            name.0,
            generic_params.0,
            lbrace.0,
            members.0,
            rbrace.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemStruct,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemStruct {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn struct_kw(&self, db: &dyn SyntaxGroup) -> TerminalStruct {
        TerminalStruct::from_syntax_node(db, self.children[2].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[5].clone())
    }
    pub fn members(&self, db: &dyn SyntaxGroup) -> MemberList {
        MemberList::from_syntax_node(db, self.children[6].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[7].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemStructPtr(pub SyntaxStablePtrId);
impl ItemStructPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemStructPtr {
    type SyntaxNode = ItemStruct;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemStruct {
        ItemStruct::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemStructPtr> for SyntaxStablePtrId {
    fn from(ptr: ItemStructPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemStructGreen(pub GreenId);
impl TypedSyntaxNode for ItemStruct {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemStruct);
    type StablePtr = ItemStructPtr;
    type Green = ItemStructGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemStruct,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalStruct::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalLBrace::missing(db).0,
                        MemberList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemStruct,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemStruct
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemStruct { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemStructPtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemStruct> for SyntaxStablePtrId {
    fn from(node: &ItemStruct) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemEnum {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemEnum {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_ENUM_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_LBRACE: usize = 5;
    pub const INDEX_VARIANTS: usize = 6;
    pub const INDEX_RBRACE: usize = 7;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        enum_kw: TerminalEnumGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        lbrace: TerminalLBraceGreen,
        variants: VariantListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> ItemEnumGreen {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            enum_kw.0,
            name.0,
            generic_params.0,
            lbrace.0,
            variants.0,
            rbrace.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemEnum,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemEnum {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn enum_kw(&self, db: &dyn SyntaxGroup) -> TerminalEnum {
        TerminalEnum::from_syntax_node(db, self.children[2].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4].clone())
    }
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[5].clone())
    }
    pub fn variants(&self, db: &dyn SyntaxGroup) -> VariantList {
        VariantList::from_syntax_node(db, self.children[6].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[7].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemEnumPtr(pub SyntaxStablePtrId);
impl ItemEnumPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemEnumPtr {
    type SyntaxNode = ItemEnum;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemEnum {
        ItemEnum::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemEnumPtr> for SyntaxStablePtrId {
    fn from(ptr: ItemEnumPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemEnumGreen(pub GreenId);
impl TypedSyntaxNode for ItemEnum {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemEnum);
    type StablePtr = ItemEnumPtr;
    type Green = ItemEnumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemEnum,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalEnum::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalLBrace::missing(db).0,
                        VariantList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemEnum,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemEnum
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemEnum { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemEnumPtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemEnum> for SyntaxStablePtrId {
    fn from(node: &ItemEnum) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemTypeAlias {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemTypeAlias {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_TYPE_KW: usize = 2;
    pub const INDEX_NAME: usize = 3;
    pub const INDEX_GENERIC_PARAMS: usize = 4;
    pub const INDEX_EQ: usize = 5;
    pub const INDEX_TY: usize = 6;
    pub const INDEX_SEMICOLON: usize = 7;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        type_kw: TerminalTypeGreen,
        name: TerminalIdentifierGreen,
        generic_params: OptionWrappedGenericParamListGreen,
        eq: TerminalEqGreen,
        ty: ExprGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> ItemTypeAliasGreen {
        let children: Vec<GreenId> = vec![
            attributes.0,
            visibility.0,
            type_kw.0,
            name.0,
            generic_params.0,
            eq.0,
            ty.0,
            semicolon.0,
        ];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemTypeAliasGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemTypeAlias,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemTypeAlias {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn type_kw(&self, db: &dyn SyntaxGroup) -> TerminalType {
        TerminalType::from_syntax_node(db, self.children[2].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[3].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.children[4].clone())
    }
    pub fn eq(&self, db: &dyn SyntaxGroup) -> TerminalEq {
        TerminalEq::from_syntax_node(db, self.children[5].clone())
    }
    pub fn ty(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[6].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[7].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemTypeAliasPtr(pub SyntaxStablePtrId);
impl ItemTypeAliasPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemTypeAliasPtr {
    type SyntaxNode = ItemTypeAlias;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemTypeAlias {
        ItemTypeAlias::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemTypeAliasPtr> for SyntaxStablePtrId {
    fn from(ptr: ItemTypeAliasPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemTypeAliasGreen(pub GreenId);
impl TypedSyntaxNode for ItemTypeAlias {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemTypeAlias);
    type StablePtr = ItemTypeAliasPtr;
    type Green = ItemTypeAliasGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemTypeAliasGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemTypeAlias,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalType::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        OptionWrappedGenericParamList::missing(db).0,
                        TerminalEq::missing(db).0,
                        Expr::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemTypeAlias,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemTypeAlias
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemTypeAlias {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemTypeAliasPtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemTypeAlias> for SyntaxStablePtrId {
    fn from(node: &ItemTypeAlias) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct ItemUse {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl ItemUse {
    pub const INDEX_ATTRIBUTES: usize = 0;
    pub const INDEX_VISIBILITY: usize = 1;
    pub const INDEX_USE_KW: usize = 2;
    pub const INDEX_USE_PATH: usize = 3;
    pub const INDEX_SEMICOLON: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        attributes: AttributeListGreen,
        visibility: VisibilityGreen,
        use_kw: TerminalUseGreen,
        use_path: UsePathGreen,
        semicolon: TerminalSemicolonGreen,
    ) -> ItemUseGreen {
        let children: Vec<GreenId> =
            vec![attributes.0, visibility.0, use_kw.0, use_path.0, semicolon.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        ItemUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemUse,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl ItemUse {
    pub fn attributes(&self, db: &dyn SyntaxGroup) -> AttributeList {
        AttributeList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn visibility(&self, db: &dyn SyntaxGroup) -> Visibility {
        Visibility::from_syntax_node(db, self.children[1].clone())
    }
    pub fn use_kw(&self, db: &dyn SyntaxGroup) -> TerminalUse {
        TerminalUse::from_syntax_node(db, self.children[2].clone())
    }
    pub fn use_path(&self, db: &dyn SyntaxGroup) -> UsePath {
        UsePath::from_syntax_node(db, self.children[3].clone())
    }
    pub fn semicolon(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemUsePtr(pub SyntaxStablePtrId);
impl ItemUsePtr {
    pub fn use_path_green(self, db: &dyn SyntaxGroup) -> UsePathGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            UsePathGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for ItemUsePtr {
    type SyntaxNode = ItemUse;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> ItemUse {
        ItemUse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<ItemUsePtr> for SyntaxStablePtrId {
    fn from(ptr: ItemUsePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct ItemUseGreen(pub GreenId);
impl TypedSyntaxNode for ItemUse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::ItemUse);
    type StablePtr = ItemUsePtr;
    type Green = ItemUseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        ItemUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::ItemUse,
                details: GreenNodeDetails::Node {
                    children: vec![
                        AttributeList::missing(db).0,
                        Visibility::missing(db).0,
                        TerminalUse::missing(db).0,
                        UsePath::missing(db).0,
                        TerminalSemicolon::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::ItemUse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::ItemUse
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::ItemUse { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        ItemUsePtr(self.node.0.stable_ptr)
    }
}
impl From<&ItemUse> for SyntaxStablePtrId {
    fn from(node: &ItemUse) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum UsePath {
    Leaf(UsePathLeaf),
    Single(UsePathSingle),
    Multi(UsePathMulti),
    Star(UsePathStar),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for UsePathPtr {
    type SyntaxNode = UsePath;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> UsePath {
        UsePath::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<UsePathPtr> for SyntaxStablePtrId {
    fn from(ptr: UsePathPtr) -> Self {
        ptr.untyped()
    }
}
impl From<UsePathLeafPtr> for UsePathPtr {
    fn from(value: UsePathLeafPtr) -> Self {
        Self(value.0)
    }
}
impl From<UsePathSinglePtr> for UsePathPtr {
    fn from(value: UsePathSinglePtr) -> Self {
        Self(value.0)
    }
}
impl From<UsePathMultiPtr> for UsePathPtr {
    fn from(value: UsePathMultiPtr) -> Self {
        Self(value.0)
    }
}
impl From<UsePathStarPtr> for UsePathPtr {
    fn from(value: UsePathStarPtr) -> Self {
        Self(value.0)
    }
}
impl From<UsePathLeafGreen> for UsePathGreen {
    fn from(value: UsePathLeafGreen) -> Self {
        Self(value.0)
    }
}
impl From<UsePathSingleGreen> for UsePathGreen {
    fn from(value: UsePathSingleGreen) -> Self {
        Self(value.0)
    }
}
impl From<UsePathMultiGreen> for UsePathGreen {
    fn from(value: UsePathMultiGreen) -> Self {
        Self(value.0)
    }
}
impl From<UsePathStarGreen> for UsePathGreen {
    fn from(value: UsePathStarGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathGreen(pub GreenId);
impl TypedSyntaxNode for UsePath {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = UsePathPtr;
    type Green = UsePathGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::UsePathLeaf => UsePath::Leaf(UsePathLeaf::from_syntax_node(db, node)),
            SyntaxKind::UsePathSingle => UsePath::Single(UsePathSingle::from_syntax_node(db, node)),
            SyntaxKind::UsePathMulti => UsePath::Multi(UsePathMulti::from_syntax_node(db, node)),
            SyntaxKind::UsePathStar => UsePath::Star(UsePathStar::from_syntax_node(db, node)),
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "UsePath"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::UsePathLeaf => Some(UsePath::Leaf(UsePathLeaf::from_syntax_node(db, node))),
            SyntaxKind::UsePathSingle => {
                Some(UsePath::Single(UsePathSingle::from_syntax_node(db, node)))
            }
            SyntaxKind::UsePathMulti => {
                Some(UsePath::Multi(UsePathMulti::from_syntax_node(db, node)))
            }
            SyntaxKind::UsePathStar => Some(UsePath::Star(UsePathStar::from_syntax_node(db, node))),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            UsePath::Leaf(x) => x.as_syntax_node(),
            UsePath::Single(x) => x.as_syntax_node(),
            UsePath::Multi(x) => x.as_syntax_node(),
            UsePath::Star(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        UsePathPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&UsePath> for SyntaxStablePtrId {
    fn from(node: &UsePath) -> Self {
        node.stable_ptr().untyped()
    }
}
impl UsePath {
    /// Checks if a kind of a variant of [UsePath].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::UsePathLeaf
                | SyntaxKind::UsePathSingle
                | SyntaxKind::UsePathMulti
                | SyntaxKind::UsePathStar
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct UsePathLeaf {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl UsePathLeaf {
    pub const INDEX_IDENT: usize = 0;
    pub const INDEX_ALIAS_CLAUSE: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        ident: PathSegmentGreen,
        alias_clause: OptionAliasClauseGreen,
    ) -> UsePathLeafGreen {
        let children: Vec<GreenId> = vec![ident.0, alias_clause.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        UsePathLeafGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathLeaf,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl UsePathLeaf {
    pub fn ident(&self, db: &dyn SyntaxGroup) -> PathSegment {
        PathSegment::from_syntax_node(db, self.children[0].clone())
    }
    pub fn alias_clause(&self, db: &dyn SyntaxGroup) -> OptionAliasClause {
        OptionAliasClause::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathLeafPtr(pub SyntaxStablePtrId);
impl UsePathLeafPtr {
    pub fn ident_green(self, db: &dyn SyntaxGroup) -> PathSegmentGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            PathSegmentGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
    pub fn alias_clause_green(self, db: &dyn SyntaxGroup) -> OptionAliasClauseGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            OptionAliasClauseGreen(key_fields[1])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for UsePathLeafPtr {
    type SyntaxNode = UsePathLeaf;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> UsePathLeaf {
        UsePathLeaf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<UsePathLeafPtr> for SyntaxStablePtrId {
    fn from(ptr: UsePathLeafPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathLeafGreen(pub GreenId);
impl TypedSyntaxNode for UsePathLeaf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::UsePathLeaf);
    type StablePtr = UsePathLeafPtr;
    type Green = UsePathLeafGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        UsePathLeafGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathLeaf,
                details: GreenNodeDetails::Node {
                    children: vec![PathSegment::missing(db).0, OptionAliasClause::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::UsePathLeaf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::UsePathLeaf
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::UsePathLeaf { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        UsePathLeafPtr(self.node.0.stable_ptr)
    }
}
impl From<&UsePathLeaf> for SyntaxStablePtrId {
    fn from(node: &UsePathLeaf) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct UsePathSingle {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl UsePathSingle {
    pub const INDEX_IDENT: usize = 0;
    pub const INDEX_COLON_COLON: usize = 1;
    pub const INDEX_USE_PATH: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        ident: PathSegmentGreen,
        colon_colon: TerminalColonColonGreen,
        use_path: UsePathGreen,
    ) -> UsePathSingleGreen {
        let children: Vec<GreenId> = vec![ident.0, colon_colon.0, use_path.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        UsePathSingleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathSingle,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl UsePathSingle {
    pub fn ident(&self, db: &dyn SyntaxGroup) -> PathSegment {
        PathSegment::from_syntax_node(db, self.children[0].clone())
    }
    pub fn colon_colon(&self, db: &dyn SyntaxGroup) -> TerminalColonColon {
        TerminalColonColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn use_path(&self, db: &dyn SyntaxGroup) -> UsePath {
        UsePath::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathSinglePtr(pub SyntaxStablePtrId);
impl UsePathSinglePtr {}
impl TypedStablePtr for UsePathSinglePtr {
    type SyntaxNode = UsePathSingle;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> UsePathSingle {
        UsePathSingle::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<UsePathSinglePtr> for SyntaxStablePtrId {
    fn from(ptr: UsePathSinglePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathSingleGreen(pub GreenId);
impl TypedSyntaxNode for UsePathSingle {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::UsePathSingle);
    type StablePtr = UsePathSinglePtr;
    type Green = UsePathSingleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        UsePathSingleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathSingle,
                details: GreenNodeDetails::Node {
                    children: vec![
                        PathSegment::missing(db).0,
                        TerminalColonColon::missing(db).0,
                        UsePath::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::UsePathSingle,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::UsePathSingle
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::UsePathSingle {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        UsePathSinglePtr(self.node.0.stable_ptr)
    }
}
impl From<&UsePathSingle> for SyntaxStablePtrId {
    fn from(node: &UsePathSingle) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct UsePathMulti {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl UsePathMulti {
    pub const INDEX_LBRACE: usize = 0;
    pub const INDEX_USE_PATHS: usize = 1;
    pub const INDEX_RBRACE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrace: TerminalLBraceGreen,
        use_paths: UsePathListGreen,
        rbrace: TerminalRBraceGreen,
    ) -> UsePathMultiGreen {
        let children: Vec<GreenId> = vec![lbrace.0, use_paths.0, rbrace.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        UsePathMultiGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathMulti,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl UsePathMulti {
    pub fn lbrace(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.children[0].clone())
    }
    pub fn use_paths(&self, db: &dyn SyntaxGroup) -> UsePathList {
        UsePathList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrace(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathMultiPtr(pub SyntaxStablePtrId);
impl UsePathMultiPtr {}
impl TypedStablePtr for UsePathMultiPtr {
    type SyntaxNode = UsePathMulti;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> UsePathMulti {
        UsePathMulti::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<UsePathMultiPtr> for SyntaxStablePtrId {
    fn from(ptr: UsePathMultiPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathMultiGreen(pub GreenId);
impl TypedSyntaxNode for UsePathMulti {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::UsePathMulti);
    type StablePtr = UsePathMultiPtr;
    type Green = UsePathMultiGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        UsePathMultiGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathMulti,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrace::missing(db).0,
                        UsePathList::missing(db).0,
                        TerminalRBrace::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::UsePathMulti,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::UsePathMulti
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::UsePathMulti { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        UsePathMultiPtr(self.node.0.stable_ptr)
    }
}
impl From<&UsePathMulti> for SyntaxStablePtrId {
    fn from(node: &UsePathMulti) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct UsePathStar {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl UsePathStar {
    pub const INDEX_STAR: usize = 0;
    pub fn new_green(db: &dyn SyntaxGroup, star: TerminalMulGreen) -> UsePathStarGreen {
        let children: Vec<GreenId> = vec![star.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        UsePathStarGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathStar,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl UsePathStar {
    pub fn star(&self, db: &dyn SyntaxGroup) -> TerminalMul {
        TerminalMul::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathStarPtr(pub SyntaxStablePtrId);
impl UsePathStarPtr {}
impl TypedStablePtr for UsePathStarPtr {
    type SyntaxNode = UsePathStar;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> UsePathStar {
        UsePathStar::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<UsePathStarPtr> for SyntaxStablePtrId {
    fn from(ptr: UsePathStarPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathStarGreen(pub GreenId);
impl TypedSyntaxNode for UsePathStar {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::UsePathStar);
    type StablePtr = UsePathStarPtr;
    type Green = UsePathStarGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        UsePathStarGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathStar,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalMul::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::UsePathStar,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::UsePathStar
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::UsePathStar { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        UsePathStarPtr(self.node.0.stable_ptr)
    }
}
impl From<&UsePathStar> for SyntaxStablePtrId {
    fn from(node: &UsePathStar) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct UsePathList(ElementList<UsePath, 2>);
impl Deref for UsePathList {
    type Target = ElementList<UsePath, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl UsePathList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<UsePathListElementOrSeparatorGreen>,
    ) -> UsePathListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        UsePathListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for UsePathListPtr {
    type SyntaxNode = UsePathList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> UsePathList {
        UsePathList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<UsePathListPtr> for SyntaxStablePtrId {
    fn from(ptr: UsePathListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum UsePathListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(UsePathGreen),
}
impl From<TerminalCommaGreen> for UsePathListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        UsePathListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<UsePathGreen> for UsePathListElementOrSeparatorGreen {
    fn from(value: UsePathGreen) -> Self {
        UsePathListElementOrSeparatorGreen::Element(value)
    }
}
impl UsePathListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            UsePathListElementOrSeparatorGreen::Separator(green) => green.0,
            UsePathListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct UsePathListGreen(pub GreenId);
impl TypedSyntaxNode for UsePathList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::UsePathList);
    type StablePtr = UsePathListPtr;
    type Green = UsePathListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        UsePathListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::UsePathList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::UsePathList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        UsePathListPtr(self.node.0.stable_ptr)
    }
}
impl From<&UsePathList> for SyntaxStablePtrId {
    fn from(node: &UsePathList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct AliasClause {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl AliasClause {
    pub const INDEX_AS_KW: usize = 0;
    pub const INDEX_ALIAS: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        as_kw: TerminalAsGreen,
        alias: TerminalIdentifierGreen,
    ) -> AliasClauseGreen {
        let children: Vec<GreenId> = vec![as_kw.0, alias.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        AliasClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AliasClause,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl AliasClause {
    pub fn as_kw(&self, db: &dyn SyntaxGroup) -> TerminalAs {
        TerminalAs::from_syntax_node(db, self.children[0].clone())
    }
    pub fn alias(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AliasClausePtr(pub SyntaxStablePtrId);
impl AliasClausePtr {
    pub fn alias_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for AliasClausePtr {
    type SyntaxNode = AliasClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> AliasClause {
        AliasClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<AliasClausePtr> for SyntaxStablePtrId {
    fn from(ptr: AliasClausePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AliasClauseGreen(pub GreenId);
impl TypedSyntaxNode for AliasClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AliasClause);
    type StablePtr = AliasClausePtr;
    type Green = AliasClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        AliasClauseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AliasClause,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalAs::missing(db).0, TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::AliasClause,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::AliasClause
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::AliasClause { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        AliasClausePtr(self.node.0.stable_ptr)
    }
}
impl From<&AliasClause> for SyntaxStablePtrId {
    fn from(node: &AliasClause) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionAliasClause {
    Empty(OptionAliasClauseEmpty),
    AliasClause(AliasClause),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAliasClausePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionAliasClausePtr {
    type SyntaxNode = OptionAliasClause;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionAliasClause {
        OptionAliasClause::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionAliasClausePtr> for SyntaxStablePtrId {
    fn from(ptr: OptionAliasClausePtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionAliasClauseEmptyPtr> for OptionAliasClausePtr {
    fn from(value: OptionAliasClauseEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<AliasClausePtr> for OptionAliasClausePtr {
    fn from(value: AliasClausePtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionAliasClauseEmptyGreen> for OptionAliasClauseGreen {
    fn from(value: OptionAliasClauseEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<AliasClauseGreen> for OptionAliasClauseGreen {
    fn from(value: AliasClauseGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAliasClauseGreen(pub GreenId);
impl TypedSyntaxNode for OptionAliasClause {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionAliasClausePtr;
    type Green = OptionAliasClauseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionAliasClauseEmpty => {
                OptionAliasClause::Empty(OptionAliasClauseEmpty::from_syntax_node(db, node))
            }
            SyntaxKind::AliasClause => {
                OptionAliasClause::AliasClause(AliasClause::from_syntax_node(db, node))
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionAliasClause"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionAliasClauseEmpty => {
                Some(OptionAliasClause::Empty(OptionAliasClauseEmpty::from_syntax_node(db, node)))
            }
            SyntaxKind::AliasClause => {
                Some(OptionAliasClause::AliasClause(AliasClause::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionAliasClause::Empty(x) => x.as_syntax_node(),
            OptionAliasClause::AliasClause(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionAliasClausePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionAliasClause> for SyntaxStablePtrId {
    fn from(node: &OptionAliasClause) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionAliasClause {
    /// Checks if a kind of a variant of [OptionAliasClause].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::OptionAliasClauseEmpty | SyntaxKind::AliasClause)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionAliasClauseEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionAliasClauseEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionAliasClauseEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionAliasClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionAliasClauseEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionAliasClauseEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAliasClauseEmptyPtr(pub SyntaxStablePtrId);
impl OptionAliasClauseEmptyPtr {}
impl TypedStablePtr for OptionAliasClauseEmptyPtr {
    type SyntaxNode = OptionAliasClauseEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionAliasClauseEmpty {
        OptionAliasClauseEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionAliasClauseEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionAliasClauseEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAliasClauseEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionAliasClauseEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionAliasClauseEmpty);
    type StablePtr = OptionAliasClauseEmptyPtr;
    type Green = OptionAliasClauseEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionAliasClauseEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionAliasClauseEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionAliasClauseEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionAliasClauseEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionAliasClauseEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionAliasClauseEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionAliasClauseEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionAliasClauseEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum GenericArg {
    Unnamed(GenericArgUnnamed),
    Named(GenericArgNamed),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for GenericArgPtr {
    type SyntaxNode = GenericArg;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericArg {
        GenericArg::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericArgPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericArgPtr) -> Self {
        ptr.untyped()
    }
}
impl From<GenericArgUnnamedPtr> for GenericArgPtr {
    fn from(value: GenericArgUnnamedPtr) -> Self {
        Self(value.0)
    }
}
impl From<GenericArgNamedPtr> for GenericArgPtr {
    fn from(value: GenericArgNamedPtr) -> Self {
        Self(value.0)
    }
}
impl From<GenericArgUnnamedGreen> for GenericArgGreen {
    fn from(value: GenericArgUnnamedGreen) -> Self {
        Self(value.0)
    }
}
impl From<GenericArgNamedGreen> for GenericArgGreen {
    fn from(value: GenericArgNamedGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgGreen(pub GreenId);
impl TypedSyntaxNode for GenericArg {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = GenericArgPtr;
    type Green = GenericArgGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericArgUnnamed => {
                GenericArg::Unnamed(GenericArgUnnamed::from_syntax_node(db, node))
            }
            SyntaxKind::GenericArgNamed => {
                GenericArg::Named(GenericArgNamed::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "GenericArg"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericArgUnnamed => {
                Some(GenericArg::Unnamed(GenericArgUnnamed::from_syntax_node(db, node)))
            }
            SyntaxKind::GenericArgNamed => {
                Some(GenericArg::Named(GenericArgNamed::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            GenericArg::Unnamed(x) => x.as_syntax_node(),
            GenericArg::Named(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericArgPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&GenericArg> for SyntaxStablePtrId {
    fn from(node: &GenericArg) -> Self {
        node.stable_ptr().untyped()
    }
}
impl GenericArg {
    /// Checks if a kind of a variant of [GenericArg].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::GenericArgUnnamed | SyntaxKind::GenericArgNamed)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericArgNamed {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl GenericArgNamed {
    pub const INDEX_NAME: usize = 0;
    pub const INDEX_COLON: usize = 1;
    pub const INDEX_VALUE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        name: TerminalIdentifierGreen,
        colon: TerminalColonGreen,
        value: GenericArgValueGreen,
    ) -> GenericArgNamedGreen {
        let children: Vec<GreenId> = vec![name.0, colon.0, value.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericArgNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgNamed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl GenericArgNamed {
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn value(&self, db: &dyn SyntaxGroup) -> GenericArgValue {
        GenericArgValue::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgNamedPtr(pub SyntaxStablePtrId);
impl GenericArgNamedPtr {}
impl TypedStablePtr for GenericArgNamedPtr {
    type SyntaxNode = GenericArgNamed;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericArgNamed {
        GenericArgNamed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericArgNamedPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericArgNamedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgNamedGreen(pub GreenId);
impl TypedSyntaxNode for GenericArgNamed {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgNamed);
    type StablePtr = GenericArgNamedPtr;
    type Green = GenericArgNamedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericArgNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgNamed,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        GenericArgValue::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericArgNamed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericArgNamed
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericArgNamed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericArgNamedPtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericArgNamed> for SyntaxStablePtrId {
    fn from(node: &GenericArgNamed) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericArgUnnamed {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl GenericArgUnnamed {
    pub const INDEX_VALUE: usize = 0;
    pub fn new_green(db: &dyn SyntaxGroup, value: GenericArgValueGreen) -> GenericArgUnnamedGreen {
        let children: Vec<GreenId> = vec![value.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericArgUnnamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgUnnamed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl GenericArgUnnamed {
    pub fn value(&self, db: &dyn SyntaxGroup) -> GenericArgValue {
        GenericArgValue::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgUnnamedPtr(pub SyntaxStablePtrId);
impl GenericArgUnnamedPtr {}
impl TypedStablePtr for GenericArgUnnamedPtr {
    type SyntaxNode = GenericArgUnnamed;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericArgUnnamed {
        GenericArgUnnamed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericArgUnnamedPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericArgUnnamedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgUnnamedGreen(pub GreenId);
impl TypedSyntaxNode for GenericArgUnnamed {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgUnnamed);
    type StablePtr = GenericArgUnnamedPtr;
    type Green = GenericArgUnnamedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericArgUnnamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgUnnamed,
                details: GreenNodeDetails::Node {
                    children: vec![GenericArgValue::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericArgUnnamed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericArgUnnamed
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericArgUnnamed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericArgUnnamedPtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericArgUnnamed> for SyntaxStablePtrId {
    fn from(node: &GenericArgUnnamed) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum GenericArgValue {
    Expr(GenericArgValueExpr),
    Underscore(TerminalUnderscore),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgValuePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for GenericArgValuePtr {
    type SyntaxNode = GenericArgValue;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericArgValue {
        GenericArgValue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericArgValuePtr> for SyntaxStablePtrId {
    fn from(ptr: GenericArgValuePtr) -> Self {
        ptr.untyped()
    }
}
impl From<GenericArgValueExprPtr> for GenericArgValuePtr {
    fn from(value: GenericArgValueExprPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalUnderscorePtr> for GenericArgValuePtr {
    fn from(value: TerminalUnderscorePtr) -> Self {
        Self(value.0)
    }
}
impl From<GenericArgValueExprGreen> for GenericArgValueGreen {
    fn from(value: GenericArgValueExprGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalUnderscoreGreen> for GenericArgValueGreen {
    fn from(value: TerminalUnderscoreGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgValueGreen(pub GreenId);
impl TypedSyntaxNode for GenericArgValue {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = GenericArgValuePtr;
    type Green = GenericArgValueGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericArgValueExpr => {
                GenericArgValue::Expr(GenericArgValueExpr::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalUnderscore => {
                GenericArgValue::Underscore(TerminalUnderscore::from_syntax_node(db, node))
            }
            _ => {
                panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "GenericArgValue")
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericArgValueExpr => {
                Some(GenericArgValue::Expr(GenericArgValueExpr::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalUnderscore => {
                Some(GenericArgValue::Underscore(TerminalUnderscore::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            GenericArgValue::Expr(x) => x.as_syntax_node(),
            GenericArgValue::Underscore(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericArgValuePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&GenericArgValue> for SyntaxStablePtrId {
    fn from(node: &GenericArgValue) -> Self {
        node.stable_ptr().untyped()
    }
}
impl GenericArgValue {
    /// Checks if a kind of a variant of [GenericArgValue].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::GenericArgValueExpr | SyntaxKind::TerminalUnderscore)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericArgValueExpr {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl GenericArgValueExpr {
    pub const INDEX_EXPR: usize = 0;
    pub fn new_green(db: &dyn SyntaxGroup, expr: ExprGreen) -> GenericArgValueExprGreen {
        let children: Vec<GreenId> = vec![expr.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericArgValueExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgValueExpr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl GenericArgValueExpr {
    pub fn expr(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgValueExprPtr(pub SyntaxStablePtrId);
impl GenericArgValueExprPtr {}
impl TypedStablePtr for GenericArgValueExprPtr {
    type SyntaxNode = GenericArgValueExpr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericArgValueExpr {
        GenericArgValueExpr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericArgValueExprPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericArgValueExprPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgValueExprGreen(pub GreenId);
impl TypedSyntaxNode for GenericArgValueExpr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgValueExpr);
    type StablePtr = GenericArgValueExprPtr;
    type Green = GenericArgValueExprGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericArgValueExprGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgValueExpr,
                details: GreenNodeDetails::Node {
                    children: vec![Expr::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericArgValueExpr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericArgValueExpr
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericArgValueExpr {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericArgValueExprPtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericArgValueExpr> for SyntaxStablePtrId {
    fn from(node: &GenericArgValueExpr) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericArgs {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl GenericArgs {
    pub const INDEX_LANGLE: usize = 0;
    pub const INDEX_GENERIC_ARGS: usize = 1;
    pub const INDEX_RANGLE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        langle: TerminalLTGreen,
        generic_args: GenericArgListGreen,
        rangle: TerminalGTGreen,
    ) -> GenericArgsGreen {
        let children: Vec<GreenId> = vec![langle.0, generic_args.0, rangle.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericArgsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgs,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl GenericArgs {
    pub fn langle(&self, db: &dyn SyntaxGroup) -> TerminalLT {
        TerminalLT::from_syntax_node(db, self.children[0].clone())
    }
    pub fn generic_args(&self, db: &dyn SyntaxGroup) -> GenericArgList {
        GenericArgList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rangle(&self, db: &dyn SyntaxGroup) -> TerminalGT {
        TerminalGT::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgsPtr(pub SyntaxStablePtrId);
impl GenericArgsPtr {}
impl TypedStablePtr for GenericArgsPtr {
    type SyntaxNode = GenericArgs;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericArgs {
        GenericArgs::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericArgsPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericArgsPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgsGreen(pub GreenId);
impl TypedSyntaxNode for GenericArgs {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgs);
    type StablePtr = GenericArgsPtr;
    type Green = GenericArgsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericArgsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgs,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLT::missing(db).0,
                        GenericArgList::missing(db).0,
                        TerminalGT::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericArgs,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericArgs
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericArgs { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericArgsPtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericArgs> for SyntaxStablePtrId {
    fn from(node: &GenericArgs) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericArgList(ElementList<GenericArg, 2>);
impl Deref for GenericArgList {
    type Target = ElementList<GenericArg, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl GenericArgList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<GenericArgListElementOrSeparatorGreen>,
    ) -> GenericArgListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        GenericArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for GenericArgListPtr {
    type SyntaxNode = GenericArgList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericArgList {
        GenericArgList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericArgListPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericArgListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum GenericArgListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(GenericArgGreen),
}
impl From<TerminalCommaGreen> for GenericArgListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        GenericArgListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<GenericArgGreen> for GenericArgListElementOrSeparatorGreen {
    fn from(value: GenericArgGreen) -> Self {
        GenericArgListElementOrSeparatorGreen::Element(value)
    }
}
impl GenericArgListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            GenericArgListElementOrSeparatorGreen::Separator(green) => green.0,
            GenericArgListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericArgListGreen(pub GreenId);
impl TypedSyntaxNode for GenericArgList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericArgList);
    type StablePtr = GenericArgListPtr;
    type Green = GenericArgListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericArgListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericArgList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::GenericArgList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericArgListPtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericArgList> for SyntaxStablePtrId {
    fn from(node: &GenericArgList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct AssociatedItemConstraint {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl AssociatedItemConstraint {
    pub const INDEX_ITEM: usize = 0;
    pub const INDEX_COLON: usize = 1;
    pub const INDEX_VALUE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        item: TerminalIdentifierGreen,
        colon: TerminalColonGreen,
        value: ExprGreen,
    ) -> AssociatedItemConstraintGreen {
        let children: Vec<GreenId> = vec![item.0, colon.0, value.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        AssociatedItemConstraintGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraint,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl AssociatedItemConstraint {
    pub fn item(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn value(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AssociatedItemConstraintPtr(pub SyntaxStablePtrId);
impl AssociatedItemConstraintPtr {}
impl TypedStablePtr for AssociatedItemConstraintPtr {
    type SyntaxNode = AssociatedItemConstraint;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> AssociatedItemConstraint {
        AssociatedItemConstraint::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<AssociatedItemConstraintPtr> for SyntaxStablePtrId {
    fn from(ptr: AssociatedItemConstraintPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AssociatedItemConstraintGreen(pub GreenId);
impl TypedSyntaxNode for AssociatedItemConstraint {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AssociatedItemConstraint);
    type StablePtr = AssociatedItemConstraintPtr;
    type Green = AssociatedItemConstraintGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        AssociatedItemConstraintGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraint,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::AssociatedItemConstraint,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::AssociatedItemConstraint
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::AssociatedItemConstraint {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        AssociatedItemConstraintPtr(self.node.0.stable_ptr)
    }
}
impl From<&AssociatedItemConstraint> for SyntaxStablePtrId {
    fn from(node: &AssociatedItemConstraint) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct AssociatedItemConstraints {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl AssociatedItemConstraints {
    pub const INDEX_LBRACK: usize = 0;
    pub const INDEX_ASSOCIATED_ITEM_CONSTRAINTS: usize = 1;
    pub const INDEX_RBRACK: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        lbrack: TerminalLBrackGreen,
        associated_item_constraints: AssociatedItemConstraintListGreen,
        rbrack: TerminalRBrackGreen,
    ) -> AssociatedItemConstraintsGreen {
        let children: Vec<GreenId> = vec![lbrack.0, associated_item_constraints.0, rbrack.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        AssociatedItemConstraintsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraints,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl AssociatedItemConstraints {
    pub fn lbrack(&self, db: &dyn SyntaxGroup) -> TerminalLBrack {
        TerminalLBrack::from_syntax_node(db, self.children[0].clone())
    }
    pub fn associated_item_constraints(
        &self,
        db: &dyn SyntaxGroup,
    ) -> AssociatedItemConstraintList {
        AssociatedItemConstraintList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rbrack(&self, db: &dyn SyntaxGroup) -> TerminalRBrack {
        TerminalRBrack::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AssociatedItemConstraintsPtr(pub SyntaxStablePtrId);
impl AssociatedItemConstraintsPtr {}
impl TypedStablePtr for AssociatedItemConstraintsPtr {
    type SyntaxNode = AssociatedItemConstraints;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> AssociatedItemConstraints {
        AssociatedItemConstraints::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<AssociatedItemConstraintsPtr> for SyntaxStablePtrId {
    fn from(ptr: AssociatedItemConstraintsPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AssociatedItemConstraintsGreen(pub GreenId);
impl TypedSyntaxNode for AssociatedItemConstraints {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AssociatedItemConstraints);
    type StablePtr = AssociatedItemConstraintsPtr;
    type Green = AssociatedItemConstraintsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        AssociatedItemConstraintsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraints,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLBrack::missing(db).0,
                        AssociatedItemConstraintList::missing(db).0,
                        TerminalRBrack::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::AssociatedItemConstraints,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::AssociatedItemConstraints
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::AssociatedItemConstraints {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        AssociatedItemConstraintsPtr(self.node.0.stable_ptr)
    }
}
impl From<&AssociatedItemConstraints> for SyntaxStablePtrId {
    fn from(node: &AssociatedItemConstraints) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct AssociatedItemConstraintList(ElementList<AssociatedItemConstraint, 2>);
impl Deref for AssociatedItemConstraintList {
    type Target = ElementList<AssociatedItemConstraint, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl AssociatedItemConstraintList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<AssociatedItemConstraintListElementOrSeparatorGreen>,
    ) -> AssociatedItemConstraintListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        AssociatedItemConstraintListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraintList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AssociatedItemConstraintListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for AssociatedItemConstraintListPtr {
    type SyntaxNode = AssociatedItemConstraintList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> AssociatedItemConstraintList {
        AssociatedItemConstraintList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<AssociatedItemConstraintListPtr> for SyntaxStablePtrId {
    fn from(ptr: AssociatedItemConstraintListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum AssociatedItemConstraintListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(AssociatedItemConstraintGreen),
}
impl From<TerminalCommaGreen> for AssociatedItemConstraintListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        AssociatedItemConstraintListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<AssociatedItemConstraintGreen> for AssociatedItemConstraintListElementOrSeparatorGreen {
    fn from(value: AssociatedItemConstraintGreen) -> Self {
        AssociatedItemConstraintListElementOrSeparatorGreen::Element(value)
    }
}
impl AssociatedItemConstraintListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            AssociatedItemConstraintListElementOrSeparatorGreen::Separator(green) => green.0,
            AssociatedItemConstraintListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct AssociatedItemConstraintListGreen(pub GreenId);
impl TypedSyntaxNode for AssociatedItemConstraintList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::AssociatedItemConstraintList);
    type StablePtr = AssociatedItemConstraintListPtr;
    type Green = AssociatedItemConstraintListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        AssociatedItemConstraintListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::AssociatedItemConstraintList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::AssociatedItemConstraintList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        AssociatedItemConstraintListPtr(self.node.0.stable_ptr)
    }
}
impl From<&AssociatedItemConstraintList> for SyntaxStablePtrId {
    fn from(node: &AssociatedItemConstraintList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionAssociatedItemConstraints {
    Empty(OptionAssociatedItemConstraintsEmpty),
    AssociatedItemConstraints(AssociatedItemConstraints),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAssociatedItemConstraintsPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionAssociatedItemConstraintsPtr {
    type SyntaxNode = OptionAssociatedItemConstraints;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionAssociatedItemConstraints {
        OptionAssociatedItemConstraints::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionAssociatedItemConstraintsPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionAssociatedItemConstraintsPtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionAssociatedItemConstraintsEmptyPtr> for OptionAssociatedItemConstraintsPtr {
    fn from(value: OptionAssociatedItemConstraintsEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<AssociatedItemConstraintsPtr> for OptionAssociatedItemConstraintsPtr {
    fn from(value: AssociatedItemConstraintsPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionAssociatedItemConstraintsEmptyGreen> for OptionAssociatedItemConstraintsGreen {
    fn from(value: OptionAssociatedItemConstraintsEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<AssociatedItemConstraintsGreen> for OptionAssociatedItemConstraintsGreen {
    fn from(value: AssociatedItemConstraintsGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAssociatedItemConstraintsGreen(pub GreenId);
impl TypedSyntaxNode for OptionAssociatedItemConstraints {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionAssociatedItemConstraintsPtr;
    type Green = OptionAssociatedItemConstraintsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionAssociatedItemConstraintsEmpty => {
                OptionAssociatedItemConstraints::Empty(
                    OptionAssociatedItemConstraintsEmpty::from_syntax_node(db, node),
                )
            }
            SyntaxKind::AssociatedItemConstraints => {
                OptionAssociatedItemConstraints::AssociatedItemConstraints(
                    AssociatedItemConstraints::from_syntax_node(db, node),
                )
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionAssociatedItemConstraints"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionAssociatedItemConstraintsEmpty => {
                Some(OptionAssociatedItemConstraints::Empty(
                    OptionAssociatedItemConstraintsEmpty::from_syntax_node(db, node),
                ))
            }
            SyntaxKind::AssociatedItemConstraints => {
                Some(OptionAssociatedItemConstraints::AssociatedItemConstraints(
                    AssociatedItemConstraints::from_syntax_node(db, node),
                ))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionAssociatedItemConstraints::Empty(x) => x.as_syntax_node(),
            OptionAssociatedItemConstraints::AssociatedItemConstraints(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionAssociatedItemConstraintsPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionAssociatedItemConstraints> for SyntaxStablePtrId {
    fn from(node: &OptionAssociatedItemConstraints) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionAssociatedItemConstraints {
    /// Checks if a kind of a variant of [OptionAssociatedItemConstraints].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::OptionAssociatedItemConstraintsEmpty
                | SyntaxKind::AssociatedItemConstraints
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionAssociatedItemConstraintsEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionAssociatedItemConstraintsEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionAssociatedItemConstraintsEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionAssociatedItemConstraintsEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionAssociatedItemConstraintsEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionAssociatedItemConstraintsEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAssociatedItemConstraintsEmptyPtr(pub SyntaxStablePtrId);
impl OptionAssociatedItemConstraintsEmptyPtr {}
impl TypedStablePtr for OptionAssociatedItemConstraintsEmptyPtr {
    type SyntaxNode = OptionAssociatedItemConstraintsEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionAssociatedItemConstraintsEmpty {
        OptionAssociatedItemConstraintsEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionAssociatedItemConstraintsEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionAssociatedItemConstraintsEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionAssociatedItemConstraintsEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionAssociatedItemConstraintsEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> =
        Some(SyntaxKind::OptionAssociatedItemConstraintsEmpty);
    type StablePtr = OptionAssociatedItemConstraintsEmptyPtr;
    type Green = OptionAssociatedItemConstraintsEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionAssociatedItemConstraintsEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionAssociatedItemConstraintsEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionAssociatedItemConstraintsEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionAssociatedItemConstraintsEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionAssociatedItemConstraintsEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionAssociatedItemConstraintsEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionAssociatedItemConstraintsEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionAssociatedItemConstraintsEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum OptionWrappedGenericParamList {
    Empty(OptionWrappedGenericParamListEmpty),
    WrappedGenericParamList(WrappedGenericParamList),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionWrappedGenericParamListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for OptionWrappedGenericParamListPtr {
    type SyntaxNode = OptionWrappedGenericParamList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamList {
        OptionWrappedGenericParamList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionWrappedGenericParamListPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionWrappedGenericParamListPtr) -> Self {
        ptr.untyped()
    }
}
impl From<OptionWrappedGenericParamListEmptyPtr> for OptionWrappedGenericParamListPtr {
    fn from(value: OptionWrappedGenericParamListEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<WrappedGenericParamListPtr> for OptionWrappedGenericParamListPtr {
    fn from(value: WrappedGenericParamListPtr) -> Self {
        Self(value.0)
    }
}
impl From<OptionWrappedGenericParamListEmptyGreen> for OptionWrappedGenericParamListGreen {
    fn from(value: OptionWrappedGenericParamListEmptyGreen) -> Self {
        Self(value.0)
    }
}
impl From<WrappedGenericParamListGreen> for OptionWrappedGenericParamListGreen {
    fn from(value: WrappedGenericParamListGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionWrappedGenericParamListGreen(pub GreenId);
impl TypedSyntaxNode for OptionWrappedGenericParamList {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = OptionWrappedGenericParamListPtr;
    type Green = OptionWrappedGenericParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionWrappedGenericParamListEmpty => OptionWrappedGenericParamList::Empty(
                OptionWrappedGenericParamListEmpty::from_syntax_node(db, node),
            ),
            SyntaxKind::WrappedGenericParamList => {
                OptionWrappedGenericParamList::WrappedGenericParamList(
                    WrappedGenericParamList::from_syntax_node(db, node),
                )
            }
            _ => panic!(
                "Unexpected syntax kind {:?} when constructing {}.",
                kind, "OptionWrappedGenericParamList"
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::OptionWrappedGenericParamListEmpty => {
                Some(OptionWrappedGenericParamList::Empty(
                    OptionWrappedGenericParamListEmpty::from_syntax_node(db, node),
                ))
            }
            SyntaxKind::WrappedGenericParamList => {
                Some(OptionWrappedGenericParamList::WrappedGenericParamList(
                    WrappedGenericParamList::from_syntax_node(db, node),
                ))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            OptionWrappedGenericParamList::Empty(x) => x.as_syntax_node(),
            OptionWrappedGenericParamList::WrappedGenericParamList(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionWrappedGenericParamListPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&OptionWrappedGenericParamList> for SyntaxStablePtrId {
    fn from(node: &OptionWrappedGenericParamList) -> Self {
        node.stable_ptr().untyped()
    }
}
impl OptionWrappedGenericParamList {
    /// Checks if a kind of a variant of [OptionWrappedGenericParamList].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::OptionWrappedGenericParamListEmpty | SyntaxKind::WrappedGenericParamList
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct OptionWrappedGenericParamListEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl OptionWrappedGenericParamListEmpty {
    pub fn new_green(db: &dyn SyntaxGroup) -> OptionWrappedGenericParamListEmptyGreen {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        OptionWrappedGenericParamListEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionWrappedGenericParamListEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl OptionWrappedGenericParamListEmpty {}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionWrappedGenericParamListEmptyPtr(pub SyntaxStablePtrId);
impl OptionWrappedGenericParamListEmptyPtr {}
impl TypedStablePtr for OptionWrappedGenericParamListEmptyPtr {
    type SyntaxNode = OptionWrappedGenericParamListEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> OptionWrappedGenericParamListEmpty {
        OptionWrappedGenericParamListEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<OptionWrappedGenericParamListEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: OptionWrappedGenericParamListEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct OptionWrappedGenericParamListEmptyGreen(pub GreenId);
impl TypedSyntaxNode for OptionWrappedGenericParamListEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::OptionWrappedGenericParamListEmpty);
    type StablePtr = OptionWrappedGenericParamListEmptyPtr;
    type Green = OptionWrappedGenericParamListEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        OptionWrappedGenericParamListEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::OptionWrappedGenericParamListEmpty,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::OptionWrappedGenericParamListEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::OptionWrappedGenericParamListEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::OptionWrappedGenericParamListEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        OptionWrappedGenericParamListEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&OptionWrappedGenericParamListEmpty> for SyntaxStablePtrId {
    fn from(node: &OptionWrappedGenericParamListEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct WrappedGenericParamList {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl WrappedGenericParamList {
    pub const INDEX_LANGLE: usize = 0;
    pub const INDEX_GENERIC_PARAMS: usize = 1;
    pub const INDEX_RANGLE: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        langle: TerminalLTGreen,
        generic_params: GenericParamListGreen,
        rangle: TerminalGTGreen,
    ) -> WrappedGenericParamListGreen {
        let children: Vec<GreenId> = vec![langle.0, generic_params.0, rangle.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        WrappedGenericParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::WrappedGenericParamList,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl WrappedGenericParamList {
    pub fn langle(&self, db: &dyn SyntaxGroup) -> TerminalLT {
        TerminalLT::from_syntax_node(db, self.children[0].clone())
    }
    pub fn generic_params(&self, db: &dyn SyntaxGroup) -> GenericParamList {
        GenericParamList::from_syntax_node(db, self.children[1].clone())
    }
    pub fn rangle(&self, db: &dyn SyntaxGroup) -> TerminalGT {
        TerminalGT::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct WrappedGenericParamListPtr(pub SyntaxStablePtrId);
impl WrappedGenericParamListPtr {}
impl TypedStablePtr for WrappedGenericParamListPtr {
    type SyntaxNode = WrappedGenericParamList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> WrappedGenericParamList {
        WrappedGenericParamList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<WrappedGenericParamListPtr> for SyntaxStablePtrId {
    fn from(ptr: WrappedGenericParamListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct WrappedGenericParamListGreen(pub GreenId);
impl TypedSyntaxNode for WrappedGenericParamList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::WrappedGenericParamList);
    type StablePtr = WrappedGenericParamListPtr;
    type Green = WrappedGenericParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        WrappedGenericParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::WrappedGenericParamList,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalLT::missing(db).0,
                        GenericParamList::missing(db).0,
                        TerminalGT::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::WrappedGenericParamList,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::WrappedGenericParamList
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::WrappedGenericParamList {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        WrappedGenericParamListPtr(self.node.0.stable_ptr)
    }
}
impl From<&WrappedGenericParamList> for SyntaxStablePtrId {
    fn from(node: &WrappedGenericParamList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericParamList(ElementList<GenericParam, 2>);
impl Deref for GenericParamList {
    type Target = ElementList<GenericParam, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl GenericParamList {
    pub fn new_green(
        db: &dyn SyntaxGroup,
        children: Vec<GenericParamListElementOrSeparatorGreen>,
    ) -> GenericParamListGreen {
        let width = children.iter().map(|id| id.id().lookup_intern(db).width()).sum();
        GenericParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamList,
                details: GreenNodeDetails::Node {
                    children: children.iter().map(|x| x.id()).collect(),
                    width,
                },
            })
            .intern(db),
        )
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamListPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for GenericParamListPtr {
    type SyntaxNode = GenericParamList;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericParamList {
        GenericParamList::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericParamListPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericParamListPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum GenericParamListElementOrSeparatorGreen {
    Separator(TerminalCommaGreen),
    Element(GenericParamGreen),
}
impl From<TerminalCommaGreen> for GenericParamListElementOrSeparatorGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        GenericParamListElementOrSeparatorGreen::Separator(value)
    }
}
impl From<GenericParamGreen> for GenericParamListElementOrSeparatorGreen {
    fn from(value: GenericParamGreen) -> Self {
        GenericParamListElementOrSeparatorGreen::Element(value)
    }
}
impl GenericParamListElementOrSeparatorGreen {
    fn id(&self) -> GreenId {
        match self {
            GenericParamListElementOrSeparatorGreen::Separator(green) => green.0,
            GenericParamListElementOrSeparatorGreen::Element(green) => green.0,
        }
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamListGreen(pub GreenId);
impl TypedSyntaxNode for GenericParamList {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamList);
    type StablePtr = GenericParamListPtr;
    type Green = GenericParamListGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericParamListGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamList,
                details: GreenNodeDetails::Node { children: vec![], width: TextWidth::default() },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        if node.kind(db) == SyntaxKind::GenericParamList {
            Some(Self(ElementList::new(node)))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericParamListPtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericParamList> for SyntaxStablePtrId {
    fn from(node: &GenericParamList) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum GenericParam {
    Type(GenericParamType),
    Const(GenericParamConst),
    ImplNamed(GenericParamImplNamed),
    ImplAnonymous(GenericParamImplAnonymous),
    NegativeImpl(GenericParamNegativeImpl),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for GenericParamPtr {
    type SyntaxNode = GenericParam;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericParam {
        GenericParam::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericParamPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericParamPtr) -> Self {
        ptr.untyped()
    }
}
impl From<GenericParamTypePtr> for GenericParamPtr {
    fn from(value: GenericParamTypePtr) -> Self {
        Self(value.0)
    }
}
impl From<GenericParamConstPtr> for GenericParamPtr {
    fn from(value: GenericParamConstPtr) -> Self {
        Self(value.0)
    }
}
impl From<GenericParamImplNamedPtr> for GenericParamPtr {
    fn from(value: GenericParamImplNamedPtr) -> Self {
        Self(value.0)
    }
}
impl From<GenericParamImplAnonymousPtr> for GenericParamPtr {
    fn from(value: GenericParamImplAnonymousPtr) -> Self {
        Self(value.0)
    }
}
impl From<GenericParamNegativeImplPtr> for GenericParamPtr {
    fn from(value: GenericParamNegativeImplPtr) -> Self {
        Self(value.0)
    }
}
impl From<GenericParamTypeGreen> for GenericParamGreen {
    fn from(value: GenericParamTypeGreen) -> Self {
        Self(value.0)
    }
}
impl From<GenericParamConstGreen> for GenericParamGreen {
    fn from(value: GenericParamConstGreen) -> Self {
        Self(value.0)
    }
}
impl From<GenericParamImplNamedGreen> for GenericParamGreen {
    fn from(value: GenericParamImplNamedGreen) -> Self {
        Self(value.0)
    }
}
impl From<GenericParamImplAnonymousGreen> for GenericParamGreen {
    fn from(value: GenericParamImplAnonymousGreen) -> Self {
        Self(value.0)
    }
}
impl From<GenericParamNegativeImplGreen> for GenericParamGreen {
    fn from(value: GenericParamNegativeImplGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamGreen(pub GreenId);
impl TypedSyntaxNode for GenericParam {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = GenericParamPtr;
    type Green = GenericParamGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericParamType => {
                GenericParam::Type(GenericParamType::from_syntax_node(db, node))
            }
            SyntaxKind::GenericParamConst => {
                GenericParam::Const(GenericParamConst::from_syntax_node(db, node))
            }
            SyntaxKind::GenericParamImplNamed => {
                GenericParam::ImplNamed(GenericParamImplNamed::from_syntax_node(db, node))
            }
            SyntaxKind::GenericParamImplAnonymous => {
                GenericParam::ImplAnonymous(GenericParamImplAnonymous::from_syntax_node(db, node))
            }
            SyntaxKind::GenericParamNegativeImpl => {
                GenericParam::NegativeImpl(GenericParamNegativeImpl::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "GenericParam"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::GenericParamType => {
                Some(GenericParam::Type(GenericParamType::from_syntax_node(db, node)))
            }
            SyntaxKind::GenericParamConst => {
                Some(GenericParam::Const(GenericParamConst::from_syntax_node(db, node)))
            }
            SyntaxKind::GenericParamImplNamed => {
                Some(GenericParam::ImplNamed(GenericParamImplNamed::from_syntax_node(db, node)))
            }
            SyntaxKind::GenericParamImplAnonymous => Some(GenericParam::ImplAnonymous(
                GenericParamImplAnonymous::from_syntax_node(db, node),
            )),
            SyntaxKind::GenericParamNegativeImpl => Some(GenericParam::NegativeImpl(
                GenericParamNegativeImpl::from_syntax_node(db, node),
            )),
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            GenericParam::Type(x) => x.as_syntax_node(),
            GenericParam::Const(x) => x.as_syntax_node(),
            GenericParam::ImplNamed(x) => x.as_syntax_node(),
            GenericParam::ImplAnonymous(x) => x.as_syntax_node(),
            GenericParam::NegativeImpl(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericParamPtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&GenericParam> for SyntaxStablePtrId {
    fn from(node: &GenericParam) -> Self {
        node.stable_ptr().untyped()
    }
}
impl GenericParam {
    /// Checks if a kind of a variant of [GenericParam].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::GenericParamType
                | SyntaxKind::GenericParamConst
                | SyntaxKind::GenericParamImplNamed
                | SyntaxKind::GenericParamImplAnonymous
                | SyntaxKind::GenericParamNegativeImpl
        )
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericParamType {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl GenericParamType {
    pub const INDEX_NAME: usize = 0;
    pub fn new_green(db: &dyn SyntaxGroup, name: TerminalIdentifierGreen) -> GenericParamTypeGreen {
        let children: Vec<GreenId> = vec![name.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericParamTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamType,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl GenericParamType {
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamTypePtr(pub SyntaxStablePtrId);
impl GenericParamTypePtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for GenericParamTypePtr {
    type SyntaxNode = GenericParamType;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericParamType {
        GenericParamType::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericParamTypePtr> for SyntaxStablePtrId {
    fn from(ptr: GenericParamTypePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamTypeGreen(pub GreenId);
impl TypedSyntaxNode for GenericParamType {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamType);
    type StablePtr = GenericParamTypePtr;
    type Green = GenericParamTypeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericParamTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamType,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalIdentifier::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParamType,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParamType
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericParamType {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericParamTypePtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericParamType> for SyntaxStablePtrId {
    fn from(node: &GenericParamType) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericParamConst {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl GenericParamConst {
    pub const INDEX_CONST_KW: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_COLON: usize = 2;
    pub const INDEX_TY: usize = 3;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        const_kw: TerminalConstGreen,
        name: TerminalIdentifierGreen,
        colon: TerminalColonGreen,
        ty: ExprGreen,
    ) -> GenericParamConstGreen {
        let children: Vec<GreenId> = vec![const_kw.0, name.0, colon.0, ty.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericParamConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamConst,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl GenericParamConst {
    pub fn const_kw(&self, db: &dyn SyntaxGroup) -> TerminalConst {
        TerminalConst::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[2].clone())
    }
    pub fn ty(&self, db: &dyn SyntaxGroup) -> Expr {
        Expr::from_syntax_node(db, self.children[3].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamConstPtr(pub SyntaxStablePtrId);
impl GenericParamConstPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for GenericParamConstPtr {
    type SyntaxNode = GenericParamConst;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericParamConst {
        GenericParamConst::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericParamConstPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericParamConstPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamConstGreen(pub GreenId);
impl TypedSyntaxNode for GenericParamConst {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamConst);
    type StablePtr = GenericParamConstPtr;
    type Green = GenericParamConstGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericParamConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamConst,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalConst::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        Expr::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParamConst,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParamConst
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericParamConst {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericParamConstPtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericParamConst> for SyntaxStablePtrId {
    fn from(node: &GenericParamConst) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericParamImplNamed {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl GenericParamImplNamed {
    pub const INDEX_IMPL_KW: usize = 0;
    pub const INDEX_NAME: usize = 1;
    pub const INDEX_COLON: usize = 2;
    pub const INDEX_TRAIT_PATH: usize = 3;
    pub const INDEX_TYPE_CONSTRAINS: usize = 4;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        impl_kw: TerminalImplGreen,
        name: TerminalIdentifierGreen,
        colon: TerminalColonGreen,
        trait_path: ExprPathGreen,
        type_constrains: OptionAssociatedItemConstraintsGreen,
    ) -> GenericParamImplNamedGreen {
        let children: Vec<GreenId> =
            vec![impl_kw.0, name.0, colon.0, trait_path.0, type_constrains.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericParamImplNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamImplNamed,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl GenericParamImplNamed {
    pub fn impl_kw(&self, db: &dyn SyntaxGroup) -> TerminalImpl {
        TerminalImpl::from_syntax_node(db, self.children[0].clone())
    }
    pub fn name(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn colon(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.children[2].clone())
    }
    pub fn trait_path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[3].clone())
    }
    pub fn type_constrains(&self, db: &dyn SyntaxGroup) -> OptionAssociatedItemConstraints {
        OptionAssociatedItemConstraints::from_syntax_node(db, self.children[4].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamImplNamedPtr(pub SyntaxStablePtrId);
impl GenericParamImplNamedPtr {
    pub fn name_green(self, db: &dyn SyntaxGroup) -> TerminalIdentifierGreen {
        let ptr = self.0.lookup_intern(db);
        if let SyntaxStablePtr::Child { key_fields, .. } = ptr {
            TerminalIdentifierGreen(key_fields[0])
        } else {
            panic!("Unexpected key field query on root.");
        }
    }
}
impl TypedStablePtr for GenericParamImplNamedPtr {
    type SyntaxNode = GenericParamImplNamed;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericParamImplNamed {
        GenericParamImplNamed::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericParamImplNamedPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericParamImplNamedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamImplNamedGreen(pub GreenId);
impl TypedSyntaxNode for GenericParamImplNamed {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamImplNamed);
    type StablePtr = GenericParamImplNamedPtr;
    type Green = GenericParamImplNamedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericParamImplNamedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamImplNamed,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalImpl::missing(db).0,
                        TerminalIdentifier::missing(db).0,
                        TerminalColon::missing(db).0,
                        ExprPath::missing(db).0,
                        OptionAssociatedItemConstraints::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParamImplNamed,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParamImplNamed
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericParamImplNamed {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericParamImplNamedPtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericParamImplNamed> for SyntaxStablePtrId {
    fn from(node: &GenericParamImplNamed) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericParamImplAnonymous {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl GenericParamImplAnonymous {
    pub const INDEX_PLUS: usize = 0;
    pub const INDEX_TRAIT_PATH: usize = 1;
    pub const INDEX_TYPE_CONSTRAINS: usize = 2;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        plus: TerminalPlusGreen,
        trait_path: ExprPathGreen,
        type_constrains: OptionAssociatedItemConstraintsGreen,
    ) -> GenericParamImplAnonymousGreen {
        let children: Vec<GreenId> = vec![plus.0, trait_path.0, type_constrains.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericParamImplAnonymousGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamImplAnonymous,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl GenericParamImplAnonymous {
    pub fn plus(&self, db: &dyn SyntaxGroup) -> TerminalPlus {
        TerminalPlus::from_syntax_node(db, self.children[0].clone())
    }
    pub fn trait_path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[1].clone())
    }
    pub fn type_constrains(&self, db: &dyn SyntaxGroup) -> OptionAssociatedItemConstraints {
        OptionAssociatedItemConstraints::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamImplAnonymousPtr(pub SyntaxStablePtrId);
impl GenericParamImplAnonymousPtr {}
impl TypedStablePtr for GenericParamImplAnonymousPtr {
    type SyntaxNode = GenericParamImplAnonymous;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericParamImplAnonymous {
        GenericParamImplAnonymous::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericParamImplAnonymousPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericParamImplAnonymousPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamImplAnonymousGreen(pub GreenId);
impl TypedSyntaxNode for GenericParamImplAnonymous {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamImplAnonymous);
    type StablePtr = GenericParamImplAnonymousPtr;
    type Green = GenericParamImplAnonymousGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericParamImplAnonymousGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamImplAnonymous,
                details: GreenNodeDetails::Node {
                    children: vec![
                        TerminalPlus::missing(db).0,
                        ExprPath::missing(db).0,
                        OptionAssociatedItemConstraints::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParamImplAnonymous,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParamImplAnonymous
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericParamImplAnonymous {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericParamImplAnonymousPtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericParamImplAnonymous> for SyntaxStablePtrId {
    fn from(node: &GenericParamImplAnonymous) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct GenericParamNegativeImpl {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl GenericParamNegativeImpl {
    pub const INDEX_MINUS: usize = 0;
    pub const INDEX_TRAIT_PATH: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        minus: TerminalMinusGreen,
        trait_path: ExprPathGreen,
    ) -> GenericParamNegativeImplGreen {
        let children: Vec<GreenId> = vec![minus.0, trait_path.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        GenericParamNegativeImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamNegativeImpl,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl GenericParamNegativeImpl {
    pub fn minus(&self, db: &dyn SyntaxGroup) -> TerminalMinus {
        TerminalMinus::from_syntax_node(db, self.children[0].clone())
    }
    pub fn trait_path(&self, db: &dyn SyntaxGroup) -> ExprPath {
        ExprPath::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamNegativeImplPtr(pub SyntaxStablePtrId);
impl GenericParamNegativeImplPtr {}
impl TypedStablePtr for GenericParamNegativeImplPtr {
    type SyntaxNode = GenericParamNegativeImpl;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> GenericParamNegativeImpl {
        GenericParamNegativeImpl::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<GenericParamNegativeImplPtr> for SyntaxStablePtrId {
    fn from(ptr: GenericParamNegativeImplPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct GenericParamNegativeImplGreen(pub GreenId);
impl TypedSyntaxNode for GenericParamNegativeImpl {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::GenericParamNegativeImpl);
    type StablePtr = GenericParamNegativeImplPtr;
    type Green = GenericParamNegativeImplGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        GenericParamNegativeImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::GenericParamNegativeImpl,
                details: GreenNodeDetails::Node {
                    children: vec![TerminalMinus::missing(db).0, ExprPath::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::GenericParamNegativeImpl,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::GenericParamNegativeImpl
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::GenericParamNegativeImpl {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        GenericParamNegativeImplPtr(self.node.0.stable_ptr)
    }
}
impl From<&GenericParamNegativeImpl> for SyntaxStablePtrId {
    fn from(node: &GenericParamNegativeImpl) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TriviumSkippedNode {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl TriviumSkippedNode {
    pub const INDEX_NODE: usize = 0;
    pub fn new_green(db: &dyn SyntaxGroup, node: SkippedNodeGreen) -> TriviumSkippedNodeGreen {
        let children: Vec<GreenId> = vec![node.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TriviumSkippedNodeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TriviumSkippedNode,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl TriviumSkippedNode {
    pub fn node(&self, db: &dyn SyntaxGroup) -> SkippedNode {
        SkippedNode::from_syntax_node(db, self.children[0].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviumSkippedNodePtr(pub SyntaxStablePtrId);
impl TriviumSkippedNodePtr {}
impl TypedStablePtr for TriviumSkippedNodePtr {
    type SyntaxNode = TriviumSkippedNode;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TriviumSkippedNode {
        TriviumSkippedNode::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TriviumSkippedNodePtr> for SyntaxStablePtrId {
    fn from(ptr: TriviumSkippedNodePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TriviumSkippedNodeGreen(pub GreenId);
impl TypedSyntaxNode for TriviumSkippedNode {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TriviumSkippedNode);
    type StablePtr = TriviumSkippedNodePtr;
    type Green = TriviumSkippedNodeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TriviumSkippedNodeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TriviumSkippedNode,
                details: GreenNodeDetails::Node {
                    children: vec![SkippedNode::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TriviumSkippedNode,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TriviumSkippedNode
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TriviumSkippedNode {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TriviumSkippedNodePtr(self.node.0.stable_ptr)
    }
}
impl From<&TriviumSkippedNode> for SyntaxStablePtrId {
    fn from(node: &TriviumSkippedNode) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum SkippedNode {
    AttributeList(AttributeList),
    VisibilityPub(VisibilityPub),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct SkippedNodePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for SkippedNodePtr {
    type SyntaxNode = SkippedNode;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> SkippedNode {
        SkippedNode::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<SkippedNodePtr> for SyntaxStablePtrId {
    fn from(ptr: SkippedNodePtr) -> Self {
        ptr.untyped()
    }
}
impl From<AttributeListPtr> for SkippedNodePtr {
    fn from(value: AttributeListPtr) -> Self {
        Self(value.0)
    }
}
impl From<VisibilityPubPtr> for SkippedNodePtr {
    fn from(value: VisibilityPubPtr) -> Self {
        Self(value.0)
    }
}
impl From<AttributeListGreen> for SkippedNodeGreen {
    fn from(value: AttributeListGreen) -> Self {
        Self(value.0)
    }
}
impl From<VisibilityPubGreen> for SkippedNodeGreen {
    fn from(value: VisibilityPubGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct SkippedNodeGreen(pub GreenId);
impl TypedSyntaxNode for SkippedNode {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = SkippedNodePtr;
    type Green = SkippedNodeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::AttributeList => {
                SkippedNode::AttributeList(AttributeList::from_syntax_node(db, node))
            }
            SyntaxKind::VisibilityPub => {
                SkippedNode::VisibilityPub(VisibilityPub::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "SkippedNode"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::AttributeList => {
                Some(SkippedNode::AttributeList(AttributeList::from_syntax_node(db, node)))
            }
            SyntaxKind::VisibilityPub => {
                Some(SkippedNode::VisibilityPub(VisibilityPub::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            SkippedNode::AttributeList(x) => x.as_syntax_node(),
            SkippedNode::VisibilityPub(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        SkippedNodePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&SkippedNode> for SyntaxStablePtrId {
    fn from(node: &SkippedNode) -> Self {
        node.stable_ptr().untyped()
    }
}
impl SkippedNode {
    /// Checks if a kind of a variant of [SkippedNode].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(kind, SyntaxKind::AttributeList | SyntaxKind::VisibilityPub)
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenIdentifier {
    node: SyntaxNode,
}
impl Token for TokenIdentifier {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenIdentifier,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenIdentifierPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenIdentifierPtr {
    type SyntaxNode = TokenIdentifier;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenIdentifier {
        TokenIdentifier::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenIdentifierPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenIdentifierPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenIdentifierGreen(pub GreenId);
impl TokenIdentifierGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenIdentifier {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenIdentifier);
    type StablePtr = TokenIdentifierPtr;
    type Green = TokenIdentifierGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenIdentifier)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenIdentifierPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenIdentifier> for SyntaxStablePtrId {
    fn from(node: &TokenIdentifier) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalIdentifier {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalIdentifier {
    const KIND: SyntaxKind = SyntaxKind::TerminalIdentifier;
    type TokenType = TokenIdentifier;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalIdentifier as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalIdentifier,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalIdentifier {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenIdentifier {
        TokenIdentifier::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalIdentifierPtr(pub SyntaxStablePtrId);
impl TerminalIdentifierPtr {}
impl TypedStablePtr for TerminalIdentifierPtr {
    type SyntaxNode = TerminalIdentifier;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalIdentifier {
        TerminalIdentifier::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalIdentifierPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalIdentifierPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalIdentifierGreen(pub GreenId);
impl TypedSyntaxNode for TerminalIdentifier {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalIdentifier);
    type StablePtr = TerminalIdentifierPtr;
    type Green = TerminalIdentifierGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalIdentifierGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalIdentifier,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenIdentifier::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalIdentifier,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalIdentifier
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalIdentifier {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalIdentifierPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalIdentifier> for SyntaxStablePtrId {
    fn from(node: &TerminalIdentifier) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLiteralNumber {
    node: SyntaxNode,
}
impl Token for TokenLiteralNumber {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLiteralNumberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLiteralNumber,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLiteralNumberPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenLiteralNumberPtr {
    type SyntaxNode = TokenLiteralNumber;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenLiteralNumber {
        TokenLiteralNumber::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenLiteralNumberPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenLiteralNumberPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLiteralNumberGreen(pub GreenId);
impl TokenLiteralNumberGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenLiteralNumber {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLiteralNumber);
    type StablePtr = TokenLiteralNumberPtr;
    type Green = TokenLiteralNumberGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLiteralNumberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenLiteralNumber
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLiteralNumberPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenLiteralNumber> for SyntaxStablePtrId {
    fn from(node: &TokenLiteralNumber) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLiteralNumber {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalLiteralNumber {
    const KIND: SyntaxKind = SyntaxKind::TerminalLiteralNumber;
    type TokenType = TokenLiteralNumber;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLiteralNumber as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLiteralNumberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLiteralNumber,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLiteralNumber {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLiteralNumber {
        TokenLiteralNumber::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLiteralNumberPtr(pub SyntaxStablePtrId);
impl TerminalLiteralNumberPtr {}
impl TypedStablePtr for TerminalLiteralNumberPtr {
    type SyntaxNode = TerminalLiteralNumber;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalLiteralNumber {
        TerminalLiteralNumber::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalLiteralNumberPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalLiteralNumberPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLiteralNumberGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLiteralNumber {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLiteralNumber);
    type StablePtr = TerminalLiteralNumberPtr;
    type Green = TerminalLiteralNumberGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLiteralNumberGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLiteralNumber,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLiteralNumber::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLiteralNumber,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLiteralNumber
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLiteralNumber {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLiteralNumberPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalLiteralNumber> for SyntaxStablePtrId {
    fn from(node: &TerminalLiteralNumber) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenShortString {
    node: SyntaxNode,
}
impl Token for TokenShortString {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenShortStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenShortString,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenShortStringPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenShortStringPtr {
    type SyntaxNode = TokenShortString;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenShortString {
        TokenShortString::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenShortStringPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenShortStringPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenShortStringGreen(pub GreenId);
impl TokenShortStringGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenShortString {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenShortString);
    type StablePtr = TokenShortStringPtr;
    type Green = TokenShortStringGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenShortStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenShortString)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenShortStringPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenShortString> for SyntaxStablePtrId {
    fn from(node: &TokenShortString) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalShortString {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalShortString {
    const KIND: SyntaxKind = SyntaxKind::TerminalShortString;
    type TokenType = TokenShortString;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalShortString as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalShortStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalShortString,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalShortString {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenShortString {
        TokenShortString::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalShortStringPtr(pub SyntaxStablePtrId);
impl TerminalShortStringPtr {}
impl TypedStablePtr for TerminalShortStringPtr {
    type SyntaxNode = TerminalShortString;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalShortString {
        TerminalShortString::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalShortStringPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalShortStringPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalShortStringGreen(pub GreenId);
impl TypedSyntaxNode for TerminalShortString {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalShortString);
    type StablePtr = TerminalShortStringPtr;
    type Green = TerminalShortStringGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalShortStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalShortString,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenShortString::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalShortString,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalShortString
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalShortString {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalShortStringPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalShortString> for SyntaxStablePtrId {
    fn from(node: &TerminalShortString) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenString {
    node: SyntaxNode,
}
impl Token for TokenString {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenString,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenStringPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenStringPtr {
    type SyntaxNode = TokenString;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenString {
        TokenString::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenStringPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenStringPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenStringGreen(pub GreenId);
impl TokenStringGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenString {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenString);
    type StablePtr = TokenStringPtr;
    type Green = TokenStringGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenString)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenStringPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenString> for SyntaxStablePtrId {
    fn from(node: &TokenString) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalString {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalString {
    const KIND: SyntaxKind = SyntaxKind::TerminalString;
    type TokenType = TokenString;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalString as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalString,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalString {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenString {
        TokenString::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalStringPtr(pub SyntaxStablePtrId);
impl TerminalStringPtr {}
impl TypedStablePtr for TerminalStringPtr {
    type SyntaxNode = TerminalString;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalString {
        TerminalString::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalStringPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalStringPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalStringGreen(pub GreenId);
impl TypedSyntaxNode for TerminalString {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalString);
    type StablePtr = TerminalStringPtr;
    type Green = TerminalStringGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalStringGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalString,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenString::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalString,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalString
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalString {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalStringPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalString> for SyntaxStablePtrId {
    fn from(node: &TerminalString) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenAs {
    node: SyntaxNode,
}
impl Token for TokenAs {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenAsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenAs,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAsPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenAsPtr {
    type SyntaxNode = TokenAs;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenAs {
        TokenAs::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenAsPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenAsPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAsGreen(pub GreenId);
impl TokenAsGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenAs {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenAs);
    type StablePtr = TokenAsPtr;
    type Green = TokenAsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenAsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenAs)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenAsPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenAs> for SyntaxStablePtrId {
    fn from(node: &TokenAs) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalAs {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalAs {
    const KIND: SyntaxKind = SyntaxKind::TerminalAs;
    type TokenType = TokenAs;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalAs as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalAsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAs,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalAs {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenAs {
        TokenAs::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAsPtr(pub SyntaxStablePtrId);
impl TerminalAsPtr {}
impl TypedStablePtr for TerminalAsPtr {
    type SyntaxNode = TerminalAs;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalAs {
        TerminalAs::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalAsPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalAsPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAsGreen(pub GreenId);
impl TypedSyntaxNode for TerminalAs {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalAs);
    type StablePtr = TerminalAsPtr;
    type Green = TerminalAsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalAsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAs,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenAs::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalAs,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalAs
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalAs { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalAsPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalAs> for SyntaxStablePtrId {
    fn from(node: &TerminalAs) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenConst {
    node: SyntaxNode,
}
impl Token for TokenConst {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenConst,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenConstPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenConstPtr {
    type SyntaxNode = TokenConst;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenConst {
        TokenConst::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenConstPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenConstPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenConstGreen(pub GreenId);
impl TokenConstGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenConst {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenConst);
    type StablePtr = TokenConstPtr;
    type Green = TokenConstGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenConst)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenConstPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenConst> for SyntaxStablePtrId {
    fn from(node: &TokenConst) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalConst {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalConst {
    const KIND: SyntaxKind = SyntaxKind::TerminalConst;
    type TokenType = TokenConst;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalConst as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalConst,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalConst {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenConst {
        TokenConst::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalConstPtr(pub SyntaxStablePtrId);
impl TerminalConstPtr {}
impl TypedStablePtr for TerminalConstPtr {
    type SyntaxNode = TerminalConst;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalConst {
        TerminalConst::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalConstPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalConstPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalConstGreen(pub GreenId);
impl TypedSyntaxNode for TerminalConst {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalConst);
    type StablePtr = TerminalConstPtr;
    type Green = TerminalConstGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalConstGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalConst,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenConst::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalConst,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalConst
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalConst {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalConstPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalConst> for SyntaxStablePtrId {
    fn from(node: &TerminalConst) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenElse {
    node: SyntaxNode,
}
impl Token for TokenElse {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenElseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenElse,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenElsePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenElsePtr {
    type SyntaxNode = TokenElse;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenElse {
        TokenElse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenElsePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenElsePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenElseGreen(pub GreenId);
impl TokenElseGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenElse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenElse);
    type StablePtr = TokenElsePtr;
    type Green = TokenElseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenElseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenElse)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenElsePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenElse> for SyntaxStablePtrId {
    fn from(node: &TokenElse) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalElse {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalElse {
    const KIND: SyntaxKind = SyntaxKind::TerminalElse;
    type TokenType = TokenElse;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalElse as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalElseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalElse,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalElse {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenElse {
        TokenElse::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalElsePtr(pub SyntaxStablePtrId);
impl TerminalElsePtr {}
impl TypedStablePtr for TerminalElsePtr {
    type SyntaxNode = TerminalElse;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalElse {
        TerminalElse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalElsePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalElsePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalElseGreen(pub GreenId);
impl TypedSyntaxNode for TerminalElse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalElse);
    type StablePtr = TerminalElsePtr;
    type Green = TerminalElseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalElseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalElse,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenElse::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalElse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalElse
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalElse { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalElsePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalElse> for SyntaxStablePtrId {
    fn from(node: &TerminalElse) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenEnum {
    node: SyntaxNode,
}
impl Token for TokenEnum {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenEnum,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEnumPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenEnumPtr {
    type SyntaxNode = TokenEnum;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenEnum {
        TokenEnum::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenEnumPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenEnumPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEnumGreen(pub GreenId);
impl TokenEnumGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenEnum {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEnum);
    type StablePtr = TokenEnumPtr;
    type Green = TokenEnumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEnum)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenEnumPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenEnum> for SyntaxStablePtrId {
    fn from(node: &TokenEnum) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalEnum {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalEnum {
    const KIND: SyntaxKind = SyntaxKind::TerminalEnum;
    type TokenType = TokenEnum;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalEnum as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEnum,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalEnum {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenEnum {
        TokenEnum::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEnumPtr(pub SyntaxStablePtrId);
impl TerminalEnumPtr {}
impl TypedStablePtr for TerminalEnumPtr {
    type SyntaxNode = TerminalEnum;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalEnum {
        TerminalEnum::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalEnumPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalEnumPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEnumGreen(pub GreenId);
impl TypedSyntaxNode for TerminalEnum {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEnum);
    type StablePtr = TerminalEnumPtr;
    type Green = TerminalEnumGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalEnumGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEnum,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenEnum::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEnum,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEnum
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalEnum { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalEnumPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalEnum> for SyntaxStablePtrId {
    fn from(node: &TerminalEnum) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenExtern {
    node: SyntaxNode,
}
impl Token for TokenExtern {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenExternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenExtern,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenExternPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenExternPtr {
    type SyntaxNode = TokenExtern;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenExtern {
        TokenExtern::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenExternPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenExternPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenExternGreen(pub GreenId);
impl TokenExternGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenExtern {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenExtern);
    type StablePtr = TokenExternPtr;
    type Green = TokenExternGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenExternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenExtern)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenExternPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenExtern> for SyntaxStablePtrId {
    fn from(node: &TokenExtern) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalExtern {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalExtern {
    const KIND: SyntaxKind = SyntaxKind::TerminalExtern;
    type TokenType = TokenExtern;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalExtern as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalExternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalExtern,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalExtern {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenExtern {
        TokenExtern::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalExternPtr(pub SyntaxStablePtrId);
impl TerminalExternPtr {}
impl TypedStablePtr for TerminalExternPtr {
    type SyntaxNode = TerminalExtern;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalExtern {
        TerminalExtern::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalExternPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalExternPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalExternGreen(pub GreenId);
impl TypedSyntaxNode for TerminalExtern {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalExtern);
    type StablePtr = TerminalExternPtr;
    type Green = TerminalExternGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalExternGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalExtern,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenExtern::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalExtern,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalExtern
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalExtern {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalExternPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalExtern> for SyntaxStablePtrId {
    fn from(node: &TerminalExtern) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenFalse {
    node: SyntaxNode,
}
impl Token for TokenFalse {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenFalseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenFalse,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenFalsePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenFalsePtr {
    type SyntaxNode = TokenFalse;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenFalse {
        TokenFalse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenFalsePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenFalsePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenFalseGreen(pub GreenId);
impl TokenFalseGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenFalse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenFalse);
    type StablePtr = TokenFalsePtr;
    type Green = TokenFalseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenFalseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenFalse)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenFalsePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenFalse> for SyntaxStablePtrId {
    fn from(node: &TokenFalse) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalFalse {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalFalse {
    const KIND: SyntaxKind = SyntaxKind::TerminalFalse;
    type TokenType = TokenFalse;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalFalse as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalFalseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFalse,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalFalse {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenFalse {
        TokenFalse::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalFalsePtr(pub SyntaxStablePtrId);
impl TerminalFalsePtr {}
impl TypedStablePtr for TerminalFalsePtr {
    type SyntaxNode = TerminalFalse;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalFalse {
        TerminalFalse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalFalsePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalFalsePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalFalseGreen(pub GreenId);
impl TypedSyntaxNode for TerminalFalse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalFalse);
    type StablePtr = TerminalFalsePtr;
    type Green = TerminalFalseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalFalseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFalse,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenFalse::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalFalse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalFalse
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalFalse {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalFalsePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalFalse> for SyntaxStablePtrId {
    fn from(node: &TerminalFalse) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenFunction {
    node: SyntaxNode,
}
impl Token for TokenFunction {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenFunction,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenFunctionPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenFunctionPtr {
    type SyntaxNode = TokenFunction;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenFunction {
        TokenFunction::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenFunctionPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenFunctionPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenFunctionGreen(pub GreenId);
impl TokenFunctionGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenFunction {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenFunction);
    type StablePtr = TokenFunctionPtr;
    type Green = TokenFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenFunction)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenFunctionPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenFunction> for SyntaxStablePtrId {
    fn from(node: &TokenFunction) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalFunction {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalFunction {
    const KIND: SyntaxKind = SyntaxKind::TerminalFunction;
    type TokenType = TokenFunction;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalFunction as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFunction,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalFunction {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenFunction {
        TokenFunction::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalFunctionPtr(pub SyntaxStablePtrId);
impl TerminalFunctionPtr {}
impl TypedStablePtr for TerminalFunctionPtr {
    type SyntaxNode = TerminalFunction;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalFunction {
        TerminalFunction::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalFunctionPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalFunctionPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalFunctionGreen(pub GreenId);
impl TypedSyntaxNode for TerminalFunction {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalFunction);
    type StablePtr = TerminalFunctionPtr;
    type Green = TerminalFunctionGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalFunctionGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFunction,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenFunction::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalFunction,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalFunction
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalFunction {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalFunctionPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalFunction> for SyntaxStablePtrId {
    fn from(node: &TerminalFunction) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenIf {
    node: SyntaxNode,
}
impl Token for TokenIf {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenIf,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenIfPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenIfPtr {
    type SyntaxNode = TokenIf;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenIf {
        TokenIf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenIfPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenIfPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenIfGreen(pub GreenId);
impl TokenIfGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenIf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenIf);
    type StablePtr = TokenIfPtr;
    type Green = TokenIfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenIf)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenIfPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenIf> for SyntaxStablePtrId {
    fn from(node: &TokenIf) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalIf {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalIf {
    const KIND: SyntaxKind = SyntaxKind::TerminalIf;
    type TokenType = TokenIf;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalIf as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalIf,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalIf {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenIf {
        TokenIf::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalIfPtr(pub SyntaxStablePtrId);
impl TerminalIfPtr {}
impl TypedStablePtr for TerminalIfPtr {
    type SyntaxNode = TerminalIf;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalIf {
        TerminalIf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalIfPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalIfPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalIfGreen(pub GreenId);
impl TypedSyntaxNode for TerminalIf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalIf);
    type StablePtr = TerminalIfPtr;
    type Green = TerminalIfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalIfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalIf,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenIf::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalIf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalIf
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalIf { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalIfPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalIf> for SyntaxStablePtrId {
    fn from(node: &TerminalIf) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenWhile {
    node: SyntaxNode,
}
impl Token for TokenWhile {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenWhile,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenWhilePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenWhilePtr {
    type SyntaxNode = TokenWhile;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenWhile {
        TokenWhile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenWhilePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenWhilePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenWhileGreen(pub GreenId);
impl TokenWhileGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenWhile {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenWhile);
    type StablePtr = TokenWhilePtr;
    type Green = TokenWhileGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenWhile)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenWhilePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenWhile> for SyntaxStablePtrId {
    fn from(node: &TokenWhile) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalWhile {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalWhile {
    const KIND: SyntaxKind = SyntaxKind::TerminalWhile;
    type TokenType = TokenWhile;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalWhile as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalWhile,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalWhile {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenWhile {
        TokenWhile::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalWhilePtr(pub SyntaxStablePtrId);
impl TerminalWhilePtr {}
impl TypedStablePtr for TerminalWhilePtr {
    type SyntaxNode = TerminalWhile;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalWhile {
        TerminalWhile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalWhilePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalWhilePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalWhileGreen(pub GreenId);
impl TypedSyntaxNode for TerminalWhile {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalWhile);
    type StablePtr = TerminalWhilePtr;
    type Green = TerminalWhileGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalWhileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalWhile,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenWhile::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalWhile,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalWhile
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalWhile {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalWhilePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalWhile> for SyntaxStablePtrId {
    fn from(node: &TerminalWhile) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenFor {
    node: SyntaxNode,
}
impl Token for TokenFor {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenFor,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenForPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenForPtr {
    type SyntaxNode = TokenFor;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenFor {
        TokenFor::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenForPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenForPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenForGreen(pub GreenId);
impl TokenForGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenFor {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenFor);
    type StablePtr = TokenForPtr;
    type Green = TokenForGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenFor)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenForPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenFor> for SyntaxStablePtrId {
    fn from(node: &TokenFor) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalFor {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalFor {
    const KIND: SyntaxKind = SyntaxKind::TerminalFor;
    type TokenType = TokenFor;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalFor as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFor,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalFor {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenFor {
        TokenFor::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalForPtr(pub SyntaxStablePtrId);
impl TerminalForPtr {}
impl TypedStablePtr for TerminalForPtr {
    type SyntaxNode = TerminalFor;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalFor {
        TerminalFor::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalForPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalForPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalForGreen(pub GreenId);
impl TypedSyntaxNode for TerminalFor {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalFor);
    type StablePtr = TerminalForPtr;
    type Green = TerminalForGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalForGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalFor,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenFor::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalFor,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalFor
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalFor { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalForPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalFor> for SyntaxStablePtrId {
    fn from(node: &TerminalFor) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLoop {
    node: SyntaxNode,
}
impl Token for TokenLoop {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLoop,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLoopPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenLoopPtr {
    type SyntaxNode = TokenLoop;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenLoop {
        TokenLoop::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenLoopPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenLoopPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLoopGreen(pub GreenId);
impl TokenLoopGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenLoop {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLoop);
    type StablePtr = TokenLoopPtr;
    type Green = TokenLoopGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLoop)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLoopPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenLoop> for SyntaxStablePtrId {
    fn from(node: &TokenLoop) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLoop {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalLoop {
    const KIND: SyntaxKind = SyntaxKind::TerminalLoop;
    type TokenType = TokenLoop;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLoop as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLoop,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLoop {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLoop {
        TokenLoop::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLoopPtr(pub SyntaxStablePtrId);
impl TerminalLoopPtr {}
impl TypedStablePtr for TerminalLoopPtr {
    type SyntaxNode = TerminalLoop;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalLoop {
        TerminalLoop::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalLoopPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalLoopPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLoopGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLoop {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLoop);
    type StablePtr = TerminalLoopPtr;
    type Green = TerminalLoopGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLoopGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLoop,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLoop::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLoop,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLoop
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLoop { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLoopPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalLoop> for SyntaxStablePtrId {
    fn from(node: &TerminalLoop) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenImpl {
    node: SyntaxNode,
}
impl Token for TokenImpl {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenImpl,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenImplPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenImplPtr {
    type SyntaxNode = TokenImpl;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenImpl {
        TokenImpl::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenImplPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenImplPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenImplGreen(pub GreenId);
impl TokenImplGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenImpl {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenImpl);
    type StablePtr = TokenImplPtr;
    type Green = TokenImplGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenImpl)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenImplPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenImpl> for SyntaxStablePtrId {
    fn from(node: &TokenImpl) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalImpl {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalImpl {
    const KIND: SyntaxKind = SyntaxKind::TerminalImpl;
    type TokenType = TokenImpl;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalImpl as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalImpl,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalImpl {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenImpl {
        TokenImpl::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalImplPtr(pub SyntaxStablePtrId);
impl TerminalImplPtr {}
impl TypedStablePtr for TerminalImplPtr {
    type SyntaxNode = TerminalImpl;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalImpl {
        TerminalImpl::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalImplPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalImplPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalImplGreen(pub GreenId);
impl TypedSyntaxNode for TerminalImpl {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalImpl);
    type StablePtr = TerminalImplPtr;
    type Green = TerminalImplGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalImplGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalImpl,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenImpl::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalImpl,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalImpl
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalImpl { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalImplPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalImpl> for SyntaxStablePtrId {
    fn from(node: &TerminalImpl) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenImplicits {
    node: SyntaxNode,
}
impl Token for TokenImplicits {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenImplicitsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenImplicits,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenImplicitsPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenImplicitsPtr {
    type SyntaxNode = TokenImplicits;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenImplicits {
        TokenImplicits::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenImplicitsPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenImplicitsPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenImplicitsGreen(pub GreenId);
impl TokenImplicitsGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenImplicits {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenImplicits);
    type StablePtr = TokenImplicitsPtr;
    type Green = TokenImplicitsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenImplicitsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenImplicits)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenImplicitsPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenImplicits> for SyntaxStablePtrId {
    fn from(node: &TokenImplicits) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalImplicits {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalImplicits {
    const KIND: SyntaxKind = SyntaxKind::TerminalImplicits;
    type TokenType = TokenImplicits;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalImplicits as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalImplicitsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalImplicits,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalImplicits {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenImplicits {
        TokenImplicits::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalImplicitsPtr(pub SyntaxStablePtrId);
impl TerminalImplicitsPtr {}
impl TypedStablePtr for TerminalImplicitsPtr {
    type SyntaxNode = TerminalImplicits;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalImplicits {
        TerminalImplicits::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalImplicitsPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalImplicitsPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalImplicitsGreen(pub GreenId);
impl TypedSyntaxNode for TerminalImplicits {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalImplicits);
    type StablePtr = TerminalImplicitsPtr;
    type Green = TerminalImplicitsGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalImplicitsGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalImplicits,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenImplicits::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalImplicits,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalImplicits
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalImplicits {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalImplicitsPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalImplicits> for SyntaxStablePtrId {
    fn from(node: &TerminalImplicits) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLet {
    node: SyntaxNode,
}
impl Token for TokenLet {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLet,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLetPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenLetPtr {
    type SyntaxNode = TokenLet;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenLet {
        TokenLet::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenLetPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenLetPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLetGreen(pub GreenId);
impl TokenLetGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenLet {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLet);
    type StablePtr = TokenLetPtr;
    type Green = TokenLetGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLet)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLetPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenLet> for SyntaxStablePtrId {
    fn from(node: &TokenLet) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLet {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalLet {
    const KIND: SyntaxKind = SyntaxKind::TerminalLet;
    type TokenType = TokenLet;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLet as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLet,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLet {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLet {
        TokenLet::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLetPtr(pub SyntaxStablePtrId);
impl TerminalLetPtr {}
impl TypedStablePtr for TerminalLetPtr {
    type SyntaxNode = TerminalLet;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalLet {
        TerminalLet::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalLetPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalLetPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLetGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLet {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLet);
    type StablePtr = TerminalLetPtr;
    type Green = TerminalLetGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLetGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLet,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLet::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLet,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLet
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLet { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLetPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalLet> for SyntaxStablePtrId {
    fn from(node: &TerminalLet) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMatch {
    node: SyntaxNode,
}
impl Token for TokenMatch {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMatch,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMatchPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenMatchPtr {
    type SyntaxNode = TokenMatch;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenMatch {
        TokenMatch::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenMatchPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenMatchPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMatchGreen(pub GreenId);
impl TokenMatchGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenMatch {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMatch);
    type StablePtr = TokenMatchPtr;
    type Green = TokenMatchGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMatch)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMatchPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenMatch> for SyntaxStablePtrId {
    fn from(node: &TokenMatch) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMatch {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalMatch {
    const KIND: SyntaxKind = SyntaxKind::TerminalMatch;
    type TokenType = TokenMatch;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMatch as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMatch,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMatch {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMatch {
        TokenMatch::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMatchPtr(pub SyntaxStablePtrId);
impl TerminalMatchPtr {}
impl TypedStablePtr for TerminalMatchPtr {
    type SyntaxNode = TerminalMatch;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalMatch {
        TerminalMatch::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalMatchPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalMatchPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMatchGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMatch {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMatch);
    type StablePtr = TerminalMatchPtr;
    type Green = TerminalMatchGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMatchGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMatch,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMatch::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMatch,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMatch
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMatch {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMatchPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalMatch> for SyntaxStablePtrId {
    fn from(node: &TerminalMatch) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenModule {
    node: SyntaxNode,
}
impl Token for TokenModule {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenModule,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenModulePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenModulePtr {
    type SyntaxNode = TokenModule;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenModule {
        TokenModule::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenModulePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenModulePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenModuleGreen(pub GreenId);
impl TokenModuleGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenModule {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenModule);
    type StablePtr = TokenModulePtr;
    type Green = TokenModuleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenModule)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenModulePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenModule> for SyntaxStablePtrId {
    fn from(node: &TokenModule) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalModule {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalModule {
    const KIND: SyntaxKind = SyntaxKind::TerminalModule;
    type TokenType = TokenModule;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalModule as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalModule,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalModule {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenModule {
        TokenModule::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalModulePtr(pub SyntaxStablePtrId);
impl TerminalModulePtr {}
impl TypedStablePtr for TerminalModulePtr {
    type SyntaxNode = TerminalModule;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalModule {
        TerminalModule::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalModulePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalModulePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalModuleGreen(pub GreenId);
impl TypedSyntaxNode for TerminalModule {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalModule);
    type StablePtr = TerminalModulePtr;
    type Green = TerminalModuleGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalModuleGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalModule,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenModule::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalModule,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalModule
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalModule {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalModulePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalModule> for SyntaxStablePtrId {
    fn from(node: &TerminalModule) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMut {
    node: SyntaxNode,
}
impl Token for TokenMut {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMutGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMut,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMutPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenMutPtr {
    type SyntaxNode = TokenMut;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenMut {
        TokenMut::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenMutPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenMutPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMutGreen(pub GreenId);
impl TokenMutGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenMut {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMut);
    type StablePtr = TokenMutPtr;
    type Green = TokenMutGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMutGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMut)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMutPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenMut> for SyntaxStablePtrId {
    fn from(node: &TokenMut) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMut {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalMut {
    const KIND: SyntaxKind = SyntaxKind::TerminalMut;
    type TokenType = TokenMut;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMut as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMutGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMut,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMut {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMut {
        TokenMut::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMutPtr(pub SyntaxStablePtrId);
impl TerminalMutPtr {}
impl TypedStablePtr for TerminalMutPtr {
    type SyntaxNode = TerminalMut;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalMut {
        TerminalMut::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalMutPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalMutPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMutGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMut {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMut);
    type StablePtr = TerminalMutPtr;
    type Green = TerminalMutGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMutGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMut,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMut::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMut,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMut
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMut { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMutPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalMut> for SyntaxStablePtrId {
    fn from(node: &TerminalMut) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenNoPanic {
    node: SyntaxNode,
}
impl Token for TokenNoPanic {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNoPanicGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenNoPanic,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNoPanicPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenNoPanicPtr {
    type SyntaxNode = TokenNoPanic;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenNoPanic {
        TokenNoPanic::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenNoPanicPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenNoPanicPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNoPanicGreen(pub GreenId);
impl TokenNoPanicGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenNoPanic {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNoPanic);
    type StablePtr = TokenNoPanicPtr;
    type Green = TokenNoPanicGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenNoPanicGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNoPanic)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenNoPanicPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenNoPanic> for SyntaxStablePtrId {
    fn from(node: &TokenNoPanic) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalNoPanic {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalNoPanic {
    const KIND: SyntaxKind = SyntaxKind::TerminalNoPanic;
    type TokenType = TokenNoPanic;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalNoPanic as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalNoPanicGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNoPanic,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalNoPanic {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenNoPanic {
        TokenNoPanic::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNoPanicPtr(pub SyntaxStablePtrId);
impl TerminalNoPanicPtr {}
impl TypedStablePtr for TerminalNoPanicPtr {
    type SyntaxNode = TerminalNoPanic;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalNoPanic {
        TerminalNoPanic::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalNoPanicPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalNoPanicPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNoPanicGreen(pub GreenId);
impl TypedSyntaxNode for TerminalNoPanic {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalNoPanic);
    type StablePtr = TerminalNoPanicPtr;
    type Green = TerminalNoPanicGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalNoPanicGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNoPanic,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenNoPanic::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalNoPanic,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalNoPanic
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalNoPanic {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalNoPanicPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalNoPanic> for SyntaxStablePtrId {
    fn from(node: &TerminalNoPanic) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenOf {
    node: SyntaxNode,
}
impl Token for TokenOf {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenOfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenOf,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOfPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenOfPtr {
    type SyntaxNode = TokenOf;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenOf {
        TokenOf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenOfPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenOfPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOfGreen(pub GreenId);
impl TokenOfGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenOf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenOf);
    type StablePtr = TokenOfPtr;
    type Green = TokenOfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenOfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenOf)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenOfPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenOf> for SyntaxStablePtrId {
    fn from(node: &TokenOf) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalOf {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalOf {
    const KIND: SyntaxKind = SyntaxKind::TerminalOf;
    type TokenType = TokenOf;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalOf as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalOfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOf,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalOf {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenOf {
        TokenOf::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOfPtr(pub SyntaxStablePtrId);
impl TerminalOfPtr {}
impl TypedStablePtr for TerminalOfPtr {
    type SyntaxNode = TerminalOf;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalOf {
        TerminalOf::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalOfPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalOfPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOfGreen(pub GreenId);
impl TypedSyntaxNode for TerminalOf {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalOf);
    type StablePtr = TerminalOfPtr;
    type Green = TerminalOfGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalOfGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOf,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenOf::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalOf,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalOf
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalOf { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalOfPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalOf> for SyntaxStablePtrId {
    fn from(node: &TerminalOf) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenRef {
    node: SyntaxNode,
}
impl Token for TokenRef {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRefGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenRef,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRefPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenRefPtr {
    type SyntaxNode = TokenRef;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenRef {
        TokenRef::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenRefPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenRefPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRefGreen(pub GreenId);
impl TokenRefGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenRef {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRef);
    type StablePtr = TokenRefPtr;
    type Green = TokenRefGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenRefGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRef)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenRefPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenRef> for SyntaxStablePtrId {
    fn from(node: &TokenRef) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalRef {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalRef {
    const KIND: SyntaxKind = SyntaxKind::TerminalRef;
    type TokenType = TokenRef;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalRef as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalRefGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRef,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalRef {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenRef {
        TokenRef::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRefPtr(pub SyntaxStablePtrId);
impl TerminalRefPtr {}
impl TypedStablePtr for TerminalRefPtr {
    type SyntaxNode = TerminalRef;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalRef {
        TerminalRef::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalRefPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalRefPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRefGreen(pub GreenId);
impl TypedSyntaxNode for TerminalRef {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRef);
    type StablePtr = TerminalRefPtr;
    type Green = TerminalRefGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalRefGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRef,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenRef::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRef,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRef
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalRef { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalRefPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalRef> for SyntaxStablePtrId {
    fn from(node: &TerminalRef) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenContinue {
    node: SyntaxNode,
}
impl Token for TokenContinue {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenContinue,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenContinuePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenContinuePtr {
    type SyntaxNode = TokenContinue;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenContinue {
        TokenContinue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenContinuePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenContinuePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenContinueGreen(pub GreenId);
impl TokenContinueGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenContinue {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenContinue);
    type StablePtr = TokenContinuePtr;
    type Green = TokenContinueGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenContinue)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenContinuePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenContinue> for SyntaxStablePtrId {
    fn from(node: &TokenContinue) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalContinue {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalContinue {
    const KIND: SyntaxKind = SyntaxKind::TerminalContinue;
    type TokenType = TokenContinue;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalContinue as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalContinue,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalContinue {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenContinue {
        TokenContinue::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalContinuePtr(pub SyntaxStablePtrId);
impl TerminalContinuePtr {}
impl TypedStablePtr for TerminalContinuePtr {
    type SyntaxNode = TerminalContinue;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalContinue {
        TerminalContinue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalContinuePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalContinuePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalContinueGreen(pub GreenId);
impl TypedSyntaxNode for TerminalContinue {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalContinue);
    type StablePtr = TerminalContinuePtr;
    type Green = TerminalContinueGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalContinueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalContinue,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenContinue::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalContinue,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalContinue
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalContinue {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalContinuePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalContinue> for SyntaxStablePtrId {
    fn from(node: &TerminalContinue) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenReturn {
    node: SyntaxNode,
}
impl Token for TokenReturn {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenReturn,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenReturnPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenReturnPtr {
    type SyntaxNode = TokenReturn;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenReturn {
        TokenReturn::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenReturnPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenReturnPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenReturnGreen(pub GreenId);
impl TokenReturnGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenReturn {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenReturn);
    type StablePtr = TokenReturnPtr;
    type Green = TokenReturnGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenReturn)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenReturnPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenReturn> for SyntaxStablePtrId {
    fn from(node: &TokenReturn) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalReturn {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalReturn {
    const KIND: SyntaxKind = SyntaxKind::TerminalReturn;
    type TokenType = TokenReturn;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalReturn as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalReturn,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalReturn {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenReturn {
        TokenReturn::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalReturnPtr(pub SyntaxStablePtrId);
impl TerminalReturnPtr {}
impl TypedStablePtr for TerminalReturnPtr {
    type SyntaxNode = TerminalReturn;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalReturn {
        TerminalReturn::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalReturnPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalReturnPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalReturnGreen(pub GreenId);
impl TypedSyntaxNode for TerminalReturn {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalReturn);
    type StablePtr = TerminalReturnPtr;
    type Green = TerminalReturnGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalReturnGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalReturn,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenReturn::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalReturn,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalReturn
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalReturn {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalReturnPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalReturn> for SyntaxStablePtrId {
    fn from(node: &TerminalReturn) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenBreak {
    node: SyntaxNode,
}
impl Token for TokenBreak {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenBreak,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenBreakPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenBreakPtr {
    type SyntaxNode = TokenBreak;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenBreak {
        TokenBreak::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenBreakPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenBreakPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenBreakGreen(pub GreenId);
impl TokenBreakGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenBreak {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenBreak);
    type StablePtr = TokenBreakPtr;
    type Green = TokenBreakGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenBreak)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenBreakPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenBreak> for SyntaxStablePtrId {
    fn from(node: &TokenBreak) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalBreak {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalBreak {
    const KIND: SyntaxKind = SyntaxKind::TerminalBreak;
    type TokenType = TokenBreak;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalBreak as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBreak,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalBreak {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenBreak {
        TokenBreak::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalBreakPtr(pub SyntaxStablePtrId);
impl TerminalBreakPtr {}
impl TypedStablePtr for TerminalBreakPtr {
    type SyntaxNode = TerminalBreak;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalBreak {
        TerminalBreak::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalBreakPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalBreakPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalBreakGreen(pub GreenId);
impl TypedSyntaxNode for TerminalBreak {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalBreak);
    type StablePtr = TerminalBreakPtr;
    type Green = TerminalBreakGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalBreakGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBreak,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenBreak::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalBreak,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalBreak
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalBreak {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalBreakPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalBreak> for SyntaxStablePtrId {
    fn from(node: &TerminalBreak) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenStruct {
    node: SyntaxNode,
}
impl Token for TokenStruct {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenStruct,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenStructPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenStructPtr {
    type SyntaxNode = TokenStruct;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenStruct {
        TokenStruct::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenStructPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenStructPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenStructGreen(pub GreenId);
impl TokenStructGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenStruct {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenStruct);
    type StablePtr = TokenStructPtr;
    type Green = TokenStructGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenStruct)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenStructPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenStruct> for SyntaxStablePtrId {
    fn from(node: &TokenStruct) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalStruct {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalStruct {
    const KIND: SyntaxKind = SyntaxKind::TerminalStruct;
    type TokenType = TokenStruct;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalStruct as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalStruct,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalStruct {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenStruct {
        TokenStruct::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalStructPtr(pub SyntaxStablePtrId);
impl TerminalStructPtr {}
impl TypedStablePtr for TerminalStructPtr {
    type SyntaxNode = TerminalStruct;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalStruct {
        TerminalStruct::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalStructPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalStructPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalStructGreen(pub GreenId);
impl TypedSyntaxNode for TerminalStruct {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalStruct);
    type StablePtr = TerminalStructPtr;
    type Green = TerminalStructGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalStructGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalStruct,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenStruct::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalStruct,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalStruct
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalStruct {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalStructPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalStruct> for SyntaxStablePtrId {
    fn from(node: &TerminalStruct) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenTrait {
    node: SyntaxNode,
}
impl Token for TokenTrait {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTrait,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTraitPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenTraitPtr {
    type SyntaxNode = TokenTrait;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenTrait {
        TokenTrait::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenTraitPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenTraitPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTraitGreen(pub GreenId);
impl TokenTraitGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenTrait {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTrait);
    type StablePtr = TokenTraitPtr;
    type Green = TokenTraitGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenTrait)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenTraitPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenTrait> for SyntaxStablePtrId {
    fn from(node: &TokenTrait) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalTrait {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalTrait {
    const KIND: SyntaxKind = SyntaxKind::TerminalTrait;
    type TokenType = TokenTrait;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalTrait as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalTrait,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalTrait {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenTrait {
        TokenTrait::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTraitPtr(pub SyntaxStablePtrId);
impl TerminalTraitPtr {}
impl TypedStablePtr for TerminalTraitPtr {
    type SyntaxNode = TerminalTrait;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalTrait {
        TerminalTrait::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalTraitPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalTraitPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTraitGreen(pub GreenId);
impl TypedSyntaxNode for TerminalTrait {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalTrait);
    type StablePtr = TerminalTraitPtr;
    type Green = TerminalTraitGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalTraitGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalTrait,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenTrait::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalTrait,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalTrait
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalTrait {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalTraitPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalTrait> for SyntaxStablePtrId {
    fn from(node: &TerminalTrait) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenTrue {
    node: SyntaxNode,
}
impl Token for TokenTrue {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenTrueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenTrue,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTruePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenTruePtr {
    type SyntaxNode = TokenTrue;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenTrue {
        TokenTrue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenTruePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenTruePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTrueGreen(pub GreenId);
impl TokenTrueGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenTrue {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenTrue);
    type StablePtr = TokenTruePtr;
    type Green = TokenTrueGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenTrueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenTrue)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenTruePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenTrue> for SyntaxStablePtrId {
    fn from(node: &TokenTrue) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalTrue {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalTrue {
    const KIND: SyntaxKind = SyntaxKind::TerminalTrue;
    type TokenType = TokenTrue;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalTrue as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalTrueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalTrue,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalTrue {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenTrue {
        TokenTrue::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTruePtr(pub SyntaxStablePtrId);
impl TerminalTruePtr {}
impl TypedStablePtr for TerminalTruePtr {
    type SyntaxNode = TerminalTrue;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalTrue {
        TerminalTrue::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalTruePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalTruePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTrueGreen(pub GreenId);
impl TypedSyntaxNode for TerminalTrue {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalTrue);
    type StablePtr = TerminalTruePtr;
    type Green = TerminalTrueGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalTrueGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalTrue,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenTrue::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalTrue,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalTrue
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalTrue { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalTruePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalTrue> for SyntaxStablePtrId {
    fn from(node: &TerminalTrue) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenType {
    node: SyntaxNode,
}
impl Token for TokenType {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenType,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTypePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenTypePtr {
    type SyntaxNode = TokenType;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenType {
        TokenType::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenTypePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenTypePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenTypeGreen(pub GreenId);
impl TokenTypeGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenType {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenType);
    type StablePtr = TokenTypePtr;
    type Green = TokenTypeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenType)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenTypePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenType> for SyntaxStablePtrId {
    fn from(node: &TokenType) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalType {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalType {
    const KIND: SyntaxKind = SyntaxKind::TerminalType;
    type TokenType = TokenType;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalType as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalType,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalType {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenType {
        TokenType::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTypePtr(pub SyntaxStablePtrId);
impl TerminalTypePtr {}
impl TypedStablePtr for TerminalTypePtr {
    type SyntaxNode = TerminalType;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalType {
        TerminalType::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalTypePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalTypePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalTypeGreen(pub GreenId);
impl TypedSyntaxNode for TerminalType {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalType);
    type StablePtr = TerminalTypePtr;
    type Green = TerminalTypeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalTypeGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalType,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenType::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalType,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalType
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalType { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalTypePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalType> for SyntaxStablePtrId {
    fn from(node: &TerminalType) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenUse {
    node: SyntaxNode,
}
impl Token for TokenUse {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenUse,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenUsePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenUsePtr {
    type SyntaxNode = TokenUse;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenUse {
        TokenUse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenUsePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenUsePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenUseGreen(pub GreenId);
impl TokenUseGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenUse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenUse);
    type StablePtr = TokenUsePtr;
    type Green = TokenUseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenUse)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenUsePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenUse> for SyntaxStablePtrId {
    fn from(node: &TokenUse) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalUse {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalUse {
    const KIND: SyntaxKind = SyntaxKind::TerminalUse;
    type TokenType = TokenUse;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalUse as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalUse,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalUse {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenUse {
        TokenUse::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalUsePtr(pub SyntaxStablePtrId);
impl TerminalUsePtr {}
impl TypedStablePtr for TerminalUsePtr {
    type SyntaxNode = TerminalUse;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalUse {
        TerminalUse::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalUsePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalUsePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalUseGreen(pub GreenId);
impl TypedSyntaxNode for TerminalUse {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalUse);
    type StablePtr = TerminalUsePtr;
    type Green = TerminalUseGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalUseGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalUse,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenUse::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalUse,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalUse
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalUse { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalUsePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalUse> for SyntaxStablePtrId {
    fn from(node: &TerminalUse) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenPub {
    node: SyntaxNode,
}
impl Token for TokenPub {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenPub,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenPubPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenPubPtr {
    type SyntaxNode = TokenPub;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenPub {
        TokenPub::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenPubPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenPubPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenPubGreen(pub GreenId);
impl TokenPubGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenPub {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenPub);
    type StablePtr = TokenPubPtr;
    type Green = TokenPubGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenPub)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenPubPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenPub> for SyntaxStablePtrId {
    fn from(node: &TokenPub) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalPub {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalPub {
    const KIND: SyntaxKind = SyntaxKind::TerminalPub;
    type TokenType = TokenPub;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalPub as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPub,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalPub {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenPub {
        TokenPub::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalPubPtr(pub SyntaxStablePtrId);
impl TerminalPubPtr {}
impl TypedStablePtr for TerminalPubPtr {
    type SyntaxNode = TerminalPub;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalPub {
        TerminalPub::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalPubPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalPubPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalPubGreen(pub GreenId);
impl TypedSyntaxNode for TerminalPub {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalPub);
    type StablePtr = TerminalPubPtr;
    type Green = TerminalPubGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalPubGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPub,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenPub::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalPub,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalPub
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalPub { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalPubPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalPub> for SyntaxStablePtrId {
    fn from(node: &TerminalPub) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenAnd {
    node: SyntaxNode,
}
impl Token for TokenAnd {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenAnd,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAndPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenAndPtr {
    type SyntaxNode = TokenAnd;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenAnd {
        TokenAnd::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenAndPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenAndPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAndGreen(pub GreenId);
impl TokenAndGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenAnd {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenAnd);
    type StablePtr = TokenAndPtr;
    type Green = TokenAndGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenAnd)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenAndPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenAnd> for SyntaxStablePtrId {
    fn from(node: &TokenAnd) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalAnd {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalAnd {
    const KIND: SyntaxKind = SyntaxKind::TerminalAnd;
    type TokenType = TokenAnd;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalAnd as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAnd,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalAnd {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenAnd {
        TokenAnd::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAndPtr(pub SyntaxStablePtrId);
impl TerminalAndPtr {}
impl TypedStablePtr for TerminalAndPtr {
    type SyntaxNode = TerminalAnd;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalAnd {
        TerminalAnd::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalAndPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalAndPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAndGreen(pub GreenId);
impl TypedSyntaxNode for TerminalAnd {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalAnd);
    type StablePtr = TerminalAndPtr;
    type Green = TerminalAndGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAnd,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenAnd::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalAnd,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalAnd
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalAnd { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalAndPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalAnd> for SyntaxStablePtrId {
    fn from(node: &TerminalAnd) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenAndAnd {
    node: SyntaxNode,
}
impl Token for TokenAndAnd {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenAndAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenAndAnd,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAndAndPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenAndAndPtr {
    type SyntaxNode = TokenAndAnd;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenAndAnd {
        TokenAndAnd::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenAndAndPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenAndAndPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAndAndGreen(pub GreenId);
impl TokenAndAndGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenAndAnd {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenAndAnd);
    type StablePtr = TokenAndAndPtr;
    type Green = TokenAndAndGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenAndAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenAndAnd)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenAndAndPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenAndAnd> for SyntaxStablePtrId {
    fn from(node: &TokenAndAnd) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalAndAnd {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalAndAnd {
    const KIND: SyntaxKind = SyntaxKind::TerminalAndAnd;
    type TokenType = TokenAndAnd;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalAndAnd as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalAndAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAndAnd,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalAndAnd {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenAndAnd {
        TokenAndAnd::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAndAndPtr(pub SyntaxStablePtrId);
impl TerminalAndAndPtr {}
impl TypedStablePtr for TerminalAndAndPtr {
    type SyntaxNode = TerminalAndAnd;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalAndAnd {
        TerminalAndAnd::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalAndAndPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalAndAndPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAndAndGreen(pub GreenId);
impl TypedSyntaxNode for TerminalAndAnd {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalAndAnd);
    type StablePtr = TerminalAndAndPtr;
    type Green = TerminalAndAndGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalAndAndGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAndAnd,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenAndAnd::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalAndAnd,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalAndAnd
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalAndAnd {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalAndAndPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalAndAnd> for SyntaxStablePtrId {
    fn from(node: &TerminalAndAnd) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenArrow {
    node: SyntaxNode,
}
impl Token for TokenArrow {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenArrow,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenArrowPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenArrowPtr {
    type SyntaxNode = TokenArrow;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenArrow {
        TokenArrow::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenArrowPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenArrowPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenArrowGreen(pub GreenId);
impl TokenArrowGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenArrow {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenArrow);
    type StablePtr = TokenArrowPtr;
    type Green = TokenArrowGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenArrow)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenArrowPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenArrow> for SyntaxStablePtrId {
    fn from(node: &TokenArrow) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalArrow {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalArrow {
    const KIND: SyntaxKind = SyntaxKind::TerminalArrow;
    type TokenType = TokenArrow;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalArrow as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalArrow,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalArrow {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenArrow {
        TokenArrow::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalArrowPtr(pub SyntaxStablePtrId);
impl TerminalArrowPtr {}
impl TypedStablePtr for TerminalArrowPtr {
    type SyntaxNode = TerminalArrow;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalArrow {
        TerminalArrow::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalArrowPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalArrowPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalArrowGreen(pub GreenId);
impl TypedSyntaxNode for TerminalArrow {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalArrow);
    type StablePtr = TerminalArrowPtr;
    type Green = TerminalArrowGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalArrow,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenArrow::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalArrow,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalArrow
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalArrow {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalArrowPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalArrow> for SyntaxStablePtrId {
    fn from(node: &TerminalArrow) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenAt {
    node: SyntaxNode,
}
impl Token for TokenAt {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenAtGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenAt,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAtPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenAtPtr {
    type SyntaxNode = TokenAt;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenAt {
        TokenAt::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenAtPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenAtPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenAtGreen(pub GreenId);
impl TokenAtGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenAt {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenAt);
    type StablePtr = TokenAtPtr;
    type Green = TokenAtGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenAtGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenAt)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenAtPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenAt> for SyntaxStablePtrId {
    fn from(node: &TokenAt) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalAt {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalAt {
    const KIND: SyntaxKind = SyntaxKind::TerminalAt;
    type TokenType = TokenAt;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalAt as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalAtGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAt,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalAt {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenAt {
        TokenAt::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAtPtr(pub SyntaxStablePtrId);
impl TerminalAtPtr {}
impl TypedStablePtr for TerminalAtPtr {
    type SyntaxNode = TerminalAt;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalAt {
        TerminalAt::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalAtPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalAtPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalAtGreen(pub GreenId);
impl TypedSyntaxNode for TerminalAt {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalAt);
    type StablePtr = TerminalAtPtr;
    type Green = TerminalAtGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalAtGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalAt,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenAt::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalAt,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalAt
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalAt { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalAtPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalAt> for SyntaxStablePtrId {
    fn from(node: &TerminalAt) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenBadCharacters {
    node: SyntaxNode,
}
impl Token for TokenBadCharacters {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenBadCharactersGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenBadCharacters,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenBadCharactersPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenBadCharactersPtr {
    type SyntaxNode = TokenBadCharacters;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenBadCharacters {
        TokenBadCharacters::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenBadCharactersPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenBadCharactersPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenBadCharactersGreen(pub GreenId);
impl TokenBadCharactersGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenBadCharacters {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenBadCharacters);
    type StablePtr = TokenBadCharactersPtr;
    type Green = TokenBadCharactersGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenBadCharactersGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenBadCharacters
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenBadCharactersPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenBadCharacters> for SyntaxStablePtrId {
    fn from(node: &TokenBadCharacters) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalBadCharacters {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalBadCharacters {
    const KIND: SyntaxKind = SyntaxKind::TerminalBadCharacters;
    type TokenType = TokenBadCharacters;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalBadCharacters as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalBadCharactersGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBadCharacters,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalBadCharacters {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenBadCharacters {
        TokenBadCharacters::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalBadCharactersPtr(pub SyntaxStablePtrId);
impl TerminalBadCharactersPtr {}
impl TypedStablePtr for TerminalBadCharactersPtr {
    type SyntaxNode = TerminalBadCharacters;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalBadCharacters {
        TerminalBadCharacters::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalBadCharactersPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalBadCharactersPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalBadCharactersGreen(pub GreenId);
impl TypedSyntaxNode for TerminalBadCharacters {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalBadCharacters);
    type StablePtr = TerminalBadCharactersPtr;
    type Green = TerminalBadCharactersGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalBadCharactersGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBadCharacters,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenBadCharacters::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalBadCharacters,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalBadCharacters
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalBadCharacters {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalBadCharactersPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalBadCharacters> for SyntaxStablePtrId {
    fn from(node: &TerminalBadCharacters) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenColon {
    node: SyntaxNode,
}
impl Token for TokenColon {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenColon,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenColonPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenColonPtr {
    type SyntaxNode = TokenColon;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenColon {
        TokenColon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenColonPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenColonPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenColonGreen(pub GreenId);
impl TokenColonGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenColon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenColon);
    type StablePtr = TokenColonPtr;
    type Green = TokenColonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenColon)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenColonPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenColon> for SyntaxStablePtrId {
    fn from(node: &TokenColon) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalColon {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalColon {
    const KIND: SyntaxKind = SyntaxKind::TerminalColon;
    type TokenType = TokenColon;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalColon as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalColon,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalColon {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenColon {
        TokenColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalColonPtr(pub SyntaxStablePtrId);
impl TerminalColonPtr {}
impl TypedStablePtr for TerminalColonPtr {
    type SyntaxNode = TerminalColon;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalColon {
        TerminalColon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalColonPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalColonPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalColonGreen(pub GreenId);
impl TypedSyntaxNode for TerminalColon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalColon);
    type StablePtr = TerminalColonPtr;
    type Green = TerminalColonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalColon,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenColon::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalColon,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalColon
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalColon {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalColonPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalColon> for SyntaxStablePtrId {
    fn from(node: &TerminalColon) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenColonColon {
    node: SyntaxNode,
}
impl Token for TokenColonColon {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenColonColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenColonColon,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenColonColonPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenColonColonPtr {
    type SyntaxNode = TokenColonColon;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenColonColon {
        TokenColonColon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenColonColonPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenColonColonPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenColonColonGreen(pub GreenId);
impl TokenColonColonGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenColonColon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenColonColon);
    type StablePtr = TokenColonColonPtr;
    type Green = TokenColonColonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenColonColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenColonColon)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenColonColonPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenColonColon> for SyntaxStablePtrId {
    fn from(node: &TokenColonColon) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalColonColon {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalColonColon {
    const KIND: SyntaxKind = SyntaxKind::TerminalColonColon;
    type TokenType = TokenColonColon;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalColonColon as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalColonColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalColonColon,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalColonColon {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenColonColon {
        TokenColonColon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalColonColonPtr(pub SyntaxStablePtrId);
impl TerminalColonColonPtr {}
impl TypedStablePtr for TerminalColonColonPtr {
    type SyntaxNode = TerminalColonColon;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalColonColon {
        TerminalColonColon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalColonColonPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalColonColonPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalColonColonGreen(pub GreenId);
impl TypedSyntaxNode for TerminalColonColon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalColonColon);
    type StablePtr = TerminalColonColonPtr;
    type Green = TerminalColonColonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalColonColonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalColonColon,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenColonColon::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalColonColon,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalColonColon
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalColonColon {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalColonColonPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalColonColon> for SyntaxStablePtrId {
    fn from(node: &TerminalColonColon) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenComma {
    node: SyntaxNode,
}
impl Token for TokenComma {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenCommaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenComma,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenCommaPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenCommaPtr {
    type SyntaxNode = TokenComma;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenComma {
        TokenComma::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenCommaPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenCommaPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenCommaGreen(pub GreenId);
impl TokenCommaGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenComma {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenComma);
    type StablePtr = TokenCommaPtr;
    type Green = TokenCommaGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenCommaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenComma)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenCommaPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenComma> for SyntaxStablePtrId {
    fn from(node: &TokenComma) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalComma {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalComma {
    const KIND: SyntaxKind = SyntaxKind::TerminalComma;
    type TokenType = TokenComma;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalComma as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalCommaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalComma,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalComma {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenComma {
        TokenComma::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalCommaPtr(pub SyntaxStablePtrId);
impl TerminalCommaPtr {}
impl TypedStablePtr for TerminalCommaPtr {
    type SyntaxNode = TerminalComma;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalComma {
        TerminalComma::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalCommaPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalCommaPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalCommaGreen(pub GreenId);
impl TypedSyntaxNode for TerminalComma {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalComma);
    type StablePtr = TerminalCommaPtr;
    type Green = TerminalCommaGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalCommaGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalComma,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenComma::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalComma,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalComma
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalComma {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalCommaPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalComma> for SyntaxStablePtrId {
    fn from(node: &TerminalComma) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenDiv {
    node: SyntaxNode,
}
impl Token for TokenDiv {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDivGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDiv,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDivPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenDivPtr {
    type SyntaxNode = TokenDiv;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenDiv {
        TokenDiv::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenDivPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenDivPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDivGreen(pub GreenId);
impl TokenDivGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenDiv {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDiv);
    type StablePtr = TokenDivPtr;
    type Green = TokenDivGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenDivGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDiv)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenDivPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenDiv> for SyntaxStablePtrId {
    fn from(node: &TokenDiv) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalDiv {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalDiv {
    const KIND: SyntaxKind = SyntaxKind::TerminalDiv;
    type TokenType = TokenDiv;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalDiv as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDivGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDiv,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalDiv {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenDiv {
        TokenDiv::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDivPtr(pub SyntaxStablePtrId);
impl TerminalDivPtr {}
impl TypedStablePtr for TerminalDivPtr {
    type SyntaxNode = TerminalDiv;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalDiv {
        TerminalDiv::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalDivPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalDivPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDivGreen(pub GreenId);
impl TypedSyntaxNode for TerminalDiv {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDiv);
    type StablePtr = TerminalDivPtr;
    type Green = TerminalDivGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalDivGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDiv,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDiv::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDiv,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDiv
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDiv { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalDivPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalDiv> for SyntaxStablePtrId {
    fn from(node: &TerminalDiv) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenDivEq {
    node: SyntaxNode,
}
impl Token for TokenDivEq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDivEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDivEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDivEqPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenDivEqPtr {
    type SyntaxNode = TokenDivEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenDivEq {
        TokenDivEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenDivEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenDivEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDivEqGreen(pub GreenId);
impl TokenDivEqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenDivEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDivEq);
    type StablePtr = TokenDivEqPtr;
    type Green = TokenDivEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenDivEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDivEq)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenDivEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenDivEq> for SyntaxStablePtrId {
    fn from(node: &TokenDivEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalDivEq {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalDivEq {
    const KIND: SyntaxKind = SyntaxKind::TerminalDivEq;
    type TokenType = TokenDivEq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalDivEq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDivEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDivEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalDivEq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenDivEq {
        TokenDivEq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDivEqPtr(pub SyntaxStablePtrId);
impl TerminalDivEqPtr {}
impl TypedStablePtr for TerminalDivEqPtr {
    type SyntaxNode = TerminalDivEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalDivEq {
        TerminalDivEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalDivEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalDivEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDivEqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalDivEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDivEq);
    type StablePtr = TerminalDivEqPtr;
    type Green = TerminalDivEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalDivEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDivEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDivEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDivEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDivEq
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDivEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalDivEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalDivEq> for SyntaxStablePtrId {
    fn from(node: &TerminalDivEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenDot {
    node: SyntaxNode,
}
impl Token for TokenDot {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDot,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDotPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenDotPtr {
    type SyntaxNode = TokenDot;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenDot {
        TokenDot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenDotPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenDotPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDotGreen(pub GreenId);
impl TokenDotGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenDot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDot);
    type StablePtr = TokenDotPtr;
    type Green = TokenDotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDot)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenDotPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenDot> for SyntaxStablePtrId {
    fn from(node: &TokenDot) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalDot {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalDot {
    const KIND: SyntaxKind = SyntaxKind::TerminalDot;
    type TokenType = TokenDot;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalDot as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDot,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalDot {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenDot {
        TokenDot::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDotPtr(pub SyntaxStablePtrId);
impl TerminalDotPtr {}
impl TypedStablePtr for TerminalDotPtr {
    type SyntaxNode = TerminalDot;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalDot {
        TerminalDot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalDotPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalDotPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDotGreen(pub GreenId);
impl TypedSyntaxNode for TerminalDot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDot);
    type StablePtr = TerminalDotPtr;
    type Green = TerminalDotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDot,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDot::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDot
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDot { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalDotPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalDot> for SyntaxStablePtrId {
    fn from(node: &TerminalDot) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenDotDot {
    node: SyntaxNode,
}
impl Token for TokenDotDot {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDotDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDotDot,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDotDotPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenDotDotPtr {
    type SyntaxNode = TokenDotDot;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenDotDot {
        TokenDotDot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenDotDotPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenDotDotPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDotDotGreen(pub GreenId);
impl TokenDotDotGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenDotDot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDotDot);
    type StablePtr = TokenDotDotPtr;
    type Green = TokenDotDotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenDotDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDotDot)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenDotDotPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenDotDot> for SyntaxStablePtrId {
    fn from(node: &TokenDotDot) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalDotDot {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalDotDot {
    const KIND: SyntaxKind = SyntaxKind::TerminalDotDot;
    type TokenType = TokenDotDot;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalDotDot as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDotDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDotDot,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalDotDot {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenDotDot {
        TokenDotDot::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDotDotPtr(pub SyntaxStablePtrId);
impl TerminalDotDotPtr {}
impl TypedStablePtr for TerminalDotDotPtr {
    type SyntaxNode = TerminalDotDot;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalDotDot {
        TerminalDotDot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalDotDotPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalDotDotPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDotDotGreen(pub GreenId);
impl TypedSyntaxNode for TerminalDotDot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDotDot);
    type StablePtr = TerminalDotDotPtr;
    type Green = TerminalDotDotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalDotDotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDotDot,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDotDot::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDotDot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDotDot
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDotDot {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalDotDotPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalDotDot> for SyntaxStablePtrId {
    fn from(node: &TerminalDotDot) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenDotDotEq {
    node: SyntaxNode,
}
impl Token for TokenDotDotEq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenDotDotEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenDotDotEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDotDotEqPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenDotDotEqPtr {
    type SyntaxNode = TokenDotDotEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenDotDotEq {
        TokenDotDotEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenDotDotEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenDotDotEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenDotDotEqGreen(pub GreenId);
impl TokenDotDotEqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenDotDotEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenDotDotEq);
    type StablePtr = TokenDotDotEqPtr;
    type Green = TokenDotDotEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenDotDotEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenDotDotEq)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenDotDotEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenDotDotEq> for SyntaxStablePtrId {
    fn from(node: &TokenDotDotEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalDotDotEq {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalDotDotEq {
    const KIND: SyntaxKind = SyntaxKind::TerminalDotDotEq;
    type TokenType = TokenDotDotEq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalDotDotEq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalDotDotEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDotDotEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalDotDotEq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenDotDotEq {
        TokenDotDotEq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDotDotEqPtr(pub SyntaxStablePtrId);
impl TerminalDotDotEqPtr {}
impl TypedStablePtr for TerminalDotDotEqPtr {
    type SyntaxNode = TerminalDotDotEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalDotDotEq {
        TerminalDotDotEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalDotDotEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalDotDotEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalDotDotEqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalDotDotEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalDotDotEq);
    type StablePtr = TerminalDotDotEqPtr;
    type Green = TerminalDotDotEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalDotDotEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalDotDotEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenDotDotEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalDotDotEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalDotDotEq
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalDotDotEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalDotDotEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalDotDotEq> for SyntaxStablePtrId {
    fn from(node: &TerminalDotDotEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenEndOfFile {
    node: SyntaxNode,
}
impl Token for TokenEndOfFile {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEndOfFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenEndOfFile,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEndOfFilePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenEndOfFilePtr {
    type SyntaxNode = TokenEndOfFile;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenEndOfFile {
        TokenEndOfFile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenEndOfFilePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenEndOfFilePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEndOfFileGreen(pub GreenId);
impl TokenEndOfFileGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenEndOfFile {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEndOfFile);
    type StablePtr = TokenEndOfFilePtr;
    type Green = TokenEndOfFileGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenEndOfFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEndOfFile)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenEndOfFilePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenEndOfFile> for SyntaxStablePtrId {
    fn from(node: &TokenEndOfFile) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalEndOfFile {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalEndOfFile {
    const KIND: SyntaxKind = SyntaxKind::TerminalEndOfFile;
    type TokenType = TokenEndOfFile;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalEndOfFile as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalEndOfFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEndOfFile,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalEndOfFile {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenEndOfFile {
        TokenEndOfFile::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEndOfFilePtr(pub SyntaxStablePtrId);
impl TerminalEndOfFilePtr {}
impl TypedStablePtr for TerminalEndOfFilePtr {
    type SyntaxNode = TerminalEndOfFile;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalEndOfFile {
        TerminalEndOfFile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalEndOfFilePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalEndOfFilePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEndOfFileGreen(pub GreenId);
impl TypedSyntaxNode for TerminalEndOfFile {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEndOfFile);
    type StablePtr = TerminalEndOfFilePtr;
    type Green = TerminalEndOfFileGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalEndOfFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEndOfFile,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenEndOfFile::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEndOfFile,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEndOfFile
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalEndOfFile {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalEndOfFilePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalEndOfFile> for SyntaxStablePtrId {
    fn from(node: &TerminalEndOfFile) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenEq {
    node: SyntaxNode,
}
impl Token for TokenEq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEqPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenEqPtr {
    type SyntaxNode = TokenEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenEq {
        TokenEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEqGreen(pub GreenId);
impl TokenEqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEq);
    type StablePtr = TokenEqPtr;
    type Green = TokenEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEq)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenEq> for SyntaxStablePtrId {
    fn from(node: &TokenEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalEq {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalEq {
    const KIND: SyntaxKind = SyntaxKind::TerminalEq;
    type TokenType = TokenEq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalEq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalEq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenEq {
        TokenEq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEqPtr(pub SyntaxStablePtrId);
impl TerminalEqPtr {}
impl TypedStablePtr for TerminalEqPtr {
    type SyntaxNode = TerminalEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalEq {
        TerminalEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEq);
    type StablePtr = TerminalEqPtr;
    type Green = TerminalEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEq
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalEq { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalEq> for SyntaxStablePtrId {
    fn from(node: &TerminalEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenEqEq {
    node: SyntaxNode,
}
impl Token for TokenEqEq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEqEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenEqEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEqEqPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenEqEqPtr {
    type SyntaxNode = TokenEqEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenEqEq {
        TokenEqEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenEqEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenEqEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEqEqGreen(pub GreenId);
impl TokenEqEqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenEqEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEqEq);
    type StablePtr = TokenEqEqPtr;
    type Green = TokenEqEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenEqEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEqEq)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenEqEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenEqEq> for SyntaxStablePtrId {
    fn from(node: &TokenEqEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalEqEq {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalEqEq {
    const KIND: SyntaxKind = SyntaxKind::TerminalEqEq;
    type TokenType = TokenEqEq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalEqEq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalEqEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEqEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalEqEq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenEqEq {
        TokenEqEq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEqEqPtr(pub SyntaxStablePtrId);
impl TerminalEqEqPtr {}
impl TypedStablePtr for TerminalEqEqPtr {
    type SyntaxNode = TerminalEqEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalEqEq {
        TerminalEqEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalEqEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalEqEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEqEqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalEqEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEqEq);
    type StablePtr = TerminalEqEqPtr;
    type Green = TerminalEqEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalEqEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEqEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenEqEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEqEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEqEq
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalEqEq { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalEqEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalEqEq> for SyntaxStablePtrId {
    fn from(node: &TerminalEqEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenGE {
    node: SyntaxNode,
}
impl Token for TokenGE {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenGEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenGE,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenGEPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenGEPtr {
    type SyntaxNode = TokenGE;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenGE {
        TokenGE::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenGEPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenGEPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenGEGreen(pub GreenId);
impl TokenGEGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenGE {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenGE);
    type StablePtr = TokenGEPtr;
    type Green = TokenGEGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenGEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenGE)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenGEPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenGE> for SyntaxStablePtrId {
    fn from(node: &TokenGE) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalGE {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalGE {
    const KIND: SyntaxKind = SyntaxKind::TerminalGE;
    type TokenType = TokenGE;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalGE as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalGEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalGE,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalGE {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenGE {
        TokenGE::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalGEPtr(pub SyntaxStablePtrId);
impl TerminalGEPtr {}
impl TypedStablePtr for TerminalGEPtr {
    type SyntaxNode = TerminalGE;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalGE {
        TerminalGE::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalGEPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalGEPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalGEGreen(pub GreenId);
impl TypedSyntaxNode for TerminalGE {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalGE);
    type StablePtr = TerminalGEPtr;
    type Green = TerminalGEGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalGEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalGE,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenGE::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalGE,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalGE
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalGE { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalGEPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalGE> for SyntaxStablePtrId {
    fn from(node: &TerminalGE) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenGT {
    node: SyntaxNode,
}
impl Token for TokenGT {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenGTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenGT,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenGTPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenGTPtr {
    type SyntaxNode = TokenGT;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenGT {
        TokenGT::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenGTPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenGTPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenGTGreen(pub GreenId);
impl TokenGTGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenGT {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenGT);
    type StablePtr = TokenGTPtr;
    type Green = TokenGTGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenGTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenGT)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenGTPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenGT> for SyntaxStablePtrId {
    fn from(node: &TokenGT) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalGT {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalGT {
    const KIND: SyntaxKind = SyntaxKind::TerminalGT;
    type TokenType = TokenGT;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalGT as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalGTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalGT,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalGT {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenGT {
        TokenGT::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalGTPtr(pub SyntaxStablePtrId);
impl TerminalGTPtr {}
impl TypedStablePtr for TerminalGTPtr {
    type SyntaxNode = TerminalGT;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalGT {
        TerminalGT::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalGTPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalGTPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalGTGreen(pub GreenId);
impl TypedSyntaxNode for TerminalGT {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalGT);
    type StablePtr = TerminalGTPtr;
    type Green = TerminalGTGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalGTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalGT,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenGT::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalGT,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalGT
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalGT { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalGTPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalGT> for SyntaxStablePtrId {
    fn from(node: &TerminalGT) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenHash {
    node: SyntaxNode,
}
impl Token for TokenHash {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenHashGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenHash,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenHashPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenHashPtr {
    type SyntaxNode = TokenHash;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenHash {
        TokenHash::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenHashPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenHashPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenHashGreen(pub GreenId);
impl TokenHashGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenHash {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenHash);
    type StablePtr = TokenHashPtr;
    type Green = TokenHashGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenHashGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenHash)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenHashPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenHash> for SyntaxStablePtrId {
    fn from(node: &TokenHash) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalHash {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalHash {
    const KIND: SyntaxKind = SyntaxKind::TerminalHash;
    type TokenType = TokenHash;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalHash as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalHashGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalHash,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalHash {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenHash {
        TokenHash::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalHashPtr(pub SyntaxStablePtrId);
impl TerminalHashPtr {}
impl TypedStablePtr for TerminalHashPtr {
    type SyntaxNode = TerminalHash;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalHash {
        TerminalHash::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalHashPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalHashPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalHashGreen(pub GreenId);
impl TypedSyntaxNode for TerminalHash {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalHash);
    type StablePtr = TerminalHashPtr;
    type Green = TerminalHashGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalHashGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalHash,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenHash::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalHash,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalHash
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalHash { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalHashPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalHash> for SyntaxStablePtrId {
    fn from(node: &TerminalHash) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLBrace {
    node: SyntaxNode,
}
impl Token for TokenLBrace {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLBrace,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLBracePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenLBracePtr {
    type SyntaxNode = TokenLBrace;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenLBrace {
        TokenLBrace::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenLBracePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenLBracePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLBraceGreen(pub GreenId);
impl TokenLBraceGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenLBrace {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLBrace);
    type StablePtr = TokenLBracePtr;
    type Green = TokenLBraceGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLBrace)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLBracePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenLBrace> for SyntaxStablePtrId {
    fn from(node: &TokenLBrace) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLBrace {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalLBrace {
    const KIND: SyntaxKind = SyntaxKind::TerminalLBrace;
    type TokenType = TokenLBrace;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLBrace as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLBrace,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLBrace {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLBrace {
        TokenLBrace::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLBracePtr(pub SyntaxStablePtrId);
impl TerminalLBracePtr {}
impl TypedStablePtr for TerminalLBracePtr {
    type SyntaxNode = TerminalLBrace;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalLBrace {
        TerminalLBrace::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalLBracePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalLBracePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLBraceGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLBrace {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLBrace);
    type StablePtr = TerminalLBracePtr;
    type Green = TerminalLBraceGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLBrace,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLBrace::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLBrace,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLBrace
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLBrace {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLBracePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalLBrace> for SyntaxStablePtrId {
    fn from(node: &TerminalLBrace) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLBrack {
    node: SyntaxNode,
}
impl Token for TokenLBrack {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLBrack,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLBrackPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenLBrackPtr {
    type SyntaxNode = TokenLBrack;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenLBrack {
        TokenLBrack::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenLBrackPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenLBrackPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLBrackGreen(pub GreenId);
impl TokenLBrackGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenLBrack {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLBrack);
    type StablePtr = TokenLBrackPtr;
    type Green = TokenLBrackGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLBrack)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLBrackPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenLBrack> for SyntaxStablePtrId {
    fn from(node: &TokenLBrack) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLBrack {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalLBrack {
    const KIND: SyntaxKind = SyntaxKind::TerminalLBrack;
    type TokenType = TokenLBrack;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLBrack as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLBrack,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLBrack {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLBrack {
        TokenLBrack::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLBrackPtr(pub SyntaxStablePtrId);
impl TerminalLBrackPtr {}
impl TypedStablePtr for TerminalLBrackPtr {
    type SyntaxNode = TerminalLBrack;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalLBrack {
        TerminalLBrack::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalLBrackPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalLBrackPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLBrackGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLBrack {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLBrack);
    type StablePtr = TerminalLBrackPtr;
    type Green = TerminalLBrackGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLBrack,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLBrack::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLBrack,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLBrack
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLBrack {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLBrackPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalLBrack> for SyntaxStablePtrId {
    fn from(node: &TerminalLBrack) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLE {
    node: SyntaxNode,
}
impl Token for TokenLE {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLE,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLEPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenLEPtr {
    type SyntaxNode = TokenLE;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenLE {
        TokenLE::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenLEPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenLEPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLEGreen(pub GreenId);
impl TokenLEGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenLE {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLE);
    type StablePtr = TokenLEPtr;
    type Green = TokenLEGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLE)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLEPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenLE> for SyntaxStablePtrId {
    fn from(node: &TokenLE) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLE {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalLE {
    const KIND: SyntaxKind = SyntaxKind::TerminalLE;
    type TokenType = TokenLE;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLE as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLE,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLE {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLE {
        TokenLE::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLEPtr(pub SyntaxStablePtrId);
impl TerminalLEPtr {}
impl TypedStablePtr for TerminalLEPtr {
    type SyntaxNode = TerminalLE;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalLE {
        TerminalLE::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalLEPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalLEPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLEGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLE {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLE);
    type StablePtr = TerminalLEPtr;
    type Green = TerminalLEGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLEGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLE,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLE::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLE,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLE
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLE { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLEPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalLE> for SyntaxStablePtrId {
    fn from(node: &TerminalLE) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLParen {
    node: SyntaxNode,
}
impl Token for TokenLParen {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLParen,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLParenPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenLParenPtr {
    type SyntaxNode = TokenLParen;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenLParen {
        TokenLParen::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenLParenPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenLParenPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLParenGreen(pub GreenId);
impl TokenLParenGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenLParen {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLParen);
    type StablePtr = TokenLParenPtr;
    type Green = TokenLParenGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLParen)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLParenPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenLParen> for SyntaxStablePtrId {
    fn from(node: &TokenLParen) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLParen {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalLParen {
    const KIND: SyntaxKind = SyntaxKind::TerminalLParen;
    type TokenType = TokenLParen;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLParen as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLParen,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLParen {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLParen {
        TokenLParen::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLParenPtr(pub SyntaxStablePtrId);
impl TerminalLParenPtr {}
impl TypedStablePtr for TerminalLParenPtr {
    type SyntaxNode = TerminalLParen;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalLParen {
        TerminalLParen::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalLParenPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalLParenPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLParenGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLParen {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLParen);
    type StablePtr = TerminalLParenPtr;
    type Green = TerminalLParenGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLParen,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLParen::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLParen,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLParen
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLParen {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLParenPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalLParen> for SyntaxStablePtrId {
    fn from(node: &TerminalLParen) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenLT {
    node: SyntaxNode,
}
impl Token for TokenLT {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenLTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenLT,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLTPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenLTPtr {
    type SyntaxNode = TokenLT;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenLT {
        TokenLT::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenLTPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenLTPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenLTGreen(pub GreenId);
impl TokenLTGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenLT {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenLT);
    type StablePtr = TokenLTPtr;
    type Green = TokenLTGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenLTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenLT)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenLTPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenLT> for SyntaxStablePtrId {
    fn from(node: &TokenLT) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalLT {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalLT {
    const KIND: SyntaxKind = SyntaxKind::TerminalLT;
    type TokenType = TokenLT;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalLT as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalLTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLT,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalLT {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenLT {
        TokenLT::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLTPtr(pub SyntaxStablePtrId);
impl TerminalLTPtr {}
impl TypedStablePtr for TerminalLTPtr {
    type SyntaxNode = TerminalLT;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalLT {
        TerminalLT::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalLTPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalLTPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalLTGreen(pub GreenId);
impl TypedSyntaxNode for TerminalLT {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalLT);
    type StablePtr = TerminalLTPtr;
    type Green = TerminalLTGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalLTGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalLT,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenLT::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalLT,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalLT
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalLT { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalLTPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalLT> for SyntaxStablePtrId {
    fn from(node: &TerminalLT) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMatchArrow {
    node: SyntaxNode,
}
impl Token for TokenMatchArrow {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMatchArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMatchArrow,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMatchArrowPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenMatchArrowPtr {
    type SyntaxNode = TokenMatchArrow;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenMatchArrow {
        TokenMatchArrow::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenMatchArrowPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenMatchArrowPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMatchArrowGreen(pub GreenId);
impl TokenMatchArrowGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenMatchArrow {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMatchArrow);
    type StablePtr = TokenMatchArrowPtr;
    type Green = TokenMatchArrowGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMatchArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMatchArrow)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMatchArrowPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenMatchArrow> for SyntaxStablePtrId {
    fn from(node: &TokenMatchArrow) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMatchArrow {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalMatchArrow {
    const KIND: SyntaxKind = SyntaxKind::TerminalMatchArrow;
    type TokenType = TokenMatchArrow;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMatchArrow as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMatchArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMatchArrow,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMatchArrow {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMatchArrow {
        TokenMatchArrow::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMatchArrowPtr(pub SyntaxStablePtrId);
impl TerminalMatchArrowPtr {}
impl TypedStablePtr for TerminalMatchArrowPtr {
    type SyntaxNode = TerminalMatchArrow;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalMatchArrow {
        TerminalMatchArrow::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalMatchArrowPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalMatchArrowPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMatchArrowGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMatchArrow {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMatchArrow);
    type StablePtr = TerminalMatchArrowPtr;
    type Green = TerminalMatchArrowGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMatchArrowGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMatchArrow,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMatchArrow::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMatchArrow,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMatchArrow
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMatchArrow {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMatchArrowPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalMatchArrow> for SyntaxStablePtrId {
    fn from(node: &TerminalMatchArrow) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMinus {
    node: SyntaxNode,
}
impl Token for TokenMinus {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMinusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMinus,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMinusPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenMinusPtr {
    type SyntaxNode = TokenMinus;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenMinus {
        TokenMinus::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenMinusPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenMinusPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMinusGreen(pub GreenId);
impl TokenMinusGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenMinus {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMinus);
    type StablePtr = TokenMinusPtr;
    type Green = TokenMinusGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMinusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMinus)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMinusPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenMinus> for SyntaxStablePtrId {
    fn from(node: &TokenMinus) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMinus {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalMinus {
    const KIND: SyntaxKind = SyntaxKind::TerminalMinus;
    type TokenType = TokenMinus;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMinus as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMinusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMinus,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMinus {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMinus {
        TokenMinus::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMinusPtr(pub SyntaxStablePtrId);
impl TerminalMinusPtr {}
impl TypedStablePtr for TerminalMinusPtr {
    type SyntaxNode = TerminalMinus;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalMinus {
        TerminalMinus::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalMinusPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalMinusPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMinusGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMinus {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMinus);
    type StablePtr = TerminalMinusPtr;
    type Green = TerminalMinusGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMinusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMinus,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMinus::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMinus,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMinus
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMinus {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMinusPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalMinus> for SyntaxStablePtrId {
    fn from(node: &TerminalMinus) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMinusEq {
    node: SyntaxNode,
}
impl Token for TokenMinusEq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMinusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMinusEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMinusEqPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenMinusEqPtr {
    type SyntaxNode = TokenMinusEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenMinusEq {
        TokenMinusEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenMinusEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenMinusEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMinusEqGreen(pub GreenId);
impl TokenMinusEqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenMinusEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMinusEq);
    type StablePtr = TokenMinusEqPtr;
    type Green = TokenMinusEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMinusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMinusEq)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMinusEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenMinusEq> for SyntaxStablePtrId {
    fn from(node: &TokenMinusEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMinusEq {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalMinusEq {
    const KIND: SyntaxKind = SyntaxKind::TerminalMinusEq;
    type TokenType = TokenMinusEq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMinusEq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMinusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMinusEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMinusEq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMinusEq {
        TokenMinusEq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMinusEqPtr(pub SyntaxStablePtrId);
impl TerminalMinusEqPtr {}
impl TypedStablePtr for TerminalMinusEqPtr {
    type SyntaxNode = TerminalMinusEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalMinusEq {
        TerminalMinusEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalMinusEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalMinusEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMinusEqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMinusEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMinusEq);
    type StablePtr = TerminalMinusEqPtr;
    type Green = TerminalMinusEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMinusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMinusEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMinusEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMinusEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMinusEq
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMinusEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMinusEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalMinusEq> for SyntaxStablePtrId {
    fn from(node: &TerminalMinusEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMod {
    node: SyntaxNode,
}
impl Token for TokenMod {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenModGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMod,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenModPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenModPtr {
    type SyntaxNode = TokenMod;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenMod {
        TokenMod::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenModPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenModPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenModGreen(pub GreenId);
impl TokenModGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenMod {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMod);
    type StablePtr = TokenModPtr;
    type Green = TokenModGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenModGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMod)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenModPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenMod> for SyntaxStablePtrId {
    fn from(node: &TokenMod) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMod {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalMod {
    const KIND: SyntaxKind = SyntaxKind::TerminalMod;
    type TokenType = TokenMod;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMod as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalModGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMod,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMod {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMod {
        TokenMod::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalModPtr(pub SyntaxStablePtrId);
impl TerminalModPtr {}
impl TypedStablePtr for TerminalModPtr {
    type SyntaxNode = TerminalMod;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalMod {
        TerminalMod::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalModPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalModPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalModGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMod {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMod);
    type StablePtr = TerminalModPtr;
    type Green = TerminalModGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalModGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMod,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMod::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMod,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMod
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMod { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalModPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalMod> for SyntaxStablePtrId {
    fn from(node: &TerminalMod) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenModEq {
    node: SyntaxNode,
}
impl Token for TokenModEq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenModEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenModEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenModEqPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenModEqPtr {
    type SyntaxNode = TokenModEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenModEq {
        TokenModEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenModEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenModEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenModEqGreen(pub GreenId);
impl TokenModEqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenModEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenModEq);
    type StablePtr = TokenModEqPtr;
    type Green = TokenModEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenModEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenModEq)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenModEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenModEq> for SyntaxStablePtrId {
    fn from(node: &TokenModEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalModEq {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalModEq {
    const KIND: SyntaxKind = SyntaxKind::TerminalModEq;
    type TokenType = TokenModEq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalModEq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalModEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalModEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalModEq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenModEq {
        TokenModEq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalModEqPtr(pub SyntaxStablePtrId);
impl TerminalModEqPtr {}
impl TypedStablePtr for TerminalModEqPtr {
    type SyntaxNode = TerminalModEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalModEq {
        TerminalModEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalModEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalModEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalModEqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalModEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalModEq);
    type StablePtr = TerminalModEqPtr;
    type Green = TerminalModEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalModEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalModEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenModEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalModEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalModEq
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalModEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalModEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalModEq> for SyntaxStablePtrId {
    fn from(node: &TerminalModEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMul {
    node: SyntaxNode,
}
impl Token for TokenMul {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMulGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMul,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMulPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenMulPtr {
    type SyntaxNode = TokenMul;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenMul {
        TokenMul::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenMulPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenMulPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMulGreen(pub GreenId);
impl TokenMulGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenMul {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMul);
    type StablePtr = TokenMulPtr;
    type Green = TokenMulGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMulGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMul)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMulPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenMul> for SyntaxStablePtrId {
    fn from(node: &TokenMul) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMul {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalMul {
    const KIND: SyntaxKind = SyntaxKind::TerminalMul;
    type TokenType = TokenMul;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMul as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMulGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMul,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMul {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMul {
        TokenMul::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMulPtr(pub SyntaxStablePtrId);
impl TerminalMulPtr {}
impl TypedStablePtr for TerminalMulPtr {
    type SyntaxNode = TerminalMul;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalMul {
        TerminalMul::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalMulPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalMulPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMulGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMul {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMul);
    type StablePtr = TerminalMulPtr;
    type Green = TerminalMulGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMulGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMul,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMul::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMul,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMul
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMul { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMulPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalMul> for SyntaxStablePtrId {
    fn from(node: &TerminalMul) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMulEq {
    node: SyntaxNode,
}
impl Token for TokenMulEq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMulEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMulEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMulEqPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenMulEqPtr {
    type SyntaxNode = TokenMulEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenMulEq {
        TokenMulEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenMulEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenMulEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMulEqGreen(pub GreenId);
impl TokenMulEqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenMulEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMulEq);
    type StablePtr = TokenMulEqPtr;
    type Green = TokenMulEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMulEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMulEq)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMulEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenMulEq> for SyntaxStablePtrId {
    fn from(node: &TokenMulEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalMulEq {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalMulEq {
    const KIND: SyntaxKind = SyntaxKind::TerminalMulEq;
    type TokenType = TokenMulEq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalMulEq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalMulEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMulEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalMulEq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenMulEq {
        TokenMulEq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMulEqPtr(pub SyntaxStablePtrId);
impl TerminalMulEqPtr {}
impl TypedStablePtr for TerminalMulEqPtr {
    type SyntaxNode = TerminalMulEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalMulEq {
        TerminalMulEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalMulEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalMulEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalMulEqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalMulEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalMulEq);
    type StablePtr = TerminalMulEqPtr;
    type Green = TerminalMulEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalMulEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalMulEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenMulEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalMulEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalMulEq
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalMulEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalMulEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalMulEq> for SyntaxStablePtrId {
    fn from(node: &TerminalMulEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenNeq {
    node: SyntaxNode,
}
impl Token for TokenNeq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNeqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenNeq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNeqPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenNeqPtr {
    type SyntaxNode = TokenNeq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenNeq {
        TokenNeq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenNeqPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenNeqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNeqGreen(pub GreenId);
impl TokenNeqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenNeq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNeq);
    type StablePtr = TokenNeqPtr;
    type Green = TokenNeqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenNeqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNeq)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenNeqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenNeq> for SyntaxStablePtrId {
    fn from(node: &TokenNeq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalNeq {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalNeq {
    const KIND: SyntaxKind = SyntaxKind::TerminalNeq;
    type TokenType = TokenNeq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalNeq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalNeqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNeq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalNeq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenNeq {
        TokenNeq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNeqPtr(pub SyntaxStablePtrId);
impl TerminalNeqPtr {}
impl TypedStablePtr for TerminalNeqPtr {
    type SyntaxNode = TerminalNeq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalNeq {
        TerminalNeq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalNeqPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalNeqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNeqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalNeq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalNeq);
    type StablePtr = TerminalNeqPtr;
    type Green = TerminalNeqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalNeqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNeq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenNeq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalNeq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalNeq
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalNeq { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalNeqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalNeq> for SyntaxStablePtrId {
    fn from(node: &TerminalNeq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenNot {
    node: SyntaxNode,
}
impl Token for TokenNot {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenNot,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNotPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenNotPtr {
    type SyntaxNode = TokenNot;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenNot {
        TokenNot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenNotPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenNotPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNotGreen(pub GreenId);
impl TokenNotGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenNot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNot);
    type StablePtr = TokenNotPtr;
    type Green = TokenNotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNot)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenNotPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenNot> for SyntaxStablePtrId {
    fn from(node: &TokenNot) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalNot {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalNot {
    const KIND: SyntaxKind = SyntaxKind::TerminalNot;
    type TokenType = TokenNot;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalNot as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNot,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalNot {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenNot {
        TokenNot::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNotPtr(pub SyntaxStablePtrId);
impl TerminalNotPtr {}
impl TypedStablePtr for TerminalNotPtr {
    type SyntaxNode = TerminalNot;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalNot {
        TerminalNot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalNotPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalNotPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalNotGreen(pub GreenId);
impl TypedSyntaxNode for TerminalNot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalNot);
    type StablePtr = TerminalNotPtr;
    type Green = TerminalNotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalNot,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenNot::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalNot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalNot
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalNot { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalNotPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalNot> for SyntaxStablePtrId {
    fn from(node: &TerminalNot) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenBitNot {
    node: SyntaxNode,
}
impl Token for TokenBitNot {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenBitNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenBitNot,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenBitNotPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenBitNotPtr {
    type SyntaxNode = TokenBitNot;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenBitNot {
        TokenBitNot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenBitNotPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenBitNotPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenBitNotGreen(pub GreenId);
impl TokenBitNotGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenBitNot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenBitNot);
    type StablePtr = TokenBitNotPtr;
    type Green = TokenBitNotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenBitNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenBitNot)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenBitNotPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenBitNot> for SyntaxStablePtrId {
    fn from(node: &TokenBitNot) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalBitNot {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalBitNot {
    const KIND: SyntaxKind = SyntaxKind::TerminalBitNot;
    type TokenType = TokenBitNot;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalBitNot as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalBitNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBitNot,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalBitNot {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenBitNot {
        TokenBitNot::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalBitNotPtr(pub SyntaxStablePtrId);
impl TerminalBitNotPtr {}
impl TypedStablePtr for TerminalBitNotPtr {
    type SyntaxNode = TerminalBitNot;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalBitNot {
        TerminalBitNot::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalBitNotPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalBitNotPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalBitNotGreen(pub GreenId);
impl TypedSyntaxNode for TerminalBitNot {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalBitNot);
    type StablePtr = TerminalBitNotPtr;
    type Green = TerminalBitNotGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalBitNotGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalBitNot,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenBitNot::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalBitNot,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalBitNot
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalBitNot {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalBitNotPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalBitNot> for SyntaxStablePtrId {
    fn from(node: &TerminalBitNot) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenOr {
    node: SyntaxNode,
}
impl Token for TokenOr {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenOr,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOrPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenOrPtr {
    type SyntaxNode = TokenOr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenOr {
        TokenOr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenOrPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenOrPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOrGreen(pub GreenId);
impl TokenOrGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenOr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenOr);
    type StablePtr = TokenOrPtr;
    type Green = TokenOrGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenOr)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenOrPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenOr> for SyntaxStablePtrId {
    fn from(node: &TokenOr) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalOr {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalOr {
    const KIND: SyntaxKind = SyntaxKind::TerminalOr;
    type TokenType = TokenOr;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalOr as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalOr {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenOr {
        TokenOr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOrPtr(pub SyntaxStablePtrId);
impl TerminalOrPtr {}
impl TypedStablePtr for TerminalOrPtr {
    type SyntaxNode = TerminalOr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalOr {
        TerminalOr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalOrPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalOrPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOrGreen(pub GreenId);
impl TypedSyntaxNode for TerminalOr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalOr);
    type StablePtr = TerminalOrPtr;
    type Green = TerminalOrGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOr,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenOr::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalOr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalOr
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalOr { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalOrPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalOr> for SyntaxStablePtrId {
    fn from(node: &TerminalOr) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenOrOr {
    node: SyntaxNode,
}
impl Token for TokenOrOr {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenOrOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenOrOr,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOrOrPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenOrOrPtr {
    type SyntaxNode = TokenOrOr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenOrOr {
        TokenOrOr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenOrOrPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenOrOrPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenOrOrGreen(pub GreenId);
impl TokenOrOrGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenOrOr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenOrOr);
    type StablePtr = TokenOrOrPtr;
    type Green = TokenOrOrGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenOrOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenOrOr)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenOrOrPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenOrOr> for SyntaxStablePtrId {
    fn from(node: &TokenOrOr) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalOrOr {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalOrOr {
    const KIND: SyntaxKind = SyntaxKind::TerminalOrOr;
    type TokenType = TokenOrOr;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalOrOr as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalOrOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOrOr,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalOrOr {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenOrOr {
        TokenOrOr::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOrOrPtr(pub SyntaxStablePtrId);
impl TerminalOrOrPtr {}
impl TypedStablePtr for TerminalOrOrPtr {
    type SyntaxNode = TerminalOrOr;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalOrOr {
        TerminalOrOr::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalOrOrPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalOrOrPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalOrOrGreen(pub GreenId);
impl TypedSyntaxNode for TerminalOrOr {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalOrOr);
    type StablePtr = TerminalOrOrPtr;
    type Green = TerminalOrOrGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalOrOrGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalOrOr,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenOrOr::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalOrOr,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalOrOr
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalOrOr { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalOrOrPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalOrOr> for SyntaxStablePtrId {
    fn from(node: &TerminalOrOr) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenPlus {
    node: SyntaxNode,
}
impl Token for TokenPlus {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenPlusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenPlus,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenPlusPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenPlusPtr {
    type SyntaxNode = TokenPlus;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenPlus {
        TokenPlus::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenPlusPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenPlusPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenPlusGreen(pub GreenId);
impl TokenPlusGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenPlus {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenPlus);
    type StablePtr = TokenPlusPtr;
    type Green = TokenPlusGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenPlusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenPlus)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenPlusPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenPlus> for SyntaxStablePtrId {
    fn from(node: &TokenPlus) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalPlus {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalPlus {
    const KIND: SyntaxKind = SyntaxKind::TerminalPlus;
    type TokenType = TokenPlus;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalPlus as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalPlusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPlus,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalPlus {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenPlus {
        TokenPlus::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalPlusPtr(pub SyntaxStablePtrId);
impl TerminalPlusPtr {}
impl TypedStablePtr for TerminalPlusPtr {
    type SyntaxNode = TerminalPlus;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalPlus {
        TerminalPlus::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalPlusPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalPlusPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalPlusGreen(pub GreenId);
impl TypedSyntaxNode for TerminalPlus {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalPlus);
    type StablePtr = TerminalPlusPtr;
    type Green = TerminalPlusGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalPlusGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPlus,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenPlus::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalPlus,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalPlus
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalPlus { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalPlusPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalPlus> for SyntaxStablePtrId {
    fn from(node: &TerminalPlus) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenPlusEq {
    node: SyntaxNode,
}
impl Token for TokenPlusEq {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenPlusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenPlusEq,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenPlusEqPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenPlusEqPtr {
    type SyntaxNode = TokenPlusEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenPlusEq {
        TokenPlusEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenPlusEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenPlusEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenPlusEqGreen(pub GreenId);
impl TokenPlusEqGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenPlusEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenPlusEq);
    type StablePtr = TokenPlusEqPtr;
    type Green = TokenPlusEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenPlusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenPlusEq)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenPlusEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenPlusEq> for SyntaxStablePtrId {
    fn from(node: &TokenPlusEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalPlusEq {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalPlusEq {
    const KIND: SyntaxKind = SyntaxKind::TerminalPlusEq;
    type TokenType = TokenPlusEq;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalPlusEq as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalPlusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPlusEq,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalPlusEq {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenPlusEq {
        TokenPlusEq::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalPlusEqPtr(pub SyntaxStablePtrId);
impl TerminalPlusEqPtr {}
impl TypedStablePtr for TerminalPlusEqPtr {
    type SyntaxNode = TerminalPlusEq;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalPlusEq {
        TerminalPlusEq::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalPlusEqPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalPlusEqPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalPlusEqGreen(pub GreenId);
impl TypedSyntaxNode for TerminalPlusEq {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalPlusEq);
    type StablePtr = TerminalPlusEqPtr;
    type Green = TerminalPlusEqGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalPlusEqGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalPlusEq,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenPlusEq::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalPlusEq,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalPlusEq
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalPlusEq {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalPlusEqPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalPlusEq> for SyntaxStablePtrId {
    fn from(node: &TerminalPlusEq) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenQuestionMark {
    node: SyntaxNode,
}
impl Token for TokenQuestionMark {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenQuestionMarkGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenQuestionMark,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenQuestionMarkPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenQuestionMarkPtr {
    type SyntaxNode = TokenQuestionMark;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenQuestionMark {
        TokenQuestionMark::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenQuestionMarkPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenQuestionMarkPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenQuestionMarkGreen(pub GreenId);
impl TokenQuestionMarkGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenQuestionMark {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenQuestionMark);
    type StablePtr = TokenQuestionMarkPtr;
    type Green = TokenQuestionMarkGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenQuestionMarkGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenQuestionMark)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenQuestionMarkPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenQuestionMark> for SyntaxStablePtrId {
    fn from(node: &TokenQuestionMark) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalQuestionMark {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalQuestionMark {
    const KIND: SyntaxKind = SyntaxKind::TerminalQuestionMark;
    type TokenType = TokenQuestionMark;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalQuestionMark as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalQuestionMarkGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalQuestionMark,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalQuestionMark {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenQuestionMark {
        TokenQuestionMark::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalQuestionMarkPtr(pub SyntaxStablePtrId);
impl TerminalQuestionMarkPtr {}
impl TypedStablePtr for TerminalQuestionMarkPtr {
    type SyntaxNode = TerminalQuestionMark;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalQuestionMark {
        TerminalQuestionMark::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalQuestionMarkPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalQuestionMarkPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalQuestionMarkGreen(pub GreenId);
impl TypedSyntaxNode for TerminalQuestionMark {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalQuestionMark);
    type StablePtr = TerminalQuestionMarkPtr;
    type Green = TerminalQuestionMarkGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalQuestionMarkGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalQuestionMark,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenQuestionMark::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalQuestionMark,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalQuestionMark
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalQuestionMark {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalQuestionMarkPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalQuestionMark> for SyntaxStablePtrId {
    fn from(node: &TerminalQuestionMark) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenRBrace {
    node: SyntaxNode,
}
impl Token for TokenRBrace {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenRBrace,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRBracePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenRBracePtr {
    type SyntaxNode = TokenRBrace;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenRBrace {
        TokenRBrace::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenRBracePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenRBracePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRBraceGreen(pub GreenId);
impl TokenRBraceGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenRBrace {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRBrace);
    type StablePtr = TokenRBracePtr;
    type Green = TokenRBraceGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenRBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRBrace)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenRBracePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenRBrace> for SyntaxStablePtrId {
    fn from(node: &TokenRBrace) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalRBrace {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalRBrace {
    const KIND: SyntaxKind = SyntaxKind::TerminalRBrace;
    type TokenType = TokenRBrace;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalRBrace as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalRBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRBrace,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalRBrace {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenRBrace {
        TokenRBrace::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRBracePtr(pub SyntaxStablePtrId);
impl TerminalRBracePtr {}
impl TypedStablePtr for TerminalRBracePtr {
    type SyntaxNode = TerminalRBrace;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalRBrace {
        TerminalRBrace::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalRBracePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalRBracePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRBraceGreen(pub GreenId);
impl TypedSyntaxNode for TerminalRBrace {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRBrace);
    type StablePtr = TerminalRBracePtr;
    type Green = TerminalRBraceGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalRBraceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRBrace,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenRBrace::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRBrace,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRBrace
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalRBrace {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalRBracePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalRBrace> for SyntaxStablePtrId {
    fn from(node: &TerminalRBrace) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenRBrack {
    node: SyntaxNode,
}
impl Token for TokenRBrack {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenRBrack,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRBrackPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenRBrackPtr {
    type SyntaxNode = TokenRBrack;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenRBrack {
        TokenRBrack::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenRBrackPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenRBrackPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRBrackGreen(pub GreenId);
impl TokenRBrackGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenRBrack {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRBrack);
    type StablePtr = TokenRBrackPtr;
    type Green = TokenRBrackGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenRBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRBrack)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenRBrackPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenRBrack> for SyntaxStablePtrId {
    fn from(node: &TokenRBrack) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalRBrack {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalRBrack {
    const KIND: SyntaxKind = SyntaxKind::TerminalRBrack;
    type TokenType = TokenRBrack;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalRBrack as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalRBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRBrack,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalRBrack {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenRBrack {
        TokenRBrack::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRBrackPtr(pub SyntaxStablePtrId);
impl TerminalRBrackPtr {}
impl TypedStablePtr for TerminalRBrackPtr {
    type SyntaxNode = TerminalRBrack;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalRBrack {
        TerminalRBrack::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalRBrackPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalRBrackPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRBrackGreen(pub GreenId);
impl TypedSyntaxNode for TerminalRBrack {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRBrack);
    type StablePtr = TerminalRBrackPtr;
    type Green = TerminalRBrackGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalRBrackGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRBrack,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenRBrack::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRBrack,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRBrack
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalRBrack {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalRBrackPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalRBrack> for SyntaxStablePtrId {
    fn from(node: &TerminalRBrack) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenRParen {
    node: SyntaxNode,
}
impl Token for TokenRParen {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenRParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenRParen,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRParenPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenRParenPtr {
    type SyntaxNode = TokenRParen;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenRParen {
        TokenRParen::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenRParenPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenRParenPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenRParenGreen(pub GreenId);
impl TokenRParenGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenRParen {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenRParen);
    type StablePtr = TokenRParenPtr;
    type Green = TokenRParenGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenRParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenRParen)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenRParenPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenRParen> for SyntaxStablePtrId {
    fn from(node: &TokenRParen) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalRParen {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalRParen {
    const KIND: SyntaxKind = SyntaxKind::TerminalRParen;
    type TokenType = TokenRParen;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalRParen as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalRParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRParen,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalRParen {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenRParen {
        TokenRParen::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRParenPtr(pub SyntaxStablePtrId);
impl TerminalRParenPtr {}
impl TypedStablePtr for TerminalRParenPtr {
    type SyntaxNode = TerminalRParen;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalRParen {
        TerminalRParen::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalRParenPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalRParenPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalRParenGreen(pub GreenId);
impl TypedSyntaxNode for TerminalRParen {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalRParen);
    type StablePtr = TerminalRParenPtr;
    type Green = TerminalRParenGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalRParenGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalRParen,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenRParen::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalRParen,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalRParen
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalRParen {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalRParenPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalRParen> for SyntaxStablePtrId {
    fn from(node: &TerminalRParen) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenSemicolon {
    node: SyntaxNode,
}
impl Token for TokenSemicolon {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSemicolonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenSemicolon,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSemicolonPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenSemicolonPtr {
    type SyntaxNode = TokenSemicolon;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenSemicolon {
        TokenSemicolon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenSemicolonPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenSemicolonPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSemicolonGreen(pub GreenId);
impl TokenSemicolonGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenSemicolon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSemicolon);
    type StablePtr = TokenSemicolonPtr;
    type Green = TokenSemicolonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenSemicolonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenSemicolon)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenSemicolonPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenSemicolon> for SyntaxStablePtrId {
    fn from(node: &TokenSemicolon) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalSemicolon {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalSemicolon {
    const KIND: SyntaxKind = SyntaxKind::TerminalSemicolon;
    type TokenType = TokenSemicolon;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalSemicolon as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalSemicolonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalSemicolon,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalSemicolon {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenSemicolon {
        TokenSemicolon::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalSemicolonPtr(pub SyntaxStablePtrId);
impl TerminalSemicolonPtr {}
impl TypedStablePtr for TerminalSemicolonPtr {
    type SyntaxNode = TerminalSemicolon;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalSemicolon {
        TerminalSemicolon::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalSemicolonPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalSemicolonPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalSemicolonGreen(pub GreenId);
impl TypedSyntaxNode for TerminalSemicolon {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalSemicolon);
    type StablePtr = TerminalSemicolonPtr;
    type Green = TerminalSemicolonGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalSemicolonGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalSemicolon,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenSemicolon::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalSemicolon,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalSemicolon
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalSemicolon {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalSemicolonPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalSemicolon> for SyntaxStablePtrId {
    fn from(node: &TerminalSemicolon) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenUnderscore {
    node: SyntaxNode,
}
impl Token for TokenUnderscore {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenUnderscoreGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenUnderscore,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenUnderscorePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenUnderscorePtr {
    type SyntaxNode = TokenUnderscore;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenUnderscore {
        TokenUnderscore::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenUnderscorePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenUnderscorePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenUnderscoreGreen(pub GreenId);
impl TokenUnderscoreGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenUnderscore {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenUnderscore);
    type StablePtr = TokenUnderscorePtr;
    type Green = TokenUnderscoreGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenUnderscoreGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenUnderscore)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenUnderscorePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenUnderscore> for SyntaxStablePtrId {
    fn from(node: &TokenUnderscore) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalUnderscore {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalUnderscore {
    const KIND: SyntaxKind = SyntaxKind::TerminalUnderscore;
    type TokenType = TokenUnderscore;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalUnderscore as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalUnderscoreGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalUnderscore,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalUnderscore {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenUnderscore {
        TokenUnderscore::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalUnderscorePtr(pub SyntaxStablePtrId);
impl TerminalUnderscorePtr {}
impl TypedStablePtr for TerminalUnderscorePtr {
    type SyntaxNode = TerminalUnderscore;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalUnderscore {
        TerminalUnderscore::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalUnderscorePtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalUnderscorePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalUnderscoreGreen(pub GreenId);
impl TypedSyntaxNode for TerminalUnderscore {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalUnderscore);
    type StablePtr = TerminalUnderscorePtr;
    type Green = TerminalUnderscoreGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalUnderscoreGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalUnderscore,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenUnderscore::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalUnderscore,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalUnderscore
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalUnderscore {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalUnderscorePtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalUnderscore> for SyntaxStablePtrId {
    fn from(node: &TerminalUnderscore) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenXor {
    node: SyntaxNode,
}
impl Token for TokenXor {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenXorGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenXor,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenXorPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenXorPtr {
    type SyntaxNode = TokenXor;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenXor {
        TokenXor::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenXorPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenXorPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenXorGreen(pub GreenId);
impl TokenXorGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenXor {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenXor);
    type StablePtr = TokenXorPtr;
    type Green = TokenXorGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenXorGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenXor)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenXorPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenXor> for SyntaxStablePtrId {
    fn from(node: &TokenXor) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalXor {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalXor {
    const KIND: SyntaxKind = SyntaxKind::TerminalXor;
    type TokenType = TokenXor;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalXor as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalXorGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalXor,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalXor {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenXor {
        TokenXor::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalXorPtr(pub SyntaxStablePtrId);
impl TerminalXorPtr {}
impl TypedStablePtr for TerminalXorPtr {
    type SyntaxNode = TerminalXor;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalXor {
        TerminalXor::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalXorPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalXorPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalXorGreen(pub GreenId);
impl TypedSyntaxNode for TerminalXor {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalXor);
    type StablePtr = TerminalXorPtr;
    type Green = TerminalXorGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalXorGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalXor,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenXor::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalXor,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalXor
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalXor { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalXorPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalXor> for SyntaxStablePtrId {
    fn from(node: &TerminalXor) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct SyntaxFile {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl SyntaxFile {
    pub const INDEX_ITEMS: usize = 0;
    pub const INDEX_EOF: usize = 1;
    pub fn new_green(
        db: &dyn SyntaxGroup,
        items: ModuleItemListGreen,
        eof: TerminalEndOfFileGreen,
    ) -> SyntaxFileGreen {
        let children: Vec<GreenId> = vec![items.0, eof.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        SyntaxFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::SyntaxFile,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
}
impl SyntaxFile {
    pub fn items(&self, db: &dyn SyntaxGroup) -> ModuleItemList {
        ModuleItemList::from_syntax_node(db, self.children[0].clone())
    }
    pub fn eof(&self, db: &dyn SyntaxGroup) -> TerminalEndOfFile {
        TerminalEndOfFile::from_syntax_node(db, self.children[1].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct SyntaxFilePtr(pub SyntaxStablePtrId);
impl SyntaxFilePtr {}
impl TypedStablePtr for SyntaxFilePtr {
    type SyntaxNode = SyntaxFile;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> SyntaxFile {
        SyntaxFile::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<SyntaxFilePtr> for SyntaxStablePtrId {
    fn from(ptr: SyntaxFilePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct SyntaxFileGreen(pub GreenId);
impl TypedSyntaxNode for SyntaxFile {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::SyntaxFile);
    type StablePtr = SyntaxFilePtr;
    type Green = SyntaxFileGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        SyntaxFileGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::SyntaxFile,
                details: GreenNodeDetails::Node {
                    children: vec![ModuleItemList::missing(db).0, TerminalEndOfFile::missing(db).0],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::SyntaxFile,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::SyntaxFile
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::SyntaxFile { Some(Self::from_syntax_node(db, node)) } else { None }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        SyntaxFilePtr(self.node.0.stable_ptr)
    }
}
impl From<&SyntaxFile> for SyntaxStablePtrId {
    fn from(node: &SyntaxFile) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenEmpty {
    node: SyntaxNode,
}
impl Token for TokenEmpty {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenEmpty,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEmptyPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenEmptyPtr {
    type SyntaxNode = TokenEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenEmpty {
        TokenEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenEmptyGreen(pub GreenId);
impl TokenEmptyGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenEmpty);
    type StablePtr = TokenEmptyPtr;
    type Green = TokenEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenEmpty)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenEmpty> for SyntaxStablePtrId {
    fn from(node: &TokenEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TerminalEmpty {
    node: SyntaxNode,
    children: Arc<[SyntaxNode]>,
}
impl Terminal for TerminalEmpty {
    const KIND: SyntaxKind = SyntaxKind::TerminalEmpty;
    type TokenType = TokenEmpty;
    fn new_green(
        db: &dyn SyntaxGroup,
        leading_trivia: TriviaGreen,
        token: <<TerminalEmpty as Terminal>::TokenType as TypedSyntaxNode>::Green,
        trailing_trivia: TriviaGreen,
    ) -> Self::Green {
        let children: Vec<GreenId> = vec![leading_trivia.0, token.0, trailing_trivia.0];
        let width = children.iter().copied().map(|id| id.lookup_intern(db).width()).sum();
        TerminalEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEmpty,
                details: GreenNodeDetails::Node { children, width },
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        self.token(db).text(db)
    }
}
impl TerminalEmpty {
    pub fn leading_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[0].clone())
    }
    pub fn token(&self, db: &dyn SyntaxGroup) -> TokenEmpty {
        TokenEmpty::from_syntax_node(db, self.children[1].clone())
    }
    pub fn trailing_trivia(&self, db: &dyn SyntaxGroup) -> Trivia {
        Trivia::from_syntax_node(db, self.children[2].clone())
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEmptyPtr(pub SyntaxStablePtrId);
impl TerminalEmptyPtr {}
impl TypedStablePtr for TerminalEmptyPtr {
    type SyntaxNode = TerminalEmpty;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TerminalEmpty {
        TerminalEmpty::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TerminalEmptyPtr> for SyntaxStablePtrId {
    fn from(ptr: TerminalEmptyPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TerminalEmptyGreen(pub GreenId);
impl TypedSyntaxNode for TerminalEmpty {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TerminalEmpty);
    type StablePtr = TerminalEmptyPtr;
    type Green = TerminalEmptyGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TerminalEmptyGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TerminalEmpty,
                details: GreenNodeDetails::Node {
                    children: vec![
                        Trivia::missing(db).0,
                        TokenEmpty::missing(db).0,
                        Trivia::missing(db).0,
                    ],
                    width: TextWidth::default(),
                },
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        assert_eq!(
            kind,
            SyntaxKind::TerminalEmpty,
            "Unexpected SyntaxKind {:?}. Expected {:?}.",
            kind,
            SyntaxKind::TerminalEmpty
        );
        let children = db.get_children(node.clone());
        Self { node, children }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        if kind == SyntaxKind::TerminalEmpty {
            Some(Self::from_syntax_node(db, node))
        } else {
            None
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TerminalEmptyPtr(self.node.0.stable_ptr)
    }
}
impl From<&TerminalEmpty> for SyntaxStablePtrId {
    fn from(node: &TerminalEmpty) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenSingleLineComment {
    node: SyntaxNode,
}
impl Token for TokenSingleLineComment {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSingleLineCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenSingleLineComment,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSingleLineCommentPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenSingleLineCommentPtr {
    type SyntaxNode = TokenSingleLineComment;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenSingleLineComment {
        TokenSingleLineComment::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenSingleLineCommentPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenSingleLineCommentPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSingleLineCommentGreen(pub GreenId);
impl TokenSingleLineCommentGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenSingleLineComment {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSingleLineComment);
    type StablePtr = TokenSingleLineCommentPtr;
    type Green = TokenSingleLineCommentGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenSingleLineCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenSingleLineComment
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenSingleLineCommentPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenSingleLineComment> for SyntaxStablePtrId {
    fn from(node: &TokenSingleLineComment) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenSingleLineInnerComment {
    node: SyntaxNode,
}
impl Token for TokenSingleLineInnerComment {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSingleLineInnerCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenSingleLineInnerComment,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSingleLineInnerCommentPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenSingleLineInnerCommentPtr {
    type SyntaxNode = TokenSingleLineInnerComment;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenSingleLineInnerComment {
        TokenSingleLineInnerComment::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenSingleLineInnerCommentPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenSingleLineInnerCommentPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSingleLineInnerCommentGreen(pub GreenId);
impl TokenSingleLineInnerCommentGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenSingleLineInnerComment {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSingleLineInnerComment);
    type StablePtr = TokenSingleLineInnerCommentPtr;
    type Green = TokenSingleLineInnerCommentGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenSingleLineInnerCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenSingleLineInnerComment
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenSingleLineInnerCommentPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenSingleLineInnerComment> for SyntaxStablePtrId {
    fn from(node: &TokenSingleLineInnerComment) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenSingleLineDocComment {
    node: SyntaxNode,
}
impl Token for TokenSingleLineDocComment {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSingleLineDocCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenSingleLineDocComment,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSingleLineDocCommentPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenSingleLineDocCommentPtr {
    type SyntaxNode = TokenSingleLineDocComment;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenSingleLineDocComment {
        TokenSingleLineDocComment::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenSingleLineDocCommentPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenSingleLineDocCommentPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSingleLineDocCommentGreen(pub GreenId);
impl TokenSingleLineDocCommentGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenSingleLineDocComment {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSingleLineDocComment);
    type StablePtr = TokenSingleLineDocCommentPtr;
    type Green = TokenSingleLineDocCommentGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenSingleLineDocCommentGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => panic!(
                "Expected a token {:?}, not an internal node",
                SyntaxKind::TokenSingleLineDocComment
            ),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenSingleLineDocCommentPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenSingleLineDocComment> for SyntaxStablePtrId {
    fn from(node: &TokenSingleLineDocComment) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenWhitespace {
    node: SyntaxNode,
}
impl Token for TokenWhitespace {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenWhitespaceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenWhitespace,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenWhitespacePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenWhitespacePtr {
    type SyntaxNode = TokenWhitespace;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenWhitespace {
        TokenWhitespace::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenWhitespacePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenWhitespacePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenWhitespaceGreen(pub GreenId);
impl TokenWhitespaceGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenWhitespace {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenWhitespace);
    type StablePtr = TokenWhitespacePtr;
    type Green = TokenWhitespaceGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenWhitespaceGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenWhitespace)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenWhitespacePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenWhitespace> for SyntaxStablePtrId {
    fn from(node: &TokenWhitespace) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenNewline {
    node: SyntaxNode,
}
impl Token for TokenNewline {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenNewlineGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenNewline,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNewlinePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenNewlinePtr {
    type SyntaxNode = TokenNewline;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenNewline {
        TokenNewline::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenNewlinePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenNewlinePtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNewlineGreen(pub GreenId);
impl TokenNewlineGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenNewline {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenNewline);
    type StablePtr = TokenNewlinePtr;
    type Green = TokenNewlineGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenNewlineGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenNewline)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenNewlinePtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenNewline> for SyntaxStablePtrId {
    fn from(node: &TokenNewline) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenMissing {
    node: SyntaxNode,
}
impl Token for TokenMissing {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMissingPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenMissingPtr {
    type SyntaxNode = TokenMissing;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenMissing {
        TokenMissing::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenMissingPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenMissingPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenMissingGreen(pub GreenId);
impl TokenMissingGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenMissing {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenMissing);
    type StablePtr = TokenMissingPtr;
    type Green = TokenMissingGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenMissingGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenMissing)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenMissingPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenMissing> for SyntaxStablePtrId {
    fn from(node: &TokenMissing) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TokenSkipped {
    node: SyntaxNode,
}
impl Token for TokenSkipped {
    fn new_green(db: &dyn SyntaxGroup, text: SmolStr) -> Self::Green {
        TokenSkippedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenSkipped,
                details: GreenNodeDetails::Token(text),
            })
            .intern(db),
        )
    }
    fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.node.0.green.lookup_intern(db).details, GreenNodeDetails::Token)
            .clone()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSkippedPtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenSkippedPtr {
    type SyntaxNode = TokenSkipped;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenSkipped {
        TokenSkipped::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenSkippedPtr> for SyntaxStablePtrId {
    fn from(ptr: TokenSkippedPtr) -> Self {
        ptr.untyped()
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenSkippedGreen(pub GreenId);
impl TokenSkippedGreen {
    pub fn text(&self, db: &dyn SyntaxGroup) -> SmolStr {
        extract_matches!(&self.0.lookup_intern(db).details, GreenNodeDetails::Token).clone()
    }
}
impl TypedSyntaxNode for TokenSkipped {
    const OPTIONAL_KIND: Option<SyntaxKind> = Some(SyntaxKind::TokenSkipped);
    type StablePtr = TokenSkippedPtr;
    type Green = TokenSkippedGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        TokenSkippedGreen(
            Arc::new(GreenNode {
                kind: SyntaxKind::TokenMissing,
                details: GreenNodeDetails::Token("".into()),
            })
            .intern(db),
        )
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Self { node },
            GreenNodeDetails::Node { .. } => {
                panic!("Expected a token {:?}, not an internal node", SyntaxKind::TokenSkipped)
            }
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        match node.0.green.lookup_intern(db).details {
            GreenNodeDetails::Token(_) => Some(Self { node }),
            GreenNodeDetails::Node { .. } => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        self.node.clone()
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenSkippedPtr(self.node.0.stable_ptr)
    }
}
impl From<&TokenSkipped> for SyntaxStablePtrId {
    fn from(node: &TokenSkipped) -> Self {
        node.stable_ptr().untyped()
    }
}
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum TokenNode {
    TerminalIdentifier(TerminalIdentifier),
    TerminalLiteralNumber(TerminalLiteralNumber),
    TerminalShortString(TerminalShortString),
    TerminalString(TerminalString),
    TerminalAs(TerminalAs),
    TerminalConst(TerminalConst),
    TerminalElse(TerminalElse),
    TerminalEnum(TerminalEnum),
    TerminalExtern(TerminalExtern),
    TerminalFalse(TerminalFalse),
    TerminalFunction(TerminalFunction),
    TerminalIf(TerminalIf),
    TerminalWhile(TerminalWhile),
    TerminalFor(TerminalFor),
    TerminalLoop(TerminalLoop),
    TerminalImpl(TerminalImpl),
    TerminalImplicits(TerminalImplicits),
    TerminalLet(TerminalLet),
    TerminalMatch(TerminalMatch),
    TerminalModule(TerminalModule),
    TerminalMut(TerminalMut),
    TerminalNoPanic(TerminalNoPanic),
    TerminalOf(TerminalOf),
    TerminalRef(TerminalRef),
    TerminalContinue(TerminalContinue),
    TerminalReturn(TerminalReturn),
    TerminalBreak(TerminalBreak),
    TerminalStruct(TerminalStruct),
    TerminalTrait(TerminalTrait),
    TerminalTrue(TerminalTrue),
    TerminalType(TerminalType),
    TerminalUse(TerminalUse),
    TerminalPub(TerminalPub),
    TerminalAnd(TerminalAnd),
    TerminalAndAnd(TerminalAndAnd),
    TerminalArrow(TerminalArrow),
    TerminalAt(TerminalAt),
    TerminalBadCharacters(TerminalBadCharacters),
    TerminalColon(TerminalColon),
    TerminalColonColon(TerminalColonColon),
    TerminalComma(TerminalComma),
    TerminalDiv(TerminalDiv),
    TerminalDivEq(TerminalDivEq),
    TerminalDot(TerminalDot),
    TerminalDotDot(TerminalDotDot),
    TerminalDotDotEq(TerminalDotDotEq),
    TerminalEndOfFile(TerminalEndOfFile),
    TerminalEq(TerminalEq),
    TerminalEqEq(TerminalEqEq),
    TerminalGE(TerminalGE),
    TerminalGT(TerminalGT),
    TerminalHash(TerminalHash),
    TerminalLBrace(TerminalLBrace),
    TerminalLBrack(TerminalLBrack),
    TerminalLE(TerminalLE),
    TerminalLParen(TerminalLParen),
    TerminalLT(TerminalLT),
    TerminalMatchArrow(TerminalMatchArrow),
    TerminalMinus(TerminalMinus),
    TerminalMinusEq(TerminalMinusEq),
    TerminalMod(TerminalMod),
    TerminalModEq(TerminalModEq),
    TerminalMul(TerminalMul),
    TerminalMulEq(TerminalMulEq),
    TerminalNeq(TerminalNeq),
    TerminalNot(TerminalNot),
    TerminalBitNot(TerminalBitNot),
    TerminalOr(TerminalOr),
    TerminalOrOr(TerminalOrOr),
    TerminalPlus(TerminalPlus),
    TerminalPlusEq(TerminalPlusEq),
    TerminalQuestionMark(TerminalQuestionMark),
    TerminalRBrace(TerminalRBrace),
    TerminalRBrack(TerminalRBrack),
    TerminalRParen(TerminalRParen),
    TerminalSemicolon(TerminalSemicolon),
    TerminalUnderscore(TerminalUnderscore),
    TerminalXor(TerminalXor),
    TerminalEmpty(TerminalEmpty),
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNodePtr(pub SyntaxStablePtrId);
impl TypedStablePtr for TokenNodePtr {
    type SyntaxNode = TokenNode;
    fn untyped(&self) -> SyntaxStablePtrId {
        self.0
    }
    fn lookup(&self, db: &dyn SyntaxGroup) -> TokenNode {
        TokenNode::from_syntax_node(db, self.0.lookup(db))
    }
}
impl From<TokenNodePtr> for SyntaxStablePtrId {
    fn from(ptr: TokenNodePtr) -> Self {
        ptr.untyped()
    }
}
impl From<TerminalIdentifierPtr> for TokenNodePtr {
    fn from(value: TerminalIdentifierPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLiteralNumberPtr> for TokenNodePtr {
    fn from(value: TerminalLiteralNumberPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalShortStringPtr> for TokenNodePtr {
    fn from(value: TerminalShortStringPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalStringPtr> for TokenNodePtr {
    fn from(value: TerminalStringPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAsPtr> for TokenNodePtr {
    fn from(value: TerminalAsPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalConstPtr> for TokenNodePtr {
    fn from(value: TerminalConstPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalElsePtr> for TokenNodePtr {
    fn from(value: TerminalElsePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEnumPtr> for TokenNodePtr {
    fn from(value: TerminalEnumPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalExternPtr> for TokenNodePtr {
    fn from(value: TerminalExternPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalFalsePtr> for TokenNodePtr {
    fn from(value: TerminalFalsePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalFunctionPtr> for TokenNodePtr {
    fn from(value: TerminalFunctionPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalIfPtr> for TokenNodePtr {
    fn from(value: TerminalIfPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalWhilePtr> for TokenNodePtr {
    fn from(value: TerminalWhilePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalForPtr> for TokenNodePtr {
    fn from(value: TerminalForPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLoopPtr> for TokenNodePtr {
    fn from(value: TerminalLoopPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalImplPtr> for TokenNodePtr {
    fn from(value: TerminalImplPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalImplicitsPtr> for TokenNodePtr {
    fn from(value: TerminalImplicitsPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLetPtr> for TokenNodePtr {
    fn from(value: TerminalLetPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMatchPtr> for TokenNodePtr {
    fn from(value: TerminalMatchPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModulePtr> for TokenNodePtr {
    fn from(value: TerminalModulePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMutPtr> for TokenNodePtr {
    fn from(value: TerminalMutPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNoPanicPtr> for TokenNodePtr {
    fn from(value: TerminalNoPanicPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOfPtr> for TokenNodePtr {
    fn from(value: TerminalOfPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalRefPtr> for TokenNodePtr {
    fn from(value: TerminalRefPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalContinuePtr> for TokenNodePtr {
    fn from(value: TerminalContinuePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalReturnPtr> for TokenNodePtr {
    fn from(value: TerminalReturnPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalBreakPtr> for TokenNodePtr {
    fn from(value: TerminalBreakPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalStructPtr> for TokenNodePtr {
    fn from(value: TerminalStructPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTraitPtr> for TokenNodePtr {
    fn from(value: TerminalTraitPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTruePtr> for TokenNodePtr {
    fn from(value: TerminalTruePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTypePtr> for TokenNodePtr {
    fn from(value: TerminalTypePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalUsePtr> for TokenNodePtr {
    fn from(value: TerminalUsePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPubPtr> for TokenNodePtr {
    fn from(value: TerminalPubPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAndPtr> for TokenNodePtr {
    fn from(value: TerminalAndPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAndAndPtr> for TokenNodePtr {
    fn from(value: TerminalAndAndPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalArrowPtr> for TokenNodePtr {
    fn from(value: TerminalArrowPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAtPtr> for TokenNodePtr {
    fn from(value: TerminalAtPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalBadCharactersPtr> for TokenNodePtr {
    fn from(value: TerminalBadCharactersPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalColonPtr> for TokenNodePtr {
    fn from(value: TerminalColonPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalColonColonPtr> for TokenNodePtr {
    fn from(value: TerminalColonColonPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalCommaPtr> for TokenNodePtr {
    fn from(value: TerminalCommaPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDivPtr> for TokenNodePtr {
    fn from(value: TerminalDivPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDivEqPtr> for TokenNodePtr {
    fn from(value: TerminalDivEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotPtr> for TokenNodePtr {
    fn from(value: TerminalDotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotPtr> for TokenNodePtr {
    fn from(value: TerminalDotDotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotEqPtr> for TokenNodePtr {
    fn from(value: TerminalDotDotEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEndOfFilePtr> for TokenNodePtr {
    fn from(value: TerminalEndOfFilePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqPtr> for TokenNodePtr {
    fn from(value: TerminalEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqEqPtr> for TokenNodePtr {
    fn from(value: TerminalEqEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGEPtr> for TokenNodePtr {
    fn from(value: TerminalGEPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGTPtr> for TokenNodePtr {
    fn from(value: TerminalGTPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalHashPtr> for TokenNodePtr {
    fn from(value: TerminalHashPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLBracePtr> for TokenNodePtr {
    fn from(value: TerminalLBracePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLBrackPtr> for TokenNodePtr {
    fn from(value: TerminalLBrackPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLEPtr> for TokenNodePtr {
    fn from(value: TerminalLEPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLParenPtr> for TokenNodePtr {
    fn from(value: TerminalLParenPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLTPtr> for TokenNodePtr {
    fn from(value: TerminalLTPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMatchArrowPtr> for TokenNodePtr {
    fn from(value: TerminalMatchArrowPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusPtr> for TokenNodePtr {
    fn from(value: TerminalMinusPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusEqPtr> for TokenNodePtr {
    fn from(value: TerminalMinusEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModPtr> for TokenNodePtr {
    fn from(value: TerminalModPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModEqPtr> for TokenNodePtr {
    fn from(value: TerminalModEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulPtr> for TokenNodePtr {
    fn from(value: TerminalMulPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulEqPtr> for TokenNodePtr {
    fn from(value: TerminalMulEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNeqPtr> for TokenNodePtr {
    fn from(value: TerminalNeqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNotPtr> for TokenNodePtr {
    fn from(value: TerminalNotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalBitNotPtr> for TokenNodePtr {
    fn from(value: TerminalBitNotPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrPtr> for TokenNodePtr {
    fn from(value: TerminalOrPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrOrPtr> for TokenNodePtr {
    fn from(value: TerminalOrOrPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPlusPtr> for TokenNodePtr {
    fn from(value: TerminalPlusPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPlusEqPtr> for TokenNodePtr {
    fn from(value: TerminalPlusEqPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalQuestionMarkPtr> for TokenNodePtr {
    fn from(value: TerminalQuestionMarkPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalRBracePtr> for TokenNodePtr {
    fn from(value: TerminalRBracePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalRBrackPtr> for TokenNodePtr {
    fn from(value: TerminalRBrackPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalRParenPtr> for TokenNodePtr {
    fn from(value: TerminalRParenPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonPtr> for TokenNodePtr {
    fn from(value: TerminalSemicolonPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalUnderscorePtr> for TokenNodePtr {
    fn from(value: TerminalUnderscorePtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalXorPtr> for TokenNodePtr {
    fn from(value: TerminalXorPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEmptyPtr> for TokenNodePtr {
    fn from(value: TerminalEmptyPtr) -> Self {
        Self(value.0)
    }
}
impl From<TerminalIdentifierGreen> for TokenNodeGreen {
    fn from(value: TerminalIdentifierGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLiteralNumberGreen> for TokenNodeGreen {
    fn from(value: TerminalLiteralNumberGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalShortStringGreen> for TokenNodeGreen {
    fn from(value: TerminalShortStringGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalStringGreen> for TokenNodeGreen {
    fn from(value: TerminalStringGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAsGreen> for TokenNodeGreen {
    fn from(value: TerminalAsGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalConstGreen> for TokenNodeGreen {
    fn from(value: TerminalConstGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalElseGreen> for TokenNodeGreen {
    fn from(value: TerminalElseGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEnumGreen> for TokenNodeGreen {
    fn from(value: TerminalEnumGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalExternGreen> for TokenNodeGreen {
    fn from(value: TerminalExternGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalFalseGreen> for TokenNodeGreen {
    fn from(value: TerminalFalseGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalFunctionGreen> for TokenNodeGreen {
    fn from(value: TerminalFunctionGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalIfGreen> for TokenNodeGreen {
    fn from(value: TerminalIfGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalWhileGreen> for TokenNodeGreen {
    fn from(value: TerminalWhileGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalForGreen> for TokenNodeGreen {
    fn from(value: TerminalForGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLoopGreen> for TokenNodeGreen {
    fn from(value: TerminalLoopGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalImplGreen> for TokenNodeGreen {
    fn from(value: TerminalImplGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalImplicitsGreen> for TokenNodeGreen {
    fn from(value: TerminalImplicitsGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLetGreen> for TokenNodeGreen {
    fn from(value: TerminalLetGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMatchGreen> for TokenNodeGreen {
    fn from(value: TerminalMatchGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModuleGreen> for TokenNodeGreen {
    fn from(value: TerminalModuleGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMutGreen> for TokenNodeGreen {
    fn from(value: TerminalMutGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNoPanicGreen> for TokenNodeGreen {
    fn from(value: TerminalNoPanicGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOfGreen> for TokenNodeGreen {
    fn from(value: TerminalOfGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalRefGreen> for TokenNodeGreen {
    fn from(value: TerminalRefGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalContinueGreen> for TokenNodeGreen {
    fn from(value: TerminalContinueGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalReturnGreen> for TokenNodeGreen {
    fn from(value: TerminalReturnGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalBreakGreen> for TokenNodeGreen {
    fn from(value: TerminalBreakGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalStructGreen> for TokenNodeGreen {
    fn from(value: TerminalStructGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTraitGreen> for TokenNodeGreen {
    fn from(value: TerminalTraitGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTrueGreen> for TokenNodeGreen {
    fn from(value: TerminalTrueGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalTypeGreen> for TokenNodeGreen {
    fn from(value: TerminalTypeGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalUseGreen> for TokenNodeGreen {
    fn from(value: TerminalUseGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPubGreen> for TokenNodeGreen {
    fn from(value: TerminalPubGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAndGreen> for TokenNodeGreen {
    fn from(value: TerminalAndGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAndAndGreen> for TokenNodeGreen {
    fn from(value: TerminalAndAndGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalArrowGreen> for TokenNodeGreen {
    fn from(value: TerminalArrowGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalAtGreen> for TokenNodeGreen {
    fn from(value: TerminalAtGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalBadCharactersGreen> for TokenNodeGreen {
    fn from(value: TerminalBadCharactersGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalColonGreen> for TokenNodeGreen {
    fn from(value: TerminalColonGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalColonColonGreen> for TokenNodeGreen {
    fn from(value: TerminalColonColonGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalCommaGreen> for TokenNodeGreen {
    fn from(value: TerminalCommaGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDivGreen> for TokenNodeGreen {
    fn from(value: TerminalDivGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDivEqGreen> for TokenNodeGreen {
    fn from(value: TerminalDivEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotGreen> for TokenNodeGreen {
    fn from(value: TerminalDotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotGreen> for TokenNodeGreen {
    fn from(value: TerminalDotDotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalDotDotEqGreen> for TokenNodeGreen {
    fn from(value: TerminalDotDotEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEndOfFileGreen> for TokenNodeGreen {
    fn from(value: TerminalEndOfFileGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqGreen> for TokenNodeGreen {
    fn from(value: TerminalEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEqEqGreen> for TokenNodeGreen {
    fn from(value: TerminalEqEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGEGreen> for TokenNodeGreen {
    fn from(value: TerminalGEGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalGTGreen> for TokenNodeGreen {
    fn from(value: TerminalGTGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalHashGreen> for TokenNodeGreen {
    fn from(value: TerminalHashGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLBraceGreen> for TokenNodeGreen {
    fn from(value: TerminalLBraceGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLBrackGreen> for TokenNodeGreen {
    fn from(value: TerminalLBrackGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLEGreen> for TokenNodeGreen {
    fn from(value: TerminalLEGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLParenGreen> for TokenNodeGreen {
    fn from(value: TerminalLParenGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalLTGreen> for TokenNodeGreen {
    fn from(value: TerminalLTGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMatchArrowGreen> for TokenNodeGreen {
    fn from(value: TerminalMatchArrowGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusGreen> for TokenNodeGreen {
    fn from(value: TerminalMinusGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMinusEqGreen> for TokenNodeGreen {
    fn from(value: TerminalMinusEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModGreen> for TokenNodeGreen {
    fn from(value: TerminalModGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalModEqGreen> for TokenNodeGreen {
    fn from(value: TerminalModEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulGreen> for TokenNodeGreen {
    fn from(value: TerminalMulGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalMulEqGreen> for TokenNodeGreen {
    fn from(value: TerminalMulEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNeqGreen> for TokenNodeGreen {
    fn from(value: TerminalNeqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalNotGreen> for TokenNodeGreen {
    fn from(value: TerminalNotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalBitNotGreen> for TokenNodeGreen {
    fn from(value: TerminalBitNotGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrGreen> for TokenNodeGreen {
    fn from(value: TerminalOrGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalOrOrGreen> for TokenNodeGreen {
    fn from(value: TerminalOrOrGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPlusGreen> for TokenNodeGreen {
    fn from(value: TerminalPlusGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalPlusEqGreen> for TokenNodeGreen {
    fn from(value: TerminalPlusEqGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalQuestionMarkGreen> for TokenNodeGreen {
    fn from(value: TerminalQuestionMarkGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalRBraceGreen> for TokenNodeGreen {
    fn from(value: TerminalRBraceGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalRBrackGreen> for TokenNodeGreen {
    fn from(value: TerminalRBrackGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalRParenGreen> for TokenNodeGreen {
    fn from(value: TerminalRParenGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalSemicolonGreen> for TokenNodeGreen {
    fn from(value: TerminalSemicolonGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalUnderscoreGreen> for TokenNodeGreen {
    fn from(value: TerminalUnderscoreGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalXorGreen> for TokenNodeGreen {
    fn from(value: TerminalXorGreen) -> Self {
        Self(value.0)
    }
}
impl From<TerminalEmptyGreen> for TokenNodeGreen {
    fn from(value: TerminalEmptyGreen) -> Self {
        Self(value.0)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct TokenNodeGreen(pub GreenId);
impl TypedSyntaxNode for TokenNode {
    const OPTIONAL_KIND: Option<SyntaxKind> = None;
    type StablePtr = TokenNodePtr;
    type Green = TokenNodeGreen;
    fn missing(db: &dyn SyntaxGroup) -> Self::Green {
        panic!("No missing variant.");
    }
    fn from_syntax_node(db: &dyn SyntaxGroup, node: SyntaxNode) -> Self {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalIdentifier => {
                TokenNode::TerminalIdentifier(TerminalIdentifier::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLiteralNumber => {
                TokenNode::TerminalLiteralNumber(TerminalLiteralNumber::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalShortString => {
                TokenNode::TerminalShortString(TerminalShortString::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalString => {
                TokenNode::TerminalString(TerminalString::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalAs => TokenNode::TerminalAs(TerminalAs::from_syntax_node(db, node)),
            SyntaxKind::TerminalConst => {
                TokenNode::TerminalConst(TerminalConst::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalElse => {
                TokenNode::TerminalElse(TerminalElse::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEnum => {
                TokenNode::TerminalEnum(TerminalEnum::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalExtern => {
                TokenNode::TerminalExtern(TerminalExtern::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalFalse => {
                TokenNode::TerminalFalse(TerminalFalse::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalFunction => {
                TokenNode::TerminalFunction(TerminalFunction::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalIf => TokenNode::TerminalIf(TerminalIf::from_syntax_node(db, node)),
            SyntaxKind::TerminalWhile => {
                TokenNode::TerminalWhile(TerminalWhile::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalFor => {
                TokenNode::TerminalFor(TerminalFor::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLoop => {
                TokenNode::TerminalLoop(TerminalLoop::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalImpl => {
                TokenNode::TerminalImpl(TerminalImpl::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalImplicits => {
                TokenNode::TerminalImplicits(TerminalImplicits::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLet => {
                TokenNode::TerminalLet(TerminalLet::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMatch => {
                TokenNode::TerminalMatch(TerminalMatch::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalModule => {
                TokenNode::TerminalModule(TerminalModule::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMut => {
                TokenNode::TerminalMut(TerminalMut::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNoPanic => {
                TokenNode::TerminalNoPanic(TerminalNoPanic::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalOf => TokenNode::TerminalOf(TerminalOf::from_syntax_node(db, node)),
            SyntaxKind::TerminalRef => {
                TokenNode::TerminalRef(TerminalRef::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalContinue => {
                TokenNode::TerminalContinue(TerminalContinue::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalReturn => {
                TokenNode::TerminalReturn(TerminalReturn::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalBreak => {
                TokenNode::TerminalBreak(TerminalBreak::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalStruct => {
                TokenNode::TerminalStruct(TerminalStruct::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalTrait => {
                TokenNode::TerminalTrait(TerminalTrait::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalTrue => {
                TokenNode::TerminalTrue(TerminalTrue::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalType => {
                TokenNode::TerminalType(TerminalType::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalUse => {
                TokenNode::TerminalUse(TerminalUse::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPub => {
                TokenNode::TerminalPub(TerminalPub::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalAnd => {
                TokenNode::TerminalAnd(TerminalAnd::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalAndAnd => {
                TokenNode::TerminalAndAnd(TerminalAndAnd::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalArrow => {
                TokenNode::TerminalArrow(TerminalArrow::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalAt => TokenNode::TerminalAt(TerminalAt::from_syntax_node(db, node)),
            SyntaxKind::TerminalBadCharacters => {
                TokenNode::TerminalBadCharacters(TerminalBadCharacters::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalColon => {
                TokenNode::TerminalColon(TerminalColon::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalColonColon => {
                TokenNode::TerminalColonColon(TerminalColonColon::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalComma => {
                TokenNode::TerminalComma(TerminalComma::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDiv => {
                TokenNode::TerminalDiv(TerminalDiv::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDivEq => {
                TokenNode::TerminalDivEq(TerminalDivEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDot => {
                TokenNode::TerminalDot(TerminalDot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDotDot => {
                TokenNode::TerminalDotDot(TerminalDotDot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalDotDotEq => {
                TokenNode::TerminalDotDotEq(TerminalDotDotEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEndOfFile => {
                TokenNode::TerminalEndOfFile(TerminalEndOfFile::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEq => TokenNode::TerminalEq(TerminalEq::from_syntax_node(db, node)),
            SyntaxKind::TerminalEqEq => {
                TokenNode::TerminalEqEq(TerminalEqEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalGE => TokenNode::TerminalGE(TerminalGE::from_syntax_node(db, node)),
            SyntaxKind::TerminalGT => TokenNode::TerminalGT(TerminalGT::from_syntax_node(db, node)),
            SyntaxKind::TerminalHash => {
                TokenNode::TerminalHash(TerminalHash::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLBrace => {
                TokenNode::TerminalLBrace(TerminalLBrace::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLBrack => {
                TokenNode::TerminalLBrack(TerminalLBrack::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLE => TokenNode::TerminalLE(TerminalLE::from_syntax_node(db, node)),
            SyntaxKind::TerminalLParen => {
                TokenNode::TerminalLParen(TerminalLParen::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalLT => TokenNode::TerminalLT(TerminalLT::from_syntax_node(db, node)),
            SyntaxKind::TerminalMatchArrow => {
                TokenNode::TerminalMatchArrow(TerminalMatchArrow::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinus => {
                TokenNode::TerminalMinus(TerminalMinus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMinusEq => {
                TokenNode::TerminalMinusEq(TerminalMinusEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMod => {
                TokenNode::TerminalMod(TerminalMod::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalModEq => {
                TokenNode::TerminalModEq(TerminalModEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMul => {
                TokenNode::TerminalMul(TerminalMul::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalMulEq => {
                TokenNode::TerminalMulEq(TerminalMulEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNeq => {
                TokenNode::TerminalNeq(TerminalNeq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalNot => {
                TokenNode::TerminalNot(TerminalNot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalBitNot => {
                TokenNode::TerminalBitNot(TerminalBitNot::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalOr => TokenNode::TerminalOr(TerminalOr::from_syntax_node(db, node)),
            SyntaxKind::TerminalOrOr => {
                TokenNode::TerminalOrOr(TerminalOrOr::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPlus => {
                TokenNode::TerminalPlus(TerminalPlus::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalPlusEq => {
                TokenNode::TerminalPlusEq(TerminalPlusEq::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalQuestionMark => {
                TokenNode::TerminalQuestionMark(TerminalQuestionMark::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalRBrace => {
                TokenNode::TerminalRBrace(TerminalRBrace::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalRBrack => {
                TokenNode::TerminalRBrack(TerminalRBrack::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalRParen => {
                TokenNode::TerminalRParen(TerminalRParen::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalSemicolon => {
                TokenNode::TerminalSemicolon(TerminalSemicolon::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalUnderscore => {
                TokenNode::TerminalUnderscore(TerminalUnderscore::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalXor => {
                TokenNode::TerminalXor(TerminalXor::from_syntax_node(db, node))
            }
            SyntaxKind::TerminalEmpty => {
                TokenNode::TerminalEmpty(TerminalEmpty::from_syntax_node(db, node))
            }
            _ => panic!("Unexpected syntax kind {:?} when constructing {}.", kind, "TokenNode"),
        }
    }
    fn cast(db: &dyn SyntaxGroup, node: SyntaxNode) -> Option<Self> {
        let kind = node.kind(db);
        match kind {
            SyntaxKind::TerminalIdentifier => {
                Some(TokenNode::TerminalIdentifier(TerminalIdentifier::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLiteralNumber => Some(TokenNode::TerminalLiteralNumber(
                TerminalLiteralNumber::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalShortString => Some(TokenNode::TerminalShortString(
                TerminalShortString::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalString => {
                Some(TokenNode::TerminalString(TerminalString::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAs => {
                Some(TokenNode::TerminalAs(TerminalAs::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalConst => {
                Some(TokenNode::TerminalConst(TerminalConst::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalElse => {
                Some(TokenNode::TerminalElse(TerminalElse::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEnum => {
                Some(TokenNode::TerminalEnum(TerminalEnum::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalExtern => {
                Some(TokenNode::TerminalExtern(TerminalExtern::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalFalse => {
                Some(TokenNode::TerminalFalse(TerminalFalse::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalFunction => {
                Some(TokenNode::TerminalFunction(TerminalFunction::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalIf => {
                Some(TokenNode::TerminalIf(TerminalIf::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalWhile => {
                Some(TokenNode::TerminalWhile(TerminalWhile::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalFor => {
                Some(TokenNode::TerminalFor(TerminalFor::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLoop => {
                Some(TokenNode::TerminalLoop(TerminalLoop::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalImpl => {
                Some(TokenNode::TerminalImpl(TerminalImpl::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalImplicits => {
                Some(TokenNode::TerminalImplicits(TerminalImplicits::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLet => {
                Some(TokenNode::TerminalLet(TerminalLet::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMatch => {
                Some(TokenNode::TerminalMatch(TerminalMatch::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalModule => {
                Some(TokenNode::TerminalModule(TerminalModule::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMut => {
                Some(TokenNode::TerminalMut(TerminalMut::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalNoPanic => {
                Some(TokenNode::TerminalNoPanic(TerminalNoPanic::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalOf => {
                Some(TokenNode::TerminalOf(TerminalOf::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalRef => {
                Some(TokenNode::TerminalRef(TerminalRef::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalContinue => {
                Some(TokenNode::TerminalContinue(TerminalContinue::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalReturn => {
                Some(TokenNode::TerminalReturn(TerminalReturn::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalBreak => {
                Some(TokenNode::TerminalBreak(TerminalBreak::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalStruct => {
                Some(TokenNode::TerminalStruct(TerminalStruct::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalTrait => {
                Some(TokenNode::TerminalTrait(TerminalTrait::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalTrue => {
                Some(TokenNode::TerminalTrue(TerminalTrue::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalType => {
                Some(TokenNode::TerminalType(TerminalType::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalUse => {
                Some(TokenNode::TerminalUse(TerminalUse::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalPub => {
                Some(TokenNode::TerminalPub(TerminalPub::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAnd => {
                Some(TokenNode::TerminalAnd(TerminalAnd::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAndAnd => {
                Some(TokenNode::TerminalAndAnd(TerminalAndAnd::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalArrow => {
                Some(TokenNode::TerminalArrow(TerminalArrow::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalAt => {
                Some(TokenNode::TerminalAt(TerminalAt::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalBadCharacters => Some(TokenNode::TerminalBadCharacters(
                TerminalBadCharacters::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalColon => {
                Some(TokenNode::TerminalColon(TerminalColon::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalColonColon => {
                Some(TokenNode::TerminalColonColon(TerminalColonColon::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalComma => {
                Some(TokenNode::TerminalComma(TerminalComma::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDiv => {
                Some(TokenNode::TerminalDiv(TerminalDiv::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDivEq => {
                Some(TokenNode::TerminalDivEq(TerminalDivEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDot => {
                Some(TokenNode::TerminalDot(TerminalDot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDotDot => {
                Some(TokenNode::TerminalDotDot(TerminalDotDot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalDotDotEq => {
                Some(TokenNode::TerminalDotDotEq(TerminalDotDotEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEndOfFile => {
                Some(TokenNode::TerminalEndOfFile(TerminalEndOfFile::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEq => {
                Some(TokenNode::TerminalEq(TerminalEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEqEq => {
                Some(TokenNode::TerminalEqEq(TerminalEqEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalGE => {
                Some(TokenNode::TerminalGE(TerminalGE::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalGT => {
                Some(TokenNode::TerminalGT(TerminalGT::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalHash => {
                Some(TokenNode::TerminalHash(TerminalHash::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLBrace => {
                Some(TokenNode::TerminalLBrace(TerminalLBrace::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLBrack => {
                Some(TokenNode::TerminalLBrack(TerminalLBrack::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLE => {
                Some(TokenNode::TerminalLE(TerminalLE::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLParen => {
                Some(TokenNode::TerminalLParen(TerminalLParen::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalLT => {
                Some(TokenNode::TerminalLT(TerminalLT::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMatchArrow => {
                Some(TokenNode::TerminalMatchArrow(TerminalMatchArrow::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMinus => {
                Some(TokenNode::TerminalMinus(TerminalMinus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMinusEq => {
                Some(TokenNode::TerminalMinusEq(TerminalMinusEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMod => {
                Some(TokenNode::TerminalMod(TerminalMod::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalModEq => {
                Some(TokenNode::TerminalModEq(TerminalModEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMul => {
                Some(TokenNode::TerminalMul(TerminalMul::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalMulEq => {
                Some(TokenNode::TerminalMulEq(TerminalMulEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalNeq => {
                Some(TokenNode::TerminalNeq(TerminalNeq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalNot => {
                Some(TokenNode::TerminalNot(TerminalNot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalBitNot => {
                Some(TokenNode::TerminalBitNot(TerminalBitNot::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalOr => {
                Some(TokenNode::TerminalOr(TerminalOr::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalOrOr => {
                Some(TokenNode::TerminalOrOr(TerminalOrOr::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalPlus => {
                Some(TokenNode::TerminalPlus(TerminalPlus::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalPlusEq => {
                Some(TokenNode::TerminalPlusEq(TerminalPlusEq::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalQuestionMark => Some(TokenNode::TerminalQuestionMark(
                TerminalQuestionMark::from_syntax_node(db, node),
            )),
            SyntaxKind::TerminalRBrace => {
                Some(TokenNode::TerminalRBrace(TerminalRBrace::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalRBrack => {
                Some(TokenNode::TerminalRBrack(TerminalRBrack::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalRParen => {
                Some(TokenNode::TerminalRParen(TerminalRParen::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalSemicolon => {
                Some(TokenNode::TerminalSemicolon(TerminalSemicolon::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalUnderscore => {
                Some(TokenNode::TerminalUnderscore(TerminalUnderscore::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalXor => {
                Some(TokenNode::TerminalXor(TerminalXor::from_syntax_node(db, node)))
            }
            SyntaxKind::TerminalEmpty => {
                Some(TokenNode::TerminalEmpty(TerminalEmpty::from_syntax_node(db, node)))
            }
            _ => None,
        }
    }
    fn as_syntax_node(&self) -> SyntaxNode {
        match self {
            TokenNode::TerminalIdentifier(x) => x.as_syntax_node(),
            TokenNode::TerminalLiteralNumber(x) => x.as_syntax_node(),
            TokenNode::TerminalShortString(x) => x.as_syntax_node(),
            TokenNode::TerminalString(x) => x.as_syntax_node(),
            TokenNode::TerminalAs(x) => x.as_syntax_node(),
            TokenNode::TerminalConst(x) => x.as_syntax_node(),
            TokenNode::TerminalElse(x) => x.as_syntax_node(),
            TokenNode::TerminalEnum(x) => x.as_syntax_node(),
            TokenNode::TerminalExtern(x) => x.as_syntax_node(),
            TokenNode::TerminalFalse(x) => x.as_syntax_node(),
            TokenNode::TerminalFunction(x) => x.as_syntax_node(),
            TokenNode::TerminalIf(x) => x.as_syntax_node(),
            TokenNode::TerminalWhile(x) => x.as_syntax_node(),
            TokenNode::TerminalFor(x) => x.as_syntax_node(),
            TokenNode::TerminalLoop(x) => x.as_syntax_node(),
            TokenNode::TerminalImpl(x) => x.as_syntax_node(),
            TokenNode::TerminalImplicits(x) => x.as_syntax_node(),
            TokenNode::TerminalLet(x) => x.as_syntax_node(),
            TokenNode::TerminalMatch(x) => x.as_syntax_node(),
            TokenNode::TerminalModule(x) => x.as_syntax_node(),
            TokenNode::TerminalMut(x) => x.as_syntax_node(),
            TokenNode::TerminalNoPanic(x) => x.as_syntax_node(),
            TokenNode::TerminalOf(x) => x.as_syntax_node(),
            TokenNode::TerminalRef(x) => x.as_syntax_node(),
            TokenNode::TerminalContinue(x) => x.as_syntax_node(),
            TokenNode::TerminalReturn(x) => x.as_syntax_node(),
            TokenNode::TerminalBreak(x) => x.as_syntax_node(),
            TokenNode::TerminalStruct(x) => x.as_syntax_node(),
            TokenNode::TerminalTrait(x) => x.as_syntax_node(),
            TokenNode::TerminalTrue(x) => x.as_syntax_node(),
            TokenNode::TerminalType(x) => x.as_syntax_node(),
            TokenNode::TerminalUse(x) => x.as_syntax_node(),
            TokenNode::TerminalPub(x) => x.as_syntax_node(),
            TokenNode::TerminalAnd(x) => x.as_syntax_node(),
            TokenNode::TerminalAndAnd(x) => x.as_syntax_node(),
            TokenNode::TerminalArrow(x) => x.as_syntax_node(),
            TokenNode::TerminalAt(x) => x.as_syntax_node(),
            TokenNode::TerminalBadCharacters(x) => x.as_syntax_node(),
            TokenNode::TerminalColon(x) => x.as_syntax_node(),
            TokenNode::TerminalColonColon(x) => x.as_syntax_node(),
            TokenNode::TerminalComma(x) => x.as_syntax_node(),
            TokenNode::TerminalDiv(x) => x.as_syntax_node(),
            TokenNode::TerminalDivEq(x) => x.as_syntax_node(),
            TokenNode::TerminalDot(x) => x.as_syntax_node(),
            TokenNode::TerminalDotDot(x) => x.as_syntax_node(),
            TokenNode::TerminalDotDotEq(x) => x.as_syntax_node(),
            TokenNode::TerminalEndOfFile(x) => x.as_syntax_node(),
            TokenNode::TerminalEq(x) => x.as_syntax_node(),
            TokenNode::TerminalEqEq(x) => x.as_syntax_node(),
            TokenNode::TerminalGE(x) => x.as_syntax_node(),
            TokenNode::TerminalGT(x) => x.as_syntax_node(),
            TokenNode::TerminalHash(x) => x.as_syntax_node(),
            TokenNode::TerminalLBrace(x) => x.as_syntax_node(),
            TokenNode::TerminalLBrack(x) => x.as_syntax_node(),
            TokenNode::TerminalLE(x) => x.as_syntax_node(),
            TokenNode::TerminalLParen(x) => x.as_syntax_node(),
            TokenNode::TerminalLT(x) => x.as_syntax_node(),
            TokenNode::TerminalMatchArrow(x) => x.as_syntax_node(),
            TokenNode::TerminalMinus(x) => x.as_syntax_node(),
            TokenNode::TerminalMinusEq(x) => x.as_syntax_node(),
            TokenNode::TerminalMod(x) => x.as_syntax_node(),
            TokenNode::TerminalModEq(x) => x.as_syntax_node(),
            TokenNode::TerminalMul(x) => x.as_syntax_node(),
            TokenNode::TerminalMulEq(x) => x.as_syntax_node(),
            TokenNode::TerminalNeq(x) => x.as_syntax_node(),
            TokenNode::TerminalNot(x) => x.as_syntax_node(),
            TokenNode::TerminalBitNot(x) => x.as_syntax_node(),
            TokenNode::TerminalOr(x) => x.as_syntax_node(),
            TokenNode::TerminalOrOr(x) => x.as_syntax_node(),
            TokenNode::TerminalPlus(x) => x.as_syntax_node(),
            TokenNode::TerminalPlusEq(x) => x.as_syntax_node(),
            TokenNode::TerminalQuestionMark(x) => x.as_syntax_node(),
            TokenNode::TerminalRBrace(x) => x.as_syntax_node(),
            TokenNode::TerminalRBrack(x) => x.as_syntax_node(),
            TokenNode::TerminalRParen(x) => x.as_syntax_node(),
            TokenNode::TerminalSemicolon(x) => x.as_syntax_node(),
            TokenNode::TerminalUnderscore(x) => x.as_syntax_node(),
            TokenNode::TerminalXor(x) => x.as_syntax_node(),
            TokenNode::TerminalEmpty(x) => x.as_syntax_node(),
        }
    }
    fn stable_ptr(&self) -> Self::StablePtr {
        TokenNodePtr(self.as_syntax_node().0.stable_ptr)
    }
}
impl From<&TokenNode> for SyntaxStablePtrId {
    fn from(node: &TokenNode) -> Self {
        node.stable_ptr().untyped()
    }
}
impl TokenNode {
    /// Checks if a kind of a variant of [TokenNode].
    pub fn is_variant(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            SyntaxKind::TerminalIdentifier
                | SyntaxKind::TerminalLiteralNumber
                | SyntaxKind::TerminalShortString
                | SyntaxKind::TerminalString
                | SyntaxKind::TerminalAs
                | SyntaxKind::TerminalConst
                | SyntaxKind::TerminalElse
                | SyntaxKind::TerminalEnum
                | SyntaxKind::TerminalExtern
                | SyntaxKind::TerminalFalse
                | SyntaxKind::TerminalFunction
                | SyntaxKind::TerminalIf
                | SyntaxKind::TerminalWhile
                | SyntaxKind::TerminalFor
                | SyntaxKind::TerminalLoop
                | SyntaxKind::TerminalImpl
                | SyntaxKind::TerminalImplicits
                | SyntaxKind::TerminalLet
                | SyntaxKind::TerminalMatch
                | SyntaxKind::TerminalModule
                | SyntaxKind::TerminalMut
                | SyntaxKind::TerminalNoPanic
                | SyntaxKind::TerminalOf
                | SyntaxKind::TerminalRef
                | SyntaxKind::TerminalContinue
                | SyntaxKind::TerminalReturn
                | SyntaxKind::TerminalBreak
                | SyntaxKind::TerminalStruct
                | SyntaxKind::TerminalTrait
                | SyntaxKind::TerminalTrue
                | SyntaxKind::TerminalType
                | SyntaxKind::TerminalUse
                | SyntaxKind::TerminalPub
                | SyntaxKind::TerminalAnd
                | SyntaxKind::TerminalAndAnd
                | SyntaxKind::TerminalArrow
                | SyntaxKind::TerminalAt
                | SyntaxKind::TerminalBadCharacters
                | SyntaxKind::TerminalColon
                | SyntaxKind::TerminalColonColon
                | SyntaxKind::TerminalComma
                | SyntaxKind::TerminalDiv
                | SyntaxKind::TerminalDivEq
                | SyntaxKind::TerminalDot
                | SyntaxKind::TerminalDotDot
                | SyntaxKind::TerminalDotDotEq
                | SyntaxKind::TerminalEndOfFile
                | SyntaxKind::TerminalEq
                | SyntaxKind::TerminalEqEq
                | SyntaxKind::TerminalGE
                | SyntaxKind::TerminalGT
                | SyntaxKind::TerminalHash
                | SyntaxKind::TerminalLBrace
                | SyntaxKind::TerminalLBrack
                | SyntaxKind::TerminalLE
                | SyntaxKind::TerminalLParen
                | SyntaxKind::TerminalLT
                | SyntaxKind::TerminalMatchArrow
                | SyntaxKind::TerminalMinus
                | SyntaxKind::TerminalMinusEq
                | SyntaxKind::TerminalMod
                | SyntaxKind::TerminalModEq
                | SyntaxKind::TerminalMul
                | SyntaxKind::TerminalMulEq
                | SyntaxKind::TerminalNeq
                | SyntaxKind::TerminalNot
                | SyntaxKind::TerminalBitNot
                | SyntaxKind::TerminalOr
                | SyntaxKind::TerminalOrOr
                | SyntaxKind::TerminalPlus
                | SyntaxKind::TerminalPlusEq
                | SyntaxKind::TerminalQuestionMark
                | SyntaxKind::TerminalRBrace
                | SyntaxKind::TerminalRBrack
                | SyntaxKind::TerminalRParen
                | SyntaxKind::TerminalSemicolon
                | SyntaxKind::TerminalUnderscore
                | SyntaxKind::TerminalXor
                | SyntaxKind::TerminalEmpty
        )
    }
}
