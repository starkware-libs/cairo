use cairo_lang_casm::builder::CasmBuilder;
use cairo_lang_casm::casm_build_extend;
use cairo_lang_casm::cell_expression::CellExpression;
use cairo_lang_sierra::extensions::boolean::BoolConcreteLibfunc;

use super::{misc, CompiledInvocation, CompiledInvocationBuilder, InvocationError};

/// Builds instructions for Sierra bool operations.
pub fn build(
    libfunc: &BoolConcreteLibfunc,
    builder: CompiledInvocationBuilder<'_>,
) -> Result<CompiledInvocation, InvocationError> {
    match libfunc {
        BoolConcreteLibfunc::And(_) => build_bool_and(builder),
        BoolConcreteLibfunc::Not(_) => build_bool_not(builder),
        BoolConcreteLibfunc::Xor(_) => build_bool_xor(builder),
        BoolConcreteLibfunc::Equal(_) => misc::build_cell_eq(builder),
    }
}

/// Handles instructions for boolean AND.
fn build_bool_and(
    builder: CompiledInvocationBuilder<'_>,
) -> Result<CompiledInvocation, InvocationError> {
    let [expr_a, expr_b] = builder.try_get_refs()?;
    let a = expr_a
        .try_unpack_single()?
        .to_deref()
        .ok_or(InvocationError::InvalidReferenceExpressionForArgument)?;
    let b = expr_b
        .try_unpack_single()?
        .to_deref()
        .ok_or(InvocationError::InvalidReferenceExpressionForArgument)?;
    let mut casm_builder = CasmBuilder::default();
    let a = casm_builder.add_var(CellExpression::Deref(a));
    let b = casm_builder.add_var(CellExpression::Deref(b));
    casm_build_extend!(casm_builder, let res = a * b;);
    Ok(builder.build_from_casm_builder(casm_builder, [("Fallthrough", &[&[res]], None)]))
}

/// Handles instructions for boolean NOT.
fn build_bool_not(
    builder: CompiledInvocationBuilder<'_>,
) -> Result<CompiledInvocation, InvocationError> {
    let a = builder.try_get_refs::<1>()?[0]
        .try_unpack_single()?
        .to_deref()
        .ok_or(InvocationError::InvalidReferenceExpressionForArgument)?;
    let mut casm_builder = CasmBuilder::default();
    let a = casm_builder.add_var(CellExpression::Deref(a));
    casm_build_extend! {casm_builder,
        const one_imm = 1;
        tempvar one = one_imm;
        let res = one - a;
    };
    Ok(builder.build_from_casm_builder(casm_builder, [("Fallthrough", &[&[res]], None)]))
}

/// Handles instructions for boolean XOR.
fn build_bool_xor(
    builder: CompiledInvocationBuilder<'_>,
) -> Result<CompiledInvocation, InvocationError> {
    let [expr_a, expr_b] = builder.try_get_refs()?;
    let a = expr_a
        .try_unpack_single()?
        .to_deref()
        .ok_or(InvocationError::InvalidReferenceExpressionForArgument)?;
    let b = expr_b
        .try_unpack_single()?
        .to_deref()
        .ok_or(InvocationError::InvalidReferenceExpressionForArgument)?;

    let mut casm_builder = CasmBuilder::default();
    let a = casm_builder.add_var(CellExpression::Deref(a));
    let b = casm_builder.add_var(CellExpression::Deref(b));

    // Outputs `(a - b)^2`.
    casm_build_extend! {casm_builder,
        tempvar diff = a - b;
        let res = diff * diff;
    }
    Ok(builder.build_from_casm_builder(casm_builder, [("Fallthrough", &[&[res]], None)]))
}
