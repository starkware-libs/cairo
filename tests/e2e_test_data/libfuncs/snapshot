//! > Array snapshot.

//! > test_comments

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(a: Array::<felt252>) -> Array::<felt252> {
    bar(@a);
    a
}
fn bar(a: @Array::<felt252>) {
}

//! > casm
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 200})
test::bar: OrderedHashMap({})

//! > sierra_code
type Array<felt252> = Array<felt252> [storable: true, drop: true, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Snapshot<Array<felt252>> = Snapshot<Array<felt252>> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc store_temp<Array<felt252>> = store_temp<Array<felt252>>;
libfunc drop<Snapshot<Array<felt252>>> = drop<Snapshot<Array<felt252>>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;

store_temp<Array<felt252>>([0]) -> ([0]); // 0
return([0]); // 1
drop<Snapshot<Array<felt252>>>([0]) -> (); // 2
struct_construct<Unit>() -> ([1]); // 3
return([1]); // 4

test::foo@0([0]: Array<felt252>) -> (Array<felt252>);
test::bar@2([0]: Snapshot<Array<felt252>>) -> (Unit);

//! > ==========================================================================

//! > struct snapshot.

//! > test_comments

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
struct A {
    a: Array::<felt252>,
    b: felt252,
}
fn foo(orig: @A) -> @A{
    bar(orig.a, orig.b);
    let A {a, b} = orig;
    bar(a, b);
    orig
}
fn bar(a: @Array::<felt252>, b: @felt252) {
}

//! > casm
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 300})
test::bar: OrderedHashMap({})

//! > sierra_code
type Array<felt252> = Array<felt252> [storable: true, drop: true, dup: false, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::A = Struct<ut@test::A, Array<felt252>, felt252> [storable: true, drop: true, dup: false, zero_sized: false];
type Snapshot<test::A> = Snapshot<test::A> [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type Snapshot<Array<felt252>> = Snapshot<Array<felt252>> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc store_temp<Snapshot<test::A>> = store_temp<Snapshot<test::A>>;
libfunc drop<Snapshot<Array<felt252>>> = drop<Snapshot<Array<felt252>>>;
libfunc drop<felt252> = drop<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;

store_temp<Snapshot<test::A>>([0]) -> ([0]); // 0
return([0]); // 1
drop<Snapshot<Array<felt252>>>([0]) -> (); // 2
drop<felt252>([1]) -> (); // 3
struct_construct<Unit>() -> ([2]); // 4
return([2]); // 5

test::foo@0([0]: Snapshot<test::A>) -> (Snapshot<test::A>);
test::bar@2([0]: Snapshot<Array<felt252>>, [1]: felt252) -> (Unit);

//! > ==========================================================================

//! > enum snapshot.

//! > test_comments

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum A {
    A: Array::<felt252>,
    B: felt252,
}
fn bar0(a: @Array::<felt252>) {
}
fn bar1(b: @felt252) {
}
fn foo(orig: @A) -> @A {
    match orig {
      A::A(a) => bar0(a),
      A::B(b) => bar1(b),
    }
    orig
  }

//! > casm
ret;
ret;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::bar0: OrderedHashMap({})
test::bar1: OrderedHashMap({})
test::foo: OrderedHashMap({Const: 300})

//! > sierra_code
type Array<felt252> = Array<felt252> [storable: true, drop: true, dup: false, zero_sized: false];
type Snapshot<Array<felt252>> = Snapshot<Array<felt252>> [storable: true, drop: true, dup: true, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::A = Enum<ut@test::A, Array<felt252>, felt252> [storable: true, drop: true, dup: false, zero_sized: false];
type Snapshot<test::A> = Snapshot<test::A> [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];

libfunc drop<Snapshot<Array<felt252>>> = drop<Snapshot<Array<felt252>>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc drop<felt252> = drop<felt252>;
libfunc store_temp<Snapshot<test::A>> = store_temp<Snapshot<test::A>>;

drop<Snapshot<Array<felt252>>>([0]) -> (); // 0
struct_construct<Unit>() -> ([1]); // 1
return([1]); // 2
drop<felt252>([0]) -> (); // 3
struct_construct<Unit>() -> ([1]); // 4
return([1]); // 5
store_temp<Snapshot<test::A>>([0]) -> ([0]); // 6
return([0]); // 7

test::bar0@0([0]: Snapshot<Array<felt252>>) -> (Unit);
test::bar1@3([0]: felt252) -> (Unit);
test::foo@6([0]: Snapshot<test::A>) -> (Snapshot<test::A>);
