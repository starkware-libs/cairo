//! > Array snapshot.

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(a: Array::<felt>) -> Array::<felt> {
    bar(@a);
    a
}
fn bar(a: @Array::<felt>) {
}

//! > casm
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 5;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 600})
test::bar: OrderedHashMap({})

//! > sierra_code
type felt = felt;
type Array<felt> = Array<felt>;
type Snapshot<Array<felt>> = Snapshot<Array<felt>>;
type Unit = Struct<ut@Tuple>;

libfunc snapshot_take<Array<felt>> = snapshot_take<Array<felt>>;
libfunc store_temp<Snapshot<Array<felt>>> = store_temp<Snapshot<Array<felt>>>;
libfunc function_call<user@test::bar> = function_call<user@test::bar>;
libfunc drop<Unit> = drop<Unit>;
libfunc store_temp<Array<felt>> = store_temp<Array<felt>>;
libfunc drop<Snapshot<Array<felt>>> = drop<Snapshot<Array<felt>>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc store_temp<Unit> = store_temp<Unit>;

snapshot_take<Array<felt>>([0]) -> ([0], [1]);
store_temp<Snapshot<Array<felt>>>([1]) -> ([3]);
function_call<user@test::bar>([3]) -> ([2]);
drop<Unit>([2]) -> ();
store_temp<Array<felt>>([0]) -> ([4]);
return([4]);
drop<Snapshot<Array<felt>>>([0]) -> ();
struct_construct<Unit>() -> ([1]);
store_temp<Unit>([1]) -> ([2]);
return([2]);

test::foo@0([0]: Array<felt>) -> (Array<felt>);
test::bar@6([0]: Snapshot<Array<felt>>) -> (Unit);

//! > ==========================================================================

//! > struct snapshot.

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
struct A {
    a: Array::<felt>,
    b: felt,
}
fn foo(orig: @A) -> @A{
    bar(orig.a, orig.b);
    let A {a, b} = orig;
    bar(a, b);
    orig
}
fn bar(a: @Array::<felt>, b: @felt) {
}

//! > casm
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 11;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 6;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1300})
test::bar: OrderedHashMap({})

//! > sierra_code
type felt = felt;
type Array<felt> = Array<felt>;
type test::A = Struct<ut@test::A, Array<felt>, felt>;
type Snapshot<test::A> = Snapshot<test::A>;
type Snapshot<Array<felt>> = Snapshot<Array<felt>>;
type Unit = Struct<ut@Tuple>;

libfunc dup<Snapshot<test::A>> = dup<Snapshot<test::A>>;
libfunc struct_snapshot_deconstruct<test::A> = struct_snapshot_deconstruct<test::A>;
libfunc drop<felt> = drop<felt>;
libfunc drop<Snapshot<Array<felt>>> = drop<Snapshot<Array<felt>>>;
libfunc store_temp<Snapshot<Array<felt>>> = store_temp<Snapshot<Array<felt>>>;
libfunc store_temp<felt> = store_temp<felt>;
libfunc function_call<user@test::bar> = function_call<user@test::bar>;
libfunc drop<Unit> = drop<Unit>;
libfunc store_temp<Snapshot<test::A>> = store_temp<Snapshot<test::A>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc store_temp<Unit> = store_temp<Unit>;

dup<Snapshot<test::A>>([0]) -> ([0], [1]);
struct_snapshot_deconstruct<test::A>([1]) -> ([2], [3]);
drop<felt>([3]) -> ();
dup<Snapshot<test::A>>([0]) -> ([0], [4]);
struct_snapshot_deconstruct<test::A>([4]) -> ([5], [6]);
drop<Snapshot<Array<felt>>>([5]) -> ();
store_temp<Snapshot<Array<felt>>>([2]) -> ([8]);
store_temp<felt>([6]) -> ([9]);
function_call<user@test::bar>([8], [9]) -> ([7]);
drop<Unit>([7]) -> ();
dup<Snapshot<test::A>>([0]) -> ([0], [10]);
struct_snapshot_deconstruct<test::A>([10]) -> ([11], [12]);
store_temp<Snapshot<Array<felt>>>([11]) -> ([14]);
store_temp<felt>([12]) -> ([15]);
function_call<user@test::bar>([14], [15]) -> ([13]);
drop<Unit>([13]) -> ();
store_temp<Snapshot<test::A>>([0]) -> ([16]);
return([16]);
drop<Snapshot<Array<felt>>>([0]) -> ();
drop<felt>([1]) -> ();
struct_construct<Unit>() -> ([2]);
store_temp<Unit>([2]) -> ([3]);
return([3]);

test::foo@0([0]: Snapshot<test::A>) -> (Snapshot<test::A>);
test::bar@18([0]: Snapshot<Array<felt>>, [1]: felt) -> (Unit);

//! > ==========================================================================

//! > enum snapshot.

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
enum A {
    A: Array::<felt>,
    B: felt,
}
fn bar0(a: @Array::<felt>) {
}
fn bar1(b: @felt) {
}
fn foo(orig: @A) -> @A {
    match orig {
      A::A(a) => bar0(a),
      A::B(b) => bar1(b),
    }
    orig
  }

//! > casm
ret;
ret;
jmp rel 8 if [fp + -5] != 0;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel -6;
jmp rel 7;
ap += 1;
[ap + 0] = [fp + -4], ap++;
call rel -12;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::bar0: OrderedHashMap({})
test::bar1: OrderedHashMap({})
test::foo: OrderedHashMap({Const: 900})

//! > sierra_code
type felt = felt;
type Array<felt> = Array<felt>;
type Snapshot<Array<felt>> = Snapshot<Array<felt>>;
type Unit = Struct<ut@Tuple>;
type test::A = Enum<ut@test::A, Array<felt>, felt>;
type Snapshot<test::A> = Snapshot<test::A>;

libfunc drop<Snapshot<Array<felt>>> = drop<Snapshot<Array<felt>>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc store_temp<Unit> = store_temp<Unit>;
libfunc drop<felt> = drop<felt>;
libfunc dup<Snapshot<test::A>> = dup<Snapshot<test::A>>;
libfunc enum_snapshot_match<test::A> = enum_snapshot_match<test::A>;
libfunc branch_align = branch_align;
libfunc store_temp<Snapshot<Array<felt>>> = store_temp<Snapshot<Array<felt>>>;
libfunc function_call<user@test::bar0> = function_call<user@test::bar0>;
libfunc drop<Unit> = drop<Unit>;
libfunc jump = jump;
libfunc store_temp<felt> = store_temp<felt>;
libfunc function_call<user@test::bar1> = function_call<user@test::bar1>;
libfunc store_temp<Snapshot<test::A>> = store_temp<Snapshot<test::A>>;

drop<Snapshot<Array<felt>>>([0]) -> ();
struct_construct<Unit>() -> ([1]);
store_temp<Unit>([1]) -> ([2]);
return([2]);
drop<felt>([0]) -> ();
struct_construct<Unit>() -> ([1]);
store_temp<Unit>([1]) -> ([2]);
return([2]);
dup<Snapshot<test::A>>([0]) -> ([0], [3]);
enum_snapshot_match<test::A>([3]) { fallthrough([1]) 15([2]) };
branch_align() -> ();
store_temp<Snapshot<Array<felt>>>([1]) -> ([5]);
function_call<user@test::bar0>([5]) -> ([4]);
drop<Unit>([4]) -> ();
jump() { 19() };
branch_align() -> ();
store_temp<felt>([2]) -> ([7]);
function_call<user@test::bar1>([7]) -> ([6]);
drop<Unit>([6]) -> ();
store_temp<Snapshot<test::A>>([0]) -> ([8]);
return([8]);

test::bar0@0([0]: Snapshot<Array<felt>>) -> (Unit);
test::bar1@4([0]: felt) -> (Unit);
test::foo@8([0]: Snapshot<test::A>) -> (Snapshot<test::A>);
