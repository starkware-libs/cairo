//! > hades_permutation libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(s0: felt252, s1: felt252, s2: felt252) -> (felt252, felt252, felt252) {
    poseidon::hades_permutation(s0, s1, s2)
}

//! > casm
[fp + -5] = [[fp + -6] + 0];
[fp + -4] = [[fp + -6] + 1];
[fp + -3] = [[fp + -6] + 2];
[ap + 0] = [fp + -6] + 6, ap++;
[ap + 0] = [[fp + -6] + 3], ap++;
[ap + 0] = [[fp + -6] + 4], ap++;
[ap + 0] = [[fp + -6] + 5], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Poseidon: 1, Const: 700})

//! > sierra_code
type Poseidon = Poseidon [storable: true, drop: false, dup: false, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<felt252, felt252, felt252> = Struct<ut@Tuple, felt252, felt252, felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc hades_permutation = hades_permutation;
libfunc struct_construct<Tuple<felt252, felt252, felt252>> = struct_construct<Tuple<felt252, felt252, felt252>>;
libfunc store_temp<Poseidon> = store_temp<Poseidon>;
libfunc store_temp<Tuple<felt252, felt252, felt252>> = store_temp<Tuple<felt252, felt252, felt252>>;

hades_permutation([0], [1], [2], [3]) -> ([4], [5], [6], [7]); // 0
struct_construct<Tuple<felt252, felt252, felt252>>([5], [6], [7]) -> ([8]); // 1
store_temp<Poseidon>([4]) -> ([4]); // 2
store_temp<Tuple<felt252, felt252, felt252>>([8]) -> ([8]); // 3
return([4], [8]); // 4

test::foo@0([0]: Poseidon, [1]: felt252, [2]: felt252, [3]: felt252) -> (Poseidon, Tuple<felt252, felt252, felt252>);

//! > ==========================================================================

//! > complete tuple hash

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
use hash::{HashStateTrait, HashStateExTrait};

fn foo(s0: felt252, s1: felt252, s2: felt252) -> felt252 {
    poseidon::PoseidonTrait::new().update_with((s0, s1, s2)).finalize()
}

//! > casm
[ap + 0] = 0, ap++;
jmp rel 16 if [ap + -1] != 0;
ap += 3;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [ap + -2] + [fp + -5], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 1, ap++;
jmp rel 19;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -2] + [fp + -5], ap++;
[ap + 0] = 0, ap++;
[ap + -3] = [[fp + -6] + 0];
[ap + -2] = [[fp + -6] + 1];
[ap + -1] = [[fp + -6] + 2];
[ap + 0] = [fp + -6] + 6, ap++;
[ap + 0] = [[fp + -6] + 3], ap++;
[ap + 0] = [[fp + -6] + 4], ap++;
[ap + 0] = [[fp + -6] + 5], ap++;
[ap + 0] = 0, ap++;
jmp rel 12 if [ap + -1] != 0;
ap += 1;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6] + [fp + -4], ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = 1, ap++;
jmp rel 13;
[ap + 0] = [ap + -3] + [fp + -4], ap++;
[ap + -5] = [[ap + -6] + 0];
[ap + -1] = [[ap + -6] + 1];
[ap + -3] = [[ap + -6] + 2];
[ap + 0] = [ap + -6] + 6, ap++;
[ap + 0] = [[ap + -7] + 3], ap++;
[ap + 0] = [[ap + -8] + 4], ap++;
[ap + 0] = [[ap + -9] + 5], ap++;
[ap + 0] = 0, ap++;
jmp rel 12 if [ap + -1] != 0;
ap += 1;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6] + [fp + -3], ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = 1, ap++;
jmp rel 13;
[ap + 0] = [ap + -3] + [fp + -3], ap++;
[ap + -5] = [[ap + -6] + 0];
[ap + -1] = [[ap + -6] + 1];
[ap + -3] = [[ap + -6] + 2];
[ap + 0] = [ap + -6] + 6, ap++;
[ap + 0] = [[ap + -7] + 3], ap++;
[ap + 0] = [[ap + -8] + 4], ap++;
[ap + 0] = [[ap + -9] + 5], ap++;
[ap + 0] = 0, ap++;
jmp rel 11 if [ap + -1] != 0;
[ap + 0] = [ap + -4] + 1, ap++;
[ap + -1] = [[ap + -6] + 0];
[ap + -4] = [[ap + -6] + 1];
[ap + -3] = [[ap + -6] + 2];
[ap + 0] = [ap + -6] + 6, ap++;
[ap + 0] = [[ap + -7] + 3], ap++;
ret;
[ap + 0] = [ap + -3] + 1, ap++;
[ap + -5] = [[ap + -6] + 0];
[ap + -1] = [[ap + -6] + 1];
[ap + -3] = [[ap + -6] + 2];
[ap + 0] = [ap + -6] + 6, ap++;
[ap + 0] = [[ap + -7] + 3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Poseidon: 4, Const: 4100})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Poseidon = Poseidon [storable: true, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type core::bool = Enum<ut@core::bool, Unit, Unit> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc felt252_const<0> = felt252_const<0>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::bool, 0> = enum_init<core::bool, 0>;
libfunc store_temp<core::bool> = store_temp<core::bool>;
libfunc enum_match<core::bool> = enum_match<core::bool>;
libfunc branch_align = branch_align;
libfunc drop<Unit> = drop<Unit>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc felt252_add = felt252_add;
libfunc enum_init<core::bool, 1> = enum_init<core::bool, 1>;
libfunc store_temp<Poseidon> = store_temp<Poseidon>;
libfunc jump = jump;
libfunc hades_permutation = hades_permutation;
libfunc felt252_const<1> = felt252_const<1>;
libfunc drop<felt252> = drop<felt252>;

felt252_const<0>() -> ([4]); // 0
felt252_const<0>() -> ([5]); // 1
felt252_const<0>() -> ([6]); // 2
struct_construct<Unit>() -> ([7]); // 3
enum_init<core::bool, 0>([7]) -> ([8]); // 4
store_temp<core::bool>([8]) -> ([8]); // 5
enum_match<core::bool>([8]) { fallthrough([9]) 19([10]) }; // 6
branch_align() -> (); // 7
drop<Unit>([9]) -> (); // 8
store_temp<felt252>([4]) -> ([4]); // 9
felt252_add([4], [1]) -> ([11]); // 10
struct_construct<Unit>() -> ([12]); // 11
enum_init<core::bool, 1>([12]) -> ([13]); // 12
store_temp<Poseidon>([0]) -> ([14]); // 13
store_temp<felt252>([11]) -> ([15]); // 14
store_temp<felt252>([5]) -> ([16]); // 15
store_temp<felt252>([6]) -> ([17]); // 16
store_temp<core::bool>([13]) -> ([18]); // 17
jump() { 34() }; // 18
branch_align() -> (); // 19
drop<Unit>([10]) -> (); // 20
store_temp<felt252>([5]) -> ([5]); // 21
felt252_add([5], [1]) -> ([19]); // 22
store_temp<felt252>([4]) -> ([4]); // 23
store_temp<felt252>([19]) -> ([19]); // 24
store_temp<felt252>([6]) -> ([6]); // 25
hades_permutation([0], [4], [19], [6]) -> ([20], [21], [22], [23]); // 26
struct_construct<Unit>() -> ([24]); // 27
enum_init<core::bool, 0>([24]) -> ([25]); // 28
store_temp<Poseidon>([20]) -> ([14]); // 29
store_temp<felt252>([21]) -> ([15]); // 30
store_temp<felt252>([22]) -> ([16]); // 31
store_temp<felt252>([23]) -> ([17]); // 32
store_temp<core::bool>([25]) -> ([18]); // 33
enum_match<core::bool>([18]) { fallthrough([26]) 46([27]) }; // 34
branch_align() -> (); // 35
drop<Unit>([26]) -> (); // 36
felt252_add([15], [2]) -> ([28]); // 37
struct_construct<Unit>() -> ([29]); // 38
enum_init<core::bool, 1>([29]) -> ([30]); // 39
store_temp<Poseidon>([14]) -> ([31]); // 40
store_temp<felt252>([28]) -> ([32]); // 41
store_temp<felt252>([16]) -> ([33]); // 42
store_temp<felt252>([17]) -> ([34]); // 43
store_temp<core::bool>([30]) -> ([35]); // 44
jump() { 58() }; // 45
branch_align() -> (); // 46
drop<Unit>([27]) -> (); // 47
felt252_add([16], [2]) -> ([36]); // 48
store_temp<felt252>([36]) -> ([36]); // 49
hades_permutation([14], [15], [36], [17]) -> ([37], [38], [39], [40]); // 50
struct_construct<Unit>() -> ([41]); // 51
enum_init<core::bool, 0>([41]) -> ([42]); // 52
store_temp<Poseidon>([37]) -> ([31]); // 53
store_temp<felt252>([38]) -> ([32]); // 54
store_temp<felt252>([39]) -> ([33]); // 55
store_temp<felt252>([40]) -> ([34]); // 56
store_temp<core::bool>([42]) -> ([35]); // 57
enum_match<core::bool>([35]) { fallthrough([43]) 70([44]) }; // 58
branch_align() -> (); // 59
drop<Unit>([43]) -> (); // 60
felt252_add([32], [3]) -> ([45]); // 61
struct_construct<Unit>() -> ([46]); // 62
enum_init<core::bool, 1>([46]) -> ([47]); // 63
store_temp<Poseidon>([31]) -> ([48]); // 64
store_temp<felt252>([45]) -> ([49]); // 65
store_temp<felt252>([33]) -> ([50]); // 66
store_temp<felt252>([34]) -> ([51]); // 67
store_temp<core::bool>([47]) -> ([52]); // 68
jump() { 82() }; // 69
branch_align() -> (); // 70
drop<Unit>([44]) -> (); // 71
felt252_add([33], [3]) -> ([53]); // 72
store_temp<felt252>([53]) -> ([53]); // 73
hades_permutation([31], [32], [53], [34]) -> ([54], [55], [56], [57]); // 74
struct_construct<Unit>() -> ([58]); // 75
enum_init<core::bool, 0>([58]) -> ([59]); // 76
store_temp<Poseidon>([54]) -> ([48]); // 77
store_temp<felt252>([55]) -> ([49]); // 78
store_temp<felt252>([56]) -> ([50]); // 79
store_temp<felt252>([57]) -> ([51]); // 80
store_temp<core::bool>([59]) -> ([52]); // 81
enum_match<core::bool>([52]) { fallthrough([60]) 94([61]) }; // 82
branch_align() -> (); // 83
drop<Unit>([60]) -> (); // 84
felt252_const<1>() -> ([62]); // 85
felt252_add([49], [62]) -> ([63]); // 86
store_temp<felt252>([63]) -> ([63]); // 87
hades_permutation([48], [63], [50], [51]) -> ([64], [65], [66], [67]); // 88
drop<felt252>([66]) -> (); // 89
drop<felt252>([67]) -> (); // 90
store_temp<Poseidon>([64]) -> ([64]); // 91
store_temp<felt252>([65]) -> ([65]); // 92
return([64], [65]); // 93
branch_align() -> (); // 94
drop<Unit>([61]) -> (); // 95
felt252_const<1>() -> ([68]); // 96
felt252_add([50], [68]) -> ([69]); // 97
store_temp<felt252>([69]) -> ([69]); // 98
hades_permutation([48], [49], [69], [51]) -> ([70], [71], [72], [73]); // 99
drop<felt252>([72]) -> (); // 100
drop<felt252>([73]) -> (); // 101
store_temp<Poseidon>([70]) -> ([70]); // 102
store_temp<felt252>([71]) -> ([71]); // 103
return([70], [71]); // 104

test::foo@0([0]: Poseidon, [1]: felt252, [2]: felt252, [3]: felt252) -> (Poseidon, felt252);
