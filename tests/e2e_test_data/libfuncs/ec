//! > ec_point_try_create libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(a: felt, b: felt) -> Option::<EcPoint> {
    ec_point_try_create(a, b)
}

//! > casm
[ap + 0] = [fp + -3] * [fp + -3], ap++;
[ap + 1] = [fp + -4] * [fp + -4], ap++;
[ap + 1] = [ap + 0] * [fp + -4], ap++;
[ap + 1] = [fp + -4] + 3141592653589793238462643383279502884197169399375105820974944592307816406665, ap++;
[ap + -3] = [ap + -1] + [ap + 0], ap++;
[ap + -5] = [ap + 0] + [ap + -4], ap++;
jmp rel 8 if [ap + -1] != 0;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
jmp rel 8;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Step: 12})

//! > sierra_code
type felt = felt;
type EcPoint = EcPoint;
type Unit = Struct<ut@Tuple>;
type core::option::Option::<core::ec::EcPoint> = Enum<ut@core::option::Option::<core::ec::EcPoint>, EcPoint, Unit>;

libfunc ec_point_try_create = ec_point_try_create;
libfunc branch_align = branch_align;
libfunc enum_init<core::option::Option::<core::ec::EcPoint>, 0> = enum_init<core::option::Option::<core::ec::EcPoint>, 0>;
libfunc store_temp<core::option::Option::<core::ec::EcPoint>> = store_temp<core::option::Option::<core::ec::EcPoint>>;
libfunc rename<core::option::Option::<core::ec::EcPoint>> = rename<core::option::Option::<core::ec::EcPoint>>;
libfunc jump = jump;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<core::ec::EcPoint>, 1> = enum_init<core::option::Option::<core::ec::EcPoint>, 1>;

ec_point_try_create([0], [1]) { fallthrough([2]) 6() };
branch_align() -> ();
enum_init<core::option::Option::<core::ec::EcPoint>, 0>([2]) -> ([3]);
store_temp<core::option::Option::<core::ec::EcPoint>>([3]) -> ([3]);
rename<core::option::Option::<core::ec::EcPoint>>([3]) -> ([4]);
jump() { 11() };
branch_align() -> ();
struct_construct<Unit>() -> ([5]);
enum_init<core::option::Option::<core::ec::EcPoint>, 1>([5]) -> ([6]);
store_temp<core::option::Option::<core::ec::EcPoint>>([6]) -> ([6]);
rename<core::option::Option::<core::ec::EcPoint>>([6]) -> ([4]);
rename<core::option::Option::<core::ec::EcPoint>>([4]) -> ([7]);
return([7]);

test::foo@0([0]: felt, [1]: felt) -> (core::option::Option::<core::ec::EcPoint>);

//! > ==========================================================================

//! > ec_point_from_felts libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(a: felt, b: felt) -> EcPoint {
    ec_point_from_felts(a, b)
}

//! > casm
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 22;
jmp rel 8 if [ap + -3] != 0;
jmp rel 2;
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [ap + -2], ap++;
jmp rel 9;
ap += 2;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -5], ap++;
ret;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -3], ap++;
ret;
[ap + 0] = [fp + -3] * [fp + -3], ap++;
[ap + 1] = [fp + -4] * [fp + -4], ap++;
[ap + 1] = [ap + 0] * [fp + -4], ap++;
[ap + 1] = [fp + -4] + 3141592653589793238462643383279502884197169399375105820974944592307816406665, ap++;
[ap + -3] = [ap + -1] + [ap + 0], ap++;
[ap + -5] = [ap + 0] + [ap + -4], ap++;
jmp rel 6 if [ap + -1] != 0;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
jmp rel 13;
%{ memory[ap + 0] = segments.add() %}
ap += 1;
[ap + 0] = 2037172927806520182083, ap++;
[ap + -1] = [[ap + -2] + 0];
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -4] + 1, ap++;
ret;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -3], ap++;
ret;

//! > function_costs
core::ec::ec_point_from_felts: OrderedHashMap({Step: 14})
test::foo: OrderedHashMap({Step: 27})

//! > sierra_code
type felt = felt;
type EcPoint = EcPoint;
type Array<felt> = Array<felt>;
type core::PanicResult::<core::ec::EcPoint> = Enum<ut@core::PanicResult::<core::ec::EcPoint>, EcPoint, Array<felt>>;
type Unit = Struct<ut@Tuple>;

libfunc store_temp<felt> = store_temp<felt>;
libfunc function_call<user@core::ec::ec_point_from_felts> = function_call<user@core::ec::ec_point_from_felts>;
libfunc enum_match<core::PanicResult::<core::ec::EcPoint>> = enum_match<core::PanicResult::<core::ec::EcPoint>>;
libfunc branch_align = branch_align;
libfunc store_temp<EcPoint> = store_temp<EcPoint>;
libfunc jump = jump;
libfunc enum_init<core::PanicResult::<core::ec::EcPoint>, 1> = enum_init<core::PanicResult::<core::ec::EcPoint>, 1>;
libfunc store_temp<core::PanicResult::<core::ec::EcPoint>> = store_temp<core::PanicResult::<core::ec::EcPoint>>;
libfunc rename<core::PanicResult::<core::ec::EcPoint>> = rename<core::PanicResult::<core::ec::EcPoint>>;
libfunc enum_init<core::PanicResult::<core::ec::EcPoint>, 0> = enum_init<core::PanicResult::<core::ec::EcPoint>, 0>;
libfunc ec_point_try_create = ec_point_try_create;
libfunc rename<EcPoint> = rename<EcPoint>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc drop<Unit> = drop<Unit>;
libfunc array_new<felt> = array_new<felt>;
libfunc felt_const<2037172927806520182083> = felt_const<2037172927806520182083>;
libfunc array_append<felt> = array_append<felt>;

store_temp<felt>([0]) -> ([3]);
store_temp<felt>([1]) -> ([4]);
function_call<user@core::ec::ec_point_from_felts>([3], [4]) -> ([2]);
enum_match<core::PanicResult::<core::ec::EcPoint>>([2]) { 4([5]) 7([6]) };
branch_align() -> ();
store_temp<EcPoint>([5]) -> ([7]);
jump() { 12() };
branch_align() -> ();
enum_init<core::PanicResult::<core::ec::EcPoint>, 1>([6]) -> ([8]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([8]) -> ([8]);
rename<core::PanicResult::<core::ec::EcPoint>>([8]) -> ([9]);
return([9]);
enum_init<core::PanicResult::<core::ec::EcPoint>, 0>([7]) -> ([10]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([10]) -> ([10]);
rename<core::PanicResult::<core::ec::EcPoint>>([10]) -> ([11]);
return([11]);
ec_point_try_create([0], [1]) { fallthrough([2]) 22() };
branch_align() -> ();
store_temp<EcPoint>([2]) -> ([2]);
rename<EcPoint>([2]) -> ([3]);
rename<EcPoint>([3]) -> ([4]);
jump() { 33() };
branch_align() -> ();
struct_construct<Unit>() -> ([5]);
drop<Unit>([5]) -> ();
array_new<felt>() -> ([6]);
felt_const<2037172927806520182083>() -> ([7]);
store_temp<felt>([7]) -> ([7]);
array_append<felt>([6], [7]) -> ([8]);
enum_init<core::PanicResult::<core::ec::EcPoint>, 1>([8]) -> ([9]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([9]) -> ([9]);
rename<core::PanicResult::<core::ec::EcPoint>>([9]) -> ([10]);
return([10]);
enum_init<core::PanicResult::<core::ec::EcPoint>, 0>([4]) -> ([11]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([11]) -> ([11]);
rename<core::PanicResult::<core::ec::EcPoint>>([11]) -> ([12]);
return([12]);

test::foo@0([0]: felt, [1]: felt) -> (core::PanicResult::<core::ec::EcPoint>);
core::ec::ec_point_from_felts@16([0]: felt, [1]: felt) -> (core::PanicResult::<core::ec::EcPoint>);

//! > ==========================================================================

//! > ec_point_unwrap libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(p: EcPoint) -> (felt, felt) {
    ec_point_unwrap(p)
}

//! > casm
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Step: 2})

//! > sierra_code
type EcPoint = EcPoint;
type felt = felt;
type Tuple<felt, felt> = Struct<ut@Tuple, felt, felt>;

libfunc ec_point_unwrap = ec_point_unwrap;
libfunc struct_construct<Tuple<felt, felt>> = struct_construct<Tuple<felt, felt>>;
libfunc store_temp<Tuple<felt, felt>> = store_temp<Tuple<felt, felt>>;
libfunc rename<Tuple<felt, felt>> = rename<Tuple<felt, felt>>;

ec_point_unwrap([0]) -> ([1], [2]);
struct_construct<Tuple<felt, felt>>([1], [2]) -> ([3]);
store_temp<Tuple<felt, felt>>([3]) -> ([3]);
rename<Tuple<felt, felt>>([3]) -> ([4]);
return([4]);

test::foo@0([0]: EcPoint) -> (Tuple<felt, felt>);

//! > ==========================================================================

//! > ec_init_state libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo() -> EcState {
    ec_init_state()
}

//! > casm
%{
from starkware.crypto.signature.signature import ALPHA, BETA, FIELD_PRIME
from starkware.python.math_utils import random_ec_point
(memory[ap + 0], memory[ap + 1]) = random_ec_point(FIELD_PRIME, ALPHA, BETA)
%}
[ap + 2] = [ap + 1] * [ap + 1], ap++;
[ap + 3] = [ap + -1] * [ap + -1], ap++;
[ap + 3] = [ap + 2] * [ap + -2], ap++;
[ap + 3] = [ap + -3] + 3141592653589793238462643383279502884197169399375105820974944592307816406665, ap++;
[ap + -1] = [ap + 1] + [ap + 2], ap++;
[ap + -3] = [ap + -2], ap++;
%{ memory[ap + 1] = segments.add() %}
[ap + -6] = [[ap + 1] + 0], ap++;
[ap + -6] = [[ap + 0] + 1], ap++;
[ap + 0] = [ap + -8], ap++;
[ap + 0] = [ap + -8], ap++;
[ap + 0] = [ap + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Step: 11})

//! > sierra_code
type EcState = EcState;

libfunc ec_init_state = ec_init_state;
libfunc store_temp<EcState> = store_temp<EcState>;
libfunc rename<EcState> = rename<EcState>;

ec_init_state() -> ([0]);
store_temp<EcState>([0]) -> ([0]);
rename<EcState>([0]) -> ([1]);
return([1]);

test::foo@0() -> (EcState);

//! > ==========================================================================

//! > ec_add_to_state libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(s: EcState, p: EcPoint) -> EcState {
    ec_add_to_state(s, p)
}

//! > casm
[fp + -4] = [ap + 0] + [fp + -7], ap++;
jmp rel 4 if [ap + -1] != 0;
jmp rel 0;
[fp + -3] = [ap + 0] + [fp + -6], ap++;
[ap + -1] = [ap + 0] * [ap + -2], ap++;
[ap + 0] = [ap + -1] * [ap + -1], ap++;
[ap + 0] = [fp + -4] + [fp + -7], ap++;
[ap + -2] = [ap + 0] + [ap + -1], ap++;
[fp + -4] = [ap + 0] + [ap + -1], ap++;
[ap + 0] = [ap + -5] * [ap + -1], ap++;
[ap + -1] = [ap + 0] + [fp + -3], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [fp + -5], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Step: 12})

//! > sierra_code
type EcState = EcState;
type EcPoint = EcPoint;

libfunc ec_add_to_state = ec_add_to_state;
libfunc store_temp<EcState> = store_temp<EcState>;
libfunc rename<EcState> = rename<EcState>;

ec_add_to_state([0], [1]) -> ([2]);
store_temp<EcState>([2]) -> ([2]);
rename<EcState>([2]) -> ([3]);
return([3]);

test::foo@0([0]: EcState, [1]: EcPoint) -> (EcState);

//! > ==========================================================================

//! > ec_try_finalize_state libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(s: EcState) -> Option::<EcPoint> {
    ec_try_finalize_state(s)
}

//! > casm
[ap + 0] = [[fp + -3] + 0], ap++;
[ap + 0] = [[fp + -3] + 1], ap++;
[fp + -5] = [ap + 0] + [ap + -2], ap++;
jmp rel 5 if [ap + -1] != 0;
[fp + -4] = [ap + -2];
jmp rel 16;
[ap + 0] = [fp + -4] + [ap + -2], ap++;
[ap + -1] = [ap + 0] * [ap + -2], ap++;
[ap + 0] = [ap + -1] * [ap + -1], ap++;
[ap + 0] = [fp + -5] + [ap + -6], ap++;
[ap + -2] = [ap + 0] + [ap + -1], ap++;
[fp + -5] = [ap + 0] + [ap + -1], ap++;
[ap + 0] = [ap + -5] * [ap + -1], ap++;
[ap + -1] = [ap + 0] + [fp + -4], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -3], ap++;
jmp rel 10;
ap += 8;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Step: 19})

//! > sierra_code
type EcState = EcState;
type EcPoint = EcPoint;
type Unit = Struct<ut@Tuple>;
type core::option::Option::<core::ec::EcPoint> = Enum<ut@core::option::Option::<core::ec::EcPoint>, EcPoint, Unit>;

libfunc ec_try_finalize_state = ec_try_finalize_state;
libfunc branch_align = branch_align;
libfunc enum_init<core::option::Option::<core::ec::EcPoint>, 0> = enum_init<core::option::Option::<core::ec::EcPoint>, 0>;
libfunc store_temp<core::option::Option::<core::ec::EcPoint>> = store_temp<core::option::Option::<core::ec::EcPoint>>;
libfunc rename<core::option::Option::<core::ec::EcPoint>> = rename<core::option::Option::<core::ec::EcPoint>>;
libfunc jump = jump;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<core::ec::EcPoint>, 1> = enum_init<core::option::Option::<core::ec::EcPoint>, 1>;

ec_try_finalize_state([0]) { fallthrough([1]) 6() };
branch_align() -> ();
enum_init<core::option::Option::<core::ec::EcPoint>, 0>([1]) -> ([2]);
store_temp<core::option::Option::<core::ec::EcPoint>>([2]) -> ([2]);
rename<core::option::Option::<core::ec::EcPoint>>([2]) -> ([3]);
jump() { 11() };
branch_align() -> ();
struct_construct<Unit>() -> ([4]);
enum_init<core::option::Option::<core::ec::EcPoint>, 1>([4]) -> ([5]);
store_temp<core::option::Option::<core::ec::EcPoint>>([5]) -> ([5]);
rename<core::option::Option::<core::ec::EcPoint>>([5]) -> ([3]);
rename<core::option::Option::<core::ec::EcPoint>>([3]) -> ([6]);
return([6]);

test::foo@0([0]: EcState) -> (core::option::Option::<core::ec::EcPoint>);

//! > ==========================================================================

//! > ec_finalize_state libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(s: EcState) -> EcPoint {
    ec_finalize_state(s)
}

//! > casm
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 22;
jmp rel 8 if [ap + -3] != 0;
jmp rel 2;
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [ap + -2], ap++;
jmp rel 9;
ap += 2;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -5], ap++;
ret;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -3], ap++;
ret;
[ap + 0] = [[fp + -3] + 0], ap++;
[ap + 0] = [[fp + -3] + 1], ap++;
[fp + -5] = [ap + 0] + [ap + -2], ap++;
jmp rel 5 if [ap + -1] != 0;
[fp + -4] = [ap + -2];
jmp rel 14;
[ap + 0] = [fp + -4] + [ap + -2], ap++;
[ap + -1] = [ap + 0] * [ap + -2], ap++;
[ap + 0] = [ap + -1] * [ap + -1], ap++;
[ap + 0] = [fp + -5] + [ap + -6], ap++;
[ap + -2] = [ap + 0] + [ap + -1], ap++;
[fp + -5] = [ap + 0] + [ap + -1], ap++;
[ap + 0] = [ap + -5] * [ap + -1], ap++;
[ap + -1] = [ap + 0] + [fp + -4], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -2], ap++;
jmp rel 15;
ap += 8;
%{ memory[ap + 0] = segments.add() %}
ap += 1;
[ap + 0] = 2037172927806520182083, ap++;
[ap + -1] = [[ap + -2] + 0];
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -4] + 1, ap++;
ret;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -3], ap++;
ret;

//! > function_costs
core::ec::ec_finalize_state: OrderedHashMap({Step: 21})
test::foo: OrderedHashMap({Step: 35})

//! > sierra_code
type EcState = EcState;
type EcPoint = EcPoint;
type felt = felt;
type Array<felt> = Array<felt>;
type core::PanicResult::<core::ec::EcPoint> = Enum<ut@core::PanicResult::<core::ec::EcPoint>, EcPoint, Array<felt>>;
type Unit = Struct<ut@Tuple>;

libfunc store_temp<EcState> = store_temp<EcState>;
libfunc function_call<user@core::ec::ec_finalize_state> = function_call<user@core::ec::ec_finalize_state>;
libfunc enum_match<core::PanicResult::<core::ec::EcPoint>> = enum_match<core::PanicResult::<core::ec::EcPoint>>;
libfunc branch_align = branch_align;
libfunc store_temp<EcPoint> = store_temp<EcPoint>;
libfunc jump = jump;
libfunc enum_init<core::PanicResult::<core::ec::EcPoint>, 1> = enum_init<core::PanicResult::<core::ec::EcPoint>, 1>;
libfunc store_temp<core::PanicResult::<core::ec::EcPoint>> = store_temp<core::PanicResult::<core::ec::EcPoint>>;
libfunc rename<core::PanicResult::<core::ec::EcPoint>> = rename<core::PanicResult::<core::ec::EcPoint>>;
libfunc enum_init<core::PanicResult::<core::ec::EcPoint>, 0> = enum_init<core::PanicResult::<core::ec::EcPoint>, 0>;
libfunc ec_try_finalize_state = ec_try_finalize_state;
libfunc rename<EcPoint> = rename<EcPoint>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc drop<Unit> = drop<Unit>;
libfunc array_new<felt> = array_new<felt>;
libfunc felt_const<2037172927806520182083> = felt_const<2037172927806520182083>;
libfunc store_temp<felt> = store_temp<felt>;
libfunc array_append<felt> = array_append<felt>;

store_temp<EcState>([0]) -> ([2]);
function_call<user@core::ec::ec_finalize_state>([2]) -> ([1]);
enum_match<core::PanicResult::<core::ec::EcPoint>>([1]) { 3([3]) 6([4]) };
branch_align() -> ();
store_temp<EcPoint>([3]) -> ([5]);
jump() { 11() };
branch_align() -> ();
enum_init<core::PanicResult::<core::ec::EcPoint>, 1>([4]) -> ([6]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([6]) -> ([6]);
rename<core::PanicResult::<core::ec::EcPoint>>([6]) -> ([7]);
return([7]);
enum_init<core::PanicResult::<core::ec::EcPoint>, 0>([5]) -> ([8]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([8]) -> ([8]);
rename<core::PanicResult::<core::ec::EcPoint>>([8]) -> ([9]);
return([9]);
ec_try_finalize_state([0]) { fallthrough([1]) 21() };
branch_align() -> ();
store_temp<EcPoint>([1]) -> ([1]);
rename<EcPoint>([1]) -> ([2]);
rename<EcPoint>([2]) -> ([3]);
jump() { 32() };
branch_align() -> ();
struct_construct<Unit>() -> ([4]);
drop<Unit>([4]) -> ();
array_new<felt>() -> ([5]);
felt_const<2037172927806520182083>() -> ([6]);
store_temp<felt>([6]) -> ([6]);
array_append<felt>([5], [6]) -> ([7]);
enum_init<core::PanicResult::<core::ec::EcPoint>, 1>([7]) -> ([8]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([8]) -> ([8]);
rename<core::PanicResult::<core::ec::EcPoint>>([8]) -> ([9]);
return([9]);
enum_init<core::PanicResult::<core::ec::EcPoint>, 0>([3]) -> ([10]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([10]) -> ([10]);
rename<core::PanicResult::<core::ec::EcPoint>>([10]) -> ([11]);
return([11]);

test::foo@0([0]: EcState) -> (core::PanicResult::<core::ec::EcPoint>);
core::ec::ec_finalize_state@15([0]: EcState) -> (core::PanicResult::<core::ec::EcPoint>);

//! > ==========================================================================

//! > ec_op_builtin libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(s: EcState, m: felt, p: EcPoint) -> EcState implicits(EcOp) {
    ec_op_builtin(s, m, p)
}

//! > casm
[fp + -8] = [[fp + -9] + 0];
[fp + -7] = [[fp + -9] + 1];
[fp + -4] = [[fp + -9] + 2];
[fp + -3] = [[fp + -9] + 3];
[fp + -5] = [[fp + -9] + 4];
[ap + 0] = [fp + -9] + 7, ap++;
[ap + 0] = [[fp + -9] + 5], ap++;
[ap + 0] = [[fp + -9] + 6], ap++;
[ap + 0] = [fp + -6], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Step: 9, EcOp: 1})

//! > sierra_code
type EcOp = EcOp;
type EcState = EcState;
type felt = felt;
type EcPoint = EcPoint;

libfunc ec_op_builtin = ec_op_builtin;
libfunc store_temp<EcOp> = store_temp<EcOp>;
libfunc rename<EcOp> = rename<EcOp>;
libfunc store_temp<EcState> = store_temp<EcState>;
libfunc rename<EcState> = rename<EcState>;

ec_op_builtin([0], [1], [2], [3]) -> ([4], [5]);
store_temp<EcOp>([4]) -> ([4]);
rename<EcOp>([4]) -> ([6]);
store_temp<EcState>([5]) -> ([5]);
rename<EcState>([5]) -> ([7]);
return([6], [7]);

test::foo@0([0]: EcOp, [1]: EcState, [2]: felt, [3]: EcPoint) -> (EcOp, EcState);

//! > ==========================================================================

//! > ec_try_op libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(p: EcPoint, m: felt, q: EcPoint) -> Option::<EcPoint> implicits(EcOp) {
    ec_try_op(p, m, q)
}

//! > casm
[ap + 0] = [fp + -8], ap++;
[ap + 0] = [fp + -7], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 3;
ret;
ap += 1;
%{
from starkware.crypto.signature.signature import ALPHA, BETA, FIELD_PRIME
from starkware.python.math_utils import random_ec_point
(memory[ap + 0], memory[ap + 1]) = random_ec_point(FIELD_PRIME, ALPHA, BETA)
%}
[ap + 2] = [ap + 1] * [ap + 1], ap++;
[ap + 3] = [ap + -1] * [ap + -1], ap++;
[ap + 3] = [ap + 2] * [ap + -2], ap++;
[ap + 3] = [ap + -3] + 3141592653589793238462643383279502884197169399375105820974944592307816406665, ap++;
[ap + -1] = [ap + 1] + [ap + 2], ap++;
[ap + -3] = [ap + -2], ap++;
%{ memory[ap + 1] = segments.add() %}
[ap + -6] = [[ap + 1] + 0], ap++;
[ap + -6] = [[ap + 0] + 1], ap++;
[ap + 0] = [ap + -8], ap++;
[ap + 0] = [ap + -8], ap++;
[ap + 0] = [ap + -3], ap++;
[fp + -7] = [ap + 0] + [ap + -3], ap++;
jmp rel 4 if [ap + -1] != 0;
jmp rel 0;
[fp + -6] = [ap + 0] + [ap + -3], ap++;
[ap + -1] = [ap + 0] * [ap + -2], ap++;
[ap + 0] = [ap + -1] * [ap + -1], ap++;
[ap + 0] = [fp + -7] + [ap + -7], ap++;
[ap + -2] = [ap + 0] + [ap + -1], ap++;
[fp + -7] = [ap + 0] + [ap + -1], ap++;
[ap + 0] = [ap + -5] * [ap + -1], ap++;
[ap + -1] = [ap + 0] + [fp + -6], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [ap + -12], ap++;
[ap + -3] = [[fp + -8] + 0];
[ap + -2] = [[fp + -8] + 1];
[fp + -4] = [[fp + -8] + 2];
[fp + -3] = [[fp + -8] + 3];
[fp + -5] = [[fp + -8] + 4];
[ap + 0] = [[fp + -8] + 5], ap++;
[ap + 0] = [[fp + -8] + 6], ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [fp + -8] + 7, ap++;
[fp + 0] = [ap + -1];
[ap + 0] = [[ap + -2] + 0], ap++;
[ap + 0] = [[ap + -3] + 1], ap++;
[ap + -6] = [ap + 0] + [ap + -2], ap++;
jmp rel 5 if [ap + -1] != 0;
[ap + -6] = [ap + -2];
jmp rel 16;
[ap + 0] = [ap + -6] + [ap + -2], ap++;
[ap + -1] = [ap + 0] * [ap + -2], ap++;
[ap + 0] = [ap + -1] * [ap + -1], ap++;
[ap + 0] = [ap + -10] + [ap + -6], ap++;
[ap + -2] = [ap + 0] + [ap + -1], ap++;
[ap + -12] = [ap + 0] + [ap + -1], ap++;
[ap + 0] = [ap + -5] * [ap + -1], ap++;
[ap + -1] = [ap + 0] + [ap + -13], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -3], ap++;
jmp rel 10;
ap += 8;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + 0], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -4], ap++;
ret;

//! > function_costs
core::ec::ec_try_op: OrderedHashMap({Step: 58, EcOp: 1})
test::foo: OrderedHashMap({Step: 66, EcOp: 1})

//! > sierra_code
type EcOp = EcOp;
type EcPoint = EcPoint;
type felt = felt;
type Unit = Struct<ut@Tuple>;
type core::option::Option::<core::ec::EcPoint> = Enum<ut@core::option::Option::<core::ec::EcPoint>, EcPoint, Unit>;
type Uninitialized<EcOp> = Uninitialized<EcOp>;
type EcState = EcState;

libfunc store_temp<EcOp> = store_temp<EcOp>;
libfunc store_temp<EcPoint> = store_temp<EcPoint>;
libfunc store_temp<felt> = store_temp<felt>;
libfunc function_call<user@core::ec::ec_try_op> = function_call<user@core::ec::ec_try_op>;
libfunc rename<EcOp> = rename<EcOp>;
libfunc rename<core::option::Option::<core::ec::EcPoint>> = rename<core::option::Option::<core::ec::EcPoint>>;
libfunc alloc_local<EcOp> = alloc_local<EcOp>;
libfunc finalize_locals = finalize_locals;
libfunc ec_init_state = ec_init_state;
libfunc store_temp<EcState> = store_temp<EcState>;
libfunc ec_add_to_state = ec_add_to_state;
libfunc ec_op_builtin = ec_op_builtin;
libfunc store_local<EcOp> = store_local<EcOp>;
libfunc ec_try_finalize_state = ec_try_finalize_state;
libfunc branch_align = branch_align;
libfunc enum_init<core::option::Option::<core::ec::EcPoint>, 0> = enum_init<core::option::Option::<core::ec::EcPoint>, 0>;
libfunc store_temp<core::option::Option::<core::ec::EcPoint>> = store_temp<core::option::Option::<core::ec::EcPoint>>;
libfunc jump = jump;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<core::ec::EcPoint>, 1> = enum_init<core::option::Option::<core::ec::EcPoint>, 1>;

store_temp<EcOp>([0]) -> ([6]);
store_temp<EcPoint>([1]) -> ([7]);
store_temp<felt>([2]) -> ([8]);
store_temp<EcPoint>([3]) -> ([9]);
function_call<user@core::ec::ec_try_op>([6], [7], [8], [9]) -> ([4], [5]);
rename<EcOp>([4]) -> ([10]);
rename<core::option::Option::<core::ec::EcPoint>>([5]) -> ([11]);
return([10], [11]);
alloc_local<EcOp>() -> ([5]);
finalize_locals() -> ();
ec_init_state() -> ([6]);
store_temp<EcState>([6]) -> ([6]);
ec_add_to_state([6], [1]) -> ([7]);
store_temp<EcState>([7]) -> ([7]);
ec_op_builtin([0], [7], [2], [3]) -> ([4], [8]);
store_temp<EcState>([8]) -> ([8]);
store_temp<EcOp>([4]) -> ([4]);
store_local<EcOp>([5], [4]) -> ([4]);
ec_try_finalize_state([8]) { fallthrough([9]) 24() };
branch_align() -> ();
enum_init<core::option::Option::<core::ec::EcPoint>, 0>([9]) -> ([10]);
store_temp<core::option::Option::<core::ec::EcPoint>>([10]) -> ([10]);
rename<core::option::Option::<core::ec::EcPoint>>([10]) -> ([11]);
jump() { 29() };
branch_align() -> ();
struct_construct<Unit>() -> ([12]);
enum_init<core::option::Option::<core::ec::EcPoint>, 1>([12]) -> ([13]);
store_temp<core::option::Option::<core::ec::EcPoint>>([13]) -> ([13]);
rename<core::option::Option::<core::ec::EcPoint>>([13]) -> ([11]);
store_temp<EcOp>([4]) -> ([14]);
store_temp<core::option::Option::<core::ec::EcPoint>>([11]) -> ([15]);
return([14], [15]);

test::foo@0([0]: EcOp, [1]: EcPoint, [2]: felt, [3]: EcPoint) -> (EcOp, core::option::Option::<core::ec::EcPoint>);
core::ec::ec_try_op@8([0]: EcOp, [1]: EcPoint, [2]: felt, [3]: EcPoint) -> (EcOp, core::option::Option::<core::ec::EcPoint>);

//! > ==========================================================================

//! > ec_op libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(p: EcPoint, m: felt, q: EcPoint) -> EcPoint implicits(EcOp) {
    ec_op(p, m, q)
}

//! > casm
[ap + 0] = [fp + -8], ap++;
[ap + 0] = [fp + -7], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 24;
jmp rel 8 if [ap + -3] != 0;
jmp rel 2;
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [ap + -2], ap++;
jmp rel 10;
ap += 2;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6], ap++;
ret;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -4], ap++;
ret;
[ap + 0] = [fp + -8], ap++;
[ap + 0] = [fp + -7], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 28;
jmp rel 8 if [ap + -3] != 0;
jmp rel 2;
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [ap + -2], ap++;
jmp rel 14;
%{ memory[ap + 0] = segments.add() %}
ap += 1;
[ap + 0] = 2037172927806520182083, ap++;
[ap + -1] = [[ap + -2] + 0];
[ap + 0] = [ap + -6], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -5] + 1, ap++;
ret;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -4], ap++;
ret;
ap += 1;
%{
from starkware.crypto.signature.signature import ALPHA, BETA, FIELD_PRIME
from starkware.python.math_utils import random_ec_point
(memory[ap + 0], memory[ap + 1]) = random_ec_point(FIELD_PRIME, ALPHA, BETA)
%}
[ap + 2] = [ap + 1] * [ap + 1], ap++;
[ap + 3] = [ap + -1] * [ap + -1], ap++;
[ap + 3] = [ap + 2] * [ap + -2], ap++;
[ap + 3] = [ap + -3] + 3141592653589793238462643383279502884197169399375105820974944592307816406665, ap++;
[ap + -1] = [ap + 1] + [ap + 2], ap++;
[ap + -3] = [ap + -2], ap++;
%{ memory[ap + 1] = segments.add() %}
[ap + -6] = [[ap + 1] + 0], ap++;
[ap + -6] = [[ap + 0] + 1], ap++;
[ap + 0] = [ap + -8], ap++;
[ap + 0] = [ap + -8], ap++;
[ap + 0] = [ap + -3], ap++;
[fp + -7] = [ap + 0] + [ap + -3], ap++;
jmp rel 4 if [ap + -1] != 0;
jmp rel 0;
[fp + -6] = [ap + 0] + [ap + -3], ap++;
[ap + -1] = [ap + 0] * [ap + -2], ap++;
[ap + 0] = [ap + -1] * [ap + -1], ap++;
[ap + 0] = [fp + -7] + [ap + -7], ap++;
[ap + -2] = [ap + 0] + [ap + -1], ap++;
[fp + -7] = [ap + 0] + [ap + -1], ap++;
[ap + 0] = [ap + -5] * [ap + -1], ap++;
[ap + -1] = [ap + 0] + [fp + -6], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [ap + -12], ap++;
[ap + -3] = [[fp + -8] + 0];
[ap + -2] = [[fp + -8] + 1];
[fp + -4] = [[fp + -8] + 2];
[fp + -3] = [[fp + -8] + 3];
[fp + -5] = [[fp + -8] + 4];
[ap + 0] = [[fp + -8] + 5], ap++;
[ap + 0] = [[fp + -8] + 6], ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [fp + -8] + 7, ap++;
[fp + 0] = [ap + -1];
[ap + 0] = [[ap + -2] + 0], ap++;
[ap + 0] = [[ap + -3] + 1], ap++;
[ap + -6] = [ap + 0] + [ap + -2], ap++;
jmp rel 5 if [ap + -1] != 0;
[ap + -6] = [ap + -2];
jmp rel 16;
[ap + 0] = [ap + -6] + [ap + -2], ap++;
[ap + -1] = [ap + 0] * [ap + -2], ap++;
[ap + 0] = [ap + -1] * [ap + -1], ap++;
[ap + 0] = [ap + -10] + [ap + -6], ap++;
[ap + -2] = [ap + 0] + [ap + -1], ap++;
[ap + -12] = [ap + 0] + [ap + -1], ap++;
[ap + 0] = [ap + -5] * [ap + -1], ap++;
[ap + -1] = [ap + 0] + [ap + -13], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -3], ap++;
jmp rel 10;
ap += 8;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + 0], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -4], ap++;
ret;

//! > function_costs
core::ec::ec_op: OrderedHashMap({Step: 76, EcOp: 1})
core::ec::ec_try_op: OrderedHashMap({Step: 58, EcOp: 1})
test::foo: OrderedHashMap({Step: 94, EcOp: 1})

//! > sierra_code
type EcOp = EcOp;
type EcPoint = EcPoint;
type felt = felt;
type Array<felt> = Array<felt>;
type core::PanicResult::<core::ec::EcPoint> = Enum<ut@core::PanicResult::<core::ec::EcPoint>, EcPoint, Array<felt>>;
type Unit = Struct<ut@Tuple>;
type core::option::Option::<core::ec::EcPoint> = Enum<ut@core::option::Option::<core::ec::EcPoint>, EcPoint, Unit>;
type Uninitialized<EcOp> = Uninitialized<EcOp>;
type EcState = EcState;

libfunc store_temp<EcOp> = store_temp<EcOp>;
libfunc store_temp<EcPoint> = store_temp<EcPoint>;
libfunc store_temp<felt> = store_temp<felt>;
libfunc function_call<user@core::ec::ec_op> = function_call<user@core::ec::ec_op>;
libfunc enum_match<core::PanicResult::<core::ec::EcPoint>> = enum_match<core::PanicResult::<core::ec::EcPoint>>;
libfunc branch_align = branch_align;
libfunc jump = jump;
libfunc enum_init<core::PanicResult::<core::ec::EcPoint>, 1> = enum_init<core::PanicResult::<core::ec::EcPoint>, 1>;
libfunc store_temp<core::PanicResult::<core::ec::EcPoint>> = store_temp<core::PanicResult::<core::ec::EcPoint>>;
libfunc rename<core::PanicResult::<core::ec::EcPoint>> = rename<core::PanicResult::<core::ec::EcPoint>>;
libfunc enum_init<core::PanicResult::<core::ec::EcPoint>, 0> = enum_init<core::PanicResult::<core::ec::EcPoint>, 0>;
libfunc function_call<user@core::ec::ec_try_op> = function_call<user@core::ec::ec_try_op>;
libfunc enum_match<core::option::Option::<core::ec::EcPoint>> = enum_match<core::option::Option::<core::ec::EcPoint>>;
libfunc rename<EcPoint> = rename<EcPoint>;
libfunc drop<Unit> = drop<Unit>;
libfunc array_new<felt> = array_new<felt>;
libfunc felt_const<2037172927806520182083> = felt_const<2037172927806520182083>;
libfunc array_append<felt> = array_append<felt>;
libfunc alloc_local<EcOp> = alloc_local<EcOp>;
libfunc finalize_locals = finalize_locals;
libfunc ec_init_state = ec_init_state;
libfunc store_temp<EcState> = store_temp<EcState>;
libfunc ec_add_to_state = ec_add_to_state;
libfunc ec_op_builtin = ec_op_builtin;
libfunc store_local<EcOp> = store_local<EcOp>;
libfunc ec_try_finalize_state = ec_try_finalize_state;
libfunc enum_init<core::option::Option::<core::ec::EcPoint>, 0> = enum_init<core::option::Option::<core::ec::EcPoint>, 0>;
libfunc store_temp<core::option::Option::<core::ec::EcPoint>> = store_temp<core::option::Option::<core::ec::EcPoint>>;
libfunc rename<core::option::Option::<core::ec::EcPoint>> = rename<core::option::Option::<core::ec::EcPoint>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<core::ec::EcPoint>, 1> = enum_init<core::option::Option::<core::ec::EcPoint>, 1>;

store_temp<EcOp>([0]) -> ([6]);
store_temp<EcPoint>([1]) -> ([7]);
store_temp<felt>([2]) -> ([8]);
store_temp<EcPoint>([3]) -> ([9]);
function_call<user@core::ec::ec_op>([6], [7], [8], [9]) -> ([4], [5]);
enum_match<core::PanicResult::<core::ec::EcPoint>>([5]) { 6([10]) 9([11]) };
branch_align() -> ();
store_temp<EcPoint>([10]) -> ([12]);
jump() { 15() };
branch_align() -> ();
enum_init<core::PanicResult::<core::ec::EcPoint>, 1>([11]) -> ([13]);
store_temp<EcOp>([4]) -> ([14]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([13]) -> ([13]);
rename<core::PanicResult::<core::ec::EcPoint>>([13]) -> ([15]);
return([14], [15]);
enum_init<core::PanicResult::<core::ec::EcPoint>, 0>([12]) -> ([16]);
store_temp<EcOp>([4]) -> ([17]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([16]) -> ([16]);
rename<core::PanicResult::<core::ec::EcPoint>>([16]) -> ([18]);
return([17], [18]);
store_temp<EcOp>([0]) -> ([6]);
store_temp<EcPoint>([1]) -> ([7]);
store_temp<felt>([2]) -> ([8]);
store_temp<EcPoint>([3]) -> ([9]);
function_call<user@core::ec::ec_try_op>([6], [7], [8], [9]) -> ([4], [5]);
enum_match<core::option::Option::<core::ec::EcPoint>>([5]) { 26([10]) 30([11]) };
branch_align() -> ();
store_temp<EcPoint>([10]) -> ([12]);
rename<EcPoint>([12]) -> ([13]);
jump() { 41() };
branch_align() -> ();
drop<Unit>([11]) -> ();
array_new<felt>() -> ([14]);
felt_const<2037172927806520182083>() -> ([15]);
store_temp<felt>([15]) -> ([15]);
array_append<felt>([14], [15]) -> ([16]);
enum_init<core::PanicResult::<core::ec::EcPoint>, 1>([16]) -> ([17]);
store_temp<EcOp>([4]) -> ([18]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([17]) -> ([17]);
rename<core::PanicResult::<core::ec::EcPoint>>([17]) -> ([19]);
return([18], [19]);
enum_init<core::PanicResult::<core::ec::EcPoint>, 0>([13]) -> ([20]);
store_temp<EcOp>([4]) -> ([21]);
store_temp<core::PanicResult::<core::ec::EcPoint>>([20]) -> ([20]);
rename<core::PanicResult::<core::ec::EcPoint>>([20]) -> ([22]);
return([21], [22]);
alloc_local<EcOp>() -> ([5]);
finalize_locals() -> ();
ec_init_state() -> ([6]);
store_temp<EcState>([6]) -> ([6]);
ec_add_to_state([6], [1]) -> ([7]);
store_temp<EcState>([7]) -> ([7]);
ec_op_builtin([0], [7], [2], [3]) -> ([4], [8]);
store_temp<EcState>([8]) -> ([8]);
store_temp<EcOp>([4]) -> ([4]);
store_local<EcOp>([5], [4]) -> ([4]);
ec_try_finalize_state([8]) { fallthrough([9]) 62() };
branch_align() -> ();
enum_init<core::option::Option::<core::ec::EcPoint>, 0>([9]) -> ([10]);
store_temp<core::option::Option::<core::ec::EcPoint>>([10]) -> ([10]);
rename<core::option::Option::<core::ec::EcPoint>>([10]) -> ([11]);
jump() { 67() };
branch_align() -> ();
struct_construct<Unit>() -> ([12]);
enum_init<core::option::Option::<core::ec::EcPoint>, 1>([12]) -> ([13]);
store_temp<core::option::Option::<core::ec::EcPoint>>([13]) -> ([13]);
rename<core::option::Option::<core::ec::EcPoint>>([13]) -> ([11]);
store_temp<EcOp>([4]) -> ([14]);
store_temp<core::option::Option::<core::ec::EcPoint>>([11]) -> ([15]);
return([14], [15]);

test::foo@0([0]: EcOp, [1]: EcPoint, [2]: felt, [3]: EcPoint) -> (EcOp, core::PanicResult::<core::ec::EcPoint>);
core::ec::ec_op@20([0]: EcOp, [1]: EcPoint, [2]: felt, [3]: EcPoint) -> (EcOp, core::PanicResult::<core::ec::EcPoint>);
core::ec::ec_try_op@46([0]: EcOp, [1]: EcPoint, [2]: felt, [3]: EcPoint) -> (EcOp, core::option::Option::<core::ec::EcPoint>);
