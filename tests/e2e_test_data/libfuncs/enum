//! > init enum with a single variant

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
enum SingleVariant {
    Variant: felt252,
}

fn foo() -> SingleVariant {
    SingleVariant::Variant(5)
}

//! > casm
[ap + 0] = 0, ap++;
[ap + 0] = 5, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 200})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::SingleVariant = Enum<ut@test::SingleVariant, felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 5> = Const<felt252, 5> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<felt252, 5>> = const_as_immediate<Const<felt252, 5>>;
libfunc enum_init<test::SingleVariant, 0> = enum_init<test::SingleVariant, 0>;
libfunc store_temp<test::SingleVariant> = store_temp<test::SingleVariant>;

F0:
const_as_immediate<Const<felt252, 5>>() -> ([0]);
enum_init<test::SingleVariant, 0>([0]) -> ([1]);
store_temp<test::SingleVariant>([1]) -> ([1]);
return([1]);

test::foo@F0() -> (test::SingleVariant);

//! > ==========================================================================

//! > match enum with a single variant

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
enum SingleVariant {
    Variant: felt252,
}

fn foo(e: SingleVariant) -> felt252 {
    match e {
        SingleVariant::Variant(_x) => 0,
    }
}

//! > casm
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 100})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::SingleVariant = Enum<ut@test::SingleVariant, felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 0> = Const<felt252, 0> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc enum_match<test::SingleVariant> = enum_match<test::SingleVariant>;
libfunc branch_align = branch_align;
libfunc drop<felt252> = drop<felt252>;
libfunc const_as_immediate<Const<felt252, 0>> = const_as_immediate<Const<felt252, 0>>;
libfunc store_temp<felt252> = store_temp<felt252>;

F0:
enum_match<test::SingleVariant>([0]) -> ([1]);
branch_align() -> ();
drop<felt252>([1]) -> ();
const_as_immediate<Const<felt252, 0>>() -> ([2]);
store_temp<felt252>([2]) -> ([2]);
return([2]);

test::foo@F0([0]: test::SingleVariant) -> (felt252);

//! > ==========================================================================

//! > init enum with 2 variants

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
enum Option {
    Some: felt252,
    None: (),
}

fn foo() -> Option {
    Option::Some(5)
}

//! > casm
[ap + 0] = 0, ap++;
[ap + 0] = 5, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 200})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::Option = Enum<ut@test::Option, felt252, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 5> = Const<felt252, 5> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<felt252, 5>> = const_as_immediate<Const<felt252, 5>>;
libfunc enum_init<test::Option, 0> = enum_init<test::Option, 0>;
libfunc store_temp<test::Option> = store_temp<test::Option>;

F0:
const_as_immediate<Const<felt252, 5>>() -> ([0]);
enum_init<test::Option, 0>([0]) -> ([1]);
store_temp<test::Option>([1]) -> ([1]);
return([1]);

test::foo@F0() -> (test::Option);

//! > ==========================================================================

//! > match enum with 2 variants

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
enum Option {
    Some: felt252,
    None: (),
}

fn foo(e: Option) -> felt252 {
    match e {
        Option::Some(_) => 0,
        Option::None => 1,
    }
}

//! > casm
jmp rel 5 if [fp + -4] != 0;
[ap + 0] = 0, ap++;
ret;
[ap + 0] = 1, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 200})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::Option = Enum<ut@test::Option, felt252, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 1> = Const<felt252, 1> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<felt252, 0> = Const<felt252, 0> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc enum_match<test::Option> = enum_match<test::Option>;
libfunc branch_align = branch_align;
libfunc drop<felt252> = drop<felt252>;
libfunc const_as_immediate<Const<felt252, 0>> = const_as_immediate<Const<felt252, 0>>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc drop<Unit> = drop<Unit>;
libfunc const_as_immediate<Const<felt252, 1>> = const_as_immediate<Const<felt252, 1>>;

F0:
enum_match<test::Option>([0]) { fallthrough([1]) F0_B0([2]) };
branch_align() -> ();
drop<felt252>([1]) -> ();
const_as_immediate<Const<felt252, 0>>() -> ([3]);
store_temp<felt252>([3]) -> ([3]);
return([3]);
F0_B0:
branch_align() -> ();
drop<Unit>([2]) -> ();
const_as_immediate<Const<felt252, 1>>() -> ([4]);
store_temp<felt252>([4]) -> ([4]);
return([4]);

test::foo@F0([0]: test::Option) -> (felt252);

//! > ==========================================================================

//! > init a non-first variant in an enum with more than 2 variants

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
enum Color {
    Red: felt252,
    Green: felt252,
    Blue: felt252,
}

fn foo() -> Color {
    Color::Blue(10)
}

//! > casm
[ap + 0] = 1, ap++;
[ap + 0] = 10, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 200})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::Color = Enum<ut@test::Color, felt252, felt252, felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 10> = Const<felt252, 10> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<felt252, 10>> = const_as_immediate<Const<felt252, 10>>;
libfunc enum_init<test::Color, 2> = enum_init<test::Color, 2>;
libfunc store_temp<test::Color> = store_temp<test::Color>;

F0:
const_as_immediate<Const<felt252, 10>>() -> ([0]);
enum_init<test::Color, 2>([0]) -> ([1]);
store_temp<test::Color>([1]) -> ([1]);
return([1]);

test::foo@F0() -> (test::Color);

//! > ==========================================================================

//! > init the first variant in an enum with more than 2 variants

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
enum Color {
    Red: felt252,
    Green: felt252,
    Blue: felt252,
}

fn foo() -> Color {
    Color::Red(10)
}

//! > casm
[ap + 0] = 5, ap++;
[ap + 0] = 10, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 200})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::Color = Enum<ut@test::Color, felt252, felt252, felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 10> = Const<felt252, 10> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<felt252, 10>> = const_as_immediate<Const<felt252, 10>>;
libfunc enum_init<test::Color, 0> = enum_init<test::Color, 0>;
libfunc store_temp<test::Color> = store_temp<test::Color>;

F0:
const_as_immediate<Const<felt252, 10>>() -> ([0]);
enum_init<test::Color, 0>([0]) -> ([1]);
store_temp<test::Color>([1]) -> ([1]);
return([1]);

test::foo@F0() -> (test::Color);

//! > ==========================================================================

//! > match enum with more than 2 variants

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
enum Color {
    Red: felt252,
    Green: felt252,
    Blue: felt252,
}

fn foo(e: Color) -> felt252 {
    match e {
        Color::Red(_) => 0,
        Color::Green(_) => 1,
        Color::Blue(_) => 2,
    }
}

//! > casm
jmp rel [fp + -4];
jmp rel 10;
jmp rel 5;
[ap + 0] = 0, ap++;
ret;
[ap + 0] = 1, ap++;
ret;
[ap + 0] = 2, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 300})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::Color = Enum<ut@test::Color, felt252, felt252, felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 2> = Const<felt252, 2> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<felt252, 1> = Const<felt252, 1> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<felt252, 0> = Const<felt252, 0> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc enum_match<test::Color> = enum_match<test::Color>;
libfunc branch_align = branch_align;
libfunc drop<felt252> = drop<felt252>;
libfunc const_as_immediate<Const<felt252, 0>> = const_as_immediate<Const<felt252, 0>>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc const_as_immediate<Const<felt252, 1>> = const_as_immediate<Const<felt252, 1>>;
libfunc const_as_immediate<Const<felt252, 2>> = const_as_immediate<Const<felt252, 2>>;

F0:
enum_match<test::Color>([0]) { fallthrough([1]) F0_B0([2]) F0_B1([3]) };
branch_align() -> ();
drop<felt252>([1]) -> ();
const_as_immediate<Const<felt252, 0>>() -> ([4]);
store_temp<felt252>([4]) -> ([4]);
return([4]);
F0_B0:
branch_align() -> ();
drop<felt252>([2]) -> ();
const_as_immediate<Const<felt252, 1>>() -> ([5]);
store_temp<felt252>([5]) -> ([5]);
return([5]);
F0_B1:
branch_align() -> ();
drop<felt252>([3]) -> ();
const_as_immediate<Const<felt252, 2>>() -> ([6]);
store_temp<felt252>([6]) -> ([6]);
return([6]);

test::foo@F0([0]: test::Color) -> (felt252);

//! > ==========================================================================

//! > long enum from BoundedInt<4>

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
enum IndexEnum5 {
    Zero,
    One,
    Two,
    Three,
    Four,
}
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;


extern fn enum_from_bounded_int<T>(index: BoundedInt<0, 4>) -> T nopanic;

// This wrapper is required so that the compiler won't assume extern `enum_from_bounded_int` is a
// branch function.
fn gen_foo<T>(index: BoundedInt<0, 4>) -> T {
    enum_from_bounded_int(index)
}

fn foo(index: BoundedInt<0, 4>) -> IndexEnum5 {
    gen_foo(index)
}

//! > casm
[fp + -3] = [ap + 0] + 1809251394333065606848661391547535052811553607665798349986546028067936010245, ap++;
[ap + 0] = [ap + -1] * -2, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 200})

//! > sierra_code
type BoundedInt<0, 4> = BoundedInt<0, 4> [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::IndexEnum5 = Enum<ut@test::IndexEnum5, Unit, Unit, Unit, Unit, Unit> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_from_bounded_int<test::IndexEnum5> = enum_from_bounded_int<test::IndexEnum5>;
libfunc store_temp<test::IndexEnum5> = store_temp<test::IndexEnum5>;

F0:
enum_from_bounded_int<test::IndexEnum5>([0]) -> ([1]);
store_temp<test::IndexEnum5>([1]) -> ([1]);
return([1]);

test::foo@F0([0]: BoundedInt<0, 4>) -> (test::IndexEnum5);

//! > ==========================================================================

//! > short enum from BoundedInt<0, 1>

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
enum IndexEnum2 {
    Zero,
    One,
}
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;


extern fn enum_from_bounded_int<T>(index: BoundedInt<0, 1>) -> T nopanic;

// This wrapper is required so that the compiler won't assume extern `enum_from_bounded_int` is a
// branch function.
fn gen_foo<T>(index: BoundedInt<0, 1>) -> T {
    enum_from_bounded_int(index)
}

fn foo(index: BoundedInt<0, 1>) -> IndexEnum2 {
    gen_foo(index)
}

//! > casm
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 100})

//! > sierra_code
type BoundedInt<0, 1> = BoundedInt<0, 1> [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::IndexEnum2 = Enum<ut@test::IndexEnum2, Unit, Unit> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_from_bounded_int<test::IndexEnum2> = enum_from_bounded_int<test::IndexEnum2>;
libfunc store_temp<test::IndexEnum2> = store_temp<test::IndexEnum2>;

F0:
enum_from_bounded_int<test::IndexEnum2>([0]) -> ([1]);
store_temp<test::IndexEnum2>([1]) -> ([1]);
return([1]);

test::foo@F0([0]: BoundedInt<0, 1>) -> (test::IndexEnum2);

//! > ==========================================================================

//! > long enum from BoundedInt<0>

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
enum IndexEnum1 {
    Zero,
}
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;


extern fn enum_from_bounded_int<T>(index: BoundedInt<0, 0>) -> T nopanic;

// This wrapper is required so that the compiler won't assume extern `enum_from_bounded_int` is a
// branch function.
fn gen_foo<T>(index: BoundedInt<0, 0>) -> T {
    enum_from_bounded_int(index)
}

fn foo(index: BoundedInt<0, 0>) -> IndexEnum1 {
    gen_foo(index)
}

//! > casm
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 100})

//! > sierra_code
type BoundedInt<0, 0> = BoundedInt<0, 0> [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::IndexEnum1 = Enum<ut@test::IndexEnum1, Unit> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_from_bounded_int<test::IndexEnum1> = enum_from_bounded_int<test::IndexEnum1>;
libfunc store_temp<test::IndexEnum1> = store_temp<test::IndexEnum1>;

F0:
enum_from_bounded_int<test::IndexEnum1>([0]) -> ([1]);
store_temp<test::IndexEnum1>([1]) -> ([1]);
return([1]);

test::foo@F0([0]: BoundedInt<0, 0>) -> (test::IndexEnum1);

//! > ==========================================================================

//! > boxed match enum with 1 variant

//! > test_runner_name
SmallE2ETestRunner(test_data: add_123(5) = 128)

//! > cairo_code
enum Single {
    Value: felt252,
}

enum BoxedSingle {
    Value: Box<felt252>,
}

extern fn enum_boxed_match<T>(e: Box<T>) -> BoxedSingle nopanic;

fn foo(e: Box<Single>) -> BoxedSingle {
    enum_boxed_match(e)
}

fn add_123(x: felt252) -> felt252 {
    let boxed = BoxTrait::new(Single::Value(x));
    match foo(boxed) {
        BoxedSingle::Value(boxed_x) => boxed_x.unbox() + 123,
    }
}

//! > casm
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3] + 1, ap++;
ret;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3], ap++;
%{
if '__boxed_segment' not in globals():
    __boxed_segment = segments.add()
memory[ap + 0] = __boxed_segment
__boxed_segment += 2
%}
[ap + -2] = [[ap + 0] + 0], ap++;
[ap + -2] = [[ap + -1] + 1];
[ap + 0] = [ap + -1] + 1, ap++;
[ap + 0] = [[ap + -1] + 0], ap++;
[ap + 0] = [ap + -1] + 123, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 200})
test::add_123: SmallOrderedMap({Const: 700})

//! > sierra_code
type Box<test::Single> = Box<test::Single> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 123> = Const<felt252, 123> [storable: false, drop: false, dup: false, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Box<felt252> = Box<felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type test::BoxedSingle = Enum<ut@test::BoxedSingle, Box<felt252>> [storable: true, drop: true, dup: true, zero_sized: false];
type test::Single = Enum<ut@test::Single, felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_boxed_match<test::Single> = enum_boxed_match<test::Single>;
libfunc branch_align = branch_align;
libfunc enum_init<test::BoxedSingle, 0> = enum_init<test::BoxedSingle, 0>;
libfunc store_temp<test::BoxedSingle> = store_temp<test::BoxedSingle>;
libfunc enum_init<test::Single, 0> = enum_init<test::Single, 0>;
libfunc store_temp<test::Single> = store_temp<test::Single>;
libfunc into_box<test::Single> = into_box<test::Single>;
libfunc store_temp<Box<felt252>> = store_temp<Box<felt252>>;
libfunc unbox<felt252> = unbox<felt252>;
libfunc const_as_immediate<Const<felt252, 123>> = const_as_immediate<Const<felt252, 123>>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc felt252_add = felt252_add;

F0:
enum_boxed_match<test::Single>([0]) -> ([1]);
branch_align() -> ();
enum_init<test::BoxedSingle, 0>([1]) -> ([2]);
store_temp<test::BoxedSingle>([2]) -> ([2]);
return([2]);
F1:
enum_init<test::Single, 0>([0]) -> ([1]);
store_temp<test::Single>([1]) -> ([1]);
into_box<test::Single>([1]) -> ([2]);
enum_boxed_match<test::Single>([2]) -> ([3]);
branch_align() -> ();
store_temp<Box<felt252>>([3]) -> ([3]);
unbox<felt252>([3]) -> ([4]);
const_as_immediate<Const<felt252, 123>>() -> ([5]);
store_temp<felt252>([4]) -> ([4]);
felt252_add([4], [5]) -> ([6]);
store_temp<felt252>([6]) -> ([6]);
return([6]);

test::foo@F0([0]: Box<test::Single>) -> (test::BoxedSingle);
test::add_123@F1([0]: felt252) -> (felt252);

//! > ==========================================================================

//! > boxed match enum with 2 variants

//! > test_runner_name
SmallE2ETestRunner(test_data: add_123(5) = 128)

//! > cairo_code
enum BoxedOption {
    Some: Box<felt252>,
    None: Box<()>,
}

extern fn enum_boxed_match<T>(e: Box<T>) -> BoxedOption nopanic;

fn foo(e: Box<Option<felt252>>) -> BoxedOption {
    enum_boxed_match(e)
}

fn add_123(x: felt252) -> felt252 {
    let boxed = BoxTrait::new(Some(x));
    match foo(boxed) {
        BoxedOption::Some(boxed_x) => boxed_x.unbox() + 123,
        _ => 999,
    }
}

//! > casm
[ap + 0] = [[fp + -3] + 0], ap++;
jmp rel 7 if [ap + -1] != 0;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3] + 1, ap++;
ret;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -3] + 2, ap++;
ret;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3], ap++;
%{
if '__boxed_segment' not in globals():
    __boxed_segment = segments.add()
memory[ap + 0] = __boxed_segment
__boxed_segment += 2
%}
[ap + -2] = [[ap + 0] + 0], ap++;
[ap + -2] = [[ap + -1] + 1];
[ap + 0] = [[ap + -1] + 0], ap++;
jmp rel 8 if [ap + -1] != 0;
[ap + 0] = [ap + -2] + 1, ap++;
[ap + 0] = [[ap + -1] + 0], ap++;
[ap + 0] = [ap + -1] + 123, ap++;
ret;
ap += 2;
[ap + 0] = 999, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 400})
test::add_123: SmallOrderedMap({Const: 900})

//! > sierra_code
type Box<core::option::Option::<core::felt252>> = Box<core::option::Option::<core::felt252>> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 999> = Const<felt252, 999> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<felt252, 123> = Const<felt252, 123> [storable: false, drop: false, dup: false, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Box<felt252> = Box<felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type Box<Unit> = Box<Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type test::BoxedOption = Enum<ut@test::BoxedOption, Box<felt252>, Box<Unit>> [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type core::option::Option::<core::felt252> = Enum<ut@core::option::Option::<core::felt252>, felt252, Unit> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_boxed_match<core::option::Option::<core::felt252>> = enum_boxed_match<core::option::Option::<core::felt252>>;
libfunc branch_align = branch_align;
libfunc enum_init<test::BoxedOption, 0> = enum_init<test::BoxedOption, 0>;
libfunc store_temp<test::BoxedOption> = store_temp<test::BoxedOption>;
libfunc enum_init<test::BoxedOption, 1> = enum_init<test::BoxedOption, 1>;
libfunc enum_init<core::option::Option::<core::felt252>, 0> = enum_init<core::option::Option::<core::felt252>, 0>;
libfunc store_temp<core::option::Option::<core::felt252>> = store_temp<core::option::Option::<core::felt252>>;
libfunc into_box<core::option::Option::<core::felt252>> = into_box<core::option::Option::<core::felt252>>;
libfunc store_temp<Box<felt252>> = store_temp<Box<felt252>>;
libfunc unbox<felt252> = unbox<felt252>;
libfunc const_as_immediate<Const<felt252, 123>> = const_as_immediate<Const<felt252, 123>>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc felt252_add = felt252_add;
libfunc drop<Box<Unit>> = drop<Box<Unit>>;
libfunc const_as_immediate<Const<felt252, 999>> = const_as_immediate<Const<felt252, 999>>;

F0:
enum_boxed_match<core::option::Option::<core::felt252>>([0]) { fallthrough([1]) F0_B0([2]) };
branch_align() -> ();
enum_init<test::BoxedOption, 0>([1]) -> ([3]);
store_temp<test::BoxedOption>([3]) -> ([3]);
return([3]);
F0_B0:
branch_align() -> ();
enum_init<test::BoxedOption, 1>([2]) -> ([4]);
store_temp<test::BoxedOption>([4]) -> ([4]);
return([4]);
F1:
enum_init<core::option::Option::<core::felt252>, 0>([0]) -> ([1]);
store_temp<core::option::Option::<core::felt252>>([1]) -> ([1]);
into_box<core::option::Option::<core::felt252>>([1]) -> ([2]);
enum_boxed_match<core::option::Option::<core::felt252>>([2]) { fallthrough([3]) F1_B0([4]) };
branch_align() -> ();
store_temp<Box<felt252>>([3]) -> ([3]);
unbox<felt252>([3]) -> ([5]);
const_as_immediate<Const<felt252, 123>>() -> ([6]);
store_temp<felt252>([5]) -> ([5]);
felt252_add([5], [6]) -> ([7]);
store_temp<felt252>([7]) -> ([7]);
return([7]);
F1_B0:
branch_align() -> ();
drop<Box<Unit>>([4]) -> ();
const_as_immediate<Const<felt252, 999>>() -> ([8]);
store_temp<felt252>([8]) -> ([8]);
return([8]);

test::foo@F0([0]: Box<core::option::Option::<core::felt252>>) -> (test::BoxedOption);
test::add_123@F1([0]: felt252) -> (felt252);

//! > ==========================================================================

//! > boxed match enum with 3 variants

//! > test_runner_name
SmallE2ETestRunner(test_data: test_blue(5) = 5)

//! > cairo_code
enum Color {
    Red: felt252,
    Green: felt252,
    Blue: felt252,
}

enum BoxedColor {
    Red: Box<felt252>,
    Green: Box<felt252>,
    Blue: Box<felt252>,
}

extern fn enum_boxed_match<Color>(e: Box<Color>) -> BoxedColor nopanic;

fn foo(e: Box<Color>) -> BoxedColor {
    enum_boxed_match(e)
}

fn test_blue(x: felt252) -> felt252 {
    let boxed = BoxTrait::new(Color::Blue(x));
    match foo(boxed) {
        BoxedColor::Red(_) => 0,
        BoxedColor::Green(_) => 1,
        BoxedColor::Blue(boxed_x) => boxed_x.unbox(),
    }
}

//! > casm
[ap + 0] = [[fp + -3] + 0], ap++;
jmp rel [ap + -1];
jmp rel 14;
jmp rel 7;
[ap + 0] = 5, ap++;
[ap + 0] = [fp + -3] + 1, ap++;
ret;
[ap + 0] = 3, ap++;
[ap + 0] = [fp + -3] + 1, ap++;
ret;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -3] + 1, ap++;
ret;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -3], ap++;
%{
if '__boxed_segment' not in globals():
    __boxed_segment = segments.add()
memory[ap + 0] = __boxed_segment
__boxed_segment += 2
%}
[ap + -2] = [[ap + 0] + 0], ap++;
[ap + -2] = [[ap + -1] + 1];
[ap + 0] = [[ap + -1] + 0], ap++;
jmp rel [ap + -1];
jmp rel 14;
jmp rel 7;
ap += 1;
[ap + 0] = 0, ap++;
ret;
ap += 1;
[ap + 0] = 1, ap++;
ret;
[ap + 0] = [ap + -2] + 1, ap++;
[ap + 0] = [[ap + -1] + 0], ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 500})
test::test_blue: SmallOrderedMap({Const: 910})

//! > sierra_code
type Box<test::Color> = Box<test::Color> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 1> = Const<felt252, 1> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<felt252, 0> = Const<felt252, 0> [storable: false, drop: false, dup: false, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Box<felt252> = Box<felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type test::BoxedColor = Enum<ut@test::BoxedColor, Box<felt252>, Box<felt252>, Box<felt252>> [storable: true, drop: true, dup: true, zero_sized: false];
type test::Color = Enum<ut@test::Color, felt252, felt252, felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_boxed_match<test::Color> = enum_boxed_match<test::Color>;
libfunc branch_align = branch_align;
libfunc enum_init<test::BoxedColor, 0> = enum_init<test::BoxedColor, 0>;
libfunc store_temp<test::BoxedColor> = store_temp<test::BoxedColor>;
libfunc enum_init<test::BoxedColor, 1> = enum_init<test::BoxedColor, 1>;
libfunc enum_init<test::BoxedColor, 2> = enum_init<test::BoxedColor, 2>;
libfunc enum_init<test::Color, 2> = enum_init<test::Color, 2>;
libfunc store_temp<test::Color> = store_temp<test::Color>;
libfunc into_box<test::Color> = into_box<test::Color>;
libfunc drop<Box<felt252>> = drop<Box<felt252>>;
libfunc const_as_immediate<Const<felt252, 0>> = const_as_immediate<Const<felt252, 0>>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc const_as_immediate<Const<felt252, 1>> = const_as_immediate<Const<felt252, 1>>;
libfunc store_temp<Box<felt252>> = store_temp<Box<felt252>>;
libfunc unbox<felt252> = unbox<felt252>;

F0:
enum_boxed_match<test::Color>([0]) { fallthrough([1]) F0_B0([2]) F0_B1([3]) };
branch_align() -> ();
enum_init<test::BoxedColor, 0>([1]) -> ([4]);
store_temp<test::BoxedColor>([4]) -> ([4]);
return([4]);
F0_B0:
branch_align() -> ();
enum_init<test::BoxedColor, 1>([2]) -> ([5]);
store_temp<test::BoxedColor>([5]) -> ([5]);
return([5]);
F0_B1:
branch_align() -> ();
enum_init<test::BoxedColor, 2>([3]) -> ([6]);
store_temp<test::BoxedColor>([6]) -> ([6]);
return([6]);
F1:
enum_init<test::Color, 2>([0]) -> ([1]);
store_temp<test::Color>([1]) -> ([1]);
into_box<test::Color>([1]) -> ([2]);
enum_boxed_match<test::Color>([2]) { fallthrough([3]) F1_B0([4]) F1_B1([5]) };
branch_align() -> ();
drop<Box<felt252>>([3]) -> ();
const_as_immediate<Const<felt252, 0>>() -> ([6]);
store_temp<felt252>([6]) -> ([6]);
return([6]);
F1_B0:
branch_align() -> ();
drop<Box<felt252>>([4]) -> ();
const_as_immediate<Const<felt252, 1>>() -> ([7]);
store_temp<felt252>([7]) -> ([7]);
return([7]);
F1_B1:
branch_align() -> ();
store_temp<Box<felt252>>([5]) -> ([5]);
unbox<felt252>([5]) -> ([8]);
store_temp<felt252>([8]) -> ([8]);
return([8]);

test::foo@F0([0]: Box<test::Color>) -> (test::BoxedColor);
test::test_blue@F1([0]: felt252) -> (felt252);

//! > ==========================================================================

//! > boxed match enum with padding (different sized variants)

//! > test_runner_name
SmallE2ETestRunner(test_data: test_small(7) = 7)

//! > cairo_code
enum Data {
    Small: felt252,
    Large: (felt252, felt252, felt252),
}

enum BoxedData {
    Small: Box<felt252>,
    Large: Box<(felt252, felt252, felt252)>,
}

extern fn enum_boxed_match<Data>(e: Box<Data>) -> BoxedData nopanic;

fn foo(e: Box<Data>) -> BoxedData {
    enum_boxed_match(e)
}

fn test_small(x: felt252) -> felt252 {
    let boxed = BoxTrait::new(Data::Small(x));
    match foo(boxed) {
        BoxedData::Small(boxed_x) => boxed_x.unbox(),
        BoxedData::Large(_) => 0,
    }
}

//! > casm
[ap + 0] = [[fp + -3] + 0], ap++;
jmp rel 7 if [ap + -1] != 0;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3] + 3, ap++;
ret;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -3] + 1, ap++;
ret;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3], ap++;
%{
if '__boxed_segment' not in globals():
    __boxed_segment = segments.add()
memory[ap + 0] = __boxed_segment
__boxed_segment += 4
%}
[ap + -4] = [[ap + 0] + 0], ap++;
[ap + -4] = [[ap + -1] + 1];
[ap + -3] = [[ap + -1] + 2];
[ap + -2] = [[ap + -1] + 3];
[ap + 0] = [[ap + -1] + 0], ap++;
jmp rel 6 if [ap + -1] != 0;
[ap + 0] = [ap + -2] + 3, ap++;
[ap + 0] = [[ap + -1] + 0], ap++;
ret;
ap += 1;
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: SmallOrderedMap({Const: 400})
test::test_small: SmallOrderedMap({Const: 1210})

//! > sierra_code
type Box<test::Data> = Box<test::Data> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 0> = Const<felt252, 0> [storable: false, drop: false, dup: false, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Box<felt252> = Box<felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type Box<Tuple<felt252, felt252, felt252>> = Box<Tuple<felt252, felt252, felt252>> [storable: true, drop: true, dup: true, zero_sized: false];
type test::BoxedData = Enum<ut@test::BoxedData, Box<felt252>, Box<Tuple<felt252, felt252, felt252>>> [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<felt252, felt252, felt252> = Struct<ut@Tuple, felt252, felt252, felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type test::Data = Enum<ut@test::Data, felt252, Tuple<felt252, felt252, felt252>> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_boxed_match<test::Data> = enum_boxed_match<test::Data>;
libfunc branch_align = branch_align;
libfunc enum_init<test::BoxedData, 0> = enum_init<test::BoxedData, 0>;
libfunc store_temp<test::BoxedData> = store_temp<test::BoxedData>;
libfunc enum_init<test::BoxedData, 1> = enum_init<test::BoxedData, 1>;
libfunc enum_init<test::Data, 0> = enum_init<test::Data, 0>;
libfunc store_temp<test::Data> = store_temp<test::Data>;
libfunc into_box<test::Data> = into_box<test::Data>;
libfunc store_temp<Box<felt252>> = store_temp<Box<felt252>>;
libfunc unbox<felt252> = unbox<felt252>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc drop<Box<Tuple<felt252, felt252, felt252>>> = drop<Box<Tuple<felt252, felt252, felt252>>>;
libfunc const_as_immediate<Const<felt252, 0>> = const_as_immediate<Const<felt252, 0>>;

F0:
enum_boxed_match<test::Data>([0]) { fallthrough([1]) F0_B0([2]) };
branch_align() -> ();
enum_init<test::BoxedData, 0>([1]) -> ([3]);
store_temp<test::BoxedData>([3]) -> ([3]);
return([3]);
F0_B0:
branch_align() -> ();
enum_init<test::BoxedData, 1>([2]) -> ([4]);
store_temp<test::BoxedData>([4]) -> ([4]);
return([4]);
F1:
enum_init<test::Data, 0>([0]) -> ([1]);
store_temp<test::Data>([1]) -> ([1]);
into_box<test::Data>([1]) -> ([2]);
enum_boxed_match<test::Data>([2]) { fallthrough([3]) F1_B0([4]) };
branch_align() -> ();
store_temp<Box<felt252>>([3]) -> ([3]);
unbox<felt252>([3]) -> ([5]);
store_temp<felt252>([5]) -> ([5]);
return([5]);
F1_B0:
branch_align() -> ();
drop<Box<Tuple<felt252, felt252, felt252>>>([4]) -> ();
const_as_immediate<Const<felt252, 0>>() -> ([6]);
store_temp<felt252>([6]) -> ([6]);
return([6]);

test::foo@F0([0]: Box<test::Data>) -> (test::BoxedData);
test::test_small@F1([0]: felt252) -> (felt252);
