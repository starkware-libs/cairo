//! > init enum with a single variant

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum SingleVariant {
    Variant: felt252,
}

fn foo() -> SingleVariant {
    SingleVariant::Variant(5)
}

//! > casm
[ap + 0] = 0, ap++;
[ap + 0] = 5, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 200})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::SingleVariant = Enum<ut@test::SingleVariant, felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc felt252_const<5> = felt252_const<5>;
libfunc enum_init<test::SingleVariant, 0> = enum_init<test::SingleVariant, 0>;
libfunc store_temp<test::SingleVariant> = store_temp<test::SingleVariant>;

felt252_const<5>() -> ([0]); // 0
enum_init<test::SingleVariant, 0>([0]) -> ([1]); // 1
store_temp<test::SingleVariant>([1]) -> ([1]); // 2
return([1]); // 3

test::foo@0() -> (test::SingleVariant);

//! > ==========================================================================

//! > match enum with a single variant

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum SingleVariant {
    Variant: felt252,
}

fn foo(e: SingleVariant) -> felt252 {
    match e {
        SingleVariant::Variant(_) => 0,
    }
}

//! > casm
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::SingleVariant = Enum<ut@test::SingleVariant, felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_match<test::SingleVariant> = enum_match<test::SingleVariant>;
libfunc branch_align = branch_align;
libfunc drop<felt252> = drop<felt252>;
libfunc felt252_const<0> = felt252_const<0>;
libfunc store_temp<felt252> = store_temp<felt252>;

enum_match<test::SingleVariant>([0]) -> ([1]); // 0
branch_align() -> (); // 1
drop<felt252>([1]) -> (); // 2
felt252_const<0>() -> ([2]); // 3
store_temp<felt252>([2]) -> ([2]); // 4
return([2]); // 5

test::foo@0([0]: test::SingleVariant) -> (felt252);

//! > ==========================================================================

//! > init enum with 2 variants

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum Option {
    Some: felt252,
    None: (),
}

fn foo() -> Option {
    Option::Some(5)
}

//! > casm
[ap + 0] = 0, ap++;
[ap + 0] = 5, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 200})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::Option = Enum<ut@test::Option, felt252, Unit> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc felt252_const<5> = felt252_const<5>;
libfunc enum_init<test::Option, 0> = enum_init<test::Option, 0>;
libfunc store_temp<test::Option> = store_temp<test::Option>;

felt252_const<5>() -> ([0]); // 0
enum_init<test::Option, 0>([0]) -> ([1]); // 1
store_temp<test::Option>([1]) -> ([1]); // 2
return([1]); // 3

test::foo@0() -> (test::Option);

//! > ==========================================================================

//! > match enum with 2 variants

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum Option {
    Some: felt252,
    None: (),
}

fn foo(e: Option) -> felt252 {
    match e {
        Option::Some(_) => 0,
        Option::None => 1,
    }
}

//! > casm
jmp rel 6 if [fp + -4] != 0;
[ap + 0] = 0, ap++;
jmp rel 4;
[ap + 0] = 1, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 300})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::Option = Enum<ut@test::Option, felt252, Unit> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_match<test::Option> = enum_match<test::Option>;
libfunc branch_align = branch_align;
libfunc drop<felt252> = drop<felt252>;
libfunc felt252_const<0> = felt252_const<0>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc jump = jump;
libfunc drop<Unit> = drop<Unit>;
libfunc felt252_const<1> = felt252_const<1>;

enum_match<test::Option>([0]) { fallthrough([1]) 6([2]) }; // 0
branch_align() -> (); // 1
drop<felt252>([1]) -> (); // 2
felt252_const<0>() -> ([3]); // 3
store_temp<felt252>([3]) -> ([4]); // 4
jump() { 10() }; // 5
branch_align() -> (); // 6
drop<Unit>([2]) -> (); // 7
felt252_const<1>() -> ([5]); // 8
store_temp<felt252>([5]) -> ([4]); // 9
return([4]); // 10

test::foo@0([0]: test::Option) -> (felt252);

//! > ==========================================================================

//! > init a non-first variant in an enum with more than 2 variants

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum Color {
    Red: felt252,
    Green: felt252,
    Blue: felt252,
}

fn foo() -> Color {
    Color::Blue(10)
}

//! > casm
[ap + 0] = 1, ap++;
[ap + 0] = 10, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 200})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::Color = Enum<ut@test::Color, felt252, felt252, felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc felt252_const<10> = felt252_const<10>;
libfunc enum_init<test::Color, 2> = enum_init<test::Color, 2>;
libfunc store_temp<test::Color> = store_temp<test::Color>;

felt252_const<10>() -> ([0]); // 0
enum_init<test::Color, 2>([0]) -> ([1]); // 1
store_temp<test::Color>([1]) -> ([1]); // 2
return([1]); // 3

test::foo@0() -> (test::Color);

//! > ==========================================================================

//! > init the first variant in an enum with more than 2 variants

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum Color {
    Red: felt252,
    Green: felt252,
    Blue: felt252,
}

fn foo() -> Color {
    Color::Red(10)
}

//! > casm
[ap + 0] = 5, ap++;
[ap + 0] = 10, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 200})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::Color = Enum<ut@test::Color, felt252, felt252, felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc felt252_const<10> = felt252_const<10>;
libfunc enum_init<test::Color, 0> = enum_init<test::Color, 0>;
libfunc store_temp<test::Color> = store_temp<test::Color>;

felt252_const<10>() -> ([0]); // 0
enum_init<test::Color, 0>([0]) -> ([1]); // 1
store_temp<test::Color>([1]) -> ([1]); // 2
return([1]); // 3

test::foo@0() -> (test::Color);

//! > ==========================================================================

//! > match enum with more than 2 variants

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum Color {
    Red: felt252,
    Green: felt252,
    Blue: felt252,
}

fn foo(e: Color) -> felt252 {
    match e {
        Color::Red(_) => 0,
        Color::Green(_) => 1,
        Color::Blue(_) => 2,
    }
}

//! > casm
jmp rel [fp + -4];
jmp rel 12;
jmp rel 6;
[ap + 0] = 0, ap++;
jmp rel 8;
[ap + 0] = 1, ap++;
jmp rel 4;
[ap + 0] = 2, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 400})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type test::Color = Enum<ut@test::Color, felt252, felt252, felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_match<test::Color> = enum_match<test::Color>;
libfunc branch_align = branch_align;
libfunc drop<felt252> = drop<felt252>;
libfunc felt252_const<0> = felt252_const<0>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc jump = jump;
libfunc felt252_const<1> = felt252_const<1>;
libfunc felt252_const<2> = felt252_const<2>;

enum_match<test::Color>([0]) { fallthrough([1]) 6([2]) 11([3]) }; // 0
branch_align() -> (); // 1
drop<felt252>([1]) -> (); // 2
felt252_const<0>() -> ([4]); // 3
store_temp<felt252>([4]) -> ([5]); // 4
jump() { 15() }; // 5
branch_align() -> (); // 6
drop<felt252>([2]) -> (); // 7
felt252_const<1>() -> ([6]); // 8
store_temp<felt252>([6]) -> ([5]); // 9
jump() { 15() }; // 10
branch_align() -> (); // 11
drop<felt252>([3]) -> (); // 12
felt252_const<2>() -> ([7]); // 13
store_temp<felt252>([7]) -> ([5]); // 14
return([5]); // 15

test::foo@0([0]: test::Color) -> (felt252);

//! > ==========================================================================

//! > long enum from felt252

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum IndexEnum5 {
    Zero,
    One,
    Two,
    Three,
    Four,
}

extern fn enum_from_felt252<T>(index: felt252) -> Option<T> implicits(RangeCheck) nopanic;
fn foo(index:felt252)->Option<IndexEnum5> {
    enum_from_felt252(index)
}

//! > casm
%{ memory[ap + 0] = memory[fp + -3] < 5 %}
jmp rel 18 if [ap + 0] != 0, ap++;
[fp + -3] = [ap + 0] + 6, ap++;
%{
(value, scalar) = (memory[ap + -1], 10633823966279327296825105735305134080)
x = min(value // scalar, 340282366920938463463374607431768211454)
y = value - x * scalar
memory[ap + 0] = x
memory[ap + 1] = y
%}
[ap + 2] = [ap + 0] * 10633823966279327296825105735305134080, ap++;
[ap + -2] = [ap + 1] + [ap + 0], ap++;
[ap + -1] = [[fp + -4] + 0], ap++;
[ap + 0] = [ap + -2] + 319014718988379808869724395961157943300, ap++;
[ap + -1] = [[fp + -4] + 1], ap++;
[ap + -5] = [[fp + -4] + 2];
[ap + -5] = [ap + -1] + 340282366920938463463374607431768211455;
jmp rel 22 if [ap + -1] != 0;
[fp + -1] = [fp + -1] + 1;
[fp + -3] = [[fp + -4] + 0];
[ap + 0] = [fp + -3] + 340282366920938463463374607431768211450, ap++;
[ap + -1] = [[fp + -4] + 1];
[fp + -3] = [ap + 0] + 5, ap++;
[ap + 0] = [ap + -1] * -2, ap++;
ap += 3;
[ap + 0] = [fp + -4] + 2, ap++;
[ap + 0] = 0, ap++;
[ap + -6] = [ap + 0] + 1, ap++;
jmp rel 8;
[ap + 0] = [fp + -4] + 3, ap++;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1510})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::IndexEnum5 = Enum<ut@test::IndexEnum5, Unit, Unit, Unit, Unit, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type core::option::Option::<test::IndexEnum5> = Enum<ut@core::option::Option::<test::IndexEnum5>, test::IndexEnum5, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_from_felt252<test::IndexEnum5> = enum_from_felt252<test::IndexEnum5>;
libfunc branch_align = branch_align;
libfunc enum_init<core::option::Option::<test::IndexEnum5>, 0> = enum_init<core::option::Option::<test::IndexEnum5>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<core::option::Option::<test::IndexEnum5>> = store_temp<core::option::Option::<test::IndexEnum5>>;
libfunc jump = jump;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<test::IndexEnum5>, 1> = enum_init<core::option::Option::<test::IndexEnum5>, 1>;

enum_from_felt252<test::IndexEnum5>([0], [1]) { fallthrough([2], [3]) 6([4]) }; // 0
branch_align() -> (); // 1
enum_init<core::option::Option::<test::IndexEnum5>, 0>([3]) -> ([5]); // 2
store_temp<RangeCheck>([2]) -> ([6]); // 3
store_temp<core::option::Option::<test::IndexEnum5>>([5]) -> ([7]); // 4
jump() { 11() }; // 5
branch_align() -> (); // 6
struct_construct<Unit>() -> ([8]); // 7
enum_init<core::option::Option::<test::IndexEnum5>, 1>([8]) -> ([9]); // 8
store_temp<RangeCheck>([4]) -> ([6]); // 9
store_temp<core::option::Option::<test::IndexEnum5>>([9]) -> ([7]); // 10
return([6], [7]); // 11

test::foo@0([0]: RangeCheck, [1]: felt252) -> (RangeCheck, core::option::Option::<test::IndexEnum5>);

//! > ==========================================================================

//! > enum from felt252

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum IndexEnum3 {
    Zero,
    One,
    Two,
}

extern fn enum_from_felt252<T>(index: felt252) -> Option<T> implicits(RangeCheck) nopanic;
fn foo(index:felt252)->Option<IndexEnum3> {
    enum_from_felt252(index)
}

//! > casm
[fp + -3] = [ap + 0] + 1, ap++;
[fp + -3] = [ap + 0] + 2, ap++;
jmp rel 17 if [fp + -3] != 0;
jmp rel 15 if [ap + -2] != 0;
jmp rel 13 if [ap + -1] != 0;
[fp + -3] = [ap + 0] + 3, ap++;
[ap + 0] = [ap + -1] * -2, ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = 0, ap++;
[ap + -3] = [ap + 0] + 1, ap++;
jmp rel 9;
ap += 2;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1100})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::IndexEnum3 = Enum<ut@test::IndexEnum3, Unit, Unit, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type core::option::Option::<test::IndexEnum3> = Enum<ut@core::option::Option::<test::IndexEnum3>, test::IndexEnum3, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_from_felt252<test::IndexEnum3> = enum_from_felt252<test::IndexEnum3>;
libfunc branch_align = branch_align;
libfunc enum_init<core::option::Option::<test::IndexEnum3>, 0> = enum_init<core::option::Option::<test::IndexEnum3>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<core::option::Option::<test::IndexEnum3>> = store_temp<core::option::Option::<test::IndexEnum3>>;
libfunc jump = jump;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<test::IndexEnum3>, 1> = enum_init<core::option::Option::<test::IndexEnum3>, 1>;

enum_from_felt252<test::IndexEnum3>([0], [1]) { fallthrough([2], [3]) 6([4]) }; // 0
branch_align() -> (); // 1
enum_init<core::option::Option::<test::IndexEnum3>, 0>([3]) -> ([5]); // 2
store_temp<RangeCheck>([2]) -> ([6]); // 3
store_temp<core::option::Option::<test::IndexEnum3>>([5]) -> ([7]); // 4
jump() { 11() }; // 5
branch_align() -> (); // 6
struct_construct<Unit>() -> ([8]); // 7
enum_init<core::option::Option::<test::IndexEnum3>, 1>([8]) -> ([9]); // 8
store_temp<RangeCheck>([4]) -> ([6]); // 9
store_temp<core::option::Option::<test::IndexEnum3>>([9]) -> ([7]); // 10
return([6], [7]); // 11

test::foo@0([0]: RangeCheck, [1]: felt252) -> (RangeCheck, core::option::Option::<test::IndexEnum3>);

//! > ==========================================================================

//! > short enum from felt252

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum IndexEnum2 {
    Zero,
    One,
}

extern fn enum_from_felt252<T>(index: felt252) -> Option<T> implicits(RangeCheck) nopanic;
fn foo(index:felt252)->Option<IndexEnum2> {
    enum_from_felt252(index)
}

//! > casm
[ap + 0] = [fp + -3] * [fp + -3], ap++;
[ap + -1] = [ap + 0] + [fp + -3], ap++;
jmp rel 8 if [ap + -1] != 0;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3], ap++;
jmp rel 7;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 700})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::IndexEnum2 = Enum<ut@test::IndexEnum2, Unit, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type core::option::Option::<test::IndexEnum2> = Enum<ut@core::option::Option::<test::IndexEnum2>, test::IndexEnum2, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_from_felt252<test::IndexEnum2> = enum_from_felt252<test::IndexEnum2>;
libfunc branch_align = branch_align;
libfunc enum_init<core::option::Option::<test::IndexEnum2>, 0> = enum_init<core::option::Option::<test::IndexEnum2>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<core::option::Option::<test::IndexEnum2>> = store_temp<core::option::Option::<test::IndexEnum2>>;
libfunc jump = jump;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<test::IndexEnum2>, 1> = enum_init<core::option::Option::<test::IndexEnum2>, 1>;

enum_from_felt252<test::IndexEnum2>([0], [1]) { fallthrough([2], [3]) 6([4]) }; // 0
branch_align() -> (); // 1
enum_init<core::option::Option::<test::IndexEnum2>, 0>([3]) -> ([5]); // 2
store_temp<RangeCheck>([2]) -> ([6]); // 3
store_temp<core::option::Option::<test::IndexEnum2>>([5]) -> ([7]); // 4
jump() { 11() }; // 5
branch_align() -> (); // 6
struct_construct<Unit>() -> ([8]); // 7
enum_init<core::option::Option::<test::IndexEnum2>, 1>([8]) -> ([9]); // 8
store_temp<RangeCheck>([4]) -> ([6]); // 9
store_temp<core::option::Option::<test::IndexEnum2>>([9]) -> ([7]); // 10
return([6], [7]); // 11

test::foo@0([0]: RangeCheck, [1]: felt252) -> (RangeCheck, core::option::Option::<test::IndexEnum2>);

//! > ==========================================================================

//! > very short enum from felt252

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
enum IndexEnum1 {
    Zero,
}

extern fn enum_from_felt252<T>(index: felt252) -> Option<T> implicits(RangeCheck) nopanic;
fn foo(index:felt252)->Option<IndexEnum1> {
    enum_from_felt252(index)
}

//! > casm
jmp rel 8 if [fp + -3] != 0;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3], ap++;
jmp rel 7;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 500})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type test::IndexEnum1 = Enum<ut@test::IndexEnum1, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type core::option::Option::<test::IndexEnum1> = Enum<ut@core::option::Option::<test::IndexEnum1>, test::IndexEnum1, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc enum_from_felt252<test::IndexEnum1> = enum_from_felt252<test::IndexEnum1>;
libfunc branch_align = branch_align;
libfunc enum_init<core::option::Option::<test::IndexEnum1>, 0> = enum_init<core::option::Option::<test::IndexEnum1>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<core::option::Option::<test::IndexEnum1>> = store_temp<core::option::Option::<test::IndexEnum1>>;
libfunc jump = jump;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<test::IndexEnum1>, 1> = enum_init<core::option::Option::<test::IndexEnum1>, 1>;

enum_from_felt252<test::IndexEnum1>([0], [1]) { fallthrough([2], [3]) 6([4]) }; // 0
branch_align() -> (); // 1
enum_init<core::option::Option::<test::IndexEnum1>, 0>([3]) -> ([5]); // 2
store_temp<RangeCheck>([2]) -> ([6]); // 3
store_temp<core::option::Option::<test::IndexEnum1>>([5]) -> ([7]); // 4
jump() { 11() }; // 5
branch_align() -> (); // 6
struct_construct<Unit>() -> ([8]); // 7
enum_init<core::option::Option::<test::IndexEnum1>, 1>([8]) -> ([9]); // 8
store_temp<RangeCheck>([4]) -> ([6]); // 9
store_temp<core::option::Option::<test::IndexEnum1>>([9]) -> ([7]); // 10
return([6], [7]); // 11

test::foo@0([0]: RangeCheck, [1]: felt252) -> (RangeCheck, core::option::Option::<test::IndexEnum1>);
