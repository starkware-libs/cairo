//! > init_circuit_data

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{AddModGate, Circuit, CircuitInput, CircuitInputAccumulator, init_circuit_data};
type MyCircuit = Circuit<(AddModGate<CircuitInput<0>, CircuitInput<1>>, CircuitInput<2>)>;

fn foo() -> CircuitInputAccumulator<MyCircuit> {
    init_circuit_data::<MyCircuit>()
}

//! > casm
[ap + 0] = [fp + -3] + 32, ap++;
[ap + 0] = [fp + -3] + 4, ap++;
[ap + 0] = [fp + -3] + 16, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 2092})

//! > sierra_code
type RangeCheck96 = RangeCheck96 [storable: true, drop: false, dup: false, zero_sized: false];
type Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)> = Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)> [storable: false, drop: false, dup: false, zero_sized: true];
type CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> [storable: true, drop: true, dup: false, zero_sized: false];
type core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> = AddModGate<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<2> = CircuitInput<2> [storable: false, drop: false, dup: false, zero_sized: true];
type (core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>) = Struct<ut@Tuple, core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<1> = CircuitInput<1> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<0> = CircuitInput<0> [storable: false, drop: false, dup: false, zero_sized: true];

libfunc init_circuit_data<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = init_circuit_data<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>;
libfunc store_temp<RangeCheck96> = store_temp<RangeCheck96>;
libfunc store_temp<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>> = store_temp<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>;

init_circuit_data<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>([0]) -> ([1], [2]); // 0
store_temp<RangeCheck96>([1]) -> ([1]); // 1
store_temp<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>([2]) -> ([2]); // 2
return([1], [2]); // 3

test::foo@0([0]: RangeCheck96) -> (RangeCheck96, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>);

//! > ==========================================================================

//! > init_circuit_data multiple calls.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{AddModGate, Circuit, CircuitInput, CircuitInputAccumulator, init_circuit_data};
type MyCircuit = Circuit<(AddModGate<CircuitInput<0>, CircuitInput<1>>, CircuitInput<2>)>;

fn foo() -> (CircuitInputAccumulator<MyCircuit>, CircuitInputAccumulator<MyCircuit>) {
    (init_circuit_data::<MyCircuit>(), init_circuit_data::<MyCircuit>())
}

//! > casm
[ap + 0] = [fp + -3] + 64, ap++;
[ap + 0] = [fp + -3] + 4, ap++;
[ap + 0] = [fp + -3] + 16, ap++;
[ap + 0] = [fp + -3] + 36, ap++;
[ap + 0] = [fp + -3] + 48, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 4084})

//! > sierra_code
type RangeCheck96 = RangeCheck96 [storable: true, drop: false, dup: false, zero_sized: false];
type CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> [storable: true, drop: true, dup: false, zero_sized: false];
type Tuple<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>> = Struct<ut@Tuple, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>> [storable: true, drop: true, dup: false, zero_sized: false];
type Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)> = Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> = AddModGate<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<2> = CircuitInput<2> [storable: false, drop: false, dup: false, zero_sized: true];
type (core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>) = Struct<ut@Tuple, core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<0> = CircuitInput<0> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<1> = CircuitInput<1> [storable: false, drop: false, dup: false, zero_sized: true];

libfunc init_circuit_data<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = init_circuit_data<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>;
libfunc struct_construct<Tuple<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>> = struct_construct<Tuple<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>>;
libfunc store_temp<RangeCheck96> = store_temp<RangeCheck96>;
libfunc store_temp<Tuple<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>> = store_temp<Tuple<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>>;

init_circuit_data<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>([0]) -> ([1], [2]); // 0
init_circuit_data<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>([1]) -> ([3], [4]); // 1
struct_construct<Tuple<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>>([2], [4]) -> ([5]); // 2
store_temp<RangeCheck96>([3]) -> ([3]); // 3
store_temp<Tuple<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>>([5]) -> ([5]); // 4
return([3], [5]); // 5

test::foo@0([0]: RangeCheck96) -> (RangeCheck96, Tuple<CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>);

//! > ==========================================================================

//! > add_input

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{
    AddInputResult, AddModGate, Circuit, CircuitInput, CircuitInputAccumulator, U96Guarantee,
    add_circuit_input,
};
type MyCircuit = Circuit<(AddModGate<CircuitInput<0>, CircuitInput<1>>, CircuitInput<2>)>;

fn foo(
    accumulator: CircuitInputAccumulator<MyCircuit>, val: [U96Guarantee; 4],
) -> AddInputResult<MyCircuit> {
    add_circuit_input(accumulator, val)
}

//! > casm
[fp + -6] = [[fp + -8] + 0];
[fp + -5] = [[fp + -8] + 1];
[fp + -4] = [[fp + -8] + 2];
[fp + -3] = [[fp + -8] + 3];
[ap + 0] = [fp + -8] + 4, ap++;
[fp + -7] = [ap + 0] + [ap + -1], ap++;
jmp rel 8 if [ap + -1] != 0;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -7], ap++;
ret;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [fp + -7], ap++;
ret;

//! > sierra_code
type CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> [storable: true, drop: true, dup: false, zero_sized: false];
type CircuitData<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = CircuitData<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> [storable: true, drop: true, dup: false, zero_sized: false];
type core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = Enum<ut@core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitData<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>> [storable: true, drop: true, dup: false, zero_sized: false];
type Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)> = Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> = AddModGate<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<2> = CircuitInput<2> [storable: false, drop: false, dup: false, zero_sized: true];
type (core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>) = Struct<ut@Tuple, core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>> [storable: false, drop: false, dup: false, zero_sized: true];
type U96Guarantee = U96Guarantee [storable: true, drop: false, dup: false, zero_sized: false];
type Tuple<U96Guarantee, U96Guarantee, U96Guarantee, U96Guarantee> = Struct<ut@Tuple, U96Guarantee, U96Guarantee, U96Guarantee, U96Guarantee> [storable: true, drop: false, dup: false, zero_sized: false];
type core::circuit::CircuitInput::<1> = CircuitInput<1> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<0> = CircuitInput<0> [storable: false, drop: false, dup: false, zero_sized: true];

libfunc add_circuit_input<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = add_circuit_input<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>;
libfunc branch_align = branch_align;
libfunc enum_init<core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, 0> = enum_init<core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, 0>;
libfunc store_temp<core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>> = store_temp<core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>;
libfunc enum_init<core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, 1> = enum_init<core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, 1>;

add_circuit_input<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>([0], [1]) { fallthrough([2]) 5([3]) }; // 0
branch_align() -> (); // 1
enum_init<core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, 0>([2]) -> ([4]); // 2
store_temp<core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>([4]) -> ([4]); // 3
return([4]); // 4
branch_align() -> (); // 5
enum_init<core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, 1>([3]) -> ([5]); // 6
store_temp<core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>>([5]) -> ([5]); // 7
return([5]); // 8

test::foo@0([0]: CircuitInputAccumulator<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, [1]: Tuple<U96Guarantee, U96Guarantee, U96Guarantee, U96Guarantee>) -> (core::circuit::AddInputResult::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>);

//! > function_costs
test::foo: OrderedHashMap({Const: 1000})

//! > ==========================================================================

//! > get_circuit_descriptor

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{
    AddModGate, Circuit, CircuitDescriptor, CircuitInput, InverseGate, MulModGate, SubModGate,
    get_circuit_descriptor,
};
// Represents the circuit `(x + y, 1 / z, y * z, z - x)`.
type MyCircuit =
    Circuit<
        (
            AddModGate<CircuitInput<0>, CircuitInput<1>>,
            InverseGate<CircuitInput<2>>,
            MulModGate<CircuitInput<1>, CircuitInput<2>>,
            SubModGate<CircuitInput<2>, CircuitInput<0>>,
        ),
    >;

fn foo() -> CircuitDescriptor<MyCircuit> {
    get_circuit_descriptor::<MyCircuit>()
}

//! > casm
call rel 11;
[ap + 0] = [ap + -1] + 10, ap++;
[ap + 0] = 2, ap++;
[ap + 0] = [ap + -2] + 6, ap++;
[ap + 0] = 5, ap++;
ret;
ret;
dw 28;
dw 16;
dw 24;
dw 16;
dw 20;
dw 40;
dw 0;
dw 4;
dw 16;
dw 0;
dw 8;
dw 20;
dw 0;
dw 12;
dw 24;
dw 20;
dw 24;
dw 32;
dw 36;
dw 24;
dw 0;

//! > sierra_code
type CircuitDescriptor<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::InverseGate::<core::circuit::CircuitInput::<2>>, core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>>, core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>>)>> = CircuitDescriptor<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::InverseGate::<core::circuit::CircuitInput::<2>>, core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>>, core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>>)>> [storable: true, drop: true, dup: true, zero_sized: false];
type Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::InverseGate::<core::circuit::CircuitInput::<2>>, core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>>, core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>>)> = Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::InverseGate::<core::circuit::CircuitInput::<2>>, core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>>, core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>>)> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> = AddModGate<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::InverseGate::<core::circuit::CircuitInput::<2>> = InverseGate<core::circuit::CircuitInput::<2>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>> = MulModGate<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>> = SubModGate<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>> [storable: false, drop: false, dup: false, zero_sized: true];
type (core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::InverseGate::<core::circuit::CircuitInput::<2>>, core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>>, core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>>) = Struct<ut@Tuple, core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::InverseGate::<core::circuit::CircuitInput::<2>>, core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>>, core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<0> = CircuitInput<0> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<2> = CircuitInput<2> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<1> = CircuitInput<1> [storable: false, drop: false, dup: false, zero_sized: true];

libfunc get_circuit_descriptor<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::InverseGate::<core::circuit::CircuitInput::<2>>, core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>>, core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>>)>> = get_circuit_descriptor<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::InverseGate::<core::circuit::CircuitInput::<2>>, core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>>, core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>>)>>;

get_circuit_descriptor<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::InverseGate::<core::circuit::CircuitInput::<2>>, core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>>, core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>>)>>() -> ([0]); // 0
return([0]); // 1

test::foo@0() -> (CircuitDescriptor<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::InverseGate::<core::circuit::CircuitInput::<2>>, core::circuit::MulModGate::<core::circuit::CircuitInput::<1>, core::circuit::CircuitInput::<2>>, core::circuit::SubModGate::<core::circuit::CircuitInput::<2>, core::circuit::CircuitInput::<0>>)>>);

//! > function_costs
test::foo: OrderedHashMap({Const: 600})

//! > ==========================================================================

//! > try_into_circuit_modulus

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{CircuitModulus, try_into_circuit_modulus, u96};

fn foo(a: [u96; 4]) -> Option<CircuitModulus> {
    try_into_circuit_modulus(a)
}

//! > casm
jmp rel 16 if [fp + -3] != 0, ap++;
jmp rel 14 if [fp + -4] != 0;
jmp rel 12 if [fp + -5] != 0;
jmp rel 4 if [fp + -6] != 0;
jmp rel 15;
[fp + -6] = [ap + -1] + 1;
jmp rel 4 if [ap + -1] != 0;
jmp rel 9;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
ret;

//! > sierra_code
type BoundedInt<0, 79228162514264337593543950335> = BoundedInt<0, 79228162514264337593543950335> [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>> = Struct<ut@Tuple, BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>> [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type CircuitModulus = CircuitModulus [storable: true, drop: true, dup: true, zero_sized: false];
type core::option::Option::<core::circuit::CircuitModulus> = Enum<ut@core::option::Option::<core::circuit::CircuitModulus>, CircuitModulus, Unit> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc try_into_circuit_modulus = try_into_circuit_modulus;
libfunc branch_align = branch_align;
libfunc enum_init<core::option::Option::<core::circuit::CircuitModulus>, 0> = enum_init<core::option::Option::<core::circuit::CircuitModulus>, 0>;
libfunc store_temp<core::option::Option::<core::circuit::CircuitModulus>> = store_temp<core::option::Option::<core::circuit::CircuitModulus>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<core::circuit::CircuitModulus>, 1> = enum_init<core::option::Option::<core::circuit::CircuitModulus>, 1>;

try_into_circuit_modulus([0]) { fallthrough([1]) 5() }; // 0
branch_align() -> (); // 1
enum_init<core::option::Option::<core::circuit::CircuitModulus>, 0>([1]) -> ([2]); // 2
store_temp<core::option::Option::<core::circuit::CircuitModulus>>([2]) -> ([2]); // 3
return([2]); // 4
branch_align() -> (); // 5
struct_construct<Unit>() -> ([3]); // 6
enum_init<core::option::Option::<core::circuit::CircuitModulus>, 1>([3]) -> ([4]); // 7
store_temp<core::option::Option::<core::circuit::CircuitModulus>>([4]) -> ([4]); // 8
return([4]); // 9

test::foo@0([0]: Tuple<BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>>) -> (core::option::Option::<core::circuit::CircuitModulus>);

//! > function_costs
test::foo: OrderedHashMap({Const: 1200})

//! > ==========================================================================

//! > eval_circuit (with AddModGate)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{
    AddModGate, Circuit, CircuitData, CircuitDescriptor, CircuitInput, CircuitModulus,
    EvalCircuitResult, eval_circuit,
};
type MyCircuit = Circuit<(AddModGate<CircuitInput<0>, CircuitInput<1>>, CircuitInput<2>)>;

fn foo(
    desc: CircuitDescriptor<MyCircuit>, data: CircuitData<MyCircuit>, modulus: CircuitModulus,
) -> EvalCircuitResult<MyCircuit> {
    eval_circuit::<MyCircuit>(desc, data, modulus, 0, 1)
}

//! > casm
[ap + 0] = 0, ap++;
[ap + 0] = 1, ap++;
[fp + -7] = [ap + 0] + 16, ap++;
[ap + -2] = [[ap + -1] + 0];
[ap + -3] = [[ap + -1] + 1];
[ap + -3] = [[ap + -1] + 2];
[ap + -3] = [[ap + -1] + 3];
[fp + -6] = [[fp + -13] + 0];
[fp + -5] = [[fp + -13] + 1];
[fp + -4] = [[fp + -13] + 2];
[fp + -3] = [[fp + -13] + 3];
[ap + -1] = [[fp + -13] + 4];
[fp + -11] = [[fp + -13] + 5];
[fp + -10] = [[fp + -13] + 6];
[fp + -6] = [[fp + -12] + 0];
[fp + -5] = [[fp + -12] + 1];
[fp + -4] = [[fp + -12] + 2];
[fp + -3] = [[fp + -12] + 3];
[ap + -1] = [[fp + -12] + 4];
[fp + -9] = [[fp + -12] + 5];
%{
from starkware.cairo.lang.builtins.modulo.mod_builtin_runner import ModBuiltinRunner

ModBuiltinRunner.fill_memory(
        memory=memory,
        add_mod=(memory[fp + -13], builtin_runners["add_mod_builtin"], memory[fp + -10]),
        mul_mod=(memory[fp + -12], builtin_runners["mul_mod_builtin"], memory[fp + -8]),
)
%}
[ap + 0] = [[fp + -12] + 6], ap++;
[ap + 0] = [ap + -1] * 7, ap++;
[fp + -8] = [ap + 0] + [ap + -2], ap++;
jmp rel 31 if [ap + -1] != 0;
[ap + 0] = [fp + -13] + 7, ap++;
[ap + 0] = [fp + -12] + [ap + -3], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -16], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;
[ap + 0] = [fp + -13] + 7, ap++;
[ap + 0] = [fp + -12] + [ap + -3], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -7], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
[ap + 0] = [ap + -11], ap++;
[ap + 0] = [fp + -9], ap++;
[ap + 0] = [fp + -8], ap++;
[ap + 0] = [ap + -14], ap++;
[ap + 0] = [ap + -16], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > sierra_code
type BoundedInt<0, 0> = BoundedInt<0, 0> [storable: true, drop: true, dup: true, zero_sized: false];
type CircuitPartialOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = CircuitPartialOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> [storable: true, drop: true, dup: false, zero_sized: false];
type CircuitFailureGuarantee = CircuitFailureGuarantee [storable: true, drop: false, dup: false, zero_sized: false];
type Tuple<CircuitPartialOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitFailureGuarantee> = Struct<ut@Tuple, CircuitPartialOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitFailureGuarantee> [storable: true, drop: false, dup: false, zero_sized: false];
type CircuitOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = CircuitOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> [storable: true, drop: true, dup: true, zero_sized: false];
type core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)> = Enum<ut@core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>, CircuitOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, Tuple<CircuitPartialOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitFailureGuarantee>> [storable: true, drop: false, dup: false, zero_sized: false];
type Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)> = Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> = AddModGate<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<2> = CircuitInput<2> [storable: false, drop: false, dup: false, zero_sized: true];
type (core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>) = Struct<ut@Tuple, core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<1> = CircuitInput<1> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<0> = CircuitInput<0> [storable: false, drop: false, dup: false, zero_sized: true];
type CircuitModulus = CircuitModulus [storable: true, drop: true, dup: true, zero_sized: false];
type CircuitData<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = CircuitData<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> [storable: true, drop: true, dup: false, zero_sized: false];
type CircuitDescriptor<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = CircuitDescriptor<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> [storable: true, drop: true, dup: true, zero_sized: false];
type MulMod = MulMod [storable: true, drop: false, dup: false, zero_sized: false];
type AddMod = AddMod [storable: true, drop: false, dup: false, zero_sized: false];
type Const<BoundedInt<1, 1>, 1> = Const<BoundedInt<1, 1>, 1> [storable: false, drop: false, dup: false, zero_sized: false];
type BoundedInt<1, 1> = BoundedInt<1, 1> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<BoundedInt<0, 0>, 0> = Const<BoundedInt<0, 0>, 0> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<BoundedInt<0, 0>, 0>> = const_as_immediate<Const<BoundedInt<0, 0>, 0>>;
libfunc const_as_immediate<Const<BoundedInt<1, 1>, 1>> = const_as_immediate<Const<BoundedInt<1, 1>, 1>>;
libfunc store_temp<BoundedInt<0, 0>> = store_temp<BoundedInt<0, 0>>;
libfunc store_temp<BoundedInt<1, 1>> = store_temp<BoundedInt<1, 1>>;
libfunc eval_circuit<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = eval_circuit<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>;
libfunc branch_align = branch_align;
libfunc enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>, 0> = enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>, 0>;
libfunc store_temp<AddMod> = store_temp<AddMod>;
libfunc store_temp<MulMod> = store_temp<MulMod>;
libfunc store_temp<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>> = store_temp<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>>;
libfunc struct_construct<Tuple<CircuitPartialOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitFailureGuarantee>> = struct_construct<Tuple<CircuitPartialOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitFailureGuarantee>>;
libfunc enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>, 1> = enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>, 1>;

const_as_immediate<Const<BoundedInt<0, 0>, 0>>() -> ([5]); // 0
const_as_immediate<Const<BoundedInt<1, 1>, 1>>() -> ([6]); // 1
store_temp<BoundedInt<0, 0>>([5]) -> ([5]); // 2
store_temp<BoundedInt<1, 1>>([6]) -> ([6]); // 3
eval_circuit<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>([0], [1], [2], [3], [4], [5], [6]) { fallthrough([7], [8], [9]) 11([10], [11], [12], [13]) }; // 4
branch_align() -> (); // 5
enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>, 0>([9]) -> ([14]); // 6
store_temp<AddMod>([7]) -> ([7]); // 7
store_temp<MulMod>([8]) -> ([8]); // 8
store_temp<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>>([14]) -> ([14]); // 9
return([7], [8], [14]); // 10
branch_align() -> (); // 11
struct_construct<Tuple<CircuitPartialOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, CircuitFailureGuarantee>>([12], [13]) -> ([15]); // 12
enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>, 1>([15]) -> ([16]); // 13
store_temp<AddMod>([10]) -> ([10]); // 14
store_temp<MulMod>([11]) -> ([11]); // 15
store_temp<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>>([16]) -> ([16]); // 16
return([10], [11], [16]); // 17

test::foo@0([0]: AddMod, [1]: MulMod, [2]: CircuitDescriptor<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, [3]: CircuitData<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, [4]: CircuitModulus) -> (AddMod, MulMod, core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>, core::circuit::CircuitFailureGuarantee)>);

//! > function_costs
test::foo: OrderedHashMap({AddMod: 1, MulMod: 3, Const: 4100})

//! > ==========================================================================

//! > eval_circuit (with No AddModGate)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{
    Circuit, CircuitData, CircuitDescriptor, CircuitInput, CircuitModulus, EvalCircuitResult,
    InverseGate, eval_circuit,
};
type MyCircuit = Circuit<(InverseGate<CircuitInput<0>>,)>;

fn foo(
    desc: CircuitDescriptor<MyCircuit>, data: CircuitData<MyCircuit>, modulus: CircuitModulus,
) -> EvalCircuitResult<MyCircuit> {
    eval_circuit::<MyCircuit>(desc, data, modulus, 0, 1)
}

//! > casm
[ap + 0] = 0, ap++;
[ap + 0] = 1, ap++;
[fp + -7] = [ap + 0] + 8, ap++;
[ap + -2] = [[ap + -1] + 0];
[ap + -3] = [[ap + -1] + 1];
[ap + -3] = [[ap + -1] + 2];
[ap + -3] = [[ap + -1] + 3];
[fp + -6] = [[fp + -12] + 0];
[fp + -5] = [[fp + -12] + 1];
[fp + -4] = [[fp + -12] + 2];
[fp + -3] = [[fp + -12] + 3];
[ap + -1] = [[fp + -12] + 4];
[fp + -9] = [[fp + -12] + 5];
%{
from starkware.cairo.lang.builtins.modulo.mod_builtin_runner import ModBuiltinRunner

ModBuiltinRunner.fill_memory(
        memory=memory,
        add_mod=(memory[fp + -13], builtin_runners["add_mod_builtin"], memory[fp + -10]),
        mul_mod=(memory[fp + -12], builtin_runners["mul_mod_builtin"], memory[fp + -8]),
)
%}
[ap + 0] = [[fp + -12] + 6], ap++;
[ap + 0] = [ap + -1] * 7, ap++;
[fp + -8] = [ap + 0] + [ap + -2], ap++;
jmp rel 31 if [ap + -1] != 0;
[ap + 0] = [fp + -13] + 0, ap++;
[ap + 0] = [fp + -12] + [ap + -3], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -16], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;
[ap + 0] = [fp + -13] + 0, ap++;
[ap + 0] = [fp + -12] + [ap + -3], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -7], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
[ap + 0] = [ap + -11], ap++;
[ap + 0] = [fp + -9], ap++;
[ap + 0] = [fp + -8], ap++;
[ap + 0] = [ap + -14], ap++;
[ap + 0] = [ap + -16], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > sierra_code
type BoundedInt<0, 0> = BoundedInt<0, 0> [storable: true, drop: true, dup: true, zero_sized: false];
type CircuitPartialOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>> = CircuitPartialOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>> [storable: true, drop: true, dup: false, zero_sized: false];
type CircuitFailureGuarantee = CircuitFailureGuarantee [storable: true, drop: false, dup: false, zero_sized: false];
type Tuple<CircuitPartialOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, CircuitFailureGuarantee> = Struct<ut@Tuple, CircuitPartialOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, CircuitFailureGuarantee> [storable: true, drop: false, dup: false, zero_sized: false];
type CircuitOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>> = CircuitOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>> [storable: true, drop: true, dup: true, zero_sized: false];
type core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)> = Enum<ut@core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>, CircuitOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, Tuple<CircuitPartialOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, CircuitFailureGuarantee>> [storable: true, drop: false, dup: false, zero_sized: false];
type Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)> = Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::InverseGate::<core::circuit::CircuitInput::<0>> = InverseGate<core::circuit::CircuitInput::<0>> [storable: false, drop: false, dup: false, zero_sized: true];
type (core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,) = Struct<ut@Tuple, core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<0> = CircuitInput<0> [storable: false, drop: false, dup: false, zero_sized: true];
type CircuitModulus = CircuitModulus [storable: true, drop: true, dup: true, zero_sized: false];
type CircuitData<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>> = CircuitData<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>> [storable: true, drop: true, dup: false, zero_sized: false];
type CircuitDescriptor<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>> = CircuitDescriptor<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>> [storable: true, drop: true, dup: true, zero_sized: false];
type MulMod = MulMod [storable: true, drop: false, dup: false, zero_sized: false];
type AddMod = AddMod [storable: true, drop: false, dup: false, zero_sized: false];
type Const<BoundedInt<1, 1>, 1> = Const<BoundedInt<1, 1>, 1> [storable: false, drop: false, dup: false, zero_sized: false];
type BoundedInt<1, 1> = BoundedInt<1, 1> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<BoundedInt<0, 0>, 0> = Const<BoundedInt<0, 0>, 0> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<BoundedInt<0, 0>, 0>> = const_as_immediate<Const<BoundedInt<0, 0>, 0>>;
libfunc const_as_immediate<Const<BoundedInt<1, 1>, 1>> = const_as_immediate<Const<BoundedInt<1, 1>, 1>>;
libfunc store_temp<BoundedInt<0, 0>> = store_temp<BoundedInt<0, 0>>;
libfunc store_temp<BoundedInt<1, 1>> = store_temp<BoundedInt<1, 1>>;
libfunc eval_circuit<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>> = eval_circuit<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>;
libfunc branch_align = branch_align;
libfunc enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>, 0> = enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>, 0>;
libfunc store_temp<AddMod> = store_temp<AddMod>;
libfunc store_temp<MulMod> = store_temp<MulMod>;
libfunc store_temp<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>> = store_temp<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>>;
libfunc struct_construct<Tuple<CircuitPartialOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, CircuitFailureGuarantee>> = struct_construct<Tuple<CircuitPartialOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, CircuitFailureGuarantee>>;
libfunc enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>, 1> = enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>, 1>;

const_as_immediate<Const<BoundedInt<0, 0>, 0>>() -> ([5]); // 0
const_as_immediate<Const<BoundedInt<1, 1>, 1>>() -> ([6]); // 1
store_temp<BoundedInt<0, 0>>([5]) -> ([5]); // 2
store_temp<BoundedInt<1, 1>>([6]) -> ([6]); // 3
eval_circuit<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>([0], [1], [2], [3], [4], [5], [6]) { fallthrough([7], [8], [9]) 11([10], [11], [12], [13]) }; // 4
branch_align() -> (); // 5
enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>, 0>([9]) -> ([14]); // 6
store_temp<AddMod>([7]) -> ([7]); // 7
store_temp<MulMod>([8]) -> ([8]); // 8
store_temp<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>>([14]) -> ([14]); // 9
return([7], [8], [14]); // 10
branch_align() -> (); // 11
struct_construct<Tuple<CircuitPartialOutputs<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, CircuitFailureGuarantee>>([12], [13]) -> ([15]); // 12
enum_init<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>, 1>([15]) -> ([16]); // 13
store_temp<AddMod>([10]) -> ([10]); // 14
store_temp<MulMod>([11]) -> ([11]); // 15
store_temp<core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>>([16]) -> ([16]); // 16
return([10], [11], [16]); // 17

test::foo@0([0]: AddMod, [1]: MulMod, [2]: CircuitDescriptor<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, [3]: CircuitData<Circuit<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, [4]: CircuitModulus) -> (AddMod, MulMod, core::result::Result::<core::circuit::CircuitOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, (core::circuit::CircuitPartialOutputs::<core::circuit::Circuit::<(core::circuit::InverseGate::<core::circuit::CircuitInput::<0>>,)>>, core::circuit::CircuitFailureGuarantee)>);

//! > function_costs
test::foo: OrderedHashMap({MulMod: 2, Const: 3400})

//! > ==========================================================================

//! > circuit_failure_guarantee_verify

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{CircuitFailureGuarantee, U96LimbsLtGuarantee, circuit_failure_guarantee_verify};

fn foo(guarantee: CircuitFailureGuarantee) -> U96LimbsLtGuarantee<4> {
    circuit_failure_guarantee_verify(guarantee, 0, 1)
}

//! > casm
[ap + 0] = 0, ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -8] * 3, ap++;
[ap + 0] = [fp + -10] + [ap + -1], ap++;
[ap + -4] = [[ap + -1] + 2];
[ap + 0] = [[ap + -1] + 1], ap++;
[ap + 0] = [[ap + -2] + 0], ap++;
[fp + -11] = [ap + 0] + [fp + -7], ap++;
[ap + -7] = [[fp + -11] + 0];
[ap + -7] = [[fp + -11] + 1];
[ap + -7] = [[fp + -11] + 2];
[ap + -7] = [[fp + -11] + 3];
%{ memory[ap + 0] = segments.add() %}
[ap + -2] = [[ap + 0] + 0], ap++;
[ap + -4] = [[ap + -1] + 1];
[ap + -2] = [[ap + -1] + 2];
[fp + -8] = [[fp + -11] + 4];
[fp + -9] = [ap + 0] + [fp + -8], ap++;
[ap + -1] = [[fp + -11] + 5];
[fp + -6] = [[fp + -12] + 0];
[fp + -5] = [[fp + -12] + 1];
[fp + -4] = [[fp + -12] + 2];
[fp + -3] = [[fp + -12] + 3];
[fp + -7] = [[fp + -12] + 4];
[ap + -2] = [[fp + -12] + 5];
[ap + -8] = [[fp + -12] + 6];
[ap + 0] = [fp + -7] + [ap + -4], ap++;
[ap + 0] = [[ap + -1] + 0], ap++;
[ap + 0] = [[ap + -2] + 1], ap++;
[ap + 0] = [[ap + -3] + 2], ap++;
[ap + 0] = [[ap + -4] + 3], ap++;
jmp rel 9 if [ap + -4] != 0;
jmp rel 7 if [ap + -3] != 0;
jmp rel 5 if [ap + -2] != 0;
jmp rel 3 if [ap + -1] != 0;
[ap + -13] = [ap + -14];
[ap + 0] = [fp + -12] + 7, ap++;
[ap + 0] = [fp + -11] + 6, ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > sierra_code
type BoundedInt<0, 0> = BoundedInt<0, 0> [storable: true, drop: true, dup: true, zero_sized: false];
type U96LimbsLtGuarantee<4> = U96LimbsLtGuarantee<4> [storable: true, drop: false, dup: false, zero_sized: false];
type CircuitFailureGuarantee = CircuitFailureGuarantee [storable: true, drop: false, dup: false, zero_sized: false];
type MulMod = MulMod [storable: true, drop: false, dup: false, zero_sized: false];
type RangeCheck96 = RangeCheck96 [storable: true, drop: false, dup: false, zero_sized: false];
type Const<BoundedInt<1, 1>, 1> = Const<BoundedInt<1, 1>, 1> [storable: false, drop: false, dup: false, zero_sized: false];
type BoundedInt<1, 1> = BoundedInt<1, 1> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<BoundedInt<0, 0>, 0> = Const<BoundedInt<0, 0>, 0> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<BoundedInt<0, 0>, 0>> = const_as_immediate<Const<BoundedInt<0, 0>, 0>>;
libfunc const_as_immediate<Const<BoundedInt<1, 1>, 1>> = const_as_immediate<Const<BoundedInt<1, 1>, 1>>;
libfunc store_temp<BoundedInt<0, 0>> = store_temp<BoundedInt<0, 0>>;
libfunc store_temp<BoundedInt<1, 1>> = store_temp<BoundedInt<1, 1>>;
libfunc circuit_failure_guarantee_verify = circuit_failure_guarantee_verify;
libfunc store_temp<MulMod> = store_temp<MulMod>;
libfunc store_temp<RangeCheck96> = store_temp<RangeCheck96>;
libfunc store_temp<U96LimbsLtGuarantee<4>> = store_temp<U96LimbsLtGuarantee<4>>;

const_as_immediate<Const<BoundedInt<0, 0>, 0>>() -> ([3]); // 0
const_as_immediate<Const<BoundedInt<1, 1>, 1>>() -> ([4]); // 1
store_temp<BoundedInt<0, 0>>([3]) -> ([3]); // 2
store_temp<BoundedInt<1, 1>>([4]) -> ([4]); // 3
circuit_failure_guarantee_verify([1], [0], [2], [3], [4]) -> ([5], [6], [7]); // 4
store_temp<MulMod>([6]) -> ([6]); // 5
store_temp<RangeCheck96>([5]) -> ([5]); // 6
store_temp<U96LimbsLtGuarantee<4>>([7]) -> ([7]); // 7
return([6], [5], [7]); // 8

test::foo@0([0]: MulMod, [1]: RangeCheck96, [2]: CircuitFailureGuarantee) -> (MulMod, RangeCheck96, U96LimbsLtGuarantee<4>);

//! > function_costs
test::foo: OrderedHashMap({Const: 4736})

//! > ==========================================================================

//! > get_circuit_output

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{
    AddModGate, Circuit, CircuitInput, CircuitOutputs, U96LimbsLtGuarantee, get_circuit_output,
    u384,
};


type MyCircuit = Circuit<(AddModGate<CircuitInput<0>, CircuitInput<1>>, CircuitInput<2>)>;

fn foo(outputs: CircuitOutputs<MyCircuit>) -> (u384, U96LimbsLtGuarantee::<4>) {
    get_circuit_output::<MyCircuit, CircuitInput<1>>(outputs)
}

//! > casm
[ap + 0] = [fp + -7] + 20, ap++;
[ap + 0] = [[ap + -1] + 0], ap++;
[ap + 0] = [[ap + -2] + 1], ap++;
[ap + 0] = [[ap + -3] + 2], ap++;
[ap + 0] = [[ap + -4] + 3], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -8], ap++;
[ap + 0] = [ap + -8], ap++;
[ap + 0] = [ap + -8], ap++;
[ap + 0] = [ap + -8], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > sierra_code
type CircuitOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> = CircuitOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<0, 79228162514264337593543950335> = BoundedInt<0, 79228162514264337593543950335> [storable: true, drop: true, dup: true, zero_sized: false];
type core::circuit::u384 = Struct<ut@core::circuit::u384, BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>, BoundedInt<0, 79228162514264337593543950335>> [storable: true, drop: true, dup: true, zero_sized: false];
type U96LimbsLtGuarantee<4> = U96LimbsLtGuarantee<4> [storable: true, drop: false, dup: false, zero_sized: false];
type Tuple<core::circuit::u384, U96LimbsLtGuarantee<4>> = Struct<ut@Tuple, core::circuit::u384, U96LimbsLtGuarantee<4>> [storable: true, drop: false, dup: false, zero_sized: false];
type core::circuit::CircuitInput::<1> = CircuitInput<1> [storable: false, drop: false, dup: false, zero_sized: true];
type Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)> = Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> = AddModGate<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<2> = CircuitInput<2> [storable: false, drop: false, dup: false, zero_sized: true];
type (core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>) = Struct<ut@Tuple, core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>> [storable: false, drop: false, dup: false, zero_sized: true];
type core::circuit::CircuitInput::<0> = CircuitInput<0> [storable: false, drop: false, dup: false, zero_sized: true];

libfunc get_circuit_output<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>, core::circuit::CircuitInput::<1>> = get_circuit_output<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>, core::circuit::CircuitInput::<1>>;
libfunc struct_construct<Tuple<core::circuit::u384, U96LimbsLtGuarantee<4>>> = struct_construct<Tuple<core::circuit::u384, U96LimbsLtGuarantee<4>>>;
libfunc store_temp<Tuple<core::circuit::u384, U96LimbsLtGuarantee<4>>> = store_temp<Tuple<core::circuit::u384, U96LimbsLtGuarantee<4>>>;

get_circuit_output<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>, core::circuit::CircuitInput::<1>>([0]) -> ([1], [2]); // 0
struct_construct<Tuple<core::circuit::u384, U96LimbsLtGuarantee<4>>>([1], [2]) -> ([3]); // 1
store_temp<Tuple<core::circuit::u384, U96LimbsLtGuarantee<4>>>([3]) -> ([3]); // 2
return([3]); // 3

test::foo@0([0]: CircuitOutputs<Circuit<(core::circuit::AddModGate::<core::circuit::CircuitInput::<0>, core::circuit::CircuitInput::<1>>, core::circuit::CircuitInput::<2>)>>) -> (Tuple<core::circuit::u384, U96LimbsLtGuarantee<4>>);

//! > function_costs
test::foo: OrderedHashMap({Const: 1700})

//! > ==========================================================================

//! > into_u96_guarantee

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{U96Guarantee, into_u96_guarantee};


fn foo(val: u8) -> U96Guarantee {
    into_u96_guarantee(val)
}

//! > casm
[ap + 0] = [fp + -3], ap++;
ret;

//! > sierra_code
type u8 = u8 [storable: true, drop: true, dup: true, zero_sized: false];
type U96Guarantee = U96Guarantee [storable: true, drop: false, dup: false, zero_sized: false];

libfunc into_u96_guarantee<u8> = into_u96_guarantee<u8>;
libfunc store_temp<U96Guarantee> = store_temp<U96Guarantee>;

into_u96_guarantee<u8>([0]) -> ([1]); // 0
store_temp<U96Guarantee>([1]) -> ([1]); // 1
return([1]); // 2

test::foo@0([0]: u8) -> (U96Guarantee);

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > ==========================================================================

//! > u96_guarantee_verify

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{U96Guarantee, u96_guarantee_verify};


fn foo(guarantee: U96Guarantee) {
    u96_guarantee_verify(guarantee)
}

//! > casm
[fp + -3] = [[fp + -4] + 0];
[ap + 0] = [fp + -4] + 1, ap++;
ret;

//! > sierra_code
type RangeCheck96 = RangeCheck96 [storable: true, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type U96Guarantee = U96Guarantee [storable: true, drop: false, dup: false, zero_sized: false];

libfunc u96_guarantee_verify = u96_guarantee_verify;
libfunc store_temp<RangeCheck96> = store_temp<RangeCheck96>;

u96_guarantee_verify([0], [1]) -> ([2]); // 0
store_temp<RangeCheck96>([2]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: RangeCheck96, [1]: U96Guarantee) -> (RangeCheck96);

//! > function_costs
test::foo: OrderedHashMap({Const: 256})

//! > ==========================================================================

//! > u96_limbs_less_than_guarantee_verify for 4 limbs.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{
    NextU96LessThanGuarantee, U96LimbsLtGuarantee, u96_limbs_less_than_guarantee_verify,
};

fn foo(guarantee: U96LimbsLtGuarantee<4>) -> NextU96LessThanGuarantee<3> {
    u96_limbs_less_than_guarantee_verify(guarantee)
}

//! > casm
[fp + -3] = [ap + 0] + [fp + -7], ap++;
jmp rel 11 if [ap + -1] != 0;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -10], ap++;
[ap + 0] = [fp + -9], ap++;
[ap + 0] = [fp + -8], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
ret;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -7], ap++;
ret;

//! > sierra_code
type U96LimbsLtGuarantee<4> = U96LimbsLtGuarantee<4> [storable: true, drop: false, dup: false, zero_sized: false];
type U96LimbsLtGuarantee<3> = U96LimbsLtGuarantee<3> [storable: true, drop: false, dup: false, zero_sized: false];
type U96Guarantee = U96Guarantee [storable: true, drop: false, dup: false, zero_sized: false];
type core::circuit::NextU96LessThanGuarantee::<3> = Enum<ut@core::circuit::NextU96LessThanGuarantee::<3>, U96LimbsLtGuarantee<3>, U96Guarantee> [storable: true, drop: false, dup: false, zero_sized: false];

libfunc u96_limbs_less_than_guarantee_verify<4> = u96_limbs_less_than_guarantee_verify<4>;
libfunc branch_align = branch_align;
libfunc enum_init<core::circuit::NextU96LessThanGuarantee::<3>, 0> = enum_init<core::circuit::NextU96LessThanGuarantee::<3>, 0>;
libfunc store_temp<core::circuit::NextU96LessThanGuarantee::<3>> = store_temp<core::circuit::NextU96LessThanGuarantee::<3>>;
libfunc enum_init<core::circuit::NextU96LessThanGuarantee::<3>, 1> = enum_init<core::circuit::NextU96LessThanGuarantee::<3>, 1>;

u96_limbs_less_than_guarantee_verify<4>([0]) { fallthrough([1]) 5([2]) }; // 0
branch_align() -> (); // 1
enum_init<core::circuit::NextU96LessThanGuarantee::<3>, 0>([1]) -> ([3]); // 2
store_temp<core::circuit::NextU96LessThanGuarantee::<3>>([3]) -> ([3]); // 3
return([3]); // 4
branch_align() -> (); // 5
enum_init<core::circuit::NextU96LessThanGuarantee::<3>, 1>([2]) -> ([4]); // 6
store_temp<core::circuit::NextU96LessThanGuarantee::<3>>([4]) -> ([4]); // 7
return([4]); // 8

test::foo@0([0]: U96LimbsLtGuarantee<4>) -> (core::circuit::NextU96LessThanGuarantee::<3>);

//! > function_costs
test::foo: OrderedHashMap({Const: 900})

//! > ==========================================================================

//! > u96_single_limb_less_than_guarantee_verify.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
use core::circuit::{U96Guarantee, U96LimbsLtGuarantee, u96_single_limb_less_than_guarantee_verify};

fn foo(guarantee: U96LimbsLtGuarantee<1>) -> U96Guarantee {
    u96_single_limb_less_than_guarantee_verify(guarantee)
}

//! > casm
[fp + -3] = [ap + 0] + [fp + -4], ap++;
ret;

//! > sierra_code
type U96LimbsLtGuarantee<1> = U96LimbsLtGuarantee<1> [storable: true, drop: false, dup: false, zero_sized: false];
type U96Guarantee = U96Guarantee [storable: true, drop: false, dup: false, zero_sized: false];

libfunc u96_single_limb_less_than_guarantee_verify = u96_single_limb_less_than_guarantee_verify;
libfunc store_temp<U96Guarantee> = store_temp<U96Guarantee>;

u96_single_limb_less_than_guarantee_verify([0]) -> ([1]); // 0
store_temp<U96Guarantee>([1]) -> ([1]); // 1
return([1]); // 2

test::foo@0([0]: U96LimbsLtGuarantee<1>) -> (U96Guarantee);

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > ==========================================================================

//! > U96LimbsLtGuarantee<4> full destruct.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
fn foo(guarantee: core::circuit::U96LimbsLtGuarantee<4>) {}

//! > casm
[fp + -3] = [ap + 0] + [fp + -7], ap++;
jmp rel 19 if [ap + -1] != 0;
[fp + -4] = [ap + 0] + [fp + -8], ap++;
jmp rel 11 if [ap + -1] != 0;
[fp + -5] = [ap + 0] + [fp + -9], ap++;
jmp rel 5 if [ap + -1] != 0;
[fp + -6] = [ap + 0] + [fp + -10], ap++;
jmp rel 13;
[ap + 0] = [ap + -1], ap++;
jmp rel 10;
ap += 1;
[ap + 0] = [ap + -2], ap++;
jmp rel 5;
ap += 2;
[ap + 0] = [ap + -3], ap++;
[ap + -1] = [[fp + -11] + 0];
[ap + 0] = [fp + -11] + 1, ap++;
ret;

//! > sierra_code
type U96LimbsLtGuarantee<4> = U96LimbsLtGuarantee<4> [storable: true, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type RangeCheck96 = RangeCheck96 [storable: true, drop: false, dup: false, zero_sized: false];
type U96LimbsLtGuarantee<1> = U96LimbsLtGuarantee<1> [storable: true, drop: false, dup: false, zero_sized: false];
type U96LimbsLtGuarantee<2> = U96LimbsLtGuarantee<2> [storable: true, drop: false, dup: false, zero_sized: false];
type U96Guarantee = U96Guarantee [storable: true, drop: false, dup: false, zero_sized: false];
type U96LimbsLtGuarantee<3> = U96LimbsLtGuarantee<3> [storable: true, drop: false, dup: false, zero_sized: false];

libfunc u96_limbs_less_than_guarantee_verify<4> = u96_limbs_less_than_guarantee_verify<4>;
libfunc branch_align = branch_align;
libfunc u96_limbs_less_than_guarantee_verify<3> = u96_limbs_less_than_guarantee_verify<3>;
libfunc u96_limbs_less_than_guarantee_verify<2> = u96_limbs_less_than_guarantee_verify<2>;
libfunc u96_single_limb_less_than_guarantee_verify = u96_single_limb_less_than_guarantee_verify;
libfunc store_temp<U96Guarantee> = store_temp<U96Guarantee>;
libfunc jump = jump;
libfunc u96_guarantee_verify = u96_guarantee_verify;
libfunc store_temp<RangeCheck96> = store_temp<RangeCheck96>;

u96_limbs_less_than_guarantee_verify<4>([1]) { fallthrough([2]) 15([3]) }; // 0
branch_align() -> (); // 1
u96_limbs_less_than_guarantee_verify<3>([2]) { fallthrough([4]) 12([5]) }; // 2
branch_align() -> (); // 3
u96_limbs_less_than_guarantee_verify<2>([4]) { fallthrough([6]) 9([7]) }; // 4
branch_align() -> (); // 5
u96_single_limb_less_than_guarantee_verify([6]) -> ([8]); // 6
store_temp<U96Guarantee>([8]) -> ([9]); // 7
jump() { 17() }; // 8
branch_align() -> (); // 9
store_temp<U96Guarantee>([7]) -> ([9]); // 10
jump() { 17() }; // 11
branch_align() -> (); // 12
store_temp<U96Guarantee>([5]) -> ([9]); // 13
jump() { 17() }; // 14
branch_align() -> (); // 15
store_temp<U96Guarantee>([3]) -> ([9]); // 16
u96_guarantee_verify([0], [9]) -> ([10]); // 17
store_temp<RangeCheck96>([10]) -> ([10]); // 18
return([10]); // 19

test::foo@0([0]: RangeCheck96, [1]: U96LimbsLtGuarantee<4>) -> (RangeCheck96);

//! > function_costs
test::foo: OrderedHashMap({Const: 1056})
