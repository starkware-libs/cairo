//! > simple addition - basic arithmetic

//! > test_runner_name
SmallE2ETestRunner(test_data_function: add_three, test_data_input: 5, test_data_output: 8)

//! > cairo_code
fn add_three(x: felt252) -> felt252 {
    x + 3
}

//! > casm
[ap + 0] = [fp + -3] + 3, ap++;
ret;

//! > function_costs
test::add_three: SmallOrderedMap([(Const, 100)])

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 3> = Const<felt252, 3> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<felt252, 3>> = const_as_immediate<Const<felt252, 3>>;
libfunc felt252_add = felt252_add;
libfunc store_temp<felt252> = store_temp<felt252>;

F0:
const_as_immediate<Const<felt252, 3>>() -> ([1]);
felt252_add([0], [1]) -> ([2]);
store_temp<felt252>([2]) -> ([2]);
return([2]);

test::add_three@F0([0]: felt252) -> (felt252);

//! > ==========================================================================

//! > box creation and unbox - simple box operations

//! > test_runner_name
SmallE2ETestRunner(test_data_function: box_double, test_data_input: 7, test_data_output: 14)

//! > cairo_code
fn box_double(x: felt252) -> felt252 {
    let boxed = BoxTrait::new(x);
    let val = boxed.unbox();
    val + val
}

//! > casm
%{
if '__boxed_segment' not in globals():
    __boxed_segment = segments.add()
memory[ap + 0] = __boxed_segment
__boxed_segment += 1
%}
[fp + -3] = [[ap + 0] + 0], ap++;
[ap + 0] = [[ap + -1] + 0], ap++;
[ap + 0] = [ap + -1] + [ap + -1], ap++;
ret;

//! > function_costs
test::box_double: SmallOrderedMap([(Const, 300)])

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Box<felt252> = Box<felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc into_box<felt252> = into_box<felt252>;
libfunc unbox<felt252> = unbox<felt252>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc dup<felt252> = dup<felt252>;
libfunc felt252_add = felt252_add;

F0:
into_box<felt252>([0]) -> ([1]);
unbox<felt252>([1]) -> ([2]);
store_temp<felt252>([2]) -> ([2]);
dup<felt252>([2]) -> ([2], [3]);
felt252_add([3], [2]) -> ([4]);
store_temp<felt252>([4]) -> ([4]);
return([4]);

test::box_double@F0([0]: felt252) -> (felt252);

//! > ==========================================================================

//! > match control flow - returns different values based on input

//! > test_runner_name
SmallE2ETestRunner(test_data_function: match_val, test_data_input: 2, test_data_output: 20)

//! > cairo_code
fn match_val(x: felt252) -> felt252 {
    if x == 0 {
        0
    } else if x == 1 {
        10
    } else {
        20
    }
}

//! > casm
[fp + -3] = [ap + 0] + 0, ap++;
jmp rel 7 if [ap + -1] != 0;
ap += 1;
[ap + 0] = 0, ap++;
ret;
[fp + -3] = [ap + 0] + 1, ap++;
jmp rel 5 if [ap + -1] != 0;
[ap + 0] = 10, ap++;
ret;
[ap + 0] = 20, ap++;
ret;

//! > function_costs
test::match_val: SmallOrderedMap([(Const, 500)])

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 20> = Const<felt252, 20> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<felt252, 10> = Const<felt252, 10> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<felt252, 1> = Const<felt252, 1> [storable: false, drop: false, dup: false, zero_sized: false];
type NonZero<felt252> = NonZero<felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<felt252, 0> = Const<felt252, 0> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<felt252, 0>> = const_as_immediate<Const<felt252, 0>>;
libfunc dup<felt252> = dup<felt252>;
libfunc felt252_sub = felt252_sub;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc felt252_is_zero = felt252_is_zero;
libfunc branch_align = branch_align;
libfunc drop<felt252> = drop<felt252>;
libfunc drop<NonZero<felt252>> = drop<NonZero<felt252>>;
libfunc const_as_immediate<Const<felt252, 1>> = const_as_immediate<Const<felt252, 1>>;
libfunc const_as_immediate<Const<felt252, 10>> = const_as_immediate<Const<felt252, 10>>;
libfunc const_as_immediate<Const<felt252, 20>> = const_as_immediate<Const<felt252, 20>>;

F0:
const_as_immediate<Const<felt252, 0>>() -> ([1]);
dup<felt252>([0]) -> ([0], [2]);
dup<felt252>([1]) -> ([1], [3]);
felt252_sub([2], [3]) -> ([4]);
store_temp<felt252>([4]) -> ([4]);
felt252_is_zero([4]) { fallthrough() F0_B0([5]) };
branch_align() -> ();
drop<felt252>([0]) -> ();
store_temp<felt252>([1]) -> ([1]);
return([1]);
F0_B0:
branch_align() -> ();
drop<NonZero<felt252>>([5]) -> ();
drop<felt252>([1]) -> ();
const_as_immediate<Const<felt252, 1>>() -> ([6]);
felt252_sub([0], [6]) -> ([7]);
store_temp<felt252>([7]) -> ([7]);
felt252_is_zero([7]) { fallthrough() F0_B1([8]) };
branch_align() -> ();
const_as_immediate<Const<felt252, 10>>() -> ([9]);
store_temp<felt252>([9]) -> ([9]);
return([9]);
F0_B1:
branch_align() -> ();
drop<NonZero<felt252>>([8]) -> ();
const_as_immediate<Const<felt252, 20>>() -> ([10]);
store_temp<felt252>([10]) -> ([10]);
return([10]);

test::match_val@F0([0]: felt252) -> (felt252);

//! > ==========================================================================

//! > fibonacci with loop - fib(n) using while loop (without gas tracking)

//! > test_runner_name
SmallE2ETestRunner(skip_gas: false, test_data_function: fib, test_data_input: 3, test_data_output: 2)

//! > cairo_code
fn fib(n: felt252) -> felt252 {
    let mut a: felt252 = 0;
    let mut b: felt252 = 1;
    let mut i: felt252 = 0;
    while i != n {
        let temp = b;
        b = a + b;
        a = temp;
        i = i + 1;
    }
    a
}

//! > casm
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3], ap++;
call rel 19;
jmp rel 10 if [ap + -4] != 0;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -6], ap++;
ret;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -5], ap++;
ret;
%{ memory[ap + 0] = 1570 <= memory[fp + -7] %}
jmp rel 7 if [ap + 0] != 0, ap++;
[ap + 0] = [fp + -7] + 340282366920938463463374607431768209886, ap++;
[ap + -1] = [[fp + -8] + 0];
jmp rel 37;
[fp + -7] = [ap + 0] + 1570, ap++;
[ap + -1] = [[fp + -8] + 0];
[fp + -4] = [ap + 0] + [fp + -3], ap++;
jmp rel 16 if [ap + -1] != 0;
[ap + 0] = 1, ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -8] + 1, ap++;
[ap + 0] = [ap + -5] + 2170, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
ret;
[ap + 0] = 0, ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -8] + 1, ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [fp + -5] + [fp + -6], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = [fp + -3], ap++;
call rel -39;
ret;
call rel 12;
[ap + 0] = [fp + -8] + 1, ap++;
[ap + 0] = [fp + -7], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -6], ap++;
ret;
[ap + 0] = 375233589013918064796019, ap++;
call rel 3;
ret;
%{ memory[ap + 0] = segments.add() %}
ap += 1;
[fp + -3] = [[ap + -1] + 0];
[ap + 0] = [ap + -1], ap++;
[ap + 0] = [ap + -2] + 1, ap++;
ret;

//! > function_costs
test::fib: SmallOrderedMap([(Const, 3370)])
test::fib[116-219]: SmallOrderedMap([(Const, 1970)])
core::panic_with_const_felt252::<375233589013918064796019>: SmallOrderedMap([(Const, 700)])
core::panic_with_felt252: SmallOrderedMap([(Const, 400)])

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type core::panics::Panic = Struct<ut@core::panics::Panic> [storable: true, drop: true, dup: true, zero_sized: true];
type Array<felt252> = Array<felt252> [storable: true, drop: true, dup: false, zero_sized: false];
type Const<felt252, 375233589013918064796019> = Const<felt252, 375233589013918064796019> [storable: false, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type core::bool = Enum<ut@core::bool, Unit, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type NonZero<felt252> = NonZero<felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<felt252> = Struct<ut@Tuple, felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<core::panics::Panic, Array<felt252>> = Struct<ut@Tuple, core::panics::Panic, Array<felt252>> [storable: true, drop: true, dup: false, zero_sized: false];
type core::panics::PanicResult::<(core::felt252,)> = Enum<ut@core::panics::PanicResult::<(core::felt252,)>, Tuple<felt252>, Tuple<core::panics::Panic, Array<felt252>>> [storable: true, drop: true, dup: false, zero_sized: false];
type Tuple<felt252, felt252, felt252, Unit> = Struct<ut@Tuple, felt252, felt252, felt252, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())> = Enum<ut@core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>, Tuple<felt252, felt252, felt252, Unit>, Tuple<core::panics::Panic, Array<felt252>>> [storable: true, drop: true, dup: false, zero_sized: false];
type GasBuiltin = GasBuiltin [storable: true, drop: false, dup: false, zero_sized: false];
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type Const<felt252, 1> = Const<felt252, 1> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<felt252, 0> = Const<felt252, 0> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc disable_ap_tracking = disable_ap_tracking;
libfunc const_as_immediate<Const<felt252, 0>> = const_as_immediate<Const<felt252, 0>>;
libfunc const_as_immediate<Const<felt252, 1>> = const_as_immediate<Const<felt252, 1>>;
libfunc snapshot_take<felt252> = snapshot_take<felt252>;
libfunc drop<felt252> = drop<felt252>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<GasBuiltin> = store_temp<GasBuiltin>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc dup<felt252> = dup<felt252>;
libfunc function_call<user@test::fib[116-219]> = function_call<user@test::fib[116-219]>;
libfunc enum_match<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>> = enum_match<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>>;
libfunc branch_align = branch_align;
libfunc redeposit_gas = redeposit_gas;
libfunc struct_deconstruct<Tuple<felt252, felt252, felt252, Unit>> = struct_deconstruct<Tuple<felt252, felt252, felt252, Unit>>;
libfunc drop<Unit> = drop<Unit>;
libfunc struct_construct<Tuple<felt252>> = struct_construct<Tuple<felt252>>;
libfunc enum_init<core::panics::PanicResult::<(core::felt252,)>, 0> = enum_init<core::panics::PanicResult::<(core::felt252,)>, 0>;
libfunc store_temp<core::panics::PanicResult::<(core::felt252,)>> = store_temp<core::panics::PanicResult::<(core::felt252,)>>;
libfunc enum_init<core::panics::PanicResult::<(core::felt252,)>, 1> = enum_init<core::panics::PanicResult::<(core::felt252,)>, 1>;
libfunc withdraw_gas = withdraw_gas;
libfunc rename<felt252> = rename<felt252>;
libfunc felt252_sub = felt252_sub;
libfunc felt252_is_zero = felt252_is_zero;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc dup<Unit> = dup<Unit>;
libfunc enum_init<core::bool, 1> = enum_init<core::bool, 1>;
libfunc store_temp<core::bool> = store_temp<core::bool>;
libfunc bool_not_impl = bool_not_impl;
libfunc drop<core::bool> = drop<core::bool>;
libfunc struct_construct<Tuple<felt252, felt252, felt252, Unit>> = struct_construct<Tuple<felt252, felt252, felt252, Unit>>;
libfunc enum_init<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>, 0> = enum_init<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>, 0>;
libfunc store_temp<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>> = store_temp<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>>;
libfunc drop<NonZero<felt252>> = drop<NonZero<felt252>>;
libfunc enum_init<core::bool, 0> = enum_init<core::bool, 0>;
libfunc felt252_add = felt252_add;
libfunc function_call<user@core::panic_with_const_felt252::<375233589013918064796019>> = function_call<user@core::panic_with_const_felt252::<375233589013918064796019>>;
libfunc enum_init<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>, 1> = enum_init<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>, 1>;
libfunc const_as_immediate<Const<felt252, 375233589013918064796019>> = const_as_immediate<Const<felt252, 375233589013918064796019>>;
libfunc function_call<user@core::panic_with_felt252> = function_call<user@core::panic_with_felt252>;
libfunc array_new<felt252> = array_new<felt252>;
libfunc array_append<felt252> = array_append<felt252>;
libfunc struct_construct<core::panics::Panic> = struct_construct<core::panics::Panic>;
libfunc struct_construct<Tuple<core::panics::Panic, Array<felt252>>> = struct_construct<Tuple<core::panics::Panic, Array<felt252>>>;
libfunc store_temp<Tuple<core::panics::Panic, Array<felt252>>> = store_temp<Tuple<core::panics::Panic, Array<felt252>>>;

F0:
disable_ap_tracking() -> ();
const_as_immediate<Const<felt252, 0>>() -> ([3]);
const_as_immediate<Const<felt252, 1>>() -> ([4]);
snapshot_take<felt252>([2]) -> ([5], [6]);
drop<felt252>([5]) -> ();
store_temp<RangeCheck>([0]) -> ([0]);
store_temp<GasBuiltin>([1]) -> ([1]);
store_temp<felt252>([4]) -> ([4]);
dup<felt252>([3]) -> ([3], [7]);
store_temp<felt252>([7]) -> ([7]);
store_temp<felt252>([3]) -> ([3]);
store_temp<felt252>([6]) -> ([6]);
function_call<user@test::fib[116-219]>([0], [1], [4], [7], [3], [6]) -> ([8], [9], [10]);
enum_match<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>>([10]) { fallthrough([11]) F0_B0([12]) };
branch_align() -> ();
redeposit_gas([9]) -> ([13]);
struct_deconstruct<Tuple<felt252, felt252, felt252, Unit>>([11]) -> ([14], [15], [16], [17]);
drop<felt252>([14]) -> ();
drop<felt252>([16]) -> ();
drop<Unit>([17]) -> ();
struct_construct<Tuple<felt252>>([15]) -> ([18]);
enum_init<core::panics::PanicResult::<(core::felt252,)>, 0>([18]) -> ([19]);
store_temp<RangeCheck>([8]) -> ([8]);
store_temp<GasBuiltin>([13]) -> ([13]);
store_temp<core::panics::PanicResult::<(core::felt252,)>>([19]) -> ([19]);
return([8], [13], [19]);
F0_B0:
branch_align() -> ();
enum_init<core::panics::PanicResult::<(core::felt252,)>, 1>([12]) -> ([20]);
store_temp<RangeCheck>([8]) -> ([8]);
store_temp<GasBuiltin>([9]) -> ([9]);
store_temp<core::panics::PanicResult::<(core::felt252,)>>([20]) -> ([20]);
return([8], [9], [20]);
F1:
disable_ap_tracking() -> ();
withdraw_gas([0], [1]) { fallthrough([6], [7]) F1_B1([8], [9]) };
branch_align() -> ();
dup<felt252>([5]) -> ([5], [10]);
rename<felt252>([10]) -> ([11]);
dup<felt252>([4]) -> ([4], [12]);
felt252_sub([12], [11]) -> ([13]);
store_temp<felt252>([13]) -> ([13]);
felt252_is_zero([13]) { fallthrough() F1_B0([14]) };
branch_align() -> ();
drop<felt252>([5]) -> ();
redeposit_gas([7]) -> ([15]);
struct_construct<Unit>() -> ([16]);
dup<Unit>([16]) -> ([16], [17]);
enum_init<core::bool, 1>([17]) -> ([18]);
store_temp<core::bool>([18]) -> ([18]);
bool_not_impl([18]) -> ([19]);
drop<core::bool>([19]) -> ();
struct_construct<Tuple<felt252, felt252, felt252, Unit>>([2], [3], [4], [16]) -> ([20]);
enum_init<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>, 0>([20]) -> ([21]);
store_temp<RangeCheck>([6]) -> ([6]);
store_temp<GasBuiltin>([15]) -> ([15]);
store_temp<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>>([21]) -> ([21]);
return([6], [15], [21]);
F1_B0:
branch_align() -> ();
drop<NonZero<felt252>>([14]) -> ();
redeposit_gas([7]) -> ([22]);
struct_construct<Unit>() -> ([23]);
enum_init<core::bool, 0>([23]) -> ([24]);
store_temp<core::bool>([24]) -> ([24]);
bool_not_impl([24]) -> ([25]);
drop<core::bool>([25]) -> ();
dup<felt252>([2]) -> ([2], [26]);
felt252_add([3], [26]) -> ([27]);
const_as_immediate<Const<felt252, 1>>() -> ([28]);
felt252_add([4], [28]) -> ([29]);
store_temp<RangeCheck>([6]) -> ([6]);
store_temp<GasBuiltin>([22]) -> ([22]);
store_temp<felt252>([27]) -> ([27]);
store_temp<felt252>([2]) -> ([2]);
store_temp<felt252>([29]) -> ([29]);
store_temp<felt252>([5]) -> ([5]);
function_call<user@test::fib[116-219]>([6], [22], [27], [2], [29], [5]) -> ([30], [31], [32]);
return([30], [31], [32]);
F1_B1:
branch_align() -> ();
drop<felt252>([5]) -> ();
drop<felt252>([3]) -> ();
drop<felt252>([2]) -> ();
drop<felt252>([4]) -> ();
function_call<user@core::panic_with_const_felt252::<375233589013918064796019>>() -> ([33]);
enum_init<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>, 1>([33]) -> ([34]);
store_temp<RangeCheck>([8]) -> ([8]);
store_temp<GasBuiltin>([9]) -> ([9]);
store_temp<core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>>([34]) -> ([34]);
return([8], [9], [34]);
F2:
const_as_immediate<Const<felt252, 375233589013918064796019>>() -> ([0]);
store_temp<felt252>([0]) -> ([0]);
function_call<user@core::panic_with_felt252>([0]) -> ([1]);
return([1]);
F3:
array_new<felt252>() -> ([1]);
array_append<felt252>([1], [0]) -> ([2]);
struct_construct<core::panics::Panic>() -> ([3]);
struct_construct<Tuple<core::panics::Panic, Array<felt252>>>([3], [2]) -> ([4]);
store_temp<Tuple<core::panics::Panic, Array<felt252>>>([4]) -> ([4]);
return([4]);

test::fib@F0([0]: RangeCheck, [1]: GasBuiltin, [2]: felt252) -> (RangeCheck, GasBuiltin, core::panics::PanicResult::<(core::felt252,)>);
test::fib[116-219]@F1([0]: RangeCheck, [1]: GasBuiltin, [2]: felt252, [3]: felt252, [4]: felt252, [5]: felt252) -> (RangeCheck, GasBuiltin, core::panics::PanicResult::<(core::felt252, core::felt252, core::felt252, ())>);
core::panic_with_const_felt252::<375233589013918064796019>@F2() -> (Tuple<core::panics::Panic, Array<felt252>>);
core::panic_with_felt252@F3([0]: felt252) -> (Tuple<core::panics::Panic, Array<felt252>>);
