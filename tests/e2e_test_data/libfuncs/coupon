//! > coupon type and coupon_call

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
impl DropCoupon<T, impl DropImpl: Drop<T>> of Drop<bar::<T, DropImpl>::Coupon>;

fn foo(x: bar::<u8>::Coupon) {
    bar::<u8>(0, __coupon__: x);
}

fn bar<T, +Drop<T>>(x: T) -> felt252 {
    10
}

//! > casm
[ap + 0] = 0, ap++;
call rel 3;
ret;
[ap + 0] = 10, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 300})
test::bar::<core::integer::u8, core::integer::u8Drop>: OrderedHashMap({Const: 100})

//! > sierra_code
type u8 = u8 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> [storable: true, drop: true, dup: false, zero_sized: true];

libfunc u8_const<0> = u8_const<0>;
libfunc store_temp<u8> = store_temp<u8>;
libfunc coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>;
libfunc drop<felt252> = drop<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc drop<u8> = drop<u8>;
libfunc felt252_const<10> = felt252_const<10>;
libfunc store_temp<felt252> = store_temp<felt252>;

u8_const<0>() -> ([1]); // 0
store_temp<u8>([1]) -> ([1]); // 1
coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>([1], [0]) -> ([2]); // 2
drop<felt252>([2]) -> (); // 3
struct_construct<Unit>() -> ([3]); // 4
return([3]); // 5
drop<u8>([0]) -> (); // 6
felt252_const<10>() -> ([1]); // 7
store_temp<felt252>([1]) -> ([1]); // 8
return([1]); // 9

test::foo@0([0]: Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>) -> (Unit);
test::bar::<core::integer::u8, core::integer::u8Drop>@6([0]: u8) -> (felt252);

//! > ==========================================================================

//! > coupon_buy

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
impl DropCoupon<T, impl DropImpl: Drop<T>> of Drop<bar::<T, DropImpl>::Coupon>;
extern fn coupon_buy<T>() -> T nopanic;

fn foo() {
    // Buy coupons.
    let (c0, _c1) = buy_coupons();
    // Use coupons.
    bar(0, __coupon__: c0);
}

fn buy_coupons() -> (bar::<u8>::Coupon, bar::<u8>::Coupon) {
    (coupon_buy(), coupon_buy())
}

fn bar<T, +Drop<T>>(x: T) -> felt252 {
    10
}

//! > casm
call rel 7;
[ap + 0] = 0, ap++;
call rel 4;
ret;
ret;
[ap + 0] = 10, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 700})
test::buy_coupons: OrderedHashMap({Const: 200})
test::bar::<core::integer::u8, core::integer::u8Drop>: OrderedHashMap({Const: 100})

//! > sierra_code
type Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> [storable: true, drop: true, dup: false, zero_sized: true];
type Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>> = Struct<ut@Tuple, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>> [storable: true, drop: true, dup: false, zero_sized: true];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type u8 = u8 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc function_call<user@test::buy_coupons> = function_call<user@test::buy_coupons>;
libfunc struct_deconstruct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>> = struct_deconstruct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>>;
libfunc drop<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>> = drop<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>;
libfunc u8_const<0> = u8_const<0>;
libfunc store_temp<u8> = store_temp<u8>;
libfunc coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>;
libfunc drop<felt252> = drop<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc coupon_buy<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>> = coupon_buy<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>;
libfunc struct_construct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>> = struct_construct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>>;
libfunc drop<u8> = drop<u8>;
libfunc felt252_const<10> = felt252_const<10>;
libfunc store_temp<felt252> = store_temp<felt252>;

function_call<user@test::buy_coupons>() -> ([0]); // 0
struct_deconstruct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>>([0]) -> ([1], [2]); // 1
drop<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>([2]) -> (); // 2
u8_const<0>() -> ([3]); // 3
store_temp<u8>([3]) -> ([3]); // 4
coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>([3], [1]) -> ([4]); // 5
drop<felt252>([4]) -> (); // 6
struct_construct<Unit>() -> ([5]); // 7
return([5]); // 8
coupon_buy<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>() -> ([0]); // 9
coupon_buy<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>() -> ([1]); // 10
struct_construct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>>([0], [1]) -> ([2]); // 11
return([2]); // 12
drop<u8>([0]) -> (); // 13
felt252_const<10>() -> ([1]); // 14
store_temp<felt252>([1]) -> ([1]); // 15
return([1]); // 16

test::foo@0() -> (Unit);
test::buy_coupons@9() -> (Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>);
test::bar::<core::integer::u8, core::integer::u8Drop>@13([0]: u8) -> (felt252);

//! > ==========================================================================

//! > coupon_refund

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern fn coupon_refund<T>(c: T) nopanic;

fn foo(c: bar::<u8>::Coupon) {
    // Get refund on coupon.
    coupon_refund(c);
    bar(0_u8);
}

#[inline(never)]
fn bar<T, +Drop<T>>(x: T) -> felt252 {
    10
}

//! > casm
[ap + 0] = 0, ap++;
call rel 3;
ret;
[ap + 0] = 10, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 300})
test::bar::<core::integer::u8, core::integer::u8Drop>: OrderedHashMap({Const: 100})

//! > sierra_code
type Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> [storable: true, drop: true, dup: false, zero_sized: true];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type u8 = u8 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc coupon_refund<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>> = coupon_refund<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>;
libfunc u8_const<0> = u8_const<0>;
libfunc store_temp<u8> = store_temp<u8>;
libfunc function_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = function_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>;
libfunc drop<felt252> = drop<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc drop<u8> = drop<u8>;
libfunc felt252_const<10> = felt252_const<10>;
libfunc store_temp<felt252> = store_temp<felt252>;

coupon_refund<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>([0]) -> (); // 0
u8_const<0>() -> ([1]); // 1
store_temp<u8>([1]) -> ([1]); // 2
function_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>([1]) -> ([2]); // 3
drop<felt252>([2]) -> (); // 4
struct_construct<Unit>() -> ([3]); // 5
return([3]); // 6
drop<u8>([0]) -> (); // 7
felt252_const<10>() -> ([1]); // 8
store_temp<felt252>([1]) -> ([1]); // 9
return([1]); // 10

test::foo@0([0]: Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>) -> (Unit);
test::bar::<core::integer::u8, core::integer::u8Drop>@7([0]: u8) -> (felt252);

//! > ==========================================================================

//! > Use coupon to destruct Array of non-droppable.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern fn drop<T>(c: T) nopanic;

struct NonDroppable {
    x: u64,
}

// TODO(lior): Mark as nopanic once the compiler allows it.
fn destruct(arr: Array<(NonDroppable, destruct::Coupon)>) {
    match arr.pop_front_consume() {
        Option::Some((rem, (elm, coupon))) => {
            integer::u64_bitwise(elm.x, elm.x);
            drop(elm);
            destruct(rem, __coupon__: coupon);
        },
        Option::None => {},
    }
}

//! > casm
[fp + -3] = [ap + 0] + [fp + -4], ap++;
jmp rel 4 if [ap + -1] != 0;
jmp rel 14;
[ap + 0] = [[fp + -4] + 0], ap++;
[ap + -1] = [[fp + -5] + 0];
[ap + -1] = [[fp + -5] + 1];
[ap + 0] = [fp + -5] + 5, ap++;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = [fp + -3], ap++;
call rel -13;
jmp rel 3;
[ap + 0] = [fp + -5], ap++;
ret;

//! > function_costs
test::destruct: OrderedHashMap({Bitwise: 1, Const: 1100})

//! > sierra_code
type Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> [storable: true, drop: true, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type Bitwise = Bitwise [storable: true, drop: false, dup: false, zero_sized: false];
type u64 = u64 [storable: true, drop: true, dup: true, zero_sized: false];
type Coupon<user@test::destruct> = Coupon<user@test::destruct> [storable: true, drop: true, dup: false, zero_sized: true];
type test::NonDroppable = Struct<ut@test::NonDroppable, u64> [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<test::NonDroppable, Coupon<user@test::destruct>> = Struct<ut@Tuple, test::NonDroppable, Coupon<user@test::destruct>> [storable: true, drop: true, dup: false, zero_sized: false];
type Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = Struct<ut@Tuple, Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>> [storable: true, drop: true, dup: false, zero_sized: false];
type Box<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = Box<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> [storable: true, drop: true, dup: false, zero_sized: false];

libfunc disable_ap_tracking = disable_ap_tracking;
libfunc array_pop_front_consume<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = array_pop_front_consume<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>;
libfunc branch_align = branch_align;
libfunc unbox<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = unbox<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>;
libfunc struct_construct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>> = struct_construct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>;
libfunc struct_deconstruct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>> = struct_deconstruct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>;
libfunc struct_deconstruct<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = struct_deconstruct<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>;
libfunc struct_deconstruct<test::NonDroppable> = struct_deconstruct<test::NonDroppable>;
libfunc store_temp<u64> = store_temp<u64>;
libfunc dup<u64> = dup<u64>;
libfunc u64_bitwise = u64_bitwise;
libfunc drop<u64> = drop<u64>;
libfunc struct_construct<test::NonDroppable> = struct_construct<test::NonDroppable>;
libfunc drop<test::NonDroppable> = drop<test::NonDroppable>;
libfunc store_temp<Bitwise> = store_temp<Bitwise>;
libfunc store_temp<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>> = store_temp<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>;
libfunc coupon_call<user@test::destruct> = coupon_call<user@test::destruct>;
libfunc drop<Unit> = drop<Unit>;
libfunc rename<Bitwise> = rename<Bitwise>;
libfunc jump = jump;
libfunc struct_construct<Unit> = struct_construct<Unit>;

disable_ap_tracking() -> (); // 0
array_pop_front_consume<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>([1]) { fallthrough([2], [3]) 23() }; // 1
branch_align() -> (); // 2
unbox<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>([3]) -> ([4]); // 3
struct_construct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>([2], [4]) -> ([5]); // 4
struct_deconstruct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>([5]) -> ([6], [7]); // 5
struct_deconstruct<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>([7]) -> ([8], [9]); // 6
struct_deconstruct<test::NonDroppable>([8]) -> ([10]); // 7
store_temp<u64>([10]) -> ([10]); // 8
dup<u64>([10]) -> ([10], [11]); // 9
dup<u64>([10]) -> ([10], [12]); // 10
u64_bitwise([0], [11], [12]) -> ([13], [14], [15], [16]); // 11
drop<u64>([14]) -> (); // 12
drop<u64>([15]) -> (); // 13
drop<u64>([16]) -> (); // 14
struct_construct<test::NonDroppable>([10]) -> ([17]); // 15
drop<test::NonDroppable>([17]) -> (); // 16
store_temp<Bitwise>([13]) -> ([13]); // 17
store_temp<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>([6]) -> ([6]); // 18
coupon_call<user@test::destruct>([13], [6], [9]) -> ([18], [19]); // 19
drop<Unit>([19]) -> (); // 20
rename<Bitwise>([18]) -> ([20]); // 21
jump() { 25() }; // 22
branch_align() -> (); // 23
store_temp<Bitwise>([0]) -> ([20]); // 24
struct_construct<Unit>() -> ([21]); // 25
return([20], [21]); // 26

test::destruct@0([0]: Bitwise, [1]: Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>) -> (Bitwise, Unit);

//! > ==========================================================================

//! > Withdraw gas is added when coupon_buy is used recursively.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern fn coupon_buy<T>() -> T nopanic;
extern fn coupon_refund<T>(c: T) nopanic;
impl CouponRecursiveBuyDrop of Drop<recursive_buy::<u8>::Coupon>;
impl CouponRecursiveRefundDrop of Drop<recursive_refund::<u8>::Coupon>;

fn recursive_buy<T>() {
    coupon_buy::<recursive_buy::<u8>::Coupon>();
}

fn recursive_refund<T>(c: recursive_refund::<u8>::Coupon) {
    coupon_refund(c);
}

fn foo(c: recursive_refund::<u8>::Coupon) {
    recursive_buy::<u8>();
    recursive_refund::<u8>(c);
}

//! > casm
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 35;
jmp rel 24 if [ap + -3] != 0;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -5], ap++;
call rel 65;
jmp rel 11 if [ap + -3] != 0;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
ret;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -5], ap++;
ret;
ap += 13;
[ap + 0] = [ap + -18], ap++;
[ap + 0] = [ap + -18], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -18], ap++;
[ap + 0] = [ap + -18], ap++;
ret;
%{ memory[ap + 0] = 990 <= memory[fp + -3] %}
jmp rel 7 if [ap + 0] != 0, ap++;
[ap + 0] = [fp + -3] + 340282366920938463463374607431768210466, ap++;
[ap + -1] = [[fp + -4] + 0];
jmp rel 17;
[fp + -3] = [ap + 0] + 990, ap++;
[ap + -1] = [[fp + -4] + 0];
ap += 2;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
ret;
%{ memory[ap + 0] = segments.add() %}
ap += 1;
[ap + 0] = 375233589013918064796019, ap++;
[ap + -1] = [[ap + -2] + 0];
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = [fp + -3], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -6] + 1, ap++;
ret;
%{ memory[ap + 0] = 0 <= memory[fp + -3] %}
jmp rel 7 if [ap + 0] != 0, ap++;
[ap + 0] = [fp + -3] + 340282366920938463463374607431768211456, ap++;
[ap + -1] = [[fp + -4] + 0];
jmp rel 17;
[fp + -3] = [ap + 0] + 0, ap++;
[ap + -1] = [[fp + -4] + 0];
ap += 2;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
ret;
%{ memory[ap + 0] = segments.add() %}
ap += 1;
[ap + 0] = 375233589013918064796019, ap++;
[ap + -1] = [[ap + -2] + 0];
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = [fp + -3], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -6] + 1, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 4040})
test::recursive_buy::<core::integer::u8>: OrderedHashMap({Const: 1270})
test::recursive_refund::<core::integer::u8>: OrderedHashMap({Const: 1270})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type core::panics::Panic = Struct<ut@core::panics::Panic> [storable: true, drop: true, dup: true, zero_sized: true];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Array<felt252> = Array<felt252> [storable: true, drop: true, dup: false, zero_sized: false];
type Coupon<user@test::recursive_buy::<core::integer::u8>> = Coupon<user@test::recursive_buy::<core::integer::u8>> [storable: true, drop: true, dup: false, zero_sized: true];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type Coupon<user@test::recursive_refund::<core::integer::u8>> = Coupon<user@test::recursive_refund::<core::integer::u8>> [storable: true, drop: true, dup: false, zero_sized: true];
type Tuple<core::panics::Panic, Array<felt252>> = Struct<ut@Tuple, core::panics::Panic, Array<felt252>> [storable: true, drop: true, dup: false, zero_sized: false];
type Tuple<Unit> = Struct<ut@Tuple, Unit> [storable: true, drop: true, dup: true, zero_sized: true];
type core::panics::PanicResult::<((),)> = Enum<ut@core::panics::PanicResult::<((),)>, Tuple<Unit>, Tuple<core::panics::Panic, Array<felt252>>> [storable: true, drop: true, dup: false, zero_sized: false];
type GasBuiltin = GasBuiltin [storable: true, drop: false, dup: false, zero_sized: false];

libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<GasBuiltin> = store_temp<GasBuiltin>;
libfunc function_call<user@test::recursive_buy::<core::integer::u8>> = function_call<user@test::recursive_buy::<core::integer::u8>>;
libfunc enum_match<core::panics::PanicResult::<((),)>> = enum_match<core::panics::PanicResult::<((),)>>;
libfunc branch_align = branch_align;
libfunc drop<Tuple<Unit>> = drop<Tuple<Unit>>;
libfunc function_call<user@test::recursive_refund::<core::integer::u8>> = function_call<user@test::recursive_refund::<core::integer::u8>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc struct_construct<Tuple<Unit>> = struct_construct<Tuple<Unit>>;
libfunc enum_init<core::panics::PanicResult::<((),)>, 0> = enum_init<core::panics::PanicResult::<((),)>, 0>;
libfunc store_temp<core::panics::PanicResult::<((),)>> = store_temp<core::panics::PanicResult::<((),)>>;
libfunc enum_init<core::panics::PanicResult::<((),)>, 1> = enum_init<core::panics::PanicResult::<((),)>, 1>;
libfunc drop<Coupon<user@test::recursive_refund::<core::integer::u8>>> = drop<Coupon<user@test::recursive_refund::<core::integer::u8>>>;
libfunc withdraw_gas = withdraw_gas;
libfunc coupon_buy<Coupon<user@test::recursive_buy::<core::integer::u8>>> = coupon_buy<Coupon<user@test::recursive_buy::<core::integer::u8>>>;
libfunc drop<Coupon<user@test::recursive_buy::<core::integer::u8>>> = drop<Coupon<user@test::recursive_buy::<core::integer::u8>>>;
libfunc array_new<felt252> = array_new<felt252>;
libfunc felt252_const<375233589013918064796019> = felt252_const<375233589013918064796019>;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc array_append<felt252> = array_append<felt252>;
libfunc struct_construct<core::panics::Panic> = struct_construct<core::panics::Panic>;
libfunc struct_construct<Tuple<core::panics::Panic, Array<felt252>>> = struct_construct<Tuple<core::panics::Panic, Array<felt252>>>;
libfunc coupon_refund<Coupon<user@test::recursive_refund::<core::integer::u8>>> = coupon_refund<Coupon<user@test::recursive_refund::<core::integer::u8>>>;

store_temp<RangeCheck>([0]) -> ([0]); // 0
store_temp<GasBuiltin>([1]) -> ([1]); // 1
function_call<user@test::recursive_buy::<core::integer::u8>>([0], [1]) -> ([3], [4], [5]); // 2
enum_match<core::panics::PanicResult::<((),)>>([5]) { fallthrough([6]) 25([7]) }; // 3
branch_align() -> (); // 4
drop<Tuple<Unit>>([6]) -> (); // 5
store_temp<RangeCheck>([3]) -> ([3]); // 6
store_temp<GasBuiltin>([4]) -> ([4]); // 7
function_call<user@test::recursive_refund::<core::integer::u8>>([3], [4], [2]) -> ([8], [9], [10]); // 8
enum_match<core::panics::PanicResult::<((),)>>([10]) { fallthrough([11]) 19([12]) }; // 9
branch_align() -> (); // 10
drop<Tuple<Unit>>([11]) -> (); // 11
struct_construct<Unit>() -> ([13]); // 12
struct_construct<Tuple<Unit>>([13]) -> ([14]); // 13
enum_init<core::panics::PanicResult::<((),)>, 0>([14]) -> ([15]); // 14
store_temp<RangeCheck>([8]) -> ([8]); // 15
store_temp<GasBuiltin>([9]) -> ([9]); // 16
store_temp<core::panics::PanicResult::<((),)>>([15]) -> ([15]); // 17
return([8], [9], [15]); // 18
branch_align() -> (); // 19
enum_init<core::panics::PanicResult::<((),)>, 1>([12]) -> ([16]); // 20
store_temp<RangeCheck>([8]) -> ([8]); // 21
store_temp<GasBuiltin>([9]) -> ([9]); // 22
store_temp<core::panics::PanicResult::<((),)>>([16]) -> ([16]); // 23
return([8], [9], [16]); // 24
branch_align() -> (); // 25
drop<Coupon<user@test::recursive_refund::<core::integer::u8>>>([2]) -> (); // 26
enum_init<core::panics::PanicResult::<((),)>, 1>([7]) -> ([17]); // 27
store_temp<RangeCheck>([3]) -> ([3]); // 28
store_temp<GasBuiltin>([4]) -> ([4]); // 29
store_temp<core::panics::PanicResult::<((),)>>([17]) -> ([17]); // 30
return([3], [4], [17]); // 31
withdraw_gas([0], [1]) { fallthrough([2], [3]) 43([4], [5]) }; // 32
branch_align() -> (); // 33
coupon_buy<Coupon<user@test::recursive_buy::<core::integer::u8>>>() -> ([6]); // 34
drop<Coupon<user@test::recursive_buy::<core::integer::u8>>>([6]) -> (); // 35
struct_construct<Unit>() -> ([7]); // 36
struct_construct<Tuple<Unit>>([7]) -> ([8]); // 37
enum_init<core::panics::PanicResult::<((),)>, 0>([8]) -> ([9]); // 38
store_temp<RangeCheck>([2]) -> ([2]); // 39
store_temp<GasBuiltin>([3]) -> ([3]); // 40
store_temp<core::panics::PanicResult::<((),)>>([9]) -> ([9]); // 41
return([2], [3], [9]); // 42
branch_align() -> (); // 43
array_new<felt252>() -> ([10]); // 44
felt252_const<375233589013918064796019>() -> ([11]); // 45
store_temp<felt252>([11]) -> ([11]); // 46
array_append<felt252>([10], [11]) -> ([12]); // 47
struct_construct<core::panics::Panic>() -> ([13]); // 48
struct_construct<Tuple<core::panics::Panic, Array<felt252>>>([13], [12]) -> ([14]); // 49
enum_init<core::panics::PanicResult::<((),)>, 1>([14]) -> ([15]); // 50
store_temp<RangeCheck>([4]) -> ([4]); // 51
store_temp<GasBuiltin>([5]) -> ([5]); // 52
store_temp<core::panics::PanicResult::<((),)>>([15]) -> ([15]); // 53
return([4], [5], [15]); // 54
withdraw_gas([0], [1]) { fallthrough([3], [4]) 65([5], [6]) }; // 55
branch_align() -> (); // 56
coupon_refund<Coupon<user@test::recursive_refund::<core::integer::u8>>>([2]) -> (); // 57
struct_construct<Unit>() -> ([7]); // 58
struct_construct<Tuple<Unit>>([7]) -> ([8]); // 59
enum_init<core::panics::PanicResult::<((),)>, 0>([8]) -> ([9]); // 60
store_temp<RangeCheck>([3]) -> ([3]); // 61
store_temp<GasBuiltin>([4]) -> ([4]); // 62
store_temp<core::panics::PanicResult::<((),)>>([9]) -> ([9]); // 63
return([3], [4], [9]); // 64
branch_align() -> (); // 65
drop<Coupon<user@test::recursive_refund::<core::integer::u8>>>([2]) -> (); // 66
array_new<felt252>() -> ([10]); // 67
felt252_const<375233589013918064796019>() -> ([11]); // 68
store_temp<felt252>([11]) -> ([11]); // 69
array_append<felt252>([10], [11]) -> ([12]); // 70
struct_construct<core::panics::Panic>() -> ([13]); // 71
struct_construct<Tuple<core::panics::Panic, Array<felt252>>>([13], [12]) -> ([14]); // 72
enum_init<core::panics::PanicResult::<((),)>, 1>([14]) -> ([15]); // 73
store_temp<RangeCheck>([5]) -> ([5]); // 74
store_temp<GasBuiltin>([6]) -> ([6]); // 75
store_temp<core::panics::PanicResult::<((),)>>([15]) -> ([15]); // 76
return([5], [6], [15]); // 77

test::foo@0([0]: RangeCheck, [1]: GasBuiltin, [2]: Coupon<user@test::recursive_refund::<core::integer::u8>>) -> (RangeCheck, GasBuiltin, core::panics::PanicResult::<((),)>);
test::recursive_buy::<core::integer::u8>@32([0]: RangeCheck, [1]: GasBuiltin) -> (RangeCheck, GasBuiltin, core::panics::PanicResult::<((),)>);
test::recursive_refund::<core::integer::u8>@55([0]: RangeCheck, [1]: GasBuiltin, [2]: Coupon<user@test::recursive_refund::<core::integer::u8>>) -> (RangeCheck, GasBuiltin, core::panics::PanicResult::<((),)>);
