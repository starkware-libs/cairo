//! > coupon type and coupon_call

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
impl DropCoupon<T, impl DropImpl: Drop<T>> of Drop<bar::<T, DropImpl>::Coupon>;

fn foo(x: bar::<u8>::Coupon) {
    bar::<u8>(0, __coupon__: x);
}

fn bar<T, +Drop<T>>(x: T) -> felt252 {
    10
}

//! > casm
[ap + 0] = 0, ap++;
call rel 3;
ret;
[ap + 0] = 10, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 300})
test::bar::<core::integer::u8, core::integer::u8Drop>: OrderedHashMap({Const: 100})

//! > sierra_code
type u8 = u8 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> [storable: true, drop: true, dup: false, zero_sized: true];

libfunc u8_const<0> = u8_const<0>;
libfunc store_temp<u8> = store_temp<u8>;
libfunc coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>;
libfunc drop<felt252> = drop<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc drop<u8> = drop<u8>;
libfunc felt252_const<10> = felt252_const<10>;
libfunc store_temp<felt252> = store_temp<felt252>;

u8_const<0>() -> ([1]); // 0
store_temp<u8>([1]) -> ([1]); // 1
coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>([1], [0]) -> ([2]); // 2
drop<felt252>([2]) -> (); // 3
struct_construct<Unit>() -> ([3]); // 4
return([3]); // 5
drop<u8>([0]) -> (); // 6
felt252_const<10>() -> ([1]); // 7
store_temp<felt252>([1]) -> ([1]); // 8
return([1]); // 9

test::foo@0([0]: Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>) -> (Unit);
test::bar::<core::integer::u8, core::integer::u8Drop>@6([0]: u8) -> (felt252);

//! > ==========================================================================

//! > coupon_buy

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
impl DropCoupon<T, impl DropImpl: Drop<T>> of Drop<bar::<T, DropImpl>::Coupon>;
extern fn coupon_buy<T>() -> T nopanic;

fn foo() {
    // Buy coupons.
    let (c0, _c1) = buy_coupons();
    // Use coupons.
    bar(0, __coupon__: c0);
}

fn buy_coupons() -> (bar::<u8>::Coupon, bar::<u8>::Coupon) {
    (coupon_buy(), coupon_buy())
}

fn bar<T, +Drop<T>>(x: T) -> felt252 {
    10
}

//! > casm
call rel 7;
[ap + 0] = 0, ap++;
call rel 4;
ret;
ret;
[ap + 0] = 10, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 700})
test::buy_coupons: OrderedHashMap({Const: 200})
test::bar::<core::integer::u8, core::integer::u8Drop>: OrderedHashMap({Const: 100})

//! > sierra_code
type Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> [storable: true, drop: true, dup: false, zero_sized: true];
type Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>> = Struct<ut@Tuple, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>> [storable: true, drop: true, dup: false, zero_sized: true];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type u8 = u8 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc function_call<user@test::buy_coupons> = function_call<user@test::buy_coupons>;
libfunc struct_deconstruct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>> = struct_deconstruct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>>;
libfunc drop<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>> = drop<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>;
libfunc u8_const<0> = u8_const<0>;
libfunc store_temp<u8> = store_temp<u8>;
libfunc coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>;
libfunc drop<felt252> = drop<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc coupon_buy<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>> = coupon_buy<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>;
libfunc struct_construct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>> = struct_construct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>>;
libfunc drop<u8> = drop<u8>;
libfunc felt252_const<10> = felt252_const<10>;
libfunc store_temp<felt252> = store_temp<felt252>;

function_call<user@test::buy_coupons>() -> ([0]); // 0
struct_deconstruct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>>([0]) -> ([1], [2]); // 1
drop<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>([2]) -> (); // 2
u8_const<0>() -> ([3]); // 3
store_temp<u8>([3]) -> ([3]); // 4
coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>([3], [1]) -> ([4]); // 5
drop<felt252>([4]) -> (); // 6
struct_construct<Unit>() -> ([5]); // 7
return([5]); // 8
coupon_buy<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>() -> ([0]); // 9
coupon_buy<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>() -> ([1]); // 10
struct_construct<Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>>([0], [1]) -> ([2]); // 11
return([2]); // 12
drop<u8>([0]) -> (); // 13
felt252_const<10>() -> ([1]); // 14
store_temp<felt252>([1]) -> ([1]); // 15
return([1]); // 16

test::foo@0() -> (Unit);
test::buy_coupons@9() -> (Tuple<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>);
test::bar::<core::integer::u8, core::integer::u8Drop>@13([0]: u8) -> (felt252);

//! > ==========================================================================

//! > coupon_refund

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern fn coupon_refund<T>(c: T) nopanic;

fn foo(c0: bar::<u8>::Coupon, c1: bar::<u8>::Coupon) {
    // Get refund on coupon.
    coupon_refund(c0);
    bar(0_u8, __coupon__: c1);
}

#[inline(never)]
fn bar<T, +Drop<T>>(x: T) -> felt252 {
    10
}

//! > casm
[ap + 0] = 0, ap++;
call rel 3;
ret;
[ap + 0] = 10, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 200})
test::bar::<core::integer::u8, core::integer::u8Drop>: OrderedHashMap({Const: 100})

//! > sierra_code
type Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>> [storable: true, drop: true, dup: false, zero_sized: true];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type u8 = u8 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc coupon_refund<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>> = coupon_refund<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>;
libfunc u8_const<0> = u8_const<0>;
libfunc store_temp<u8> = store_temp<u8>;
libfunc coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>> = coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>;
libfunc drop<felt252> = drop<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc drop<u8> = drop<u8>;
libfunc felt252_const<10> = felt252_const<10>;
libfunc store_temp<felt252> = store_temp<felt252>;

coupon_refund<Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>>([0]) -> (); // 0
u8_const<0>() -> ([2]); // 1
store_temp<u8>([2]) -> ([2]); // 2
coupon_call<user@test::bar::<core::integer::u8, core::integer::u8Drop>>([2], [1]) -> ([3]); // 3
drop<felt252>([3]) -> (); // 4
struct_construct<Unit>() -> ([4]); // 5
return([4]); // 6
drop<u8>([0]) -> (); // 7
felt252_const<10>() -> ([1]); // 8
store_temp<felt252>([1]) -> ([1]); // 9
return([1]); // 10

test::foo@0([0]: Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>, [1]: Coupon<user@test::bar::<core::integer::u8, core::integer::u8Drop>>) -> (Unit);
test::bar::<core::integer::u8, core::integer::u8Drop>@7([0]: u8) -> (felt252);

//! > ==========================================================================

//! > Use coupon to destruct Array of non-droppable.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern fn drop<T>(c: T) nopanic;

struct NonDroppable {
    x: u64,
}

fn destruct(arr: Array<(NonDroppable, destruct::Coupon)>) nopanic {
    match arr.pop_front_consume() {
        Option::Some((rem, (elm, coupon))) => {
            destruct(rem, __coupon__: coupon);
            integer::u64_bitwise(elm.x, elm.x);
            drop(elm);
        },
        Option::None => {},
    }
}

//! > casm
ap += 1;
[fp + -3] = [ap + 0] + [fp + -4], ap++;
jmp rel 4 if [ap + -1] != 0;
jmp rel 15;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = [fp + -3], ap++;
[fp + 0] = [[fp + -4] + 0];
call rel -12;
[fp + 0] = [[ap + -1] + 0];
[fp + 0] = [[ap + -1] + 1];
[ap + 0] = [ap + -1] + 5, ap++;
jmp rel 3;
[ap + 0] = [fp + -5], ap++;
ret;

//! > function_costs
test::destruct: OrderedHashMap({Bitwise: 1, Const: 1300})

//! > sierra_code
type u64 = u64 [storable: true, drop: true, dup: true, zero_sized: false];
type test::NonDroppable = Struct<ut@test::NonDroppable, u64> [storable: true, drop: true, dup: true, zero_sized: false];
type Uninitialized<test::NonDroppable> = Uninitialized<test::NonDroppable> [storable: false, drop: true, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type Bitwise = Bitwise [storable: true, drop: false, dup: false, zero_sized: false];
type Coupon<user@test::destruct> = Coupon<user@test::destruct> [storable: true, drop: true, dup: false, zero_sized: true];
type Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> [storable: true, drop: true, dup: false, zero_sized: false];
type Tuple<test::NonDroppable, Coupon<user@test::destruct>> = Struct<ut@Tuple, test::NonDroppable, Coupon<user@test::destruct>> [storable: true, drop: true, dup: false, zero_sized: false];
type Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = Struct<ut@Tuple, Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>> [storable: true, drop: true, dup: false, zero_sized: false];
type Box<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = Box<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> [storable: true, drop: true, dup: false, zero_sized: false];

libfunc alloc_local<test::NonDroppable> = alloc_local<test::NonDroppable>;
libfunc finalize_locals = finalize_locals;
libfunc disable_ap_tracking = disable_ap_tracking;
libfunc array_pop_front_consume<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = array_pop_front_consume<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>;
libfunc branch_align = branch_align;
libfunc unbox<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = unbox<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>;
libfunc struct_construct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>> = struct_construct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>;
libfunc struct_deconstruct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>> = struct_deconstruct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>;
libfunc struct_deconstruct<Tuple<test::NonDroppable, Coupon<user@test::destruct>>> = struct_deconstruct<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>;
libfunc store_temp<Bitwise> = store_temp<Bitwise>;
libfunc store_temp<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>> = store_temp<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>;
libfunc store_local<test::NonDroppable> = store_local<test::NonDroppable>;
libfunc coupon_call<user@test::destruct> = coupon_call<user@test::destruct>;
libfunc drop<Unit> = drop<Unit>;
libfunc struct_deconstruct<test::NonDroppable> = struct_deconstruct<test::NonDroppable>;
libfunc dup<u64> = dup<u64>;
libfunc u64_bitwise = u64_bitwise;
libfunc drop<u64> = drop<u64>;
libfunc struct_construct<test::NonDroppable> = struct_construct<test::NonDroppable>;
libfunc drop<test::NonDroppable> = drop<test::NonDroppable>;
libfunc jump = jump;
libfunc drop<Uninitialized<test::NonDroppable>> = drop<Uninitialized<test::NonDroppable>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;

alloc_local<test::NonDroppable>() -> ([3]); // 0
finalize_locals() -> (); // 1
disable_ap_tracking() -> (); // 2
array_pop_front_consume<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>([1]) { fallthrough([4], [5]) 25() }; // 3
branch_align() -> (); // 4
unbox<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>([5]) -> ([6]); // 5
struct_construct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>([4], [6]) -> ([7]); // 6
struct_deconstruct<Tuple<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>, Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>([7]) -> ([8], [9]); // 7
struct_deconstruct<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>([9]) -> ([2], [10]); // 8
store_temp<Bitwise>([0]) -> ([0]); // 9
store_temp<Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>>([8]) -> ([8]); // 10
store_local<test::NonDroppable>([3], [2]) -> ([2]); // 11
coupon_call<user@test::destruct>([0], [8], [10]) -> ([11], [12]); // 12
drop<Unit>([12]) -> (); // 13
struct_deconstruct<test::NonDroppable>([2]) -> ([13]); // 14
dup<u64>([13]) -> ([13], [14]); // 15
dup<u64>([13]) -> ([13], [15]); // 16
u64_bitwise([11], [14], [15]) -> ([16], [17], [18], [19]); // 17
drop<u64>([17]) -> (); // 18
drop<u64>([18]) -> (); // 19
drop<u64>([19]) -> (); // 20
struct_construct<test::NonDroppable>([13]) -> ([20]); // 21
drop<test::NonDroppable>([20]) -> (); // 22
store_temp<Bitwise>([16]) -> ([21]); // 23
jump() { 28() }; // 24
branch_align() -> (); // 25
drop<Uninitialized<test::NonDroppable>>([3]) -> (); // 26
store_temp<Bitwise>([0]) -> ([21]); // 27
struct_construct<Unit>() -> ([22]); // 28
return([21], [22]); // 29

test::destruct@0([0]: Bitwise, [1]: Array<Tuple<test::NonDroppable, Coupon<user@test::destruct>>>) -> (Bitwise, Unit);
