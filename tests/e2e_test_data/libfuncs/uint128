//! > array_pop_front libfunc

//! > test_comments

//! > test_function_name
run_small_e2e_test

//! > cairo
fn foo(a: u128, b: u128) -> (u128, u128) {
    integer::u128_wide_mul(a, b)
}

//! > casm
%{ (memory[ap + 1], memory[ap + 0]) = divmod(memory[fp + -4], 18446744073709551616) %}
[ap + 2] = [ap + 0] + 340282366920938463444927863358058659840, ap++;
[ap + 1] = [[fp + -5] + 0], ap++;
[ap + -2] = [[fp + -5] + 1], ap++;
[ap + -2] = [[fp + -5] + 2];
[ap + 0] = [ap + -2] * 18446744073709551616, ap++;
[fp + -4] = [ap + -1] + [ap + -4];
[ap + 0] = [ap + -4] * [fp + -3], ap++;
[ap + 0] = [ap + -4] * [fp + -3], ap++;
%{ (memory[ap + 0], memory[ap + 1]) = divmod(memory[ap + -1], 18446744073709551616) %}
[ap + 2] = [ap + 1] + 340282366920938463444927863358058659840, ap++;
[ap + 1] = [[fp + -5] + 3], ap++;
[ap + -1] = [[fp + -5] + 4], ap++;
[ap + -3] = [[fp + -5] + 5];
[ap + 0] = [ap + -3] * 18446744073709551616, ap++;
[ap + -5] = [ap + -1] + [ap + -3];
[ap + 0] = [ap + -3] * 18446744073709551616, ap++;
[ap + 3] = [ap + -7] + [ap + -1], ap++;
%{ (memory[ap + -1], memory[ap + 4]) = divmod(memory[ap + 2], 340282366920938463463374607431768211456) %}
[ap + 0] = [ap + -1] + 340282366920938463426481119284349108224, ap++;
[ap + -1] = [[fp + -5] + 6], ap++;
[ap + -3] = [[fp + -5] + 7], ap++;
[ap + 1] = [[fp + -5] + 8], ap++;
[ap + -3] = [ap + -5] * 340282366920938463463374607431768211456, ap++;
[ap + -3] = [ap + -4] + [ap + -1];
[ap + -2] = [ap + -11] + [ap + -6];
[ap + 0] = [fp + -5] + 9, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Step: 27})

//! > sierra_code
type RangeCheck = RangeCheck;
type u128 = u128;
type Tuple<u128, u128> = Struct<ut@Tuple, u128, u128>;

libfunc u128_wide_mul = u128_wide_mul;
libfunc struct_construct<Tuple<u128, u128>> = struct_construct<Tuple<u128, u128>>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc rename<RangeCheck> = rename<RangeCheck>;
libfunc store_temp<Tuple<u128, u128>> = store_temp<Tuple<u128, u128>>;
libfunc rename<Tuple<u128, u128>> = rename<Tuple<u128, u128>>;

u128_wide_mul([0], [1], [2]) -> ([3], [4], [5]);
struct_construct<Tuple<u128, u128>>([4], [5]) -> ([6]);
store_temp<RangeCheck>([3]) -> ([3]);
rename<RangeCheck>([3]) -> ([7]);
store_temp<Tuple<u128, u128>>([6]) -> ([6]);
rename<Tuple<u128, u128>>([6]) -> ([8]);
return([7], [8]);

test::foo@0([0]: RangeCheck, [1]: u128, [2]: u128) -> (RangeCheck, Tuple<u128, u128>);
