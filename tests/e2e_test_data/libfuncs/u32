//! > u32_overflowing_add libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
#[feature("corelib-internal-use")]
fn foo(a: u32, b: u32) -> Result::<u32, u32> {
    integer::u32_overflowing_add(a, b)
}

//! > casm
%{ memory[ap + 0] = (memory[fp + -4] + memory[fp + -3]) % PRIME < 4294967296 %}
jmp rel 8 if [ap + 0] != 0, ap++;
[ap + 0] = [fp + -4] + [fp + -3], ap++;
[ap + -1] = [ap + 0] + 4294967296, ap++;
[ap + -1] = [[fp + -5] + 0];
jmp rel 12;
[ap + 1] = [fp + -4] + [fp + -3], ap++;
[ap + -1] = [ap + 0] + 340282366920938463463374607427473244160, ap++;
[ap + -2] = [[fp + -5] + 0];
[ap + 0] = [fp + -5] + 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -3], ap++;
ret;
[ap + 0] = [fp + -5] + 1, ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 870})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type u32 = u32 [storable: true, drop: true, dup: true, zero_sized: false];
type core::result::Result::<core::integer::u32, core::integer::u32> = Enum<ut@core::result::Result::<core::integer::u32, core::integer::u32>, u32, u32> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc u32_overflowing_add = u32_overflowing_add;
libfunc branch_align = branch_align;
libfunc enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 0> = enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<core::result::Result::<core::integer::u32, core::integer::u32>> = store_temp<core::result::Result::<core::integer::u32, core::integer::u32>>;
libfunc enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 1> = enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 1>;

u32_overflowing_add([0], [1], [2]) { fallthrough([3], [4]) 6([5], [6]) }; // 0
branch_align() -> (); // 1
enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 0>([4]) -> ([7]); // 2
store_temp<RangeCheck>([3]) -> ([3]); // 3
store_temp<core::result::Result::<core::integer::u32, core::integer::u32>>([7]) -> ([7]); // 4
return([3], [7]); // 5
branch_align() -> (); // 6
enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 1>([6]) -> ([8]); // 7
store_temp<RangeCheck>([5]) -> ([5]); // 8
store_temp<core::result::Result::<core::integer::u32, core::integer::u32>>([8]) -> ([8]); // 9
return([5], [8]); // 10

test::foo@0([0]: RangeCheck, [1]: u32, [2]: u32) -> (RangeCheck, core::result::Result::<core::integer::u32, core::integer::u32>);

//! > test_name
u32_overflowing_add libfunc

//! > lean_soundness
import starkware.cairo.lean.semantics.soundness.prelude
import .u32_overflowing_add_code
open tactic

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

def limit_fixer : F := (340282366920938463463374607427473244160 : F) -- (u128::MAX - limit + 1)
def limit : F := (4294967296 : F) -- limit

def spec_u32_overflowing_add (mem : F → F) (κ : ℕ) (range_check a b ρ_branch_id ρ_a_plus_b : F) : Prop :=
  true

def auto_spec_u32_overflowing_add (mem : F → F) (κ : ℕ) (range_check a b ρ_branch_id ρ_a_plus_b : F) : Prop :=
  ∃ orig_range_check : F, orig_range_check = range_check ∧
  ∃ no_overflow : F,
  ∃ deferred_a_plus_b : F, deferred_a_plus_b = a + b ∧
  (
    (no_overflow = 0 ∧
      ∃ temp_a_plus_b : F, temp_a_plus_b = deferred_a_plus_b ∧
      ∃ fixed_a_plus_b : F, fixed_a_plus_b = temp_a_plus_b - limit ∧
      is_range_checked (rc_bound F) fixed_a_plus_b ∧
      ρ_branch_id = 1 ∧
      ρ_a_plus_b = fixed_a_plus_b
    ) ∨
    (no_overflow ≠ 0 ∧
      ∃ temp_fixed_a_plus_b : F,
      ∃ a_plus_b : F, a_plus_b = deferred_a_plus_b ∧
      temp_fixed_a_plus_b = a_plus_b + limit_fixer ∧
      is_range_checked (rc_bound F) temp_fixed_a_plus_b ∧
      ρ_branch_id = 0 ∧
      ρ_a_plus_b = a_plus_b
    )
  )

theorem sound_u32_overflowing_add
    {mem : F → F}
    (κ : ℕ)
    (range_check a b ρ_branch_id ρ_a_plus_b : F)
    (h_auto : auto_spec_u32_overflowing_add mem κ range_check a b ρ_branch_id ρ_a_plus_b) :
  spec_u32_overflowing_add mem κ range_check a b ρ_branch_id ρ_a_plus_b :=
begin
  trivial
end

theorem auto_sound_u32_overflowing_add
  -- arguments
  (range_check a b : F)
  -- code is in memory at s.pc
  (h_mem : MemAt mem code_u32_overflowing_add σ.pc)
  -- input arguments on the stack
  (hin_range_check : range_check = mem (σ.fp - 5))
  (hin_a : a = mem (σ.fp - 4))
  (hin_b : b = mem (σ.fp - 3))
  -- conclusion
  : EnsuresRet mem σ fun κ τ =>
    ∃ μ ≤ κ, RcEnsures mem (rcBound F) μ (mem (σ.fp - 5)) (mem (τ.ap - 3))
      (spec_u32_overflowing_add mem κ range_check a b (mem (τ.ap - 2)) (mem (τ.ap - 1)))) :=
by
  apply ensures_of_ensuresb; intro νbound
  unpack_memory code_u32_overflowing_add at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6,
  hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21,
  hpc22, hpc23, hpc24⟩
  -- let
  mkdef hl_orig_range_check : orig_range_check = range_check
  -- tempvar no_overflow
  mkdef hl_no_overflow : no_overflow = mem σ.ap
  have htv_no_overflow : no_overflow = mem σ.ap := by
    exact hl_no_overflow
  -- let
  mkdef hl_deferred_a_plus_b : deferred_a_plus_b = a + b
  -- jump to NoOverflow if no_overflow != 0
  step_jnz hpc0 hpc1 with hcond0 hcond0
  ·
    -- no_overflow = 0
    have a0 : no_overflow = 0 := by simp only [hl_no_overflow]; exact hcond0
    -- tempvar temp_a_plus_b
    step_assert_eq hpc2 with tv_temp_a_plus_b
    mkdef hl_temp_a_plus_b : temp_a_plus_b = deferred_a_plus_b
    have htv_temp_a_plus_b : temp_a_plus_b = mem (σ.ap + 1) := by
      sorry
    -- tempvar fixed_a_plus_b
    step_assert_eq hpc3 hpc4 with tv_fixed_a_plus_b
    mkdef hl_fixed_a_plus_b : fixed_a_plus_b = temp_a_plus_b - limit
    have htv_fixed_a_plus_b : fixed_a_plus_b = mem (σ.ap + 2) := by
      sorry
    -- range check for fixed_a_plus_b
    step_assert_eq hpc5 with rc_fixed_a_plus_b
    step_jump_imm hpc6 hpc7
    -- return values
    --   range check return value
    step_assert_eq hpc19 hpc20 with ret_range_check₁
    mkdef hl_range_check₁ : range_check₁ = range_check + 1
    have htv_range_check₁ : range_check₁ = _ := by
      apply Eq.symm; apply Eq.trans ret_range_check₁
      simp only [hl_range_check₁, hin_range_check]
    step_assert_eq hpc21 hpc22 with ret_branch_id
    step_assert_eq hpc23 with ret_a_plus_b
    step_ret hpc24
    step_done
    use_only rfl, rfl
    -- range check condition
    use_only (1 + 0); constructor; norm_num1
    constructor
    · arith_simps; exact ret_range_check₁
    intro rc_h_range_check
    have rc_h_range_check' := rangeChecked_add_right rc_h_range_check
    suffices auto_spec : auto_spec_u32_overflowing_add mem _ range_check a b _ _ by
      apply sound_u32_overflowing_add; apply auto_spec
    use_only orig_range_check, hl_orig_range_check
    use_only no_overflow
    use_only deferred_a_plus_b, hl_deferred_a_plus_b
    left
    use_only a0
    use_only temp_a_plus_b, hl_temp_a_plus_b
    use_only fixed_a_plus_b, hl_fixed_a_plus_b
    rc_app rc_h_range_check' 0 hl_fixed_a_plus_b rc_fixed_a_plus_b

    use_only ret_branch_id
    use_only ret_a_plus_b
    done
  -- no_overflow ≠ 0
  have a0 : no_overflow ≠ 0 := by simp only [hl_no_overflow]; exact hcond0
  -- tempvar temp_fixed_a_plus_b
  mkdef hl_temp_fixed_a_plus_b : temp_fixed_a_plus_b = mem (σ.ap + 1)
  have htv_temp_fixed_a_plus_b : temp_fixed_a_plus_b = mem (σ.ap + 1) := by
    exact hl_temp_fixed_a_plus_b
  -- tempvar a_plus_b
  step_assert_eq hpc8 with tv_a_plus_b
  mkdef hl_a_plus_b : a_plus_b = deferred_a_plus_b
  have htv_a_plus_b : a_plus_b = mem (σ.ap + 2) := by
    sorry
  -- assert
  step_assert_eq hpc9 hpc10 with ha9
  have a9 : temp_fixed_a_plus_b = a_plus_b + limit_fixer := by
    sorry
  -- range check for temp_fixed_a_plus_b
  step_assert_eq hpc11 with rc_temp_fixed_a_plus_b
  -- return values
  --   range check return value
  step_assert_eq hpc12 hpc13 with ret_range_check₁
  mkdef hl_range_check₁ : range_check₁ = range_check + 1
  have htv_range_check₁ : range_check₁ = _ := by
    apply Eq.symm; apply Eq.trans ret_range_check₁
    simp only [hl_range_check₁, hin_range_check]
  step_assert_eq hpc14 hpc15 with ret_branch_id
  step_assert_eq hpc16 with ret_a_plus_b
  step_jump_imm hpc17 hpc18
  step_ret hpc24
  step_done
  use_only rfl, rfl
  -- range check condition
  use_only (1 + 0); constructor; norm_num1
  constructor
  · arith_simps; exact ret_range_check₁
  intro rc_h_range_check
  have rc_h_range_check' := rangeChecked_add_right rc_h_range_check
  suffices auto_spec : auto_spec_u32_overflowing_add mem _ range_check a b _ _ by
    apply sound_u32_overflowing_add; apply auto_spec
  use_only orig_range_check, hl_orig_range_check
  use_only no_overflow
  use_only deferred_a_plus_b, hl_deferred_a_plus_b
  right
  use_only a0
  use_only temp_fixed_a_plus_b
  use_only a_plus_b, hl_a_plus_b
  use_only a9
  rc_app rc_h_range_check' 0 hl_temp_fixed_a_plus_b rc_temp_fixed_a_plus_b

  use_only ret_branch_id
  use_only ret_a_plus_b
  done

//! > ==========================================================================

//! > u32_overflowing_sub libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
#[feature("corelib-internal-use")]
fn foo(a: u32, b: u32) -> Result::<u32, u32> {
    integer::u32_overflowing_sub(a, b)
}

//! > casm
[fp + -4] = [ap + 1] + [fp + -3], ap++;
%{ memory[ap + -1] = memory[ap + 0] < 4294967296 %}
jmp rel 7 if [ap + -1] != 0, ap++;
[ap + 0] = [ap + -1] + 340282366920938463463374607431768211456, ap++;
[ap + -1] = [[fp + -5] + 0];
jmp rel 11;
[ap + -1] = [[fp + -5] + 0];
ap += 1;
[ap + 0] = [fp + -5] + 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -4], ap++;
ret;
[ap + 0] = [fp + -5] + 1, ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [ap + -4] + 4294967296, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 870})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type u32 = u32 [storable: true, drop: true, dup: true, zero_sized: false];
type core::result::Result::<core::integer::u32, core::integer::u32> = Enum<ut@core::result::Result::<core::integer::u32, core::integer::u32>, u32, u32> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc u32_overflowing_sub = u32_overflowing_sub;
libfunc branch_align = branch_align;
libfunc enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 0> = enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<core::result::Result::<core::integer::u32, core::integer::u32>> = store_temp<core::result::Result::<core::integer::u32, core::integer::u32>>;
libfunc enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 1> = enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 1>;

u32_overflowing_sub([0], [1], [2]) { fallthrough([3], [4]) 6([5], [6]) }; // 0
branch_align() -> (); // 1
enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 0>([4]) -> ([7]); // 2
store_temp<RangeCheck>([3]) -> ([3]); // 3
store_temp<core::result::Result::<core::integer::u32, core::integer::u32>>([7]) -> ([7]); // 4
return([3], [7]); // 5
branch_align() -> (); // 6
enum_init<core::result::Result::<core::integer::u32, core::integer::u32>, 1>([6]) -> ([8]); // 7
store_temp<RangeCheck>([5]) -> ([5]); // 8
store_temp<core::result::Result::<core::integer::u32, core::integer::u32>>([8]) -> ([8]); // 9
return([5], [8]); // 10

test::foo@0([0]: RangeCheck, [1]: u32, [2]: u32) -> (RangeCheck, core::result::Result::<core::integer::u32, core::integer::u32>);

//! > test_name
u32_overflowing_sub libfunc

//! > lean_soundness
import starkware.cairo.lean.semantics.soundness.prelude
import .u32_overflowing_sub_code
open tactic

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

def u128_limit : F := (340282366920938463463374607431768211456 : F) -- BigInt::from(u128::MAX) + BigInt::from(1)
def limit : F := (4294967296 : F) -- limit

def spec_u32_overflowing_sub (mem : F → F) (κ : ℕ) (range_check a b ρ_branch_id ρ_a_minus_b : F) : Prop :=
  true

def auto_spec_u32_overflowing_sub (mem : F → F) (κ : ℕ) (range_check a b ρ_branch_id ρ_a_minus_b : F) : Prop :=
  ∃ orig_range_check : F, orig_range_check = range_check ∧
  ∃ a_ge_b : F,
  ∃ a_minus_b : F, a_minus_b = a - b ∧
  (
    (a_ge_b = 0 ∧
      ∃ fixed_a_minus_b : F, fixed_a_minus_b = a_minus_b + u128_limit ∧
      is_range_checked (rc_bound F) fixed_a_minus_b ∧
      ∃ wrapping_a_minus_b : F, wrapping_a_minus_b = a_minus_b + limit ∧
      ρ_branch_id = 1 ∧
      ρ_a_minus_b = wrapping_a_minus_b
    ) ∨
    (a_ge_b ≠ 0 ∧
      is_range_checked (rc_bound F) a_minus_b ∧
      ρ_branch_id = 0 ∧
      ρ_a_minus_b = a_minus_b
    )
  )

theorem sound_u32_overflowing_sub
    {mem : F → F}
    (κ : ℕ)
    (range_check a b ρ_branch_id ρ_a_minus_b : F)
    (h_auto : auto_spec_u32_overflowing_sub mem κ range_check a b ρ_branch_id ρ_a_minus_b) :
  spec_u32_overflowing_sub mem κ range_check a b ρ_branch_id ρ_a_minus_b :=
begin
  trivial
end

theorem auto_sound_u32_overflowing_sub
  -- arguments
  (range_check a b : F)
  -- code is in memory at s.pc
  (h_mem : MemAt mem code_u32_overflowing_sub σ.pc)
  -- input arguments on the stack
  (hin_range_check : range_check = mem (σ.fp - 5))
  (hin_a : a = mem (σ.fp - 4))
  (hin_b : b = mem (σ.fp - 3))
  -- conclusion
  : EnsuresRet mem σ fun κ τ =>
    ∃ μ ≤ κ, RcEnsures mem (rcBound F) μ (mem (σ.fp - 5)) (mem (τ.ap - 3))
      (spec_u32_overflowing_sub mem κ range_check a b (mem (τ.ap - 2)) (mem (τ.ap - 1)))) :=
by
  apply ensures_of_ensuresb; intro νbound
  unpack_memory code_u32_overflowing_sub at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6,
  hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21,
  hpc22, hpc23, hpc24⟩
  -- let
  mkdef hl_orig_range_check : orig_range_check = range_check
  -- tempvar a_ge_b
  mkdef hl_a_ge_b : a_ge_b = mem σ.ap
  have htv_a_ge_b : a_ge_b = mem σ.ap := by
    exact hl_a_ge_b
  -- tempvar a_minus_b
  step_assert_eq hpc0 with tv_a_minus_b
  mkdef hl_a_minus_b : a_minus_b = a - b
  have htv_a_minus_b : a_minus_b = mem (σ.ap + 1) := by
    sorry
  -- jump to NoOverflow if a_ge_b != 0
  step_jnz hpc1 hpc2 with hcond1 hcond1
  ·
    -- a_ge_b = 0
    have a1 : a_ge_b = 0 := by simp only [hl_a_ge_b]; exact hcond1
    -- tempvar fixed_a_minus_b
    step_assert_eq hpc3 hpc4 with tv_fixed_a_minus_b
    mkdef hl_fixed_a_minus_b : fixed_a_minus_b = a_minus_b + u128_limit
    have htv_fixed_a_minus_b : fixed_a_minus_b = mem (σ.ap + 2) := by
      sorry
    -- range check for fixed_a_minus_b
    step_assert_eq hpc5 with rc_fixed_a_minus_b
    -- let
    mkdef hl_wrapping_a_minus_b : wrapping_a_minus_b = a_minus_b + limit
    step_jump_imm hpc6 hpc7
    -- return values
    --   range check return value
    step_assert_eq hpc18 hpc19 with ret_range_check₁
    mkdef hl_range_check₁ : range_check₁ = range_check + 1
    have htv_range_check₁ : range_check₁ = _ := by
      apply Eq.symm; apply Eq.trans ret_range_check₁
      simp only [hl_range_check₁, hin_range_check]
    step_assert_eq hpc20 hpc21 with ret_branch_id
    step_assert_eq hpc22 hpc23 with ret_a_minus_b
    step_ret hpc24
    step_done
    use_only rfl, rfl
    -- range check condition
    use_only (1 + 0); constructor; norm_num1
    constructor
    · arith_simps; exact ret_range_check₁
    intro rc_h_range_check
    have rc_h_range_check' := rangeChecked_add_right rc_h_range_check
    suffices auto_spec : auto_spec_u32_overflowing_sub mem _ range_check a b _ _ by
      apply sound_u32_overflowing_sub; apply auto_spec
    use_only orig_range_check, hl_orig_range_check
    use_only a_ge_b
    use_only a_minus_b, hl_a_minus_b
    left
    use_only a1
    use_only fixed_a_minus_b, hl_fixed_a_minus_b
    rc_app rc_h_range_check' 0 hl_fixed_a_minus_b rc_fixed_a_minus_b

    use_only wrapping_a_minus_b, hl_wrapping_a_minus_b
    use_only ret_branch_id
    use_only ret_a_minus_b
    done
  -- a_ge_b ≠ 0
  have a1 : a_ge_b ≠ 0 := by simp only [hl_a_ge_b]; exact hcond1
  -- range check for a_minus_b
  step_assert_eq hpc8 with rc_a_minus_b
  -- return values
  step_advance_ap hpc9 hpc10
  --   range check return value
  step_assert_eq hpc11 hpc12 with ret_range_check₁
  mkdef hl_range_check₁ : range_check₁ = range_check + 1
  have htv_range_check₁ : range_check₁ = _ := by
    apply Eq.symm; apply Eq.trans ret_range_check₁
    simp only [hl_range_check₁, hin_range_check]
  step_assert_eq hpc13 hpc14 with ret_branch_id
  step_assert_eq hpc15 with ret_a_minus_b
  step_jump_imm hpc16 hpc17
  step_ret hpc24
  step_done
  use_only rfl, rfl
  -- range check condition
  use_only (1 + 0); constructor; norm_num1
  constructor
  · arith_simps; exact ret_range_check₁
  intro rc_h_range_check
  have rc_h_range_check' := rangeChecked_add_right rc_h_range_check
  suffices auto_spec : auto_spec_u32_overflowing_sub mem _ range_check a b _ _ by
    apply sound_u32_overflowing_sub; apply auto_spec
  use_only orig_range_check, hl_orig_range_check
  use_only a_ge_b
  use_only a_minus_b, hl_a_minus_b
  right
  use_only a1
  rc_app rc_h_range_check' 0 hl_a_minus_b rc_a_minus_b

  use_only ret_branch_id
  use_only ret_a_minus_b
  done

//! > ==========================================================================

//! > u32_eq libfunc (a deref, b deref)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(a: u32, b: u32) -> bool {
    integer::u32_eq(a, b)
}

//! > casm
[fp + -4] = [ap + 0] + [fp + -3], ap++;
jmp rel 4 if [ap + -1] != 0;
jmp rel 5;
[ap + 0] = 0, ap++;
ret;
[ap + 0] = 1, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 400})

//! > sierra_code
type u32 = u32 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type core::bool = Enum<ut@core::bool, Unit, Unit> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc u32_eq = u32_eq;
libfunc branch_align = branch_align;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::bool, 0> = enum_init<core::bool, 0>;
libfunc store_temp<core::bool> = store_temp<core::bool>;
libfunc enum_init<core::bool, 1> = enum_init<core::bool, 1>;

u32_eq([0], [1]) { fallthrough() 6() }; // 0
branch_align() -> (); // 1
struct_construct<Unit>() -> ([2]); // 2
enum_init<core::bool, 0>([2]) -> ([3]); // 3
store_temp<core::bool>([3]) -> ([3]); // 4
return([3]); // 5
branch_align() -> (); // 6
struct_construct<Unit>() -> ([4]); // 7
enum_init<core::bool, 1>([4]) -> ([5]); // 8
store_temp<core::bool>([5]) -> ([5]); // 9
return([5]); // 10

test::foo@0([0]: u32, [1]: u32) -> (core::bool);

//! > test_name
u32_eq libfunc (a deref, b deref)

//! > lean_soundness

//! > ==========================================================================

//! > u32_eq libfunc (a immediate, b immediate)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo() -> bool {
    integer::u32_eq(11_u32, 12_u32)
}

//! > casm
[ap + 0] = 11, ap++;
[ap + -1] = [ap + 0] + 12, ap++;
jmp rel 4 if [ap + -1] != 0;
jmp rel 5;
[ap + 0] = 0, ap++;
ret;
[ap + 0] = 1, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 500})

//! > sierra_code
type u32 = u32 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type core::bool = Enum<ut@core::bool, Unit, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<u32, 12> = Const<u32, 12> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<u32, 11> = Const<u32, 11> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<u32, 11>> = const_as_immediate<Const<u32, 11>>;
libfunc const_as_immediate<Const<u32, 12>> = const_as_immediate<Const<u32, 12>>;
libfunc store_temp<u32> = store_temp<u32>;
libfunc u32_eq = u32_eq;
libfunc branch_align = branch_align;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::bool, 0> = enum_init<core::bool, 0>;
libfunc store_temp<core::bool> = store_temp<core::bool>;
libfunc enum_init<core::bool, 1> = enum_init<core::bool, 1>;

const_as_immediate<Const<u32, 11>>() -> ([0]); // 0
const_as_immediate<Const<u32, 12>>() -> ([1]); // 1
store_temp<u32>([0]) -> ([0]); // 2
u32_eq([0], [1]) { fallthrough() 9() }; // 3
branch_align() -> (); // 4
struct_construct<Unit>() -> ([2]); // 5
enum_init<core::bool, 0>([2]) -> ([3]); // 6
store_temp<core::bool>([3]) -> ([3]); // 7
return([3]); // 8
branch_align() -> (); // 9
struct_construct<Unit>() -> ([4]); // 10
enum_init<core::bool, 1>([4]) -> ([5]); // 11
store_temp<core::bool>([5]) -> ([5]); // 12
return([5]); // 13

test::foo@0() -> (core::bool);

//! > test_name
u32_eq libfunc (a immediate, b immediate)

//! > lean_soundness

//! > ==========================================================================

//! > u32_try_from_felt252 libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(v: felt252) -> Option::<u32> {
    integer::u32_try_from_felt252(v)
}

//! > casm
%{ memory[ap + 0] = (memory[fp + -3] + 0) % PRIME < 4294967296 %}
jmp rel 18 if [ap + 0] != 0, ap++;
[fp + -3] = [ap + 0] + 4294967296, ap++;
%{
(value, scalar) = (memory[ap + -1], 10633823966279327296825105735305134080)
x = min(value // scalar, 340282366920938463463374607431768211454)
y = value - x * scalar
memory[ap + 0] = x
memory[ap + 1] = y
%}
[ap + 2] = [ap + 0] * 10633823966279327296825105735305134080, ap++;
[ap + -2] = [ap + 1] + [ap + 0], ap++;
[ap + -1] = [[fp + -4] + 0], ap++;
[ap + 0] = [ap + -2] + 319014718988379808869724395965452910591, ap++;
[ap + -1] = [[fp + -4] + 1], ap++;
[ap + -5] = [[fp + -4] + 2];
[ap + -5] = [ap + -1] + 340282366920938463463374607431768211455;
jmp rel 16 if [ap + -1] != 0;
[fp + -1] = [fp + -1] + 1;
[fp + -3] = [[fp + -4] + 0];
[ap + 0] = [fp + -3] + 340282366920938463463374607427473244160, ap++;
[ap + -1] = [[fp + -4] + 1];
ap += 5;
[ap + 0] = [fp + -4] + 2, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3], ap++;
ret;
[ap + 0] = [fp + -4] + 3, ap++;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1510})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type u32 = u32 [storable: true, drop: true, dup: true, zero_sized: false];
type core::option::Option::<core::integer::u32> = Enum<ut@core::option::Option::<core::integer::u32>, u32, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc u32_try_from_felt252 = u32_try_from_felt252;
libfunc branch_align = branch_align;
libfunc enum_init<core::option::Option::<core::integer::u32>, 0> = enum_init<core::option::Option::<core::integer::u32>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<core::option::Option::<core::integer::u32>> = store_temp<core::option::Option::<core::integer::u32>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<core::integer::u32>, 1> = enum_init<core::option::Option::<core::integer::u32>, 1>;

u32_try_from_felt252([0], [1]) { fallthrough([2], [3]) 6([4]) }; // 0
branch_align() -> (); // 1
enum_init<core::option::Option::<core::integer::u32>, 0>([3]) -> ([5]); // 2
store_temp<RangeCheck>([2]) -> ([2]); // 3
store_temp<core::option::Option::<core::integer::u32>>([5]) -> ([5]); // 4
return([2], [5]); // 5
branch_align() -> (); // 6
struct_construct<Unit>() -> ([6]); // 7
enum_init<core::option::Option::<core::integer::u32>, 1>([6]) -> ([7]); // 8
store_temp<RangeCheck>([4]) -> ([4]); // 9
store_temp<core::option::Option::<core::integer::u32>>([7]) -> ([7]); // 10
return([4], [7]); // 11

test::foo@0([0]: RangeCheck, [1]: felt252) -> (RangeCheck, core::option::Option::<core::integer::u32>);

//! > test_name
u32_try_from_felt252 libfunc

//! > lean_soundness
import starkware.cairo.lean.semantics.soundness.prelude
import .u32_try_from_felt252_code
open tactic

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

def limit : F := (4294967296 : F) -- LIMIT
def a_imm : F := (10633823966279327296825105735305134080 : F) -- a_imm
def b_imm_fix : F := (319014718988379808869724395965452910591 : F) -- (BigInt::from(u128::MAX) - b_imm + 1) as BigInt
def u128_limit_minus_1 : F := (340282366920938463463374607431768211455 : F) -- u128::MAX
def u128_limit_minus_2 : F := (340282366920938463463374607431768211454 : F) -- u128::MAX - 1
def fixer_limit : F := (340282366920938463463374607427473244160 : F) -- (u128::MAX - LIMIT + 1)

def spec_u32_try_from_felt252 (mem : F → F) (κ : ℕ) (range_check value ρ_branch_id ρ : F) : Prop :=
  true

def auto_spec_u32_try_from_felt252 (mem : F → F) (κ : ℕ) (range_check value ρ_branch_id ρ : F) : Prop :=
  ∃ orig_range_check : F, orig_range_check = range_check ∧
  ∃ is_small : F,
  (
    (is_small = 0 ∧
      ∃ shifted_value : F, shifted_value = value - limit ∧
      ∃ x_part : F,
      ∃ x : F,
      x_part = x * a_imm ∧
      ∃ y : F,
      value = x_part + y ∧
      is_range_checked (rc_bound F) y ∧
      ∃ y_fixed : F,
      y_fixed = y + b_imm_fix ∧
      is_range_checked (rc_bound F) y_fixed ∧
      is_range_checked (rc_bound F) x ∧
      ∃ diff : F,
      diff = x - u128_limit_minus_1 ∧
      (
        (diff = 0 ∧
          false
        ) ∨
        (diff ≠ 0 ∧
          ρ_branch_id = 1
        )
      )
    ) ∨
    (is_small ≠ 0 ∧
      is_range_checked (rc_bound F) value ∧
      ∃ value_upper_limit : F, value_upper_limit = value + fixer_limit ∧
      is_range_checked (rc_bound F) value_upper_limit ∧
      ρ_branch_id = 0 ∧
      ρ = value
    )
  )

theorem sound_u32_try_from_felt252
    {mem : F → F}
    (κ : ℕ)
    (range_check value ρ_branch_id ρ : F)
    (h_auto : auto_spec_u32_try_from_felt252 mem κ range_check value ρ_branch_id ρ) :
  spec_u32_try_from_felt252 mem κ range_check value ρ_branch_id ρ :=
begin
  trivial
end

theorem auto_sound_u32_try_from_felt252
  -- arguments
  (range_check value : F)
  -- code is in memory at s.pc
  (h_mem : MemAt mem code_u32_try_from_felt252 σ.pc)
  -- input arguments on the stack
  (hin_range_check : range_check = mem (σ.fp - 4))
  (hin_value : value = mem (σ.fp - 3))
  -- conclusion
  : EnsuresRet mem σ fun κ τ =>
    ∃ μ ≤ κ, RcEnsures mem (rcBound F) μ (mem (σ.fp - 4)) (mem (τ.ap - 3))
      (spec_u32_try_from_felt252 mem κ range_check value (mem (τ.ap - 2)) (mem (τ.ap - 1)))) :=
by
  apply ensures_of_ensuresb; intro νbound
  unpack_memory code_u32_try_from_felt252 at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6,
  hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21,
  hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35,
  hpc36, hpc37⟩
  -- let
  mkdef hl_orig_range_check : orig_range_check = range_check
  -- tempvar is_small
  mkdef hl_is_small : is_small = mem σ.ap
  have htv_is_small : is_small = mem σ.ap := by
    exact hl_is_small
  -- jump to IsSmall if is_small != 0
  step_jnz hpc0 hpc1 with hcond0 hcond0
  ·
    -- is_small = 0
    have a0 : is_small = 0 := by simp only [hl_is_small]; exact hcond0
    -- tempvar shifted_value
    step_assert_eq hpc2 hpc3 with tv_shifted_value
    mkdef hl_shifted_value : shifted_value = value - limit
    have htv_shifted_value : shifted_value = mem (σ.ap + 1) := by
      sorry
    -- tempvar x_part
    mkdef hl_x_part : x_part = mem (σ.ap + 4)
    have htv_x_part : x_part = mem (σ.ap + 4) := by
      exact hl_x_part
    -- tempvar x
    mkdef hl_x : x = mem (σ.ap + 2)
    have htv_x : x = mem (σ.ap + 2) := by
      exact hl_x
    -- assert
    step_assert_eq hpc4 hpc5 with ha4
    have a4 : x_part = x * a_imm := by
      sorry
    -- tempvar y
    mkdef hl_y : y = mem (σ.ap + 3)
    have htv_y : y = mem (σ.ap + 3) := by
      exact hl_y
    -- assert
    step_assert_eq hpc6 with ha6
    have a6 : value = x_part + y := by
      sorry
    -- range check for y
    step_assert_eq hpc7 with rc_y
    -- tempvar y_fixed
    mkdef hl_y_fixed : y_fixed = mem (σ.ap + 5)
    have htv_y_fixed : y_fixed = mem (σ.ap + 5) := by
      exact hl_y_fixed
    -- assert
    step_assert_eq hpc8 hpc9 with ha8
    have a8 : y_fixed = y + b_imm_fix := by
      sorry
    -- range check for y_fixed
    step_assert_eq hpc10 with rc_y_fixed
    -- range check for x
    step_assert_eq hpc11 with rc_x
    -- tempvar diff
    mkdef hl_diff : diff = mem (σ.ap + 6)
    have htv_diff : diff = mem (σ.ap + 6) := by
      exact hl_diff
    -- assert
    step_assert_eq hpc12 hpc13 with ha12
    have a12 : diff = x - u128_limit_minus_1 := by
      sorry
    -- jump to Done if diff != 0
    step_jnz hpc14 hpc15 with hcond14 hcond14
    ·
      -- diff = 0
      have a14 : diff = 0 := by simp only [hl_diff]; exact hcond14
      -- fail
      step_assert_eq hpc16 hpc17 with ha_fail
      exfalso; apply zero_ne_one (add_left_cancel (Eq.trans ha_fail)); rw [add_zero]
      done
    -- diff ≠ 0
    have a14 : diff ≠ 0 := by simp only [hl_diff]; exact hcond14
    -- return values
    --   range check return value
    step_assert_eq hpc31 hpc32 with ret_range_check₁
    mkdef hl_range_check₁ : range_check₁ = range_check + 3
    have htv_range_check₁ : range_check₁ = _ := by
      apply Eq.symm; apply Eq.trans ret_range_check₁
      simp only [hl_range_check₁, hin_range_check]
    step_assert_eq hpc33 hpc34 with ret_branch_id
    step_assert_eq hpc35 hpc36 with ret_ρ
    step_ret hpc37
    step_done
    use_only rfl, rfl
    -- range check condition
    use_only (3 + 0); constructor; norm_num1
    constructor
    · arith_simps; exact ret_range_check₁
    intro rc_h_range_check
    have rc_h_range_check' := rangeChecked_add_right rc_h_range_check
    suffices auto_spec : auto_spec_u32_try_from_felt252 mem _ range_check value _ _ by
      apply sound_u32_try_from_felt252; apply auto_spec
    use_only orig_range_check, hl_orig_range_check
    use_only is_small
    left
    use_only a0
    use_only shifted_value, hl_shifted_value
    use_only x_part
    use_only x
    use_only a4
    use_only y
    use_only a6
    rc_app rc_h_range_check' 0 hl_y rc_y

    use_only y_fixed
    use_only a8
    rc_app rc_h_range_check' 1 hl_y_fixed rc_y_fixed

    rc_app rc_h_range_check' 2 hl_x rc_x

    use_only diff
    use_only a12
    right
    use_only a14
    use_only ret_branch_id
    use_only ret_ρ
    done
  -- is_small ≠ 0
  have a0 : is_small ≠ 0 := by simp only [hl_is_small]; exact hcond0
  -- range check for value
  step_assert_eq hpc18 with rc_value
  -- tempvar value_upper_limit
  step_assert_eq hpc19 hpc20 with tv_value_upper_limit
  mkdef hl_value_upper_limit : value_upper_limit = value + fixer_limit
  have htv_value_upper_limit : value_upper_limit = mem (σ.ap + 1) := by
    sorry
  -- range check for value_upper_limit
  step_assert_eq hpc21 with rc_value_upper_limit
  -- return values
  step_advance_ap hpc22 hpc23
  --   range check return value
  step_assert_eq hpc24 hpc25 with ret_range_check₁
  mkdef hl_range_check₁ : range_check₁ = range_check + 2
  have htv_range_check₁ : range_check₁ = _ := by
    apply Eq.symm; apply Eq.trans ret_range_check₁
    simp only [hl_range_check₁, hin_range_check]
  step_assert_eq hpc26 hpc27 with ret_branch_id
  step_assert_eq hpc28 with ret_ρ
  step_jump_imm hpc29 hpc30
  step_ret hpc37
  step_done
  use_only rfl, rfl
  -- range check condition
  use_only (2 + 0); constructor; norm_num1
  constructor
  · arith_simps; exact ret_range_check₁
  intro rc_h_range_check
  have rc_h_range_check' := rangeChecked_add_right rc_h_range_check
  suffices auto_spec : auto_spec_u32_try_from_felt252 mem _ range_check value _ _ by
    apply sound_u32_try_from_felt252; apply auto_spec
  use_only orig_range_check, hl_orig_range_check
  use_only is_small
  right
  use_only a0
  rc_app rc_h_range_check' 0 hl_value rc_value

  use_only value_upper_limit, hl_value_upper_limit
  rc_app rc_h_range_check' 1 hl_value_upper_limit rc_value_upper_limit

  use_only ret_branch_id
  use_only ret_ρ
  done

//! > ==========================================================================

//! > u32_is_zero libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
use zeroable::IsZeroResult;
fn foo(a: u32) -> u32 {
    match integer::u32_is_zero(a) {
        IsZeroResult::Zero => 1234_u32,
        IsZeroResult::NonZero(x) => x.into(),
    }
}

//! > casm
jmp rel 5 if [fp + -3] != 0;
[ap + 0] = 1234, ap++;
ret;
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 200})

//! > sierra_code
type u32 = u32 [storable: true, drop: true, dup: true, zero_sized: false];
type Const<u32, 1234> = Const<u32, 1234> [storable: false, drop: false, dup: false, zero_sized: false];
type NonZero<u32> = NonZero<u32> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc u32_is_zero = u32_is_zero;
libfunc branch_align = branch_align;
libfunc const_as_immediate<Const<u32, 1234>> = const_as_immediate<Const<u32, 1234>>;
libfunc store_temp<u32> = store_temp<u32>;
libfunc unwrap_non_zero<u32> = unwrap_non_zero<u32>;

u32_is_zero([0]) { fallthrough() 5([1]) }; // 0
branch_align() -> (); // 1
const_as_immediate<Const<u32, 1234>>() -> ([2]); // 2
store_temp<u32>([2]) -> ([2]); // 3
return([2]); // 4
branch_align() -> (); // 5
unwrap_non_zero<u32>([1]) -> ([3]); // 6
store_temp<u32>([3]) -> ([3]); // 7
return([3]); // 8

test::foo@0([0]: u32) -> (u32);

//! > test_name
u32_is_zero libfunc

//! > lean_soundness
import starkware.cairo.lean.semantics.soundness.prelude
import .u32_is_zero_code
open tactic

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F


def spec_u32_is_zero (mem : F → F) (κ : ℕ) (value ρ : F) : Prop :=
  true

def auto_spec_u32_is_zero (mem : F → F) (κ : ℕ) (value ρ : F) : Prop :=
  (
    (value = 0
    ) ∨
    (value ≠ 0 ∧
      ρ = value
    )
  )

theorem sound_u32_is_zero
    {mem : F → F}
    (κ : ℕ)
    (value ρ : F)
    (h_auto : auto_spec_u32_is_zero mem κ value ρ) :
  spec_u32_is_zero mem κ value ρ :=
begin
  trivial
end

theorem auto_sound_u32_is_zero
  -- arguments
  (value : F)
  -- code is in memory at s.pc
  (h_mem : MemAt mem code_u32_is_zero σ.pc)
  -- input arguments on the stack
  (hin_value : value = mem (σ.fp - 3))
  -- conclusion
  : EnsuresRet mem σ fun κ τ =>
    spec_u32_is_zero mem κ value (mem (τ.ap - 1))) :=
by
  apply ensures_of_ensuresb; intro νbound
  unpack_memory code_u32_is_zero at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7⟩
  -- jump to Target if value != 0
  step_jnz hpc0 hpc1 with hcond0 hcond0
  ·
    -- value = 0
    have a0 : value = 0 := by simp only [hl_value]; exact hcond0
    -- return values
    step_assert_eq hpc2 hpc3 with ret_ρ
    step_jump_imm hpc4 hpc5
    step_ret hpc7
    step_done
    use_only rfl, rfl
    suffices auto_spec : auto_spec_u32_is_zero mem _ value _ by
      apply sound_u32_is_zero; apply auto_spec
    left
    use_only a0
    use_only ret_ρ
    done
  -- value ≠ 0
  have a0 : value ≠ 0 := by simp only [hl_value]; exact hcond0
  -- return values
  step_assert_eq hpc6 with ret_ρ
  step_ret hpc7
  step_done
  use_only rfl, rfl
  suffices auto_spec : auto_spec_u32_is_zero mem _ value _ by
    apply sound_u32_is_zero; apply auto_spec
  right
  use_only a0
  use_only ret_ρ
  done

//! > ==========================================================================

//! > u32_safe_divmod libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(a: u32, b: NonZero::<u32>) -> (u32, u32) {
    integer::u32_safe_divmod(a, b)
}

//! > casm
%{ (memory[ap + 3], memory[ap + 4]) = divmod(memory[fp + -4], memory[fp + -3]) %}
[ap + 4] = [[fp + -5] + 0], ap++;
[ap + -1] = [ap + 3] + 1, ap++;
[fp + -3] = [ap + -1] + [ap + -2], ap++;
[ap + -2] = [[fp + -5] + 1], ap++;
[ap + -1] = [[fp + -5] + 2], ap++;
[ap + -3] = [fp + -3] * [ap + -2];
[fp + -4] = [ap + -3] + [ap + -1];
[ap + 0] = [fp + -5] + 3, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1210})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type u32 = u32 [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<u32, u32> = Struct<ut@Tuple, u32, u32> [storable: true, drop: true, dup: true, zero_sized: false];
type NonZero<u32> = NonZero<u32> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc u32_safe_divmod = u32_safe_divmod;
libfunc struct_construct<Tuple<u32, u32>> = struct_construct<Tuple<u32, u32>>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<Tuple<u32, u32>> = store_temp<Tuple<u32, u32>>;

u32_safe_divmod([0], [1], [2]) -> ([3], [4], [5]); // 0
struct_construct<Tuple<u32, u32>>([4], [5]) -> ([6]); // 1
store_temp<RangeCheck>([3]) -> ([3]); // 2
store_temp<Tuple<u32, u32>>([6]) -> ([6]); // 3
return([3], [6]); // 4

test::foo@0([0]: RangeCheck, [1]: u32, [2]: NonZero<u32>) -> (RangeCheck, Tuple<u32, u32>);

//! > test_name
u32_safe_divmod libfunc

//! > lean_soundness
import starkware.cairo.lean.semantics.soundness.prelude
import .u32_safe_divmod_code
open tactic

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

def one : F := (1 : F) -- 1

def spec_u32_safe_divmod (mem : F → F) (κ : ℕ) (range_check a b ρ_q ρ_r : F) : Prop :=
  true

def auto_spec_u32_safe_divmod (mem : F → F) (κ : ℕ) (range_check a b ρ_q ρ_r : F) : Prop :=
  ∃ orig_range_check : F, orig_range_check = range_check ∧
  ∃ r_plus_1 : F,
  ∃ b_minus_r_minus_1 : F,
  ∃ bq : F,
  ∃ q : F,
  ∃ r : F, r = mem range_check ∧
  r_plus_1 = r + one ∧
  b_minus_r_minus_1 = b - r_plus_1 ∧
  is_range_checked (rc_bound F) b_minus_r_minus_1 ∧
  is_range_checked (rc_bound F) q ∧
  bq = b * q ∧
  a = bq + r ∧
  ρ_q = q ∧
  ρ_r = r

theorem sound_u32_safe_divmod
    {mem : F → F}
    (κ : ℕ)
    (range_check a b ρ_q ρ_r : F)
    (h_auto : auto_spec_u32_safe_divmod mem κ range_check a b ρ_q ρ_r) :
  spec_u32_safe_divmod mem κ range_check a b ρ_q ρ_r :=
begin
  trivial
end

theorem auto_sound_u32_safe_divmod
  -- arguments
  (range_check a b : F)
  -- code is in memory at s.pc
  (h_mem : MemAt mem code_u32_safe_divmod σ.pc)
  -- input arguments on the stack
  (hin_range_check : range_check = mem (σ.fp - 5))
  (hin_a : a = mem (σ.fp - 4))
  (hin_b : b = mem (σ.fp - 3))
  -- conclusion
  : EnsuresRet mem σ fun κ τ =>
    ∃ μ ≤ κ, RcEnsures mem (rcBound F) μ (mem (σ.fp - 5)) (mem (τ.ap - 3))
      (spec_u32_safe_divmod mem κ range_check a b (mem (τ.ap - 2)) (mem (τ.ap - 1)))) :=
by
  apply ensures_of_ensuresb; intro νbound
  unpack_memory code_u32_safe_divmod at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7,
  hpc8, hpc9, hpc10, hpc11, hpc12⟩
  -- let
  mkdef hl_orig_range_check : orig_range_check = range_check
  -- tempvar r_plus_1
  mkdef hl_r_plus_1 : r_plus_1 = mem σ.ap
  have htv_r_plus_1 : r_plus_1 = mem σ.ap := by
    exact hl_r_plus_1
  -- tempvar b_minus_r_minus_1
  mkdef hl_b_minus_r_minus_1 : b_minus_r_minus_1 = mem (σ.ap + 1)
  have htv_b_minus_r_minus_1 : b_minus_r_minus_1 = mem (σ.ap + 1) := by
    exact hl_b_minus_r_minus_1
  -- tempvar bq
  mkdef hl_bq : bq = mem (σ.ap + 2)
  have htv_bq : bq = mem (σ.ap + 2) := by
    exact hl_bq
  -- tempvar q
  mkdef hl_q : q = mem (σ.ap + 3)
  have htv_q : q = mem (σ.ap + 3) := by
    exact hl_q
  -- tempvar r
  step_assert_eq hpc0 with tv_r
  mkdef hl_r : r = mem range_check
  have htv_r : r = mem (σ.ap + 4) := by
    sorry
  -- assert
  step_assert_eq hpc1 hpc2 with ha1
  have a1 : r_plus_1 = r + one := by
    sorry
  -- assert
  step_assert_eq hpc3 with ha3
  have a3 : b_minus_r_minus_1 = b - r_plus_1 := by
    sorry
  -- range check for b_minus_r_minus_1
  step_assert_eq hpc4 with rc_b_minus_r_minus_1
  -- range check for q
  step_assert_eq hpc5 with rc_q
  -- assert
  step_assert_eq hpc6 with ha6
  have a6 : bq = b * q := by
    sorry
  -- assert
  step_assert_eq hpc7 with ha7
  have a7 : a = bq + r := by
    sorry
  -- return values
  --   range check return value
  step_assert_eq hpc8 hpc9 with ret_range_check₁
  mkdef hl_range_check₁ : range_check₁ = range_check + 2
  have htv_range_check₁ : range_check₁ = _ := by
    apply Eq.symm; apply Eq.trans ret_range_check₁
    simp only [hl_range_check₁, hin_range_check]
  step_assert_eq hpc10 with ret_q
  step_assert_eq hpc11 with ret_r
  step_ret hpc12
  step_done
  use_only rfl, rfl
  -- range check condition
  use_only (2 + 0); constructor; norm_num1
  constructor
  · arith_simps; exact ret_range_check₁
  intro rc_h_range_check
  have rc_h_range_check' := rangeChecked_add_right rc_h_range_check
  suffices auto_spec : auto_spec_u32_safe_divmod mem _ range_check a b _ _ by
    apply sound_u32_safe_divmod; apply auto_spec
  use_only orig_range_check, hl_orig_range_check
  use_only r_plus_1
  use_only b_minus_r_minus_1
  use_only bq
  use_only q
  use_only r, hl_r
  use_only a1
  use_only a3
  rc_app rc_h_range_check' 0 hl_b_minus_r_minus_1 rc_b_minus_r_minus_1

  rc_app rc_h_range_check' 1 hl_q rc_q

  use_only a6
  use_only a7
  use_only ret_q
  use_only ret_r
  done

//! > ==========================================================================

//! > u32_sqrt libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
#[feature("corelib-internal-use")]
fn foo(value: u32) -> u16 {
    integer::u32_sqrt(value)
}

//! > casm
%{
import math
memory[ap + 5] = math.isqrt(memory[fp + -3])
%}
[ap + 0] = [ap + 5] + 297747071055821155530452781502797185024, ap++;
[ap + 4] = [[fp + -4] + 0], ap++;
[ap + -2] = [[fp + -4] + 1], ap++;
[ap + -2] = [ap + 2] * [ap + 2], ap++;
[fp + -3] = [ap + -2] + [ap + -3], ap++;
[ap + -3] = [[fp + -4] + 2], ap++;
[ap + -3] = [ap + -1] + [ap + -1];
[ap + -3] = [ap + -2] + [ap + -4];
[ap + -2] = [[fp + -4] + 3];
[ap + 0] = [fp + -4] + 4, ap++;
[ap + 0] = [ap + -2], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1380})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type u16 = u16 [storable: true, drop: true, dup: true, zero_sized: false];
type u32 = u32 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc u32_sqrt = u32_sqrt;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<u16> = store_temp<u16>;

u32_sqrt([0], [1]) -> ([2], [3]); // 0
store_temp<RangeCheck>([2]) -> ([2]); // 1
store_temp<u16>([3]) -> ([3]); // 2
return([2], [3]); // 3

test::foo@0([0]: RangeCheck, [1]: u32) -> (RangeCheck, u16);

//! > ==========================================================================

//! > u32_wide_mul libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
#[feature("corelib-internal-use")]
fn foo(a: u32, b: u32) -> u64 {
    integer::u32_wide_mul(a, b)
}

//! > casm
[ap + 0] = [fp + -4] * [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > sierra_code
type u32 = u32 [storable: true, drop: true, dup: true, zero_sized: false];
type u64 = u64 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc u32_wide_mul = u32_wide_mul;
libfunc store_temp<u64> = store_temp<u64>;

u32_wide_mul([0], [1]) -> ([2]); // 0
store_temp<u64>([2]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: u32, [1]: u32) -> (u64);
