//! > into_box libfunc for felt252 (size 1)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(x: felt252) -> Box::<felt252> {
    BoxTrait::new(x)
}

//! > casm
%{
if '__boxed_segment' not in globals():
    __boxed_segment = segments.add()
memory[ap + 0] = __boxed_segment
__boxed_segment += 1
%}
[fp + -3] = [[ap + 0] + 0], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Box<felt252> = Box<felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc into_box<felt252> = into_box<felt252>;
libfunc rename<Box<felt252>> = rename<Box<felt252>>;

into_box<felt252>([0]) -> ([1]); // 0
rename<Box<felt252>>([1]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: felt252) -> (Box<felt252>);

//! > ==========================================================================

//! > unbox libfunc for felt252 (size 1)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(x: Box::<felt252>) -> felt252 {
    x.unbox()
}

//! > casm
[ap + 0] = [[fp + -3] + 0], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > sierra_code
type Box<felt252> = Box<felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc unbox<felt252> = unbox<felt252>;
libfunc store_temp<felt252> = store_temp<felt252>;

unbox<felt252>([0]) -> ([1]); // 0
store_temp<felt252>([1]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: Box<felt252>) -> (felt252);

//! > ==========================================================================

//! > into_box libfunc for u256 (size 2)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(x: u256) -> Box::<u256> {
    BoxTrait::new(x)
}

//! > casm
%{
if '__boxed_segment' not in globals():
    __boxed_segment = segments.add()
memory[ap + 0] = __boxed_segment
__boxed_segment += 2
%}
[fp + -4] = [[ap + 0] + 0], ap++;
[fp + -3] = [[ap + -1] + 1];
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 200})

//! > sierra_code
type u128 = u128 [storable: true, drop: true, dup: true, zero_sized: false];
type core::integer::u256 = Struct<ut@core::integer::u256, u128, u128> [storable: true, drop: true, dup: true, zero_sized: false];
type Box<core::integer::u256> = Box<core::integer::u256> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc into_box<core::integer::u256> = into_box<core::integer::u256>;
libfunc rename<Box<core::integer::u256>> = rename<Box<core::integer::u256>>;

into_box<core::integer::u256>([0]) -> ([1]); // 0
rename<Box<core::integer::u256>>([1]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: core::integer::u256) -> (Box<core::integer::u256>);

//! > ==========================================================================

//! > unbox libfunc for u256 (size 2)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(x: Box::<u256>) -> u256 {
    x.unbox()
}

//! > casm
[ap + 0] = [[fp + -3] + 0], ap++;
[ap + 0] = [[fp + -3] + 1], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 200})

//! > sierra_code
type Box<core::integer::u256> = Box<core::integer::u256> [storable: true, drop: true, dup: true, zero_sized: false];
type u128 = u128 [storable: true, drop: true, dup: true, zero_sized: false];
type core::integer::u256 = Struct<ut@core::integer::u256, u128, u128> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc unbox<core::integer::u256> = unbox<core::integer::u256>;
libfunc store_temp<core::integer::u256> = store_temp<core::integer::u256>;

unbox<core::integer::u256>([0]) -> ([1]); // 0
store_temp<core::integer::u256>([1]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: Box<core::integer::u256>) -> (core::integer::u256);

//! > ==========================================================================

//! > into_box libfunc for unit type (size 0)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo() -> Box::<()> {
    BoxTrait::new(())
}

//! > casm
[ap + 0] = 1, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > sierra_code
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type Box<Unit> = Box<Unit> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc store_temp<Unit> = store_temp<Unit>;
libfunc into_box<Unit> = into_box<Unit>;
libfunc rename<Box<Unit>> = rename<Box<Unit>>;

struct_construct<Unit>() -> ([0]); // 0
store_temp<Unit>([0]) -> ([0]); // 1
into_box<Unit>([0]) -> ([1]); // 2
rename<Box<Unit>>([1]) -> ([2]); // 3
return([2]); // 4

test::foo@0() -> (Box<Unit>);

//! > ==========================================================================

//! > unbox libfunc for unit type (size 0)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(x: Box::<()>) -> () {
    x.unbox()
}

//! > casm
ret;

//! > function_costs
test::foo: OrderedHashMap({})

//! > sierra_code
type Box<Unit> = Box<Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];

libfunc unbox<Unit> = unbox<Unit>;
libfunc store_temp<Unit> = store_temp<Unit>;

unbox<Unit>([0]) -> ([1]); // 0
store_temp<Unit>([1]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: Box<Unit>) -> (Unit);

//! > ==========================================================================

//! > into_box libfunc for empty struct (size 0)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
struct Empty {}
fn foo() -> Box::<Empty> {
    BoxTrait::new(Empty{})
}

//! > casm
[ap + 0] = 1, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > sierra_code
type test::Empty = Struct<ut@test::Empty> [storable: true, drop: true, dup: true, zero_sized: true];
type Box<test::Empty> = Box<test::Empty> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc struct_construct<test::Empty> = struct_construct<test::Empty>;
libfunc store_temp<test::Empty> = store_temp<test::Empty>;
libfunc into_box<test::Empty> = into_box<test::Empty>;
libfunc rename<Box<test::Empty>> = rename<Box<test::Empty>>;

struct_construct<test::Empty>() -> ([0]); // 0
store_temp<test::Empty>([0]) -> ([0]); // 1
into_box<test::Empty>([0]) -> ([1]); // 2
rename<Box<test::Empty>>([1]) -> ([2]); // 3
return([2]); // 4

test::foo@0() -> (Box<test::Empty>);

//! > ==========================================================================

//! > unbox libfunc for empty struct (size 0)

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
struct Empty {}
fn foo(x: Box::<Empty>) -> Empty {
    x.unbox()
}

//! > casm
ret;

//! > function_costs
test::foo: OrderedHashMap({})

//! > sierra_code
type Box<test::Empty> = Box<test::Empty> [storable: true, drop: true, dup: true, zero_sized: false];
type test::Empty = Struct<ut@test::Empty> [storable: true, drop: true, dup: true, zero_sized: true];

libfunc unbox<test::Empty> = unbox<test::Empty>;
libfunc store_temp<test::Empty> = store_temp<test::Empty>;

unbox<test::Empty>([0]) -> ([1]); // 0
store_temp<test::Empty>([1]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: Box<test::Empty>) -> (test::Empty);
