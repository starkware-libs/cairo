//! > bounded_int_add libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;
const MIN_I8: felt252 = -128;
const MAX_I8: felt252 = 127;
type AddType = BoundedInt<{MIN_I8 + MIN_I8}, {MAX_I8 + MAX_I8}>;

extern fn bounded_int_add<T1, T2>(a: T1, b: T2) -> AddType nopanic;

fn foo(a: i8, b: i8) -> AddType {
    bounded_int_add(a, b)
}

//! > casm
[ap + 0] = [fp + -4] + [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > sierra_code
type i8 = i8 [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<-256, 254> = BoundedInt<-256, 254> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_add<i8, i8> = bounded_int_add<i8, i8>;
libfunc store_temp<BoundedInt<-256, 254>> = store_temp<BoundedInt<-256, 254>>;

bounded_int_add<i8, i8>([0], [1]) -> ([2]); // 0
store_temp<BoundedInt<-256, 254>>([2]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: i8, [1]: i8) -> (BoundedInt<-256, 254>);

//! > ==========================================================================

//! > bounded_int_sub libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;
const MIN_I8: felt252 = -128;
const MAX_I8: felt252 = 127;
type SubType = BoundedInt<{MIN_I8 - MAX_I8}, {MAX_I8 - MIN_I8}>;

extern fn bounded_int_sub<T1, T2>(a: T1, b: T2) -> SubType nopanic;

fn foo(a: i8, b: i8) -> SubType {
    bounded_int_sub(a, b)
}

//! > casm
[fp + -4] = [ap + 0] + [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > sierra_code
type i8 = i8 [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<-255, 255> = BoundedInt<-255, 255> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_sub<i8, i8> = bounded_int_sub<i8, i8>;
libfunc store_temp<BoundedInt<-255, 255>> = store_temp<BoundedInt<-255, 255>>;

bounded_int_sub<i8, i8>([0], [1]) -> ([2]); // 0
store_temp<BoundedInt<-255, 255>>([2]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: i8, [1]: i8) -> (BoundedInt<-255, 255>);

//! > ==========================================================================

//! > bounded_int_mul libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;
const MIN_I8: felt252 = -128;
const MAX_I8: felt252 = 127;
type MulType = BoundedInt<{MIN_I8 * MAX_I8}, {MIN_I8 * MIN_I8}>;

extern fn bounded_int_mul<T1, T2>(a: T1, b: T2) -> MulType nopanic;

fn foo(a: i8, b: i8) -> MulType {
    bounded_int_mul(a, b)
}

//! > casm
[ap + 0] = [fp + -4] * [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > sierra_code
type i8 = i8 [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<-16256, 16384> = BoundedInt<-16256, 16384> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_mul<i8, i8> = bounded_int_mul<i8, i8>;
libfunc store_temp<BoundedInt<-16256, 16384>> = store_temp<BoundedInt<-16256, 16384>>;

bounded_int_mul<i8, i8>([0], [1]) -> ([2]); // 0
store_temp<BoundedInt<-16256, 16384>>([2]) -> ([2]); // 1
return([2]); // 2

test::foo@0([0]: i8, [1]: i8) -> (BoundedInt<-16256, 16384>);

//! > ==========================================================================

//! > bounded_int_div_rem libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;
type DivRemType = (
    BoundedInt<16, 85>,
    BoundedInt<0, 7>,
);

extern fn bounded_int_div_rem<T1, T2>(a: T1, b: T2) -> DivRemType implicits(RangeCheck) nopanic;

fn foo(a: BoundedInt<128, 255>, b: BoundedInt<3, 8>) -> DivRemType {
    bounded_int_div_rem(a, b)
}

//! > casm
%{ (memory[ap + 3], memory[ap + 4]) = divmod(memory[fp + -4], memory[fp + -3]) %}
[ap + 4] = [[fp + -5] + 0], ap++;
[ap + -1] = [ap + 3] + 1, ap++;
[fp + -3] = [ap + -1] + [ap + -2], ap++;
[ap + -2] = [[fp + -5] + 1], ap++;
[ap + -1] = [[fp + -5] + 2], ap++;
[ap + -3] = [fp + -3] * [ap + -2];
[fp + -4] = [ap + -3] + [ap + -1];
[ap + 0] = [fp + -5] + 3, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1210})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type BoundedInt<16, 85> = BoundedInt<16, 85> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<0, 7> = BoundedInt<0, 7> [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<BoundedInt<16, 85>, BoundedInt<0, 7>> = Struct<ut@Tuple, BoundedInt<16, 85>, BoundedInt<0, 7>> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<3, 8> = BoundedInt<3, 8> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<128, 255> = BoundedInt<128, 255> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_div_rem<BoundedInt<128, 255>, BoundedInt<3, 8>> = bounded_int_div_rem<BoundedInt<128, 255>, BoundedInt<3, 8>>;
libfunc struct_construct<Tuple<BoundedInt<16, 85>, BoundedInt<0, 7>>> = struct_construct<Tuple<BoundedInt<16, 85>, BoundedInt<0, 7>>>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<Tuple<BoundedInt<16, 85>, BoundedInt<0, 7>>> = store_temp<Tuple<BoundedInt<16, 85>, BoundedInt<0, 7>>>;

bounded_int_div_rem<BoundedInt<128, 255>, BoundedInt<3, 8>>([0], [1], [2]) -> ([3], [4], [5]); // 0
struct_construct<Tuple<BoundedInt<16, 85>, BoundedInt<0, 7>>>([4], [5]) -> ([6]); // 1
store_temp<RangeCheck>([3]) -> ([3]); // 2
store_temp<Tuple<BoundedInt<16, 85>, BoundedInt<0, 7>>>([6]) -> ([6]); // 3
return([3], [6]); // 4

test::foo@0([0]: RangeCheck, [1]: BoundedInt<128, 255>, [2]: BoundedInt<3, 8>) -> (RangeCheck, Tuple<BoundedInt<16, 85>, BoundedInt<0, 7>>);

//! > ==========================================================================

//! > bounded_int_div_rem libfunc for the wide case.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;
type DivRemType = (
    BoundedInt<0, 0xffffffffffffffffffffffffffffffff>,
    BoundedInt<0, 0xfffffffffffffffffffffffffffffffe>,
);

extern fn bounded_int_div_rem<T1, T2>(a: T1, b: T2) -> DivRemType implicits(RangeCheck) nopanic;

fn foo(a: u128, b: BoundedInt<1, 0xffffffffffffffffffffffffffffffff>) -> DivRemType {
    bounded_int_div_rem(a, b)
}

//! > casm
%{ (memory[ap + 5], memory[ap + 6]) = divmod(memory[fp + -4], memory[fp + -3]) %}
[ap + 5] = [[fp + -5] + 0], ap++;
[ap + 5] = [[fp + -5] + 1], ap++;
[ap + -2] = [ap + 4] + 1, ap++;
[fp + -3] = [ap + -2] + [ap + -3], ap++;
[ap + -3] = [[fp + -5] + 2], ap++;
%{ memory[ap + -3] = memory[ap + 0] < 18446744073709551616 %}
jmp rel 6 if [ap + -3] != 0, ap++;
[ap + -3] = [fp + -3] + 340282366920938463444927863358058659840, ap++;
jmp rel 4;
[ap + -3] = [ap + -1] + 340282366920938463444927863358058659840, ap++;
[ap + -4] = [[fp + -5] + 3];
[ap + -3] = [fp + -3] * [ap + -2];
[fp + -4] = [ap + -3] + [ap + -1];
[ap + 0] = [fp + -5] + 4, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1680})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type BoundedInt<0, 340282366920938463463374607431768211455> = BoundedInt<0, 340282366920938463463374607431768211455> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<0, 340282366920938463463374607431768211454> = BoundedInt<0, 340282366920938463463374607431768211454> [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<BoundedInt<0, 340282366920938463463374607431768211455>, BoundedInt<0, 340282366920938463463374607431768211454>> = Struct<ut@Tuple, BoundedInt<0, 340282366920938463463374607431768211455>, BoundedInt<0, 340282366920938463463374607431768211454>> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<1, 340282366920938463463374607431768211455> = BoundedInt<1, 340282366920938463463374607431768211455> [storable: true, drop: true, dup: true, zero_sized: false];
type u128 = u128 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_div_rem<u128, BoundedInt<1, 340282366920938463463374607431768211455>> = bounded_int_div_rem<u128, BoundedInt<1, 340282366920938463463374607431768211455>>;
libfunc struct_construct<Tuple<BoundedInt<0, 340282366920938463463374607431768211455>, BoundedInt<0, 340282366920938463463374607431768211454>>> = struct_construct<Tuple<BoundedInt<0, 340282366920938463463374607431768211455>, BoundedInt<0, 340282366920938463463374607431768211454>>>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<Tuple<BoundedInt<0, 340282366920938463463374607431768211455>, BoundedInt<0, 340282366920938463463374607431768211454>>> = store_temp<Tuple<BoundedInt<0, 340282366920938463463374607431768211455>, BoundedInt<0, 340282366920938463463374607431768211454>>>;

bounded_int_div_rem<u128, BoundedInt<1, 340282366920938463463374607431768211455>>([0], [1], [2]) -> ([3], [4], [5]); // 0
struct_construct<Tuple<BoundedInt<0, 340282366920938463463374607431768211455>, BoundedInt<0, 340282366920938463463374607431768211454>>>([4], [5]) -> ([6]); // 1
store_temp<RangeCheck>([3]) -> ([3]); // 2
store_temp<Tuple<BoundedInt<0, 340282366920938463463374607431768211455>, BoundedInt<0, 340282366920938463463374607431768211454>>>([6]) -> ([6]); // 3
return([3], [6]); // 4

test::foo@0([0]: RangeCheck, [1]: u128, [2]: BoundedInt<1, 340282366920938463463374607431768211455>) -> (RangeCheck, Tuple<BoundedInt<0, 340282366920938463463374607431768211455>, BoundedInt<0, 340282366920938463463374607431768211454>>);

//! > ==========================================================================

//! > bounded_int_div_rem libfunc for the small possible quotient case.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;
type DivRemType = (
    BoundedInt<0, 0xf>,
    BoundedInt<0, 0xfffffffffffffffffffffffffffffff>,
);

extern fn bounded_int_div_rem<T1, T2>(a: T1, b: T2) -> DivRemType implicits(RangeCheck) nopanic;

fn foo(a: u128, b: BoundedInt<0x10000000000000000000000000000000, 0x10000000000000000000000000000000>) -> DivRemType {
    bounded_int_div_rem(a, b)
}

//! > casm
%{ (memory[ap + 4], memory[ap + 5]) = divmod(memory[fp + -4], memory[fp + -3]) %}
[ap + 4] = [[fp + -5] + 0], ap++;
[ap + 4] = [[fp + -5] + 1], ap++;
[ap + -2] = [ap + 3] + 1, ap++;
[fp + -3] = [ap + -2] + [ap + -3], ap++;
[ap + -3] = [[fp + -5] + 2], ap++;
[ap + -3] = [ap + -1] + 340282366920938463463374607431768211440, ap++;
[ap + -4] = [[fp + -5] + 3];
[ap + -3] = [fp + -3] * [ap + -2];
[fp + -4] = [ap + -3] + [ap + -1];
[ap + 0] = [fp + -5] + 4, ap++;
[ap + 0] = [ap + -3], ap++;
[ap + 0] = [ap + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1480})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type BoundedInt<0, 15> = BoundedInt<0, 15> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<0, 21267647932558653966460912964485513215> = BoundedInt<0, 21267647932558653966460912964485513215> [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<BoundedInt<0, 15>, BoundedInt<0, 21267647932558653966460912964485513215>> = Struct<ut@Tuple, BoundedInt<0, 15>, BoundedInt<0, 21267647932558653966460912964485513215>> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<21267647932558653966460912964485513216, 21267647932558653966460912964485513216> = BoundedInt<21267647932558653966460912964485513216, 21267647932558653966460912964485513216> [storable: true, drop: true, dup: true, zero_sized: false];
type u128 = u128 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_div_rem<u128, BoundedInt<21267647932558653966460912964485513216, 21267647932558653966460912964485513216>> = bounded_int_div_rem<u128, BoundedInt<21267647932558653966460912964485513216, 21267647932558653966460912964485513216>>;
libfunc struct_construct<Tuple<BoundedInt<0, 15>, BoundedInt<0, 21267647932558653966460912964485513215>>> = struct_construct<Tuple<BoundedInt<0, 15>, BoundedInt<0, 21267647932558653966460912964485513215>>>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<Tuple<BoundedInt<0, 15>, BoundedInt<0, 21267647932558653966460912964485513215>>> = store_temp<Tuple<BoundedInt<0, 15>, BoundedInt<0, 21267647932558653966460912964485513215>>>;

bounded_int_div_rem<u128, BoundedInt<21267647932558653966460912964485513216, 21267647932558653966460912964485513216>>([0], [1], [2]) -> ([3], [4], [5]); // 0
struct_construct<Tuple<BoundedInt<0, 15>, BoundedInt<0, 21267647932558653966460912964485513215>>>([4], [5]) -> ([6]); // 1
store_temp<RangeCheck>([3]) -> ([3]); // 2
store_temp<Tuple<BoundedInt<0, 15>, BoundedInt<0, 21267647932558653966460912964485513215>>>([6]) -> ([6]); // 3
return([3], [6]); // 4

test::foo@0([0]: RangeCheck, [1]: u128, [2]: BoundedInt<21267647932558653966460912964485513216, 21267647932558653966460912964485513216>) -> (RangeCheck, Tuple<BoundedInt<0, 15>, BoundedInt<0, 21267647932558653966460912964485513215>>);

//! > ==========================================================================

//! > bounded_int_constrain libfunc.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;
type Res = Result<BoundedInt<0, 0x7f>, BoundedInt<0x80, 0xff>>;

extern fn bounded_int_constrain<T, const BOUNDARY: felt252>(value: T) -> Res implicits(RangeCheck) nopanic;

fn foo(value: u8) -> Res {
    bounded_int_constrain::<_, 0x80>(value)
}

//! > casm
%{ memory[ap + 0] = 340282366920938463463374607431768211456 <= (memory[fp + -3] + -128) % PRIME %}
jmp rel 7 if [ap + 0] != 0, ap++;
[ap + 0] = [fp + -3] + -128, ap++;
[ap + -1] = [[fp + -4] + 0];
jmp rel 11;
[ap + 0] = [fp + -3] + 340282366920938463463374607431768211328, ap++;
[ap + -1] = [[fp + -4] + 0];
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3], ap++;
ret;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 770})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type BoundedInt<0, 127> = BoundedInt<0, 127> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<128, 255> = BoundedInt<128, 255> [storable: true, drop: true, dup: true, zero_sized: false];
type core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>> = Enum<ut@core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>, BoundedInt<0, 127>, BoundedInt<128, 255>> [storable: true, drop: true, dup: true, zero_sized: false];
type u8 = u8 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_constrain<u8, 128> = bounded_int_constrain<u8, 128>;
libfunc branch_align = branch_align;
libfunc enum_init<core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>, 0> = enum_init<core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>> = store_temp<core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>>;
libfunc enum_init<core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>, 1> = enum_init<core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>, 1>;

bounded_int_constrain<u8, 128>([0], [1]) { fallthrough([2], [3]) 6([4], [5]) }; // 0
branch_align() -> (); // 1
enum_init<core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>, 0>([3]) -> ([6]); // 2
store_temp<RangeCheck>([2]) -> ([2]); // 3
store_temp<core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>>([6]) -> ([6]); // 4
return([2], [6]); // 5
branch_align() -> (); // 6
enum_init<core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>, 1>([5]) -> ([7]); // 7
store_temp<RangeCheck>([4]) -> ([4]); // 8
store_temp<core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>>([7]) -> ([7]); // 9
return([4], [7]); // 10

test::foo@0([0]: RangeCheck, [1]: u8) -> (RangeCheck, core::result::Result::<test::BoundedInt::<0, 127>, test::BoundedInt::<128, 255>>);

//! > ==========================================================================

//! > bounded_int_constrain libfunc around 0.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;
type Res = Result<BoundedInt<-0x80, -1>, BoundedInt<0, 0x7f>>;

extern fn bounded_int_constrain<T, const BOUNDARY: felt252>(value: T) -> Res implicits(RangeCheck) nopanic;

fn foo(value: i8) -> Res {
    bounded_int_constrain::<_, 0>(value)
}

//! > casm
%{ memory[ap + 0] = 340282366920938463463374607431768211456 <= (memory[fp + -3] + 0) % PRIME %}
jmp rel 5 if [ap + 0] != 0, ap++;
[fp + -3] = [[fp + -4] + 0];
jmp rel 11;
[ap + 0] = [fp + -3] + 340282366920938463463374607431768211456, ap++;
[ap + -1] = [[fp + -4] + 0];
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3], ap++;
ret;
ap += 1;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 780})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type BoundedInt<-128, -1> = BoundedInt<-128, -1> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<0, 127> = BoundedInt<0, 127> [storable: true, drop: true, dup: true, zero_sized: false];
type core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>> = Enum<ut@core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>, BoundedInt<-128, -1>, BoundedInt<0, 127>> [storable: true, drop: true, dup: true, zero_sized: false];
type i8 = i8 [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_constrain<i8, 0> = bounded_int_constrain<i8, 0>;
libfunc branch_align = branch_align;
libfunc enum_init<core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>, 0> = enum_init<core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>> = store_temp<core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>>;
libfunc enum_init<core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>, 1> = enum_init<core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>, 1>;

bounded_int_constrain<i8, 0>([0], [1]) { fallthrough([2], [3]) 6([4], [5]) }; // 0
branch_align() -> (); // 1
enum_init<core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>, 0>([3]) -> ([6]); // 2
store_temp<RangeCheck>([2]) -> ([2]); // 3
store_temp<core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>>([6]) -> ([6]); // 4
return([2], [6]); // 5
branch_align() -> (); // 6
enum_init<core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>, 1>([5]) -> ([7]); // 7
store_temp<RangeCheck>([4]) -> ([4]); // 8
store_temp<core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>>([7]) -> ([7]); // 9
return([4], [7]); // 10

test::foo@0([0]: RangeCheck, [1]: i8) -> (RangeCheck, core::result::Result::<test::BoundedInt::<-128, -1>, test::BoundedInt::<0, 127>>);

//! > ==========================================================================

//! > bounded_int_constrain libfunc around 2**128.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;
type Res = Result<
    BoundedInt<0, 0xffffffffffffffffffffffffffffffff>,
    BoundedInt<0x100000000000000000000000000000000, 0x1ffffffffffffffffffffffffffffffff>,
>;

extern fn bounded_int_constrain<T, const BOUNDARY: felt252>(value: T) -> Res implicits(RangeCheck) nopanic;

fn foo(value: BoundedInt<0, 0x1ffffffffffffffffffffffffffffffff>) -> Res {
    bounded_int_constrain::<_, 0x100000000000000000000000000000000>(value)
}

//! > casm
%{ memory[ap + 0] = 340282366920938463463374607431768211456 <= (memory[fp + -3] + -340282366920938463463374607431768211456) % PRIME %}
jmp rel 7 if [ap + 0] != 0, ap++;
[ap + 0] = [fp + -3] + -340282366920938463463374607431768211456, ap++;
[ap + -1] = [[fp + -4] + 0];
jmp rel 11;
[fp + -3] = [[fp + -4] + 0];
ap += 1;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [fp + -3], ap++;
ret;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 770})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type BoundedInt<0, 340282366920938463463374607431768211455> = BoundedInt<0, 340282366920938463463374607431768211455> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<340282366920938463463374607431768211456, 680564733841876926926749214863536422911> = BoundedInt<340282366920938463463374607431768211456, 680564733841876926926749214863536422911> [storable: true, drop: true, dup: true, zero_sized: false];
type core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>> = Enum<ut@core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>, BoundedInt<0, 340282366920938463463374607431768211455>, BoundedInt<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>> [storable: true, drop: true, dup: true, zero_sized: false];
type BoundedInt<0, 680564733841876926926749214863536422911> = BoundedInt<0, 680564733841876926926749214863536422911> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_constrain<BoundedInt<0, 680564733841876926926749214863536422911>, 340282366920938463463374607431768211456> = bounded_int_constrain<BoundedInt<0, 680564733841876926926749214863536422911>, 340282366920938463463374607431768211456>;
libfunc branch_align = branch_align;
libfunc enum_init<core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>, 0> = enum_init<core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>> = store_temp<core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>>;
libfunc enum_init<core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>, 1> = enum_init<core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>, 1>;

bounded_int_constrain<BoundedInt<0, 680564733841876926926749214863536422911>, 340282366920938463463374607431768211456>([0], [1]) { fallthrough([2], [3]) 6([4], [5]) }; // 0
branch_align() -> (); // 1
enum_init<core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>, 0>([3]) -> ([6]); // 2
store_temp<RangeCheck>([2]) -> ([2]); // 3
store_temp<core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>>([6]) -> ([6]); // 4
return([2], [6]); // 5
branch_align() -> (); // 6
enum_init<core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>, 1>([5]) -> ([7]); // 7
store_temp<RangeCheck>([4]) -> ([4]); // 8
store_temp<core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>>([7]) -> ([7]); // 9
return([4], [7]); // 10

test::foo@0([0]: RangeCheck, [1]: BoundedInt<0, 680564733841876926926749214863536422911>) -> (RangeCheck, core::result::Result::<test::BoundedInt::<0, 340282366920938463463374607431768211455>, test::BoundedInt::<340282366920938463463374607431768211456, 680564733841876926926749214863536422911>>);

//! > ==========================================================================

//! > bounded_int_is_zero libfunc for i8.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
use core::zeroable::IsZeroResult;
extern fn bounded_int_is_zero<T>(value: T) -> IsZeroResult<T> implicits() nopanic;

fn foo(value: i8) -> IsZeroResult<i8> {
    bounded_int_is_zero(value)
}

//! > casm
jmp rel 7 if [fp + -3] != 0;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
ret;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 300})

//! > sierra_code
type i8 = i8 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type NonZero<i8> = NonZero<i8> [storable: true, drop: true, dup: true, zero_sized: false];
type core::zeroable::IsZeroResult::<core::integer::i8> = Enum<ut@core::zeroable::IsZeroResult::<core::integer::i8>, Unit, NonZero<i8>> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_is_zero<i8> = bounded_int_is_zero<i8>;
libfunc branch_align = branch_align;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::zeroable::IsZeroResult::<core::integer::i8>, 0> = enum_init<core::zeroable::IsZeroResult::<core::integer::i8>, 0>;
libfunc store_temp<core::zeroable::IsZeroResult::<core::integer::i8>> = store_temp<core::zeroable::IsZeroResult::<core::integer::i8>>;
libfunc enum_init<core::zeroable::IsZeroResult::<core::integer::i8>, 1> = enum_init<core::zeroable::IsZeroResult::<core::integer::i8>, 1>;

bounded_int_is_zero<i8>([0]) { fallthrough() 6([1]) }; // 0
branch_align() -> (); // 1
struct_construct<Unit>() -> ([2]); // 2
enum_init<core::zeroable::IsZeroResult::<core::integer::i8>, 0>([2]) -> ([3]); // 3
store_temp<core::zeroable::IsZeroResult::<core::integer::i8>>([3]) -> ([3]); // 4
return([3]); // 5
branch_align() -> (); // 6
enum_init<core::zeroable::IsZeroResult::<core::integer::i8>, 1>([1]) -> ([4]); // 7
store_temp<core::zeroable::IsZeroResult::<core::integer::i8>>([4]) -> ([4]); // 8
return([4]); // 9

test::foo@0([0]: i8) -> (core::zeroable::IsZeroResult::<core::integer::i8>);

//! > ==========================================================================

//! > bounded_int_is_zero libfunc for large bounded int.

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
use core::zeroable::IsZeroResult;
extern type BoundedInt<const MIN: felt252, const MAX: felt252>;
extern fn bounded_int_is_zero<T>(value: T) -> IsZeroResult<T> implicits() nopanic;

fn foo(value: BoundedInt<0, 0x1ffffffffffffffffffffffffffffffff>) -> IsZeroResult<BoundedInt<0, 0x1ffffffffffffffffffffffffffffffff>> {
    bounded_int_is_zero(value)
}

//! > casm
jmp rel 7 if [fp + -3] != 0;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
ret;
[ap + 0] = 1, ap++;
[ap + 0] = [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 300})

//! > sierra_code
type BoundedInt<0, 680564733841876926926749214863536422911> = BoundedInt<0, 680564733841876926926749214863536422911> [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type NonZero<BoundedInt<0, 680564733841876926926749214863536422911>> = NonZero<BoundedInt<0, 680564733841876926926749214863536422911>> [storable: true, drop: true, dup: true, zero_sized: false];
type core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>> = Enum<ut@core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>, Unit, NonZero<BoundedInt<0, 680564733841876926926749214863536422911>>> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc bounded_int_is_zero<BoundedInt<0, 680564733841876926926749214863536422911>> = bounded_int_is_zero<BoundedInt<0, 680564733841876926926749214863536422911>>;
libfunc branch_align = branch_align;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>, 0> = enum_init<core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>, 0>;
libfunc store_temp<core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>> = store_temp<core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>>;
libfunc enum_init<core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>, 1> = enum_init<core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>, 1>;

bounded_int_is_zero<BoundedInt<0, 680564733841876926926749214863536422911>>([0]) { fallthrough() 6([1]) }; // 0
branch_align() -> (); // 1
struct_construct<Unit>() -> ([2]); // 2
enum_init<core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>, 0>([2]) -> ([3]); // 3
store_temp<core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>>([3]) -> ([3]); // 4
return([3]); // 5
branch_align() -> (); // 6
enum_init<core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>, 1>([1]) -> ([4]); // 7
store_temp<core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>>([4]) -> ([4]); // 8
return([4]); // 9

test::foo@0([0]: BoundedInt<0, 680564733841876926926749214863536422911>) -> (core::zeroable::IsZeroResult::<test::BoundedInt::<0, 680564733841876926926749214863536422911>>);
