//! > branch_align values are pushed to the end

//! > test_runner_name
SmallE2ETestRunnerCostComputation

//! > cairo
fn foo(x: felt252) {
    // The branch_align of the external if statements should have zero value, since the value should
    // be pushed to the inner if statement.
    if x == 0 {
        if x == 1 {
            if x == 2 {
                bar();
            } else {
                bar();
            }
        } else {
            bar();
            bar();
        }
    } else {
        bar();
        bar();
        bar();
        bar();
        bar();
        bar();
    }
}

#[inline(never)]
fn bar() {
}

//! > gas_solution
#2: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 20})
#8: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#13: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#17: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 100})
#22: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 310})
#30: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})

test::foo: OrderedHashMap({Const: 1300})
test::bar: OrderedHashMap({})

//! > gas_solution_no_solver
#2: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#8: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#13: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 20})
#17: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 120})
#22: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 330})
#30: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})

test::foo: OrderedHashMap({Const: 1300})
test::bar: OrderedHashMap({})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type NonZero<felt252> = NonZero<felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc dup<felt252> = dup<felt252>;
libfunc felt252_is_zero = felt252_is_zero;
libfunc branch_align = branch_align;
libfunc felt252_const<1> = felt252_const<1>;
libfunc felt252_sub = felt252_sub;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc felt252_const<2> = felt252_const<2>;
libfunc function_call<user@test::bar> = function_call<user@test::bar>;
libfunc drop<Unit> = drop<Unit>;
libfunc jump = jump;
libfunc drop<NonZero<felt252>> = drop<NonZero<felt252>>;
libfunc drop<felt252> = drop<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc store_temp<Unit> = store_temp<Unit>;

dup<felt252>([0]) -> ([0], [1]); // 0
felt252_is_zero([1]) { fallthrough() 30([2]) }; // 1
branch_align() -> (); // 2
felt252_const<1>() -> ([3]); // 3
dup<felt252>([0]) -> ([0], [5]); // 4
felt252_sub([5], [3]) -> ([4]); // 5
store_temp<felt252>([4]) -> ([4]); // 6
felt252_is_zero([4]) { fallthrough() 22([6]) }; // 7
branch_align() -> (); // 8
felt252_const<2>() -> ([7]); // 9
felt252_sub([0], [7]) -> ([8]); // 10
store_temp<felt252>([8]) -> ([8]); // 11
felt252_is_zero([8]) { fallthrough() 17([9]) }; // 12
branch_align() -> (); // 13
function_call<user@test::bar>() -> ([10]); // 14
drop<Unit>([10]) -> (); // 15
jump() { 21() }; // 16
branch_align() -> (); // 17
drop<NonZero<felt252>>([9]) -> (); // 18
function_call<user@test::bar>() -> ([11]); // 19
drop<Unit>([11]) -> (); // 20
jump() { 29() }; // 21
branch_align() -> (); // 22
drop<NonZero<felt252>>([6]) -> (); // 23
drop<felt252>([0]) -> (); // 24
function_call<user@test::bar>() -> ([12]); // 25
drop<Unit>([12]) -> (); // 26
function_call<user@test::bar>() -> ([13]); // 27
drop<Unit>([13]) -> (); // 28
jump() { 45() }; // 29
branch_align() -> (); // 30
drop<NonZero<felt252>>([2]) -> (); // 31
drop<felt252>([0]) -> (); // 32
function_call<user@test::bar>() -> ([14]); // 33
drop<Unit>([14]) -> (); // 34
function_call<user@test::bar>() -> ([15]); // 35
drop<Unit>([15]) -> (); // 36
function_call<user@test::bar>() -> ([16]); // 37
drop<Unit>([16]) -> (); // 38
function_call<user@test::bar>() -> ([17]); // 39
drop<Unit>([17]) -> (); // 40
function_call<user@test::bar>() -> ([18]); // 41
drop<Unit>([18]) -> (); // 42
function_call<user@test::bar>() -> ([19]); // 43
drop<Unit>([19]) -> (); // 44
struct_construct<Unit>() -> ([20]); // 45
store_temp<Unit>([20]) -> ([21]); // 46
return([21]); // 47
struct_construct<Unit>() -> ([0]); // 48
store_temp<Unit>([0]) -> ([1]); // 49
return([1]); // 50

test::foo@0([0]: felt252) -> (Unit);
test::bar@48() -> (Unit);

//! > casm
jmp rel 28 if [fp + -3] != 0;
ap += 7;
[fp + -3] = [ap + 0] + 1, ap++;
jmp rel 16 if [ap + -1] != 0;
ap += 1;
[fp + -3] = [ap + 0] + 2, ap++;
jmp rel 6 if [ap + -1] != 0;
call rel 27;
jmp rel 4;
call rel 23;
jmp rel 6;
call rel 19;
call rel 17;
jmp rel 14;
call rel 13;
call rel 11;
call rel 9;
call rel 7;
call rel 5;
call rel 3;
ret;
ret;

//! > ==========================================================================

//! > branch_align of withdraw_gas

//! > test_runner_name
SmallE2ETestRunnerCostComputation

//! > cairo
fn foo(x: felt252) {
    // In this case, the failing branch is more expensive than the success branch.
    // The excess created by the external branch_align should be pushed to the next (inner)
    // statements.
    match gas::withdraw_gas() {
        Option::Some(_) => {
            if x == 0 {
                // Here we don't need to withdraw gas, since we have excess created by the external
                // failing branch.
                match gas::withdraw_gas() {
                    Option::Some(_) => {
                        bar();
                    },
                    Option::None(_) => {},
                }
            } else {
                bar();
            }
        },
        Option::None(_) => {
            bar();
            bar();
            bar();
            bar();
            bar();
            bar();
            bar();
            bar();
            bar();
            bar();
        },
    }
}

#[inline(never)]
fn bar() {
}

//! > gas_solution
#0: OrderedHashMap({Const: 0})
#1: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 780})
#4: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#5: OrderedHashMap({Const: 0})
#6: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#12: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 80})
#18: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 450})
#27: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})

test::foo: OrderedHashMap({Const: 2670})
test::bar: OrderedHashMap({})

//! > gas_solution_no_solver
#0: OrderedHashMap({Const: 0})
#1: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#4: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#5: OrderedHashMap({Const: 0})
#6: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 780})
#12: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 860})
#18: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 1230})
#27: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})

test::foo: OrderedHashMap({Const: 2670})
test::bar: OrderedHashMap({})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type NonZero<felt252> = NonZero<felt252> [storable: true, drop: true, dup: true, zero_sized: false];
type GasBuiltin = GasBuiltin [storable: true, drop: false, dup: false, zero_sized: false];

libfunc withdraw_gas = withdraw_gas;
libfunc branch_align = branch_align;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc felt252_is_zero = felt252_is_zero;
libfunc function_call<user@test::bar> = function_call<user@test::bar>;
libfunc drop<Unit> = drop<Unit>;
libfunc store_temp<GasBuiltin> = store_temp<GasBuiltin>;
libfunc jump = jump;
libfunc rename<RangeCheck> = rename<RangeCheck>;
libfunc rename<GasBuiltin> = rename<GasBuiltin>;
libfunc drop<NonZero<felt252>> = drop<NonZero<felt252>>;
libfunc drop<felt252> = drop<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc store_temp<Unit> = store_temp<Unit>;

withdraw_gas([0], [1]) { fallthrough([3], [4]) 27([5], [6]) }; // 0
branch_align() -> (); // 1
store_temp<RangeCheck>([3]) -> ([3]); // 2
felt252_is_zero([2]) { fallthrough() 18([7]) }; // 3
branch_align() -> (); // 4
withdraw_gas([3], [4]) { fallthrough([8], [9]) 12([10], [11]) }; // 5
branch_align() -> (); // 6
function_call<user@test::bar>() -> ([12]); // 7
drop<Unit>([12]) -> (); // 8
store_temp<RangeCheck>([8]) -> ([13]); // 9
store_temp<GasBuiltin>([9]) -> ([14]); // 10
jump() { 15() }; // 11
branch_align() -> (); // 12
store_temp<RangeCheck>([10]) -> ([13]); // 13
store_temp<GasBuiltin>([11]) -> ([14]); // 14
rename<RangeCheck>([13]) -> ([15]); // 15
rename<GasBuiltin>([14]) -> ([16]); // 16
jump() { 24() }; // 17
branch_align() -> (); // 18
drop<NonZero<felt252>>([7]) -> (); // 19
function_call<user@test::bar>() -> ([17]); // 20
drop<Unit>([17]) -> (); // 21
store_temp<RangeCheck>([3]) -> ([15]); // 22
store_temp<GasBuiltin>([4]) -> ([16]); // 23
rename<RangeCheck>([15]) -> ([18]); // 24
rename<GasBuiltin>([16]) -> ([19]); // 25
jump() { 51() }; // 26
branch_align() -> (); // 27
drop<felt252>([2]) -> (); // 28
function_call<user@test::bar>() -> ([20]); // 29
drop<Unit>([20]) -> (); // 30
function_call<user@test::bar>() -> ([21]); // 31
drop<Unit>([21]) -> (); // 32
function_call<user@test::bar>() -> ([22]); // 33
drop<Unit>([22]) -> (); // 34
function_call<user@test::bar>() -> ([23]); // 35
drop<Unit>([23]) -> (); // 36
function_call<user@test::bar>() -> ([24]); // 37
drop<Unit>([24]) -> (); // 38
function_call<user@test::bar>() -> ([25]); // 39
drop<Unit>([25]) -> (); // 40
function_call<user@test::bar>() -> ([26]); // 41
drop<Unit>([26]) -> (); // 42
function_call<user@test::bar>() -> ([27]); // 43
drop<Unit>([27]) -> (); // 44
function_call<user@test::bar>() -> ([28]); // 45
drop<Unit>([28]) -> (); // 46
function_call<user@test::bar>() -> ([29]); // 47
drop<Unit>([29]) -> (); // 48
store_temp<RangeCheck>([5]) -> ([18]); // 49
store_temp<GasBuiltin>([6]) -> ([19]); // 50
struct_construct<Unit>() -> ([30]); // 51
rename<RangeCheck>([18]) -> ([31]); // 52
rename<GasBuiltin>([19]) -> ([32]); // 53
store_temp<Unit>([30]) -> ([33]); // 54
return([31], [32], [33]); // 55
struct_construct<Unit>() -> ([0]); // 56
store_temp<Unit>([0]) -> ([1]); // 57
return([1]); // 58

test::foo@0([0]: RangeCheck, [1]: GasBuiltin, [2]: felt252) -> (RangeCheck, GasBuiltin, Unit);
test::bar@56() -> (Unit);

//! > casm
%{ memory[ap + 0] = 0 <= memory[fp + -4] %}
jmp rel 7 if [ap + 0] != 0, ap++;
[ap + 0] = [fp + -4] + 340282366920938463463374607431768211456, ap++;
[ap + -1] = [[fp + -5] + 0];
jmp rel 43;
[fp + -4] = [ap + 0] + 0, ap++;
[ap + -1] = [[fp + -5] + 0];
ap += 15;
[ap + 0] = [fp + -5] + 1, ap++;
jmp rel 26 if [fp + -3] != 0;
%{ memory[ap + 0] = 0 <= memory[ap + -17] %}
jmp rel 7 if [ap + 0] != 0, ap++;
[ap + 0] = [ap + -18] + 340282366920938463463374607431768211456, ap++;
[ap + -1] = [[ap + -3] + 0];
jmp rel 12;
[ap + -18] = [ap + 0] + 0, ap++;
[ap + -1] = [[ap + -3] + 0];
call rel 46;
[ap + 0] = [ap + -5] + 1, ap++;
[ap + 0] = [ap + -4], ap++;
jmp rel 7;
ap += 2;
[ap + 0] = [ap + -5] + 1, ap++;
[ap + 0] = [ap + -22], ap++;
jmp rel 8;
ap += 2;
call rel 30;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -22], ap++;
jmp rel 25;
call rel 24;
call rel 22;
call rel 20;
call rel 18;
call rel 16;
call rel 14;
call rel 12;
call rel 10;
call rel 8;
call rel 6;
[ap + 0] = [fp + -5] + 1, ap++;
[ap + 0] = [fp + -4], ap++;
ret;
ret;

//! > ==========================================================================

//! > withdraw_gas reduces excess

//! > test_runner_name
SmallE2ETestRunnerCostComputation

//! > cairo
fn foo(x: felt252) {
    if x == 0 {
        // Excess is created by the external `else` branch. Therefore, we don't need to withdraw
        // gas here.
        match gas::withdraw_gas() {
            Option::Some(_) => {
                // Here we have used the excess and we need to withdraw gas.
                match gas::withdraw_gas() {
                    Option::Some(_) => {
                        bar();
                    },
                    Option::None(_) => {},
                }
            },
            Option::None(_) => {},
        }
    } else {
        bar();
    }
}

#[inline(never)]
fn bar() {
    bar_inner();
    bar_inner();
    bar_inner();
    bar_inner();
    bar_inner();
    bar_inner();
    bar_inner();
    bar_inner();
    bar_inner();
    bar_inner();
}

#[inline(never)]
fn bar_inner() {
}

//! > gas_solution
#1: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#2: OrderedHashMap({Const: 0})
#3: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#4: OrderedHashMap({Const: 900})
#5: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#11: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 980})
#17: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 1430})
#23: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})

test::foo: OrderedHashMap({Const: 2640})
test::bar: OrderedHashMap({Const: 2000})
test::bar_inner: OrderedHashMap({})

//! > gas_solution_no_solver
#1: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#2: OrderedHashMap({Const: 0})
#3: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#4: OrderedHashMap({Const: 900})
#5: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#11: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 980})
#17: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 1430})
#23: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})

test::foo: OrderedHashMap({Const: 2640})
test::bar: OrderedHashMap({Const: 2000})
test::bar_inner: OrderedHashMap({})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type GasBuiltin = GasBuiltin [storable: true, drop: false, dup: false, zero_sized: false];
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type NonZero<felt252> = NonZero<felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc felt252_is_zero = felt252_is_zero;
libfunc branch_align = branch_align;
libfunc withdraw_gas = withdraw_gas;
libfunc function_call<user@test::bar> = function_call<user@test::bar>;
libfunc drop<Unit> = drop<Unit>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<GasBuiltin> = store_temp<GasBuiltin>;
libfunc jump = jump;
libfunc rename<RangeCheck> = rename<RangeCheck>;
libfunc rename<GasBuiltin> = rename<GasBuiltin>;
libfunc drop<NonZero<felt252>> = drop<NonZero<felt252>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc store_temp<Unit> = store_temp<Unit>;
libfunc function_call<user@test::bar_inner> = function_call<user@test::bar_inner>;

felt252_is_zero([2]) { fallthrough() 23([3]) }; // 0
branch_align() -> (); // 1
withdraw_gas([0], [1]) { fallthrough([4], [5]) 17([6], [7]) }; // 2
branch_align() -> (); // 3
withdraw_gas([4], [5]) { fallthrough([8], [9]) 11([10], [11]) }; // 4
branch_align() -> (); // 5
function_call<user@test::bar>() -> ([12]); // 6
drop<Unit>([12]) -> (); // 7
store_temp<RangeCheck>([8]) -> ([13]); // 8
store_temp<GasBuiltin>([9]) -> ([14]); // 9
jump() { 14() }; // 10
branch_align() -> (); // 11
store_temp<RangeCheck>([10]) -> ([13]); // 12
store_temp<GasBuiltin>([11]) -> ([14]); // 13
rename<RangeCheck>([13]) -> ([15]); // 14
rename<GasBuiltin>([14]) -> ([16]); // 15
jump() { 20() }; // 16
branch_align() -> (); // 17
store_temp<RangeCheck>([6]) -> ([15]); // 18
store_temp<GasBuiltin>([7]) -> ([16]); // 19
rename<RangeCheck>([15]) -> ([17]); // 20
rename<GasBuiltin>([16]) -> ([18]); // 21
jump() { 29() }; // 22
branch_align() -> (); // 23
drop<NonZero<felt252>>([3]) -> (); // 24
function_call<user@test::bar>() -> ([19]); // 25
drop<Unit>([19]) -> (); // 26
store_temp<RangeCheck>([0]) -> ([17]); // 27
store_temp<GasBuiltin>([1]) -> ([18]); // 28
struct_construct<Unit>() -> ([20]); // 29
rename<RangeCheck>([17]) -> ([21]); // 30
rename<GasBuiltin>([18]) -> ([22]); // 31
store_temp<Unit>([20]) -> ([23]); // 32
return([21], [22], [23]); // 33
function_call<user@test::bar_inner>() -> ([0]); // 34
drop<Unit>([0]) -> (); // 35
function_call<user@test::bar_inner>() -> ([1]); // 36
drop<Unit>([1]) -> (); // 37
function_call<user@test::bar_inner>() -> ([2]); // 38
drop<Unit>([2]) -> (); // 39
function_call<user@test::bar_inner>() -> ([3]); // 40
drop<Unit>([3]) -> (); // 41
function_call<user@test::bar_inner>() -> ([4]); // 42
drop<Unit>([4]) -> (); // 43
function_call<user@test::bar_inner>() -> ([5]); // 44
drop<Unit>([5]) -> (); // 45
function_call<user@test::bar_inner>() -> ([6]); // 46
drop<Unit>([6]) -> (); // 47
function_call<user@test::bar_inner>() -> ([7]); // 48
drop<Unit>([7]) -> (); // 49
function_call<user@test::bar_inner>() -> ([8]); // 50
drop<Unit>([8]) -> (); // 51
function_call<user@test::bar_inner>() -> ([9]); // 52
drop<Unit>([9]) -> (); // 53
struct_construct<Unit>() -> ([10]); // 54
store_temp<Unit>([10]) -> ([11]); // 55
return([11]); // 56
struct_construct<Unit>() -> ([0]); // 57
store_temp<Unit>([0]) -> ([1]); // 58
return([1]); // 59

test::foo@0([0]: RangeCheck, [1]: GasBuiltin, [2]: felt252) -> (RangeCheck, GasBuiltin, Unit);
test::bar@34() -> (Unit);
test::bar_inner@57() -> (Unit);

//! > casm
jmp rel 43 if [fp + -3] != 0;
%{ memory[ap + 0] = 0 <= memory[fp + -4] %}
jmp rel 7 if [ap + 0] != 0, ap++;
[ap + 0] = [fp + -4] + 340282366920938463463374607431768211456, ap++;
[ap + -1] = [[fp + -5] + 0];
jmp rel 29;
[fp + -4] = [ap + 0] + 0, ap++;
[ap + -1] = [[fp + -5] + 0];
%{ memory[ap + 0] = 900 <= memory[ap + -1] %}
jmp rel 7 if [ap + 0] != 0, ap++;
[ap + 0] = [ap + -2] + 340282366920938463463374607431768210556, ap++;
[ap + -1] = [[fp + -5] + 1];
jmp rel 12;
[ap + -2] = [ap + 0] + 900, ap++;
[ap + -1] = [[fp + -5] + 1];
call rel 28;
[ap + 0] = [fp + -5] + 2, ap++;
[ap + 0] = [ap + -24], ap++;
jmp rel 7;
ap += 22;
[ap + 0] = [fp + -5] + 2, ap++;
[ap + 0] = [ap + -26], ap++;
jmp rel 7;
ap += 24;
[ap + 0] = [fp + -5] + 1, ap++;
[ap + 0] = [fp + -4], ap++;
jmp rel 8;
ap += 4;
call rel 5;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
ret;
call rel 21;
call rel 19;
call rel 17;
call rel 15;
call rel 13;
call rel 11;
call rel 9;
call rel 7;
call rel 5;
call rel 3;
ret;
ret;

//! > ==========================================================================

//! > redeposit_gas libfunc

//! > test_runner_name
SmallE2ETestRunnerCostComputation

//! > cairo
// TODO(lior): Use gas::redeposit_gas once it's there.
extern fn redeposit_gas() implicits(GasBuiltin) nopanic;

fn foo(x: felt252) {
    if x == 0 {
        bar();
        bar();
        bar();
        bar();
        bar();
        redeposit_gas();
        return ();
    } else {
        redeposit_gas();
        if x == 1 {
            bar();
        } else {
            redeposit_gas();
        }
        return ();
    }
}

#[inline(never)]
fn bar() {
}

//! > gas_solution
#2: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#14: OrderedHashMap({Const: 0})
#19: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#21: OrderedHashMap({Const: 240})
#27: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#32: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#34: OrderedHashMap({Const: 180})

test::foo: OrderedHashMap({Const: 1200})
test::bar: OrderedHashMap({})

//! > gas_solution_no_solver
#2: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#19: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 0})
#27: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 240})
#32: OrderedHashMap({Pedersen: 0, Poseidon: 0, Bitwise: 0, EcOp: 0, Const: 420})

test::foo: OrderedHashMap({Const: 1200})
test::bar: OrderedHashMap({})

//! > sierra_code
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type GasBuiltin = GasBuiltin [storable: true, drop: false, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type NonZero<felt252> = NonZero<felt252> [storable: true, drop: true, dup: true, zero_sized: false];

libfunc dup<felt252> = dup<felt252>;
libfunc felt252_is_zero = felt252_is_zero;
libfunc branch_align = branch_align;
libfunc drop<felt252> = drop<felt252>;
libfunc function_call<user@test::bar> = function_call<user@test::bar>;
libfunc drop<Unit> = drop<Unit>;
libfunc redeposit_gas = redeposit_gas;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc store_temp<GasBuiltin> = store_temp<GasBuiltin>;
libfunc store_temp<Unit> = store_temp<Unit>;
libfunc drop<NonZero<felt252>> = drop<NonZero<felt252>>;
libfunc felt252_const<1> = felt252_const<1>;
libfunc felt252_sub = felt252_sub;
libfunc store_temp<felt252> = store_temp<felt252>;
libfunc jump = jump;
libfunc rename<GasBuiltin> = rename<GasBuiltin>;

dup<felt252>([1]) -> ([1], [2]); // 0
felt252_is_zero([2]) { fallthrough() 19([3]) }; // 1
branch_align() -> (); // 2
drop<felt252>([1]) -> (); // 3
function_call<user@test::bar>() -> ([4]); // 4
drop<Unit>([4]) -> (); // 5
function_call<user@test::bar>() -> ([5]); // 6
drop<Unit>([5]) -> (); // 7
function_call<user@test::bar>() -> ([6]); // 8
drop<Unit>([6]) -> (); // 9
function_call<user@test::bar>() -> ([7]); // 10
drop<Unit>([7]) -> (); // 11
function_call<user@test::bar>() -> ([8]); // 12
drop<Unit>([8]) -> (); // 13
redeposit_gas([0]) -> ([9]); // 14
struct_construct<Unit>() -> ([10]); // 15
store_temp<GasBuiltin>([9]) -> ([11]); // 16
store_temp<Unit>([10]) -> ([12]); // 17
return([11], [12]); // 18
branch_align() -> (); // 19
drop<NonZero<felt252>>([3]) -> (); // 20
redeposit_gas([0]) -> ([13]); // 21
felt252_const<1>() -> ([14]); // 22
felt252_sub([1], [14]) -> ([15]); // 23
store_temp<felt252>([15]) -> ([15]); // 24
store_temp<GasBuiltin>([13]) -> ([13]); // 25
felt252_is_zero([15]) { fallthrough() 32([16]) }; // 26
branch_align() -> (); // 27
function_call<user@test::bar>() -> ([17]); // 28
drop<Unit>([17]) -> (); // 29
store_temp<GasBuiltin>([13]) -> ([18]); // 30
jump() { 36() }; // 31
branch_align() -> (); // 32
drop<NonZero<felt252>>([16]) -> (); // 33
redeposit_gas([13]) -> ([19]); // 34
store_temp<GasBuiltin>([19]) -> ([18]); // 35
struct_construct<Unit>() -> ([20]); // 36
rename<GasBuiltin>([18]) -> ([21]); // 37
store_temp<Unit>([20]) -> ([22]); // 38
return([21], [22]); // 39
struct_construct<Unit>() -> ([0]); // 40
store_temp<Unit>([0]) -> ([1]); // 41
return([1]); // 42

test::foo@0([0]: GasBuiltin, [1]: felt252) -> (GasBuiltin, Unit);
test::bar@40() -> (Unit);

//! > casm
jmp rel 14 if [fp + -3] != 0;
call rel 30;
call rel 28;
call rel 26;
call rel 24;
call rel 22;
[ap + 0] = [fp + -4], ap++;
ret;
ap += 6;
[fp + -3] = [ap + 0] + 1, ap++;
[ap + 0] = [fp + -4] + 240, ap++;
jmp rel 7 if [ap + -2] != 0;
call rel 10;
[ap + 0] = [ap + -3], ap++;
jmp rel 6;
ap += 2;
[ap + 0] = [ap + -3] + 180, ap++;
ret;
ret;
