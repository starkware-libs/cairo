= Box type

`Box<T>` is a smart pointer type that allows for storing values on the heap (in Cairo VM's boxed segment) rather than on the stack.
It provides a fixed-size pointer to data of arbitrary size.

== Overview

A `Box<T>` wraps a value of type `T` and stores it in the boxed segment of Cairo VM memory, leaving only a pointer in the execution segment.
This enables:

* **Storing large values efficiently** — Moving a `Box` is cheap because only the pointer is moved, not the entire value
* **Enabling recursive types** — Types that would otherwise have infinite size can use `Box` to break the recursion
* **Fixed-size representation** — Values of arbitrary size can be represented with a fixed-size pointer

== Creating and using Box

Use `BoxTrait::new()` to create a boxed value:

[source,cairo]
----
let x = 42_u32;
let boxed_x: Box<u32> = BoxTrait::new(x);
----

Use `.unbox()` to extract the value:

[source,cairo]
----
let boxed = BoxTrait::new(42);
let value = boxed.unbox();  // value is 42
----

== Recursive data structures

`Box` is essential for creating recursive types like linked lists or trees:

[source,cairo]
----
#[derive(Copy, Drop, Debug)]
enum BinaryTree {
    Leaf: u32,
    Node: (u32, Box<BinaryTree>, Box<BinaryTree>)
}

let leaf = BinaryTree::Leaf(1);
let node = BinaryTree::Node((
    2,
    BoxTrait::new(leaf),
    BoxTrait::new(leaf)
));
----

Without `Box`, the `BinaryTree` type would have infinite size, as each `Node` would contain two full `BinaryTree` values.

== Moving large structures

When working with large data structures, `Box` provides efficient movement:

[source,cairo]
----
let large_array = array![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let boxed_array = BoxTrait::new(large_array);
// Only the pointer is moved, not the entire array
some_function(boxed_array);
----

== Copy and Drop semantics

`Box<T>` implements `Copy` if `T` implements `Copy`, and `Drop` if `T` implements `Drop`:

* `Box<T>` is copyable when `T` is copyable — copying the box copies the pointer, not the value
* `Box<T>` is droppable when `T` is droppable — dropping the box drops the wrapped value

== Snapshot conversion

Use `.as_snapshot()` to convert a snapshot of a `Box` into a `Box` of a snapshot:

[source,cairo]
----
let boxed_array = BoxTrait::new(array![1, 2, 3]);
let snap_boxed = @boxed_array;         // @Box<Array<u32>>
let boxed_snap = snap_boxed.as_snapshot();  // Box<@Array<u32>>
let array_snap = boxed_snap.unbox();   // @Array<u32>
----

This is useful when working with non-copyable types like `Array`.

== Dereferencing

`Box<T>` implements the `Deref` trait, allowing automatic dereferencing:

[source,cairo]
----
let boxed_value: Box<u32> = BoxTrait::new(42);
let value: u32 = boxed_value.deref();  // Extracts the value
----

== Memory model

In Cairo's memory model, `Box<T>` stores the value in the _boxed segment_ of memory, which is separate from the execution segment where regular values are stored.
This separation allows for efficient handling of large or recursive data structures.

== See also

* xref:linear-types.adoc[Linear types] — Understanding move semantics and Copy/Drop traits
* Implementation: `crates/cairo-lang-corelib/src/box.cairo`
