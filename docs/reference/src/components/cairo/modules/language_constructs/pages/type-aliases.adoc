= Type aliases

Type aliases provide alternative names for existing types.
They do not introduce new types; instead, they refer to an existing type,
possibly with concrete generic arguments.

Type aliases are useful for:

- Providing shorter or more descriptive names for complex types.
- Re-exporting types from other modules.
- Fixing some generic arguments of a type while keeping others generic.

See also xref:aliases.adoc[Type and impl aliases] and xref:generics.adoc[Generics].

== Syntax

A type alias has the following form:

[source,cairo]
----
type TypeAliasName<GenericParams> = path::to::Type<GenericArgs>;
----

Where:

- `TypeAliasName` is the new name of the type.
- `GenericParams` are the generic parameters introduced by the alias (optional).
- `path::to::Type` is a path to an existing type or type alias.
- `GenericArgs` are the concrete generic arguments passed to that type (optional).

== Basic examples

[source,cairo]
----
struct MyStruct {
    a: felt252,
}

type RenamedStruct = MyStruct;

enum MyEnum {
    f: felt252,
}

type RenamedEnum = MyEnum;

type IntAlias = i32;
type BoxIntAlias = Box<i32>;
type TupleAlias = (felt252, u128);
----

== Usage

Type aliases can be used anywhere the original type can be used:
in variable declarations, function parameters, and return types.

=== In function parameters and return types

Type aliases can be used as parameter types and return types:

[source,cairo]
----
fn process_struct(s: RenamedStruct) -> felt252 {
    s.a
}

fn process_enum(e: RenamedEnum) -> felt252 {
    match e {
        MyEnum::f(v) => v,
    }
}

fn process_tuple(t: TupleAlias) -> felt252 {
    let (value, _) = t;
    value
}
----

=== In variable declarations

Type aliases can be used when declaring variables:

[source,cairo]
----
let x: IntAlias = 42;
let boxed: BoxIntAlias = BoxTrait::new(10);
let pair: TupleAlias = (5, 100);
----

== Generic type aliases

Type aliases can themselves be generic.
This allows fixing some of the generic arguments of an existing type
while leaving others as parameters of the alias.

[source,cairo]
----
type BoxOption<T> = Box<Option<T>>;
type RenamedTuple<T> = (felt252, T);

fn use_generic_alias(t: RenamedTuple<u128>) -> u128 {
    let (_, value) = t;
    value
}
----

== Chaining type aliases

A type alias can refer to another type alias.
The compiler resolves such chains transitively until it reaches the
underlying concrete type.

[source,cairo]
----
type A<P4> = B<felt252, P4, u128>;
type B<P1, P2, P3> = (P1, P3, P2);

fn use_chained_alias(value: A<bool>) -> (felt252, u128, bool) {
    value
}
----

== Errors and limitations

When working with type aliases, the compiler enforces several rules:

- The right-hand side of a type alias must resolve to a valid type.
  If it does not, a compilation error is reported.
- Cyclic type aliases (where aliases form a cycle through their right-hand sides)
  are rejected by the compiler.
