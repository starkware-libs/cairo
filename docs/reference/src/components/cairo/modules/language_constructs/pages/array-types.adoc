= Array Types

Arrays in Cairo are dynamic collections of elements of the same type,
stored contiguously in memory. Due to Cairo's immutable memory model,
arrays are growable only at the end (via `.append()`) and shrinkable
only from the front (via `.pop_front()`). Direct modification of
existing elements (e.g., `arr[5] = value`) is not allowed — this is a
key difference from languages like Rust or Python.

== Declaration and Initialization

An array is declared using the generic type `Array<T>`:

[source,cairo]
----
let mut arr: Array<felt252> = ArrayTrait::new();
----

The `mut` keyword is required if you plan to modify the array (append
or pop).

You can also initialize with literal values using the `array![]` macro:

[source,cairo]
----
let arr = array![1, 2, 3, 4]; // Implicitly Array<felt252>
----

== Common Operations

- **Append** — adds an element to the end:
[source,cairo]
----
arr.append(5); // arr now: [1, 2, 3, 4, 5]
----

- **Pop front** — removes and returns the first element
  (returns `Option<T>`):
[source,cairo]
----
let first = arr.pop_front().unwrap(); // first = 1, arr now: [2, 3, 4, 5]
----

- **Length**:
[source,cairo]
----
let len = arr.len(); // usize
----

== Accessing Elements

Direct indexing (`arr[index]`) is not supported for mutation.
Instead, use safe methods:

- **`.at(index)`** — returns a snapshot (`@T`) — immutable reference
  to the element (panics if out of bounds):
[source,cairo]
----
let value = *arr.at(2); // Dereference the snapshot to get T
----

- **`.get(index)`** — returns `Option<Box<@T>>` (safe, no panic):
[source,cairo]
----
match arr.get(2) {
    Option::Some(x) => { let value = *x.unbox(); },
    Option::None => { /* out of bounds */ }
}
----

== Working with Span (Recommended for Iteration)

To safely iterate or access multiple elements, convert the array to a
`Span<T>`:

[source,cairo]
----
let span = arr.span();
for i in 0..span.len() {
    let value = *span.at(i);
    // process value
}
----

More idiomatically, you can iterate directly over the span:

[source,cairo]
----
let arr = array![1, 2, 3];
for value in arr.span() {
    // value: @felt252
    // process value without consuming `arr`
}
----

`Span<T>` is a read-only view on top of the underlying array data, and
modifying the span (for example via `pop_front()`) does not modify the
original array.

== Fixed-size array types `[T; N]`

In addition to the growable `Array<T>` type, Cairo also supports fixed-size
array types written as `[T; N]`, where `T` is the element type and `N` is a
compile-time constant length.

[source,cairo]
----
let triple: [u32; 3] = [1, 2, 3];
let empty: [felt252; 0] = [];
----

Unlike `Array<T>`, a fixed-size array cannot grow or shrink: its length is
part of the type and does not change at runtime. You cannot call methods like
`append` or `pop_front` on `[T; N]`.

Fixed-size arrays integrate with spans and dynamic arrays:

- `Span<T>` can expose fixed-size segments of its data as `[T; N]` values
  through helper methods that return `@Box<[T; N]>`.
- A fixed-size array `[T; N]` can be viewed as a `Span<T>` using `.span()`,
  which allows uniform iteration over both dynamic and fixed-size arrays.

== Limitations and Why Certain Patterns Are Forbidden

Due to memory immutability:

- No in-place mutation of elements.
- No insertion/removal in the middle (would require shifting memory cells).
- No resizing except append/pop_front.

Attempting to modify an element directly will result in a compilation
error.

== Common Patterns

- **Building an array in a loop**:
[source,cairo]
----
let mut result = ArrayTrait::new();
loop {
    if condition { break; }
    result.append(computed_value);
};

- **Checking if an array is empty**:
[source,cairo]
----
let arr = ArrayTrait::new();
if arr.is_empty() {
    // handle empty case
}
----

- **Iterating over elements without consuming the array**:
[source,cairo]
----
let arr = array![1, 2, 3];
for value in arr.span() {
    // value: @felt252
    // arr is not consumed and can still be used here
}
----

- **Draining an array (processing while consuming)**:
[source,cairo]
----
let mut arr = array![1, 2, 3];
while let Option::Some(value) = arr.pop_front() {
    // process value
};
// arr is now empty
----

== See Also

- `ArrayTrait` — full list of methods.
- Snapshots (`@T`) — immutable references and dereferencing.
- `Span<T>` — read-only view over array data.
