= Array Types

Arrays in Cairo are dynamic collections of elements of the same type,
stored contiguously in memory. Due to Cairo's immutable memory model,
arrays are growable only at the end (via `.append()`) and shrinkable
only from the front (via `.pop_front()`). Direct modification of
existing elements (e.g., `arr[5] = value`) is not allowed — this is a
key difference from languages like Rust or Python.

== Declaration and Initialization

An array is declared using the generic type `Array<T>`:

[source,cairo]
----
let mut arr: Array<felt252> = ArrayTrait::new();
----

The `mut` keyword is required if you plan to modify the array (append
or pop).

You can also initialize with literal values using the `array![]` macro:

[source,cairo]
----
let arr = array![1, 2, 3, 4]; // Implicitly Array<felt252>
----

== Common Operations

- **Append** — adds an element to the end:
[source,cairo]
----
arr.append(5); // arr now: [1, 2, 3, 4, 5]
----

- **Pop front** — removes and returns the first element
  (returns `Option<T>`):
[source,cairo]
----
let first = arr.pop_front().unwrap(); // first = 1, arr now: [2, 3, 4, 5]
----

- **Length**:
[source,cairo]
----
let len = arr.len(); // usize
----

== Accessing Elements

Direct indexing (`arr[index]`) is not supported for mutation.
Instead, use safe methods:

- **`.at(index)`** — returns a snapshot (`@T`) — immutable reference
  to the element (panics if out of bounds):
[source,cairo]
----
let value = *arr.at(2); // Dereference the snapshot to get T
----

- **`.get(index)`** — returns `Option<Box<@T>>` (safe, no panic):
[source,cairo]
----
match arr.get(2) {
    Option::Some(x) => { let value = *x.unbox(); },
    Option::None => { /* out of bounds */ }
}
----

== Working with Span (Recommended for Iteration)

To safely iterate or access multiple elements without repeated bounds
checks, convert the array to a `Span<T>`:

[source,cairo]
----
let span = arr.span();
for i in 0..span.len() {
    let value = *span.at(i);
    // process value
}
----

`Span<T>` is a read-only view and is the preferred way to read from
arrays.

== Limitations and Why Certain Patterns Are Forbidden

Due to memory immutability:

- No in-place mutation of elements.
- No insertion/removal in the middle (would require shifting memory cells).
- No resizing except append/pop_front.

Attempting to modify an element directly will result in a compilation
error.

== Common Patterns

- **Building an array in a loop**:
[source,cairo]
----
let mut result = ArrayTrait::new();
loop {
    if condition { break; }
    result.append(computed_value);
};
----

- **Draining an array (processing while consuming)**:
[source,cairo]
----
let mut arr = array![1, 2, 3];
while let Option::Some(value) = arr.pop_front() {
    // process value
};
// arr is now empty
----

== See Also

- `ArrayTrait` — full list of methods.
- Snapshots (`@T`) — immutable references and dereferencing.
- `Span<T>` — read-only view over array data.
