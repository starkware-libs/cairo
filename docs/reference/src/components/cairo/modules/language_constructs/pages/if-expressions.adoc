= Implicit arguments

Implicit arguments in Cairo are parameters that are automatically passed
to functions without being explicitly specified at each call site.
They provide context for low-level operations like range checking and gas tracking.

== Overview

Implicit arguments are compiler-managed parameters
that flow through the call stack automatically.
They're commonly used for:

* Built-in validation (range checking)
* Resource tracking (gas consumption)
* System access (Starknet syscalls)

== Syntax

Functions declare implicit arguments using the `implicits()` attribute:

[source,cairo]
----
extern fn my_function(x: u32) -> u32 implicits(RangeCheck) nopanic;
----

Multiple implicits can be declared:

[source,cairo]
----
extern fn syscall_function(
    data: Span<felt252>
) -> Result<(), ByteArray> implicits(GasBuiltin, System);
----

== Common implicit types

=== RangeCheck

Used for operations that require validating numeric ranges:

[source,cairo]
----
extern fn array_get<T>(
    arr: @Array<T>,
    index: usize,
) -> Option<Box<@T>> implicits(RangeCheck) nopanic;
----

The `RangeCheck` implicit ensures that array indices and numeric operations
stay within valid bounds.

=== GasBuiltin

Used for tracking gas consumption in functions:

[source,cairo]
----
extern fn withdraw_gas() -> Option<()> implicits(RangeCheck, GasBuiltin) nopanic;
----

The `GasBuiltin` implicit tracks computational resources
to prevent infinite loops and excessive computation.

=== System

Used for Starknet system calls:

[source,cairo]
----
fn call_contract(
    address: ContractAddress,
    selector: felt252,
) -> SyscallResult<Span<felt252>> implicits(GasBuiltin, System);
----

The `System` implicit provides access to Starknet's state and operations.

== Automatic propagation

Implicit arguments are automatically propagated through the call stack.
When a function with implicits calls another function that requires the same implicits,
they're passed automatically:

[source,cairo]
----
fn helper(x: u32) -> u32 implicits(RangeCheck) {
    // Uses RangeCheck implicit
    validated_operation(x)
}

fn caller(x: u32) -> u32 implicits(RangeCheck) {
    // RangeCheck is automatically passed to helper
    helper(x)
}
----

== Empty implicits

Functions can explicitly declare no implicits using `implicits()`:

[source,cairo]
----
extern fn bounded_int_is_zero<T>(value: T) -> IsZeroResult<T> implicits() nopanic;
----

This indicates the function doesn't require any implicit context.

== Implicit requirements

A function can only call functions whose implicits are a subset
of its own implicits.
If a function needs to call code requiring additional implicits,
it must declare those implicits itself:

[source,cairo]
----
// Valid: caller has RangeCheck
fn caller(x: u32) implicits(RangeCheck) {
    callee(x);  // callee also requires RangeCheck
}

fn callee(x: u32) implicits(RangeCheck) {
    // Implementation
}
----

== Extern functions

Low-level `extern` functions typically specify their implicit requirements:

[source,cairo]
----
extern fn downcast<T, S>(value: T) -> Option<S> implicits(RangeCheck) nopanic;
----

These declarations inform the compiler about the implicit context
needed for the operation.

== Notes

* Implicits are a low-level feature primarily used in core library code
* Most application code doesn't need to explicitly manage implicits
* The compiler automatically handles implicit threading through the call stack
* Implicits are part of a function's type signature

== See also

* xref:oolean-types.adoc[Boolean types] — The condition type
* xref:match-expressions.adoc[Match expressions] — Pattern-based conditionals
* xref:expressions.adoc[Expressions] — General expression syntax
