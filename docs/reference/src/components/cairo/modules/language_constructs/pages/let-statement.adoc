= Let statement

A _let statement_ introduces a new set of variables, given by an irrefutable pattern.
The pattern is followed optionally by a type annotation and then by an initializer expression.
Variables are _always_ initialized to some value.

== Syntax

[source,cairo]
----
let PATTERN: Type = expression;
let mut PATTERN: Type = expression;
----

When no type annotation is given, the compiler infers the type, or signals an error if
insufficient type information is available for definite inference.

== Patterns

The `let` statement uses xref:pages/patterns.adoc[patterns] to bind values to variables.
Patterns allow you to destructure data and bind their components to variables.

Simple variable binding:
[source,cairo]
----
let x = 5;
let name = 'Alice';
----

Tuple destructuring:
[source,cairo]
----
let (a, b, c) = (1, 2, 3);
----

Struct destructuring:
[source,cairo]
----
let Point { x, y } = point;
let Point { x: px, y: py } = point;  // Rename fields
----

Ignoring values with underscore:
[source,cairo]
----
let (x, _, z) = (1, 2, 3);  // Ignore second value
let Point { x, y: _ } = point;  // Ignore y field
----

See xref:pages/patterns.adoc[Patterns] for more details.

== Mutability

By default, variables are **immutable** in Cairo.
To make a variable mutable, use the `mut` keyword:

[source,cairo]
----
let x = 5;
// x = 6;  // Error: cannot assign to immutable variable

let mut y = 5;
y = 6;  // OK: y is mutable
----

Mutable variables can be reassigned using xref:pages/assignment-statement.adoc[assignment].

Mutability can be combined with patterns:
[source,cairo]
----
let mut (x, y) = (1, 2);
x = 10;  // OK
y = 20;  // OK
----

[NOTE]
====
Mutability in Cairo is local to the variable binding.
Reassigning a mutable variable does not affect other references to the value.
See xref:pages/variables.adoc[Variables] for more details.
====

== Variable scope and shadowing

Any variable introduced by this declaration is visible from the point of declaration
until the end of the enclosing block scope, except when it is shadowed by another variable
declaration.

=== Shadowing

Cairo allows you to declare a new variable with the same name as a previous variable.
This is called _shadowing_, and the new variable shadows the previous variable.

[source,cairo]
----
let x = 5;
let x = x + 1;  // Shadows the previous x
let x = x * 2;  // Shadows again
----

Shadowing is different from marking a variable as mutable.
When we shadow a variable, we create a new variable with the same name:

* The shadowed variable in the outer scope is **not modified**
* We can change the type of the value when shadowing
* Shadowing works in nested scopes

Example with nested scopes:

[source,cairo]
----
let x = 5;
{
    let x = 8;  // Shadows x only within this block
    // x is 8 here
}
// x is still 5 here
----

In contrast, when you assign to a mutable variable, you modify the same variable:

[source,cairo]
----
let mut x = 5;
{
    x = 8;  // Modifies the same x
}
// x is 8 here (was modified)
----

Shadowing can also change the type:

[source,cairo]
----
let x = 'hello';        // x is a short string (felt252)
let x: u32 = 42_u32;   // x is now u32
----

See xref:variables.adoc#shadowing[Shadowing in Variables] for more details.
