= Namespaces

Namespaces in Cairo provide a way to group related items (functions, constants, structs, 
impls, and sub-namespaces) to organize code and avoid name conflicts. They are similar 
to modules in other languages but with specific Cairo semantics.

Namespaces help structure large contracts or libraries without relying on separate files.

== Declaration

A namespace is declared using the `namespace` keyword followed by an identifier and a 
block:

[source,cairo]
----
namespace MyUtils {
    const MAX_VALUE: felt252 = 1000;

    fn add(a: felt252, b: felt252) -> felt252 {
        a + b
    }
}
----

Items inside the namespace are private by default unless marked with attributes (e.g., 
`#[external]` for visibility in contracts).

== Using Items from a Namespace

To access items, use the `use` statement or fully qualified paths.

- With `use`:
  [source,cairo]
  ----
  use MyUtils::add;
  use MyUtils::MAX_VALUE;

  fn example() -> felt252 {
      add(MAX_VALUE, 10)
  }
  ----

- Fully qualified:
  [source,cairo]
  ----
  fn example() -> felt252 {
      MyUtils::add(MyUtils::MAX_VALUE, 10)
  }
  ----

== Nested Namespaces

Namespaces can be nested for deeper organization:

[source,cairo]
----
namespace Math {
    namespace Algebra {
        fn square(x: felt252) -> felt252 {
            x * x
        }
    }

    namespace Geometry {
        const PI: felt252 = 314159; // approximation
    }
}
----

Access nested items:
[source,cairo]
----
use Math::Algebra::square;
use Math::Geometry::PI;
----

== Namespaces vs Structs and Impl Blocks

- Namespaces group free-standing items.
- Structs + impl blocks group methods associated with a type.
- You can have impls inside namespaces if needed.

Example combining:
[source,cairo]
----
namespace Crypto {
    struct Hash {}

    impl HashImpl of HashTrait {
        fn compute(data: felt252) -> felt252 {
            // implementation
        }
    }
}
----

== Scoping and Visibility

- Items in a namespace are visible only inside it or via `use`.
- No public/private keywords yet — visibility controlled by attributes like `#[external]`.
- Namespaces do not create new memory scopes; they are purely for naming.

== Common Patterns

- **Organizing utilities**:
  [source,cairo]
  ----
  namespace Utils {
      fn assert_positive(x: felt252) {
          assert x > 0, 'Must be positive');
      }
  }
  ----

- **Grouping related constants and functions** for a library.

- **Avoiding name clashes** in large projects:
  Use separate namespaces for different domains (e.g., Token, Governance).

== Limitations

- No conditional compilation inside namespaces yet.
- Cannot define traits directly in namespaces (use top-level or impls).
- Namespaces are resolved at compile time — no dynamic lookup.

== See Also

- Modules and file structure — for multi-file organization.
- Use statements — for importing and path aliases.
