= Namespaces

Cairo does not have a dedicated `namespace` keyword or
construct like in some other languages (e.g., C++ or Rust).

Instead, the language uses **modules** to achieve the same
goals: grouping related items (functions, constants,
structs, enums, traits, impls) and avoiding name conflicts
through hierarchical organization.

The module system effectively provides namespace-like
behavior via paths (e.g., `math::add::sum`).

== How Modules Work as Namespaces

Cairo has a file-based module system:

- Each `.cairo` file in `src/` (except `lib.cairo`) becomes
  a module named after the filename.
- Use `mod` to declare modules.
- Use `use` to import items into scope.
- Paths create hierarchical "namespaces".

Example project structure:
----
src/
  lib.cairo
  math.cairo
  math/
    add.cairo
    sub.cairo
----

Declaration in `lib.cairo`:
[source,cairo]
----
mod math;

fn example() {
    math::add::sum(1, 2);
}
----

In `math.cairo`:
[source,cairo]
----
mod add;
mod sub;

pub use add::sum;  // Re-export for convenience
----
Access: `math::add::sum(...)` or `math::sum(...)`

== Declaring and Using Modules

[source,cairo]
----
mod utils {
    pub fn helper() -> felt252 {
        42
    }
}

use utils::helper;

fn main() {
    let x = helper();
}
----

- Inline modules: defined directly with `mod name { ... }`
- File modules: preferred for larger projects
- Visibility: `pub` for external access
- Paths: `super::`, `self::`, `crate::` for navigation

== Importing with `use`

[source,cairo]
----
use crypto::hash::sha256;
use std::array::ArrayTrait as Arr;

use my_module::{item1, item2};
use my_module::*;  // Glob import (use carefully)
----

This hierarchical module structure fully replaces the need
for a separate `namespace` keyword while providing clean,
scalable code organization.

For detailed module documentation, see the
https://book.cairo-lang.org/ch09-00-modules.html[Cairo Book
chapter on modules].
