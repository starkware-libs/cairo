= Runtime

This page describes runtime behavior in Cairo: what happens when your code executes,
how errors are handled, and resource constraints that affect program execution.

== Error handling

=== Panics

Cairo uses panics for unrecoverable runtime errors. When a panic occurs, execution
halts immediately and control returns to the caller with an error.

Common causes of panics:

- **Division by zero**: Integer division or modulo operations with zero divisor
- **Array bounds violations**: Accessing array elements outside valid indices
- **Arithmetic overflow**: Integer operations that exceed type bounds (in checked mode)
- **Failed assertions**: `assert!()` macro with false condition
- **Explicit panics**: `panic!()` macro calls

Example:

[source,cairo]
----
fn divide(a: u32, b: u32) -> u32 {
    if b == 0 {
        panic!("division by zero");
    }
    a / b
}
----

When a panic occurs:

1. Execution stops immediately
2. The panic message (array of `felt252` values) is captured
3. Stack unwinding begins, running destructors for types with `PanicDestruct`
4. Control returns to the caller with an error indication

=== Result-based error handling

For errors that should be handled by callers, use `Result<T, E>` types instead
of panicking:

[source,cairo]
----
fn safe_divide(a: u32, b: u32) -> Result<u32, ByteArray> {
    if b == 0 {
        return Result::Err("division by zero");
    }
    Result::Ok(a / b)
}

fn calculate() -> Result<u32, ByteArray> {
    let x = safe_divide(10, 2)?;  // Propagates error if division fails
    let y = safe_divide(x, 0)?;   // Returns Err here
    Result::Ok(y)
}
----

The `?` operator automatically propagates errors through the call stack. See
xref:language_constructs:error-propagation-operator.adoc[Error propagation] for
details.

=== Stack traces

When panics occur, Cairo captures stack traces showing the call chain:

[source,text]
----
thread 'main' panicked at 'division by zero'
lib.cairo:42:5
Called from:
  calculate() at lib.cairo:15:9
  main() at lib.cairo:5:5
----

Stack traces include panic messages, source locations, and the complete call chain.
Tools like `cairo-run` and `cairo-test` display stack traces for debugging.

== Resource limits

=== Gas consumption

Cairo programs executing on Starknet consume gas for computational work. Operations
that consume gas include:

- Arithmetic and logical operations
- Memory allocations
- Function calls
- Cryptographic operations (hashing, signature verification)

Programs can check available gas and handle exhaustion gracefully. The compiler
inserts gas checks that ensure programs can detect insufficient gas before
attempting expensive operations.

If a program exceeds its gas limit during execution, the transaction reverts.

=== Builtins

Some operations are implemented as optimized builtins rather than regular Cairo code.
Builtins provide:

- Range checking for value bounds
- Cryptographic hashing (Pedersen, Poseidon, Keccak)
- Elliptic curve operations
- Bitwise operations

Builtins are typically accessed through functions in the standard library rather
than directly. The compiler automatically threads builtin context through function
calls using implicit arguments.

See xref:language_constructs:implicit-arguments.adoc[Implicit arguments] for how
builtins are passed between functions.

== See also

- xref:memory-model.adoc[Memory model] - Memory semantics and immutability
- xref:constant-evaluation.adoc[Constant evaluation] - Compile-time execution
- xref:../../language_constructs/pages/implicit-arguments.adoc[Implicit arguments] - Builtin
  threading
- xref:../../language_constructs/pages//error-propagation-operator.adoc[Error propagation] -
  The `?` operator
